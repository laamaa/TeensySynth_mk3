
.vsteensy/build/TeensySynth_mk3.elf:     file format elf32-littlearm

SYMBOL TABLE:
60000000 l    d  .text.progmem	00000000 .text.progmem
00000000 l    d  .text.itcm	00000000 .text.itcm
0001b410 l    d  .fini	00000000 .fini
0001b414 l    d  .ARM.exidx	00000000 .ARM.exidx
0001b41c l    d  .text.itcm.padding	00000000 .text.itcm.padding
20000000 l    d  .data	00000000 .data
200212e0 l    d  .bss	00000000 .bss
20200000 l    d  .bss.dma	00000000 .bss.dma
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 bootdata.c
00000000 l    df *ABS*	00000000 startup.c
000169d0 l       .text.itcm	00000000 _MSP
00000000 l    df *ABS*	00000000 imxrt_hw.cpp
00000000 l    df *ABS*	00000000 usb.c
00015970 l     F .text.itcm	00000070 schedule_transfer
000159e0 l     F .text.itcm	00000036 run_callbacks
00015a18 l     F .text.itcm	000000a0 endpoint0_transmit.constprop.1
00015ab8 l     F .text.itcm	00000614 isr
20058230 l     O .bss	00000004 endpointN_notify_mask
20058234 l     O .bss	00000001 sof_usage
20058240 l     O .bss	00000004 endpoint0_notify_mask
20058244 l     O .bss	00000001 usb_reboot_timer
20058248 l     O .bss	00000008 endpoint0_setupdata
20058250 l     O .bss	00000008 reply_buffer
20058258 l     O .bss	00000008 endpoint0_buffer
00000000 l    df *ABS*	00000000 analog.c
2005854c l     O .bss	00000001 calibrating
00000000 l    df *ABS*	00000000 tempmon.c
20058550 l     O .bss	00000004 s_hotTemp
20058554 l     O .bss	00000004 s_hot_ROOM
20058558 l     O .bss	00000004 s_roomC_hotC
2005855c l     O .bss	00000004 s_hotCount
00000000 l    df *ABS*	00000000 AudioStream.cpp
00000000 l    df *ABS*	00000000 usb_desc.c
60001848 l     O .text.progmem	0000000a qualifier_descriptor
20020a2c l     O .data	00000021 seremu_report_desc
20020a50 l     O .data	00000012 device_descriptor
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 c:/progra~2/arduino/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/fpv5-d16/crti.o
00000000 l    df *ABS*	00000000 c:/progra~2/arduino/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/fpv5-d16/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
000000dc l     F .text.itcm	00000000 __do_global_dtors_aux
200212e0 l       .bss	00000000 completed.8605
00000100 l     F .text.itcm	00000000 frame_dummy
200212e4 l       .bss	00000000 object.8610
600018a8 l     O .text.progmem	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 main.cpp
00000b4c l     F .text.itcm	00000038 _GLOBAL__sub_I_ts
20200000 l     O .bss.dma	00000208 setup::data
00000000 l    df *ABS*	00000000 output_i2s_oct.cpp
00013cc8 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN17AudioOutputI2SOct13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_i2s.cpp
00013ce0 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE
00000000 l    df *ABS*	00000000 output_pt8211.cpp
00013cf8 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE
00000000 l    df *ABS*	00000000 output_pt8211_2.cpp
00013d10 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN19AudioOutputPT8211_214block_left_1stE
00000000 l    df *ABS*	00000000 output_i2s.cpp
000140c4 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE
20200220 l     O .bss.dma	00000200 i2s_tx_buffer
00000000 l    df *ABS*	00000000 input_spdif3.cpp
000140dc l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN16AudioInputSPDIF310block_leftE
00000000 l    df *ABS*	00000000 input_i2s_oct.cpp
000140f4 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E
00000000 l    df *ABS*	00000000 input_tdm2.cpp
0001410c l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN14AudioInputTDM214block_incomingE
00000000 l    df *ABS*	00000000 input_adc.cpp
00014124 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN16AudioInputAnalog3dmaE
00000000 l    df *ABS*	00000000 output_tdm.cpp
0001413c l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE
00000000 l    df *ABS*	00000000 input_i2s2.cpp
00014154 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN14AudioInputI2S210block_leftE
00000000 l    df *ABS*	00000000 input_i2s_quad.cpp
0001416c l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E
00000000 l    df *ABS*	00000000 output_tdm2.cpp
00014184 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN15AudioOutputTDM211block_inputE
00000000 l    df *ABS*	00000000 output_i2s2.cpp
0001419c l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN15AudioOutputI2S214block_left_1stE
00000000 l    df *ABS*	00000000 output_i2s_quad.cpp
000141b4 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE
00000000 l    df *ABS*	00000000 output_spdif3.cpp
000141cc l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN17AudioOutputSPDIF314block_left_1stE
00000000 l    df *ABS*	00000000 input_tdm.cpp
000141e4 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE
00000000 l    df *ABS*	00000000 input_i2s_hex.cpp
000141fc l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E
00000000 l    df *ABS*	00000000 output_mqs.cpp
00014214 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN14AudioOutputMQS14block_left_1stE
00000000 l    df *ABS*	00000000 async_input_spdif3.cpp
0001422c l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN21AsyncAudioInputSPDIF314resetResamplerE
00000000 l    df *ABS*	00000000 output_i2s_hex.cpp
00014244 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN17AudioOutputI2SHex13block_ch1_1stE
00000000 l    df *ABS*	00000000 output_spdif2.cpp
0001425c l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN17AudioOutputSPDIF214block_left_1stE
00000000 l    df *ABS*	00000000 output_spdif.cpp
00014274 l     F .text.itcm	00000018 _GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE
00000000 l    df *ABS*	00000000 SD.cpp
00014294 l     F .text.itcm	00000024 _GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc
00000000 l    df *ABS*	00000000 Sd2Card.cpp
00014f1c l     F .text.itcm	00000014 _GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm
200581fc l     O .bss	00000008 settings
20058204 l     O .bss	00000001 chip_select_asserted
00000000 l    df *ABS*	00000000 interrupt.c
00016800 l     F .text.itcm	00000002 dummy_isr
00000000 l    df *ABS*	00000000 teensy_synth.cpp
00000000 l    df *ABS*	00000000 hardware_controls.cpp
00000000 l    df *ABS*	00000000 effect_ensemble_f32.cpp
00000000 l    df *ABS*	00000000 synth_plaits_f32.cpp
00000000 l    df *ABS*	00000000 filter_moog_f32.cpp
00000000 l    df *ABS*	00000000 effect_freeverb_f32.cpp
00000000 l    df *ABS*	00000000 voice.cpp
00000000 l    df *ABS*	00000000 naive_speech_synth.cpp
00000000 l    df *ABS*	00000000 sam_speech_synth.cpp
00000000 l    df *ABS*	00000000 lpc_speech_synth.cpp
00000000 l    df *ABS*	00000000 lpc_speech_synth_controller.cpp
0000811c l     F .text.itcm	0000004e plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]
00000000 l    df *ABS*	00000000 modal_engine.cpp
00000000 l    df *ABS*	00000000 speech_engine.cpp
00000000 l    df *ABS*	00000000 waveshaping_engine.cpp
00000000 l    df *ABS*	00000000 virtual_analog_engine.cpp
2001f738 l     O .data	00000014 plaits::intervals
00000000 l    df *ABS*	00000000 particle_engine.cpp
00000000 l    df *ABS*	00000000 hi_hat_engine.cpp
00000000 l    df *ABS*	00000000 chord_engine.cpp
2001f7a0 l     O .data	000000c0 plaits::registrations
2001f874 l     O .data	00000014 plaits::fade_point
2001f888 l     O .data	000000b0 plaits::chords
00000000 l    df *ABS*	00000000 additive_engine.cpp
2001f938 l     O .data	00000020 plaits::organ_harmonics
2001f958 l     O .data	00000060 plaits::integer_harmonics
00000000 l    df *ABS*	00000000 grain_engine.cpp
00000000 l    df *ABS*	00000000 swarm_engine.cpp
00000000 l    df *ABS*	00000000 fm_engine.cpp
2001fa08 l     O .data	00000010 plaits::fir_coefficient
00000000 l    df *ABS*	00000000 string_engine.cpp
00000000 l    df *ABS*	00000000 snare_drum_engine.cpp
00000000 l    df *ABS*	00000000 bass_drum_engine.cpp
00000000 l    df *ABS*	00000000 noise_engine.cpp
00000000 l    df *ABS*	00000000 wavetable_engine.cpp
00000000 l    df *ABS*	00000000 string_voice.cpp
00000000 l    df *ABS*	00000000 string.cpp
00000000 l    df *ABS*	00000000 resonator.cpp
00000000 l    df *ABS*	00000000 modal_voice.cpp
00000000 l    df *ABS*	00000000 File.cpp
00000000 l    df *ABS*	00000000 SdVolume.cpp
00014394 l     F .text.itcm	00000084 SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]
00000000 l    df *ABS*	00000000 NXP_SDHC.cpp
00014580 l     F .text.itcm	00000090 SDHC_CMD_Do(unsigned long)
00014610 l     F .text.itcm	00000040 SDHC_CMD12_StopTransferWaitForBusy()
200581e8 l     O .bss	00000010 sdCardDesc
00000000 l    df *ABS*	00000000 SdFile.cpp
00014800 l     F .text.itcm	0000006c SdFile::sync() [clone .part.23] [clone .constprop.37]
00000000 l    df *ABS*	00000000 SPI.cpp
00014f4c l     F .text.itcm	00000058 SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]
00000000 l    df *ABS*	00000000 AudioFilterBiquad_F32.cpp
00000000 l    df *ABS*	00000000 AudioStream_F32.cpp
20020820 l     O .data	00000001 allocate_f32_memory(int)::firstTime
20058220 l     O .bss	00000004 allocate_f32_memory(int)::data_f32
00000000 l    df *ABS*	00000000 AudioMixer_F32.cpp
00000000 l    df *ABS*	00000000 .vsteensy/build/lib/Audio//memcpy_audio.o
00015488 l       .text.itcm	00000000 .loopLR
000154cc l       .text.itcm	00000000 .loopL
0001550c l       .text.itcm	00000000 .loopR
00015548 l       .text.itcm	00000000 .loopQuad
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 clockspeed.c
00000000 l    df *ABS*	00000000 usb_seremu.c
00016244 l     F .text.itcm	00000064 rx_queue_transfer
000162a8 l     F .text.itcm	00000058 rx_event
00016510 l     F .text.itcm	0000001c usb_seremu_flush_callback
0001652c l     F .text.itcm	00000128 usb_seremu_write.part.0
20058261 l     O .bss	00000001 rx_tail
20058262 l     O .bss	00000001 tx_noautoflush
20058263 l     O .bss	00000001 tx_head
20058280 l     O .bss	00000100 rx_transfer
20058380 l     O .bss	00000010 rx_index
20058390 l     O .bss	00000009 rx_list
20200420 l     O .bss.dma	00000100 rx_buffer
20200520 l     O .bss.dma	00000300 txbuffer
2005839a l     O .bss	00000002 tx_available
2005839c l     O .bss	00000004 rx_available
200583a0 l     O .bss	00000001 rx_head
200583a1 l     O .bss	00000001 transmit_previous_timeout
200583c0 l     O .bss	00000180 tx_transfer
00000000 l    df *ABS*	00000000 delay.c
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 digital.c
00016b14 l     F .text.itcm	0000004c digitalWrite.part.0
00000000 l    df *ABS*	00000000 pwm.c
00000000 l    df *ABS*	00000000 usb_midi.c
00016ea4 l     F .text.itcm	00000048 sysex_byte
00016eec l     F .text.itcm	0000006c rx_queue_transfer
00016f58 l     F .text.itcm	00000064 rx_event
202008a0 l     O .bss.dma	00000c00 rx_buffer
202014a0 l     O .bss.dma	00000800 txbuffer
2005856c l     O .bss	00000002 rx_packet_size
2005856e l     O .bss	00000002 tx_available
20058584 l     O .bss	00000002 tx_packet_size
20058598 l     O .bss	00000001 rx_head
20058599 l     O .bss	00000001 tx_noautoflush
2005859a l     O .bss	00000001 rx_tail
2005859b l     O .bss	00000001 transmit_previous_timeout
200585a4 l     O .bss	0000000c rx_count
200585c0 l     O .bss	000000c0 rx_transfer
20058684 l     O .bss	00000004 rx_available
20058688 l     O .bss	0000000c rx_index
200586a0 l     O .bss	00000080 tx_transfer
20058728 l     O .bss	00000001 tx_head
20058730 l     O .bss	00000007 rx_list
00000000 l    df *ABS*	00000000 IntervalTimer.cpp
20058740 l     O .bss	00000010 funct_table
00000000 l    df *ABS*	00000000 yield.cpp
20058750 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 arm_biquad_cascade_df1_init_f32.c
00000000 l    df *ABS*	00000000 arm_biquad_cascade_df1_f32.c
00000000 l    df *ABS*	00000000 arm_scale_f32.c
00000000 l    df *ABS*	00000000 arm_add_f32.c
00000000 l    df *ABS*	00000000 s_sin.c
00000000 l    df *ABS*	00000000 sf_tan.c
00000000 l    df *ABS*	00000000 sf_tanh.c
00000000 l    df *ABS*	00000000 wf_exp.c
00000000 l    df *ABS*	00000000 wf_exp2.c
00000000 l    df *ABS*	00000000 wf_pow.c
00000000 l    df *ABS*	00000000 e_rem_pio2.c
2001fe90 l     O .data	00000080 npio2_hw
2001ff10 l     O .data	00000108 two_over_pi
00000000 l    df *ABS*	00000000 ef_exp.c
20020018 l     O .data	00000008 halF
20020020 l     O .data	00000008 ln2LO
20020028 l     O .data	00000008 ln2HI
00000000 l    df *ABS*	00000000 ef_pow.c
00000000 l    df *ABS*	00000000 ef_rem_pio2.c
20020030 l     O .data	00000080 npio2_hw
200200b0 l     O .data	00000318 two_over_pi
00000000 l    df *ABS*	00000000 ef_sqrt.c
00000000 l    df *ABS*	00000000 k_cos.c
00000000 l    df *ABS*	00000000 k_rem_pio2.c
200203c8 l     O .data	00000010 init_jk
200203d8 l     O .data	00000040 PIo2
00000000 l    df *ABS*	00000000 k_sin.c
00000000 l    df *ABS*	00000000 kf_rem_pio2.c
20020418 l     O .data	0000000c init_jk
20020424 l     O .data	0000002c PIo2
00000000 l    df *ABS*	00000000 kf_tan.c
00000000 l    df *ABS*	00000000 s_fabs.c
00000000 l    df *ABS*	00000000 s_floor.c
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 s_rint.c
20020450 l     O .data	00000010 TWO52
00000000 l    df *ABS*	00000000 s_scalbn.c
00000000 l    df *ABS*	00000000 sf_expm1.c
00000000 l    df *ABS*	00000000 sf_fabs.c
00000000 l    df *ABS*	00000000 sf_finite.c
00000000 l    df *ABS*	00000000 sf_floor.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 sf_scalbn.c
00000000 l    df *ABS*	00000000 s_copysign.c
00000000 l    df *ABS*	00000000 sf_copysign.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 units.cpp
00000000 l    df *ABS*	00000000 resources.cpp
00000000 l    df *ABS*	00000000 lpc_speech_synth_phonemes.cpp
00000000 l    df *ABS*	00000000 lpc_speech_synth_words.cpp
00000000 l    df *ABS*	00000000 effect_delay_ext.cpp
00000000 l    df *ABS*	00000000 impure.c
20020aa0 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 random.cpp
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 Encoder.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
00000000 l       *UND*	00000000 __fini_array_end
00000000 l       *UND*	00000000 __bss_start__
00000000 l       *UND*	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 __fini_array_start
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __libc_fini
00000000 l       *UND*	00000000 __stack
0001b3f0 l     F .text.itcm	00000008 ___ZN11AudioStream17initialize_memoryEP18audio_block_structj_veneer
0001b3f8 l     F .text.itcm	00000008 ___Z14set_audioClockilmb_veneer
0001b400 l     F .text.itcm	00000008 ___init_veneer
60001860 l     F .text.progmem	00000008 ____libc_init_array_veneer
60001868 l     F .text.progmem	00000008 __set_arm_clock_veneer
60001870 l     F .text.progmem	00000008 __startup_late_hook_veneer
60001878 l     F .text.progmem	00000008 __pwm_init_veneer
60001880 l     F .text.progmem	00000008 __usb_init_serialnumber_veneer
60001888 l     F .text.progmem	00000008 __startup_early_hook_veneer
60001890 l     F .text.progmem	00000008 __delay_veneer
60001898 l     F .text.progmem	00000008 __memset_veneer
600018a0 l     F .text.progmem	00000008 __main_veneer
20000e60 g     O .data	00000204 plaits::lut_fm_frequency_quantizer
20020630 g     O .data	00000028 plaits::word_banks_
00001240 g     F .text.itcm	0000009c TeensySynth::updateOscillator()
20057ec8 g     O .bss	00000008 AsyncAudioInputSPDIF3::dma
20058224 g     O .bss	00000001 AudioStream_F32::f32_memory_used
00016460 g     F .text.itcm	00000018 usb_seremu_available
0000013c  w    F .text.itcm	0000000c IntervalTimer::~IntervalTimer()
00017c0c g     F .text.itcm	00000004 operator new[](unsigned int)
0000f8a8 g     F .text.itcm	000001d8 plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
000169dc g     F .text.itcm	00000002 startup_default_late_hook
0001a284 g     F .text.itcm	0000000e fabs
200587e0 g     O .bss	00000004 AudioStream::memory_pool
000175e8  w    F .text.itcm	000000f0 yield
20020658 g     O .data	00000040 plaits::LPCSpeechSynthWordBank::k0_lut_
20058238 g     O .bss	00000004 usb_timer1_callback
0001486c g     F .text.itcm	0000002a SdFile::addCluster()
60001744 g     O .text.progmem	00000018 usb_string_manufacturer_name_default
00012804 g     F .text.itcm	00000378 plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)
00002480  w    F .text.itcm	00000088 Encoder::isr21()
20058580 g     O .bss	00000004 usb_midi_handleProgramChange
20000958 g     O .data	00000404 stmlib::lut_pitch_ratio_low
2001fb14 g     O .data	0000000c vtable for AudioFilterBiquad_F32
0001815c g     F .text.itcm	0000000c exp2f
2001f6fc g     O .data	00000014 vtable for plaits::ModalEngine
00002838  w    F .text.itcm	00000088 Encoder::isr28()
00017894  w    F .text.itcm	00000004 usb_seremu_class::peek()
200587e4 g     O .bss	00000001 AudioStream::update_scheduled
2001fa90 g     O .data	0000000c vtable for AudioOutputI2S
000178e4 g     F .text.itcm	00000020 Print::println()
200587e8 g     O .bss	00000002 AudioStream::memory_used
00002a58  w    F .text.itcm	0000008c Encoder::isr32()
20004520 g     O .data	00018600 plaits::wav_integrated_waves
0001b0b8 g     F .text.itcm	00000002 __malloc_unlock
20058738 g     O .bss	00000004 usb_midi_handleAfterTouch
0000f7e4 g     F .text.itcm	0000008c plaits::StringEngine::Init(stmlib::BufferAllocator*)
00014ba8 g     F .text.itcm	00000074 Sd2Card::chipSelectHigh()
0000d5c0 g     F .text.itcm	00000048 plaits::GrainEngine::Init(stmlib::BufferAllocator*)
000029d0  w    F .text.itcm	00000088 Encoder::isr31()
00002040  w    F .text.itcm	00000088 Encoder::isr13()
600013ec g     F .text.progmem	00000058 analog_init
00007b38 g     F .text.itcm	00000046 plaits::LPCSpeechSynthWordBank::Init(plaits::LPCSpeechSynthWordBankData const*, int, stmlib::BufferAllocator*)
00013fe4 g     F .text.itcm	000000e0 AudioOutputI2S::begin()
00014ae8 g     F .text.itcm	00000018 SdFile::write(unsigned char)
00008700 g     F .text.itcm	00000044 plaits::ModalEngine::Init(stmlib::BufferAllocator*)
20020828 g     O .data	00000004 F_CPU_ACTUAL
2001ed68 g     O .data	00000384 plaits::bank_1
20058594 g     O .bss	00000004 usb_midi_handleSysExComplete
00002728  w    F .text.itcm	00000088 Encoder::isr26()
0000c53c g     F .text.itcm	00000164 plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)
00018168 g     F .text.itcm	0000033c powf
0001b41c g       .ARM.exidx	00000000 __exidx_end
2001d5d0 g     O .data	000012c2 plaits::bank_4
2005a6c0 g     O .bss	00000001 usb_midi_msg_type
00011650 g     F .text.itcm	00000002 plaits::NoiseEngine::Reset()
0000341c g     F .text.itcm	00000208 HardwareControls::checkControlValues(bool)
000001e0  w    F .text.itcm	00000854 TeensySynth::TeensySynth()
20057e4c g     O .bss	00000004 AudioOutputI2S::block_right_2nd
2001f9e0 g     O .data	00000014 vtable for plaits::SwarmEngine
20058764 g     O .bss	00000001 EventResponder::runningFromYield
200208ac g     O .data	00000080 isr_table_gpio2
000152ac g     F .text.itcm	00000018 AudioStream_F32::receiveReadOnly_f32(unsigned int)
000178b8 g     F .text.itcm	0000002c Print::write(unsigned char const*, unsigned int)
0000c4ac g     F .text.itcm	00000090 plaits::ChordEngine::Reset()
20000524 g     O .data	0000000c vtable for AudioEffectEnsemble_F32
20004118 g     O .data	00000202 plaits::lut_ws_bump
0001aa3c g     F .text.itcm	0000000c __errno
00003624 g     F .text.itcm	00001334 HardwareControls::init()
60001000 g     O .text.progmem	00000020 ImageVectorTable
00017898  w    F .text.itcm	00000004 usb_seremu_class::read()
20058754 g     O .bss	00000004 EventResponder::firstInterrupt
00016240 g     F .text.itcm	00000004 usb_transfer_status
00018ef0 g     F .text.itcm	00000298 __ieee754_rem_pio2f
00002d14  w    F .text.itcm	0000008c Encoder::isr37()
000152c4 g     F .text.itcm	00000042 AudioStream_F32::receiveWritable_f32(unsigned int)
00017fbc g     F .text.itcm	000000ac tanhf
20057ea8 g     O .bss	00000008 AudioOutputSPDIF3::dma
0001669c g     F .text.itcm	00000030 usb_seremu_flush_output
00016654 g     F .text.itcm	0000002c usb_seremu_putchar
2001fbd8 g     O .data	00000280 digital_pin_to_info_PGM
00015230 g     F .text.itcm	00000048 AudioStream_F32::release(audio_block_f32_t*)
2005a7ec g     O .bss	00000004 errno
0001a298 g     F .text.itcm	00000118 floor
0001b418 g       .text.itcm	00000000 _etext
00014fa4 g     F .text.itcm	000000d4 _spi_dma_rxISR0()
200212e0 g       .bss	00000000 _sbss
000148f8 g     F .text.itcm	000001f0 SdFile::write(void const*, unsigned int)
20057fe4 g     O .bss	00000200 SdVolume::cacheBuffer_
000127cc g     F .text.itcm	00000030 plaits::StringVoice::Init(stmlib::BufferAllocator*)
20058588 g     O .bss	00000004 usb_midi_handleVelocityChange
00016698 g     F .text.itcm	00000004 usb_seremu_write_buffer_free
60001920 g       *ABS*	00000000 _stextload
00017b44 g     F .text.itcm	00000018 AudioStream::receiveReadOnly(unsigned int)
00000b34 g     F .text.itcm	00000018 loop
000150bc g     F .text.itcm	00000068 allocate_f32_memory(int)
0000f870 g     F .text.itcm	00000038 plaits::StringEngine::Reset()
00017090 g     F .text.itcm	0000009c usb_midi_flush_output
00004d80 g     F .text.itcm	0000019c AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()
000160f8 g     F .text.itcm	00000064 usb_config_rx
00015338 g     F .text.itcm	000000a2 AudioMixer4_F32::update()
00011df8 g     F .text.itcm	00000002 plaits::WavetableEngine::Reset()
0000f32c g     F .text.itcm	0000001c plaits::FMEngine::Init(stmlib::BufferAllocator*)
20000530 g     O .data	0000000c vtable for AudioSynthPlaits_F32
000178a8  w    F .text.itcm	00000008 usb_seremu_class::write(unsigned char const*, unsigned int)
00015278 g     F .text.itcm	00000034 AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)
000171bc g     F .text.itcm	000003d0 usb_midi_read
0001448c g     F .text.itcm	000000f2 SdVolume::allocContiguous(unsigned long, unsigned long*)
00001ea8  w    F .text.itcm	00000088 Encoder::isr10()
000072d0 g     F .text.itcm	000000bc plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)
20058570 g     O .bss	00000004 usb_midi_handleSystemReset
000184a8 g     F .text.itcm	0000029c __ieee754_rem_pio2
20058758 g     O .bss	00000004 EventResponder::lastInterrupt
2005a6c2 g     O .bss	00000002 usb_midi_msg_sysex_len
00015578 g     F .text.itcm	00000134 memcpy
20058720 g     O .bss	00000004 usb_midi_handleRealTimeSystem
200581f8 g     O .bss	00000004 SdFile::dateTime_
000153dc g     F .text.itcm	000000a2 AudioMixer8_F32::update()
20058548 g     O .bss	00000004 systick_millis_count
20057fdc g     O .bss	00000004 SdVolume::cacheMirrorBlock_
20058260 g     O .bss	00000001 usb_configuration
0000afb8 g     F .text.itcm	00000104 plaits::HiHatEngine::Init(stmlib::BufferAllocator*)
200212fc g     O .bss	00036b14 ts
60000000 g     O .text.progmem	00000200 FlexSPI_NOR_Config
0000b0c0 g     F .text.itcm	0000136e plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
00014338 g     F .text.itcm	0000005c SdVolume::cacheRawBlock(unsigned long, unsigned char)
000072a0 g     F .text.itcm	0000002e plaits::SAMSpeechSynth::Init()
20058770 g     O .bss	00000070 AudioStream::memory_pool_available_mask
2001fa68 g     O .data	00000014 vtable for plaits::NoiseEngine
60001744  w    O .text.progmem	00000018 usb_string_manufacturer_name
0000cef8 g     F .text.itcm	00000002 plaits::AdditiveEngine::Reset()
0001aa98 g     F .text.itcm	00000010 malloc
000078a0 g     F .text.itcm	00000298 plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)
00014f30  w    F .text.itcm	0000001c EventResponder::triggerEvent(int, void*)
20020728 g     O .data	00000040 plaits::LPCSpeechSynthWordBank::period_lut_
60001300 g     F .text.progmem	000000ec usb_init
200587e6 g     O .bss	00000002 AudioStream::memory_pool_first_mask
00015180 g     F .text.itcm	00000016 AudioMemory_F32(int)
2001fa7c g     O .data	00000014 vtable for plaits::WavetableEngine
00019230 g     F .text.itcm	00000120 __kernel_cos
000019e0  w    F .text.itcm	00000088 Encoder::isr1()
00001a68  w    F .text.itcm	00000088 Encoder::isr4()
20058814 g     O .bss	00000004 __malloc_top_pad
00017c10 g     F .text.itcm	0000001a arm_biquad_cascade_df1_init_f32
00004f1c g     F .text.itcm	00000072 AudioSynthPlaits_F32::update()
2005a280 g     O .bss	00000004 systick_safe_read
aaaaaaff g       *ABS*	00000000 _flexram_bank_config
20020464 g     O .data	00000000 .hidden __dso_handle
0000f348 g     F .text.itcm	00000002 plaits::FMEngine::Reset()
20000000 g       .data	00000000 _sdata
2005857c g     O .bss	00000004 usb_midi_handleNoteOn
000178b0  w    F .text.itcm	00000006 usb_seremu_class::write(unsigned char)
600017d4 g     O .text.progmem	00000073 usb_config_descriptor_480
0001a870 g     F .text.itcm	00000014 finitef
0001b0bc g     F .text.itcm	00000024 _sbrk_r
000169d8 g     F .text.itcm	00000002 startup_default_early_hook
60001034 g     F .text.progmem	00000270 ResetHandler
00008ae4 g     F .text.itcm	00000002 plaits::WaveshapingEngine::Reset()
00015480 g     F .text.itcm	00000000 memcpy_tointerleaveLR
2001cb20 g     O .data	000000d2 plaits::LPCSpeechSynthController::phonemes_
00016b60 g     F .text.itcm	0000000a digitalWrite
0001a860 g     F .text.itcm	0000000e fabsf
2005875c g     O .bss	00000004 EventResponder::lastYield
00002948  w    F .text.itcm	00000088 Encoder::isr30()
00016fbc g     F .text.itcm	000000d4 usb_midi_configure
20057e44 g     O .bss	00000002 AudioOutputI2S::block_right_offset
00002b70  w    F .text.itcm	0000008c Encoder::isr34()
20058810 g     O .bss	00000004 __malloc_max_sbrked_mem
000087cc g     F .text.itcm	000002d8 plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
20003f14 g     O .data	00000202 plaits::lut_ws_double_bump
00014c1c g     F .text.itcm	00000130 Sd2Card::chipSelectLow()
00016b6c g     F .text.itcm	00000080 pinMode
2000268c g     O .data	00000202 plaits::lut_ws_linear
000199d0 g     F .text.itcm	000000b0 __kernel_sin
20057e68 g     O .bss	00000008 AudioInputTDM2::dma
20057fe0 g     O .bss	00000004 SdVolume::sdCard_
20058578 g     O .bss	00000004 usb_midi_handleSysExPartial
20280000 g       .bss.dma	00000000 _heap_end
0001b414 g       .ARM.exidx	00000000 __exidx_start
00013cbc  w    F .text.itcm	0000000c DMAChannel::~DMAChannel()
2005a6c4 g     O .bss	00000001 usb_midi_msg_data1
20020a98 g     O .data	00000001 __fdlib_version
20058760 g     O .bss	00000004 EventResponder::firstYield
00001850 g     F .text.itcm	0000003c TeensySynth::updateOscillatorBalance()
00002bfc  w    F .text.itcm	0000008c Encoder::isr35()
00014898 g     F .text.itcm	00000060 SdFile::seekSet(unsigned long)
20020470 g     O .data	00000004 stmlib::Random::rng_state_
00002eb8 g     F .text.itcm	00000564 HardwareControls::updateTeensySynth(unsigned char, int)
20020460 g     O .data	00000004 _global_impure_ptr
20057e34 g     O .bss	00000002 AudioOutputI2S::block_left_offset
2001f74c g     O .data	00000014 vtable for plaits::VirtualAnalogEngine
00014e84 g     F .text.itcm	00000098 Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)
0001aa48 g     F .text.itcm	00000050 __libc_init_array
00005b0c g     F .text.itcm	000003dc AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()
2002082c g     O .data	00000080 isr_table_gpio1
000178a0  w    F .text.itcm	00000004 usb_seremu_class::flush()
00014748 g     F .text.itcm	000000b8 SDHC_CardWriteBlock(void const*, unsigned long)
00017c2c g     F .text.itcm	00000196 arm_biquad_cascade_df1_f32
00002618  w    F .text.itcm	00000088 Encoder::isr24()
0000ceb8 g     F .text.itcm	0000003e plaits::AdditiveEngine::Init(stmlib::BufferAllocator*)
000169e0  w    F .text.itcm	0000008c HardFault_HandlerC
00016a6c g     F .text.itcm	00000030 _sbrk
6001cd3c g       *ABS*	00000000 _sdataload
00016804 g     F .text.itcm	00000164 attachInterrupt
20057e78 g     O .bss	00000008 AudioOutputTDM::dma
20020a7c g     O .data	00000004 __brkval
60001854 g     F .text.progmem	00000000 _init
200206d8 g     O .data	00000010 plaits::LPCSpeechSynthWordBank::k4_lut_
00008744 g     F .text.itcm	00000080 plaits::SpeechEngine::Init(stmlib::BufferAllocator*)
00018744 g     F .text.itcm	000001b0 __ieee754_expf
600016bc g     F .text.progmem	00000070 AudioStream::initialize_memory(audio_block_struct*, unsigned int)
20058208 g     O .bss	00000018 AudioStream_F32::f32_memory_pool_available_mask
00016680 g     F .text.itcm	00000018 usb_seremu_write
0000b0bc g     F .text.itcm	00000002 plaits::HiHatEngine::Reset()
00000020 g     F .text.itcm	000000bc irq_gpio6789
60001760 g     O .text.progmem	00000073 usb_config_descriptor_12
00019350 g     F .text.itcm	0000067c __kernel_rem_pio2
20020768 g     O .data	00000008 plaits::LPCSpeechSynthWordBank::k8_lut_
00002590  w    F .text.itcm	00000088 Encoder::isr23()
2005a820 g       .bss	00000000 _ebss
0001a3b4 g     F .text.itcm	0000011c rint
00012b7c g     F .text.itcm	00000064 plaits::String::Reset()
20057e40 g     O .bss	00000004 AudioOutputI2S::block_right_1st
20002890 g     O .data	00000280 plaits::lut_lpc_excitation_pulse
20057e50 g     O .bss	00000001 AudioOutputI2S::update_responsibility
00000148  w    F .text.itcm	00000098 AudioConvert_F32toI16::update()
00012c58  w    F .text.itcm	000003bc void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)
2000000c  w    O .data	0000000c vtable for AudioConvert_F32toI16
20201ca0 g       .bss.dma	00000000 _heap_start
00008aa4 g     F .text.itcm	00000040 plaits::WaveshapingEngine::Init(stmlib::BufferAllocator*)
000027b0  w    F .text.itcm	00000088 Encoder::isr27()
2001fb2c g     O .data	0000000c vtable for AudioMixer4_F32
200206c0 g     O .data	00000010 plaits::LPCSpeechSynthWordBank::energy_lut_
00001fb8  w    F .text.itcm	00000088 Encoder::isr12()
200206b0 g     O .data	00000010 plaits::LPCSpeechSynthWordBank::k3_lut_
0001553e g     F .text.itcm	00000000 memcpy_tointerleaveQuad
0000cefc g     F .text.itcm	00000120 plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)
00013cbc  w    F .text.itcm	0000000c DMAChannel::~DMAChannel()
00000004 g       *ABS*	00000000 _itcm_block_count
00000a34 g     F .text.itcm	00000078 readMidi()
20059000 g     O .bss	00000020 endpoint0_transfer_data
00016478 g     F .text.itcm	00000030 tx_zero_pad
00016bec g     F .text.itcm	000002b8 pwm_init
00015308 g     F .text.itcm	0000002e AudioConnection_F32::connect()
600012a4 g     F .text.progmem	0000005c set_audioClock(int, long, unsigned long, bool)
000051d0 g     F .text.itcm	0000093a AudioEffectFreeverbStereo_F32::update()
20020588 g     O .data	00000066 plaits::SAMSpeechSynth::phonemes_
2001fa2c  w    O .data	00000014 plaits::AnalogSnareDrum::Render(bool, bool, float, float, float, float, float, float*, unsigned int)::kModeFrequencies
6000153c g     F .text.progmem	00000064 usb_pll_start
6000102c g     O .text.progmem	00000008 vector_table
00011dfc g     F .text.itcm	000009ce plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
200205f0 g     O .data	00000040 plaits::SAMSpeechSynth::formant_amplitude_lut
0000d60c g     F .text.itcm	00001634 plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
00000000  w      *UND*	00000000 __deregister_frame_info
20059020 g     O .bss	00000020 endpoint0_transfer_ack
000161f4 g     F .text.itcm	00000028 usb_transmit
000179ac g     F .text.itcm	00000068 software_isr()
00017874 g     F .text.itcm	00000020 systick_isr
00010870 g     F .text.itcm	00000098 plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)
20057e54 g     O .bss	00000004 AudioOutputI2S::block_left_2nd
0000816c g     F .text.itcm	00000048 plaits::LPCSpeechSynthController::Init(plaits::LPCSpeechSynthWordBank*)
00015080 g     F .text.itcm	0000003c AudioFilterBiquad_F32::update()
2005876c g     O .bss	00000004 AudioStream::first_update
20020a88 g     O .data	00000010 Serial
2001cbf4 g     O .data	000009dc plaits::bank_3
0000eca8 g     F .text.itcm	00000002 plaits::SwarmEngine::Reset()
20058766 g     O .bss	00000002 AudioStream::memory_used_max
00004f90 g     F .text.itcm	00000114 AudioFilterMoog_F32::update_fixed(float const*, float*)
000169d8  w    F .text.itcm	00000002 startup_early_hook
00004d80 g     F .text.itcm	0000019c AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()
20057e48 g     O .bss	00000004 AudioOutputI2S::block_left_1st
000178a4  w    F .text.itcm	00000004 usb_seremu_class::availableForWrite()
000156ac g     F .text.itcm	000002c4 set_arm_clock
000081b4 g     F .text.itcm	0000042c plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)
20058540 g     O .bss	00000004 systick_cycle_count
20020a64 g     O .data	00000016 usb_string_serial_number_default
0001b220 g     F .text.itcm	000001d0 _free_r
20058568 g     O .bss	00000004 usb_midi_handleStop
00002da0  w    F .text.itcm	0000008c Encoder::isr38()
20002b10 g     O .data	00001404 plaits::lut_sine
20000554 g     O .data	00000404 stmlib::lut_pitch_ratio_high
20058694 g     O .bss	00000004 usb_midi_handleControlChange
200212d8 g     O .data	00000004 __malloc_sbrk_base
20057e14 g     O .bss	00000008 AudioOutputI2SOct::dma
00017ec0 g     F .text.itcm	000000a0 sin
0000d608 g     F .text.itcm	00000002 plaits::GrainEngine::Reset()
00016a9c  w    F .text.itcm	00000004 __cxa_pure_virtual
000161c4 g     F .text.itcm	0000002e usb_prepare_transfer
000169c0 g     F .text.itcm	00000018 unused_interrupt_vector
00005b0c g     F .text.itcm	000003dc AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()
600015a0 g     F .text.progmem	0000011c tempmon_init
2005822c g     O .bss	00000004 usb_timer0_callback
00001100 g     F .text.itcm	00000140 TeensySynth::updateFilter()
00017c04  w    F .text.itcm	00000002 serialEvent()
20058225 g     O .bss	00000001 AudioStream_F32::f32_memory_used_max
0001b0e0 g     F .text.itcm	000000a4 __register_exitproc
00016300 g     F .text.itcm	000000b4 usb_seremu_configure
000020c8  w    F .text.itcm	00000088 Encoder::isr14()
20020698 g     O .data	00000008 plaits::LPCSpeechSynthWordBank::k9_lut_
00013014  w    F .text.itcm	00000560 void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)
2001fa18 g     O .data	00000014 vtable for plaits::StringEngine
00000024 g       *ABS*	00000000 _teensy_model_identifier
20057e98 g     O .bss	00000008 AudioOutputI2S2::dma
00009360 g     F .text.itcm	00000002 plaits::VirtualAnalogEngine::Reset()
20058818 g     O .bss	00000028 __malloc_current_mallinfo
20057e80 g     O .bss	00000008 AudioInputI2S2::dma
000163b4 g     F .text.itcm	00000068 usb_seremu_getchar
2001fac4 g     O .data	00000050 SPIClass::spiclass_lpspi4_hardware
2001fa40 g     O .data	00000014 vtable for plaits::SnareDrumEngine
200587ec g     O .bss	0000001c HardwareSerial::s_serials_with_serial_events
00000138  w    F .text.itcm	00000002 TeensySynth::~TeensySynth()
00008ae8 g     F .text.itcm	000007ec plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
20058228 g     O .bss	00000004 AudioStream_F32::f32_memory_pool
0000515c g     F .text.itcm	00000074 AudioFilterMoog_F32::update()
00001d98  w    F .text.itcm	00000088 Encoder::isr8()
0001aa30 g     F .text.itcm	0000000c __cxa_atexit
00017bc4 g     F .text.itcm	00000040 AudioStream::update_setup()
00001b78  w    F .text.itcm	00000088 Encoder::isr6()
2005858c g     O .bss	00000004 usb_midi_handleNoteOff
20057e2c g     O .bss	00000008 AudioOutputPT8211_2::dma
000115d8 g     F .text.itcm	00000078 plaits::NoiseEngine::Init(stmlib::BufferAllocator*)
200207d0 g     O .data	00000050 SPI
2002092c g     O .data	00000080 isr_table_gpio3
0000ec40 g     F .text.itcm	00000068 plaits::SwarmEngine::Init(stmlib::BufferAllocator*)
00001c00  w    F .text.itcm	00000088 Encoder::isr7()
0000a78c g     F .text.itcm	0000082c plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
0000fb50 g     F .text.itcm	00000d20 plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
00013e80 g     F .text.itcm	00000098 AudioOutputI2S::update()
00017dc4 g     F .text.itcm	0000006c arm_scale_f32
2001f9b8 g     O .data	00000014 vtable for plaits::AdditiveEngine
20058544 g     O .bss	00000004 scale_cpu_cycles_to_microseconds
2002048c g     O .data	000000fa plaits::NaiveSpeechSynth::phonemes_
20057eb8 g     O .bss	00000008 AudioInputI2SHex::dma
0000f34c g     F .text.itcm	00000496 plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
0001641c g     F .text.itcm	00000044 usb_seremu_peekchar
00013640 g     F .text.itcm	00000348 plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)
20020ecc g     O .data	00000408 __malloc_av_
000188f4 g     F .text.itcm	000005fc __ieee754_powf
20001064 g     O .data	00000810 plaits::lut_fold_2
000021d8  w    F .text.itcm	00000088 Encoder::isr16()
20057e1c g     O .bss	00000008 AudioInputI2S::dma
0001b0b4 g     F .text.itcm	00000002 __malloc_lock
200206a0 g     O .data	00000010 plaits::LPCSpeechSynthWordBank::k6_lut_
000127fc g     F .text.itcm	00000006 plaits::StringVoice::Reset()
0001a920 g     F .text.itcm	000000d0 scalbnf
000010f8 g     F .text.itcm	00000002 TeensySynth::OnControlChange(unsigned char, unsigned char, unsigned char)
2001e894 g     O .data	000004d1 plaits::bank_0
2005a400 g     O .bss	000002c0 _VectorsRam
20020a84 g     O .data	00000001 yield_active_check_flags
2005823c g     O .bss	00000001 usb_high_speed
000154be g     F .text.itcm	00000000 memcpy_tointerleaveL
00015124 g     F .text.itcm	0000005c AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)
20057e88 g     O .bss	00000008 AudioInputI2SQuad::dma
0001b018 g     F .text.itcm	0000009a memset
00019188 g     F .text.itcm	000000a2 __ieee754_sqrtf
2001fe58  w    O .data	00000024 vtable for usb_seremu_class
0001799c g     F .text.itcm	00000010 main
00014418 g     F .text.itcm	00000074 SdVolume::fatGet(unsigned long, unsigned long*) const
20057e38 g     O .bss	00000008 AudioOutputI2S::dma
2005880c g     O .bss	00000004 __malloc_max_total_mem
00009464 g     F .text.itcm	0000126e plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
20200820 g     O .bss.dma	00000073 usb_descriptor_buffer
00013590 g     F .text.itcm	000000b0 plaits::Resonator::Init(float, int)
0000a768 g     F .text.itcm	00000022 plaits::ParticleEngine::Reset()
20000548 g     O .data	0000000c vtable for AudioEffectFreeverbStereo_F32
2001f0ec g     O .data	00000610 plaits::bank_2
0001a3b0 g     F .text.itcm	00000004 matherr
00016968 g     F .text.itcm	00000058 usb_init_serialnumber
60001914 g       .text.progmem	00000000 __init_array_end
0001aaa8 g     F .text.itcm	00000570 _malloc_r
20058808 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
00001d10  w    F .text.itcm	00000088 Encoder::isr3()
0001090c g     F .text.itcm	00000ccc plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
20058560 g     O .bss	00000004 usb_midi_handleSongPosition
00002e2c  w    F .text.itcm	0000008c Encoder::isr39()
20057e60 g     O .bss	00000008 AudioInputI2SOct::dma
00002370  w    F .text.itcm	00000088 Encoder::isr19()
00000138  w    F .text.itcm	00000002 TeensySynth::~TeensySynth()
2001fa9c  w    O .data	00000010 SPIClass::beginTransaction(SPISettings)::clk_sel
000177ac g     F .text.itcm	00000080 EventResponder::triggerEventNotImmediate()
20058564 g     O .bss	00000004 usb_midi_handleContinue
2005a6c5 g     O .bss	00000001 usb_midi_msg_data2
00015078 g     F .text.itcm	00000008 SPIClass::transfer(void const*, void*, unsigned int)
00000031 g       *ABS*	00000000 __rtc_localtime
20001874 g     O .data	00000810 plaits::lut_fold
2001fa54 g     O .data	00000014 vtable for plaits::BassDrumEngine
0001a0b0 g     F .text.itcm	000001d4 __kernel_tanf
00010908 g     F .text.itcm	00000002 plaits::BassDrumEngine::Reset()
0001b184 g     F .text.itcm	0000009c _malloc_trim_r
00001c88  w    F .text.itcm	00000088 Encoder::isr2()
6000175c g     O .text.progmem	00000004 string0
00014650 g     F .text.itcm	000000f8 SDHC_CardReadBlock(void*, unsigned long)
000169dc  w    F .text.itcm	00000002 startup_late_hook
00007608 g     F .text.itcm	00000298 plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)
00001958  w    F .text.itcm	00000088 Encoder::isr0()
60001852 g     O .text.progmem	00000001 _serialEvent_default
20002488 g     O .data	00000202 plaits::lut_ws_inverse_tan
2005a6c6 g     O .bss	00000001 usb_midi_msg_cable
000001e0  w    F .text.itcm	00000854 TeensySynth::TeensySynth()
20057e10 g     O .bss	00000004 hw
2005a000 g     O .bss	00000280 endpoint_queue_head
0000ecac g     F .text.itcm	00000680 plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
6000172c  w    O .text.progmem	00000018 usb_string_product_name
00000b84 g     F .text.itcm	0000007e TeensySynth::notesDel(signed char*, unsigned char)
0001a9f0 g     F .text.itcm	0000001a copysign
000166cc g     F .text.itcm	000000cc delay
20020780 g     O .data	00000010 plaits::LPCSpeechSynthWordBank::k2_lut_
00000c04 g     F .text.itcm	000002e0 TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)
20058752 g     O .bss	00000002 dma_channel_allocated_mask
20000d5c g     O .data	00000104 plaits::lut_stiffness
0001b410 g     F .fini	00000000 _fini
200207cc g     O .data	00000004 SdVolume::cacheBlockNumber_
00006d90 g     F .text.itcm	00000080 plaits::NaiveSpeechSynth::Init()
20057e24 g     O .bss	00000008 AudioOutputPT8211::dma
60001020 g     O .text.progmem	0000000c BootData
20020770 g     O .data	00000010 plaits::LPCSpeechSynthWordBank::k5_lut_
0001aa0c g     F .text.itcm	00000018 copysignf
20057ec0 g     O .bss	00000008 AudioOutputMQS::dma
0000c430 g     F .text.itcm	0000007c plaits::ChordEngine::Init(stmlib::BufferAllocator*)
00017984 g     F .text.itcm	00000016 Print::print(long)
00016af0 g     F .text.itcm	00000024 Panic_Temp_isr
2000053c g     O .data	0000000c vtable for AudioFilterMoog_F32
2001f78c g     O .data	00000014 vtable for plaits::HiHatEngine
20057f88 g     O .bss	00000054 SD
00017abc g     F .text.itcm	00000054 AudioStream::release(audio_block_struct*)
0001789c  w    F .text.itcm	00000004 usb_seremu_class::available()
00002ae4  w    F .text.itcm	0000008c Encoder::isr33()
0001a914 g     F .text.itcm	0000000c nanf
0001712c g     F .text.itcm	00000090 usb_midi_read_message
20020ec8 g     O .data	00000004 _impure_ptr
0001a4d0 g     F .text.itcm	0000011c scalbn
20057ee0 g     O .bss	00000008 AudioOutputSPDIF::dma
000085e0 g     F .text.itcm	00000006 plaits::ModalEngine::Reset()
00013988 g     F .text.itcm	0000001c plaits::ModalVoice::Init()
00017b10 g     F .text.itcm	00000034 AudioStream::transmit(audio_block_struct*, unsigned char)
0001758c g     F .text.itcm	0000005c IntervalTimer::end()
2005872c g     O .bss	00000004 usb_midi_handleTuneRequest
200206e8 g     O .data	00000040 plaits::LPCSpeechSynthWordBank::k1_lut_
600018a8 g       .text.progmem	00000000 __preinit_array_end
20057eb0 g     O .bss	00000008 AudioInputTDM::dma
20057e90 g     O .bss	00000008 AudioOutputTDM2::dma
2005a6c7 g     O .bss	00000001 usb_midi_msg_channel
00002c88  w    F .text.itcm	0000008c Encoder::isr36()
0000fb4c g     F .text.itcm	00000002 plaits::SnareDrumEngine::Reset()
000022e8  w    F .text.itcm	00000088 Encoder::isr18()
00017a14 g     F .text.itcm	000000a8 AudioStream::allocate()
000092d4 g     F .text.itcm	0000008c plaits::VirtualAnalogEngine::Init(stmlib::BufferAllocator*)
000160cc g     F .text.itcm	0000002c usb_stop_sof_interrupts
0000a6d4 g     F .text.itcm	00000094 plaits::ParticleEngine::Init(stmlib::BufferAllocator*)
000028c0  w    F .text.itcm	00000088 Encoder::isr29()
00000aac g     F .text.itcm	00000088 setup
2001fb54 g     O .data	00000084 usb_descriptor_list
00002260  w    F .text.itcm	00000088 Encoder::isr17()
000012dc g     F .text.itcm	00000574 TeensySynth::init()
00014290  w    F .text.itcm	00000002 Print::flush()
00001e20  w    F .text.itcm	00000088 Encoder::isr9()
20058590 g     O .bss	00000004 usb_midi_handleStart
0000c6a0 g     F .text.itcm	00000818 plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
2001f9f4 g     O .data	00000014 vtable for plaits::FMEngine
20060000 g       .bss.dma	00000000 _estack
00017778 g     F .text.itcm	00000034 DMAChannel::release()
00017f60 g     F .text.itcm	0000005c tanf
00017b5c g     F .text.itcm	00000068 AudioConnection::connect()
00014d4c g     F .text.itcm	00000048 Sd2Card::waitStartBlock()
00001af0  w    F .text.itcm	00000088 Encoder::isr5()
2001fb20 g     O .data	0000000c vtable for AudioMixer8_F32
200212e0 g       .data	00000000 _edata
00009364 g     F .text.itcm	00000100 plaits::VirtualAnalogEngine::ComputeDetuning(float) const
00004958 g     F .text.itcm	00000424 AudioEffectEnsemble_F32::update()
00002508  w    F .text.itcm	00000088 Encoder::isr22()
00015198 g     F .text.itcm	00000098 AudioStream_F32::allocate_f32()
00006e10 g     F .text.itcm	0000048e plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)
2005859c g     O .bss	00000004 usb_midi_handleClock
200209ac g     O .data	00000080 isr_table_gpio4
00016aa0 g     F .text.itcm	0000004e ultoa
2001faac g     O .data	00000018 vtable for SdFile
20002084 g     O .data	00000404 plaits::lut_svf_shift
20020790 g     O .data	0000003c plaits::wavetable
00017c08 g     F .text.itcm	00000004 operator new(unsigned int)
0001782c g     F .text.itcm	00000044 EventResponder::runFromInterrupt()
00005ee8 g     F .text.itcm	000002b4 plaits::Voice::Init(stmlib::BufferAllocator*)
200212d4 g     O .data	00000004 __malloc_trim_threshold
00014e10 g     F .text.itcm	00000074 Sd2Card::writeData(unsigned char, unsigned char const*)
000139a4 g     F .text.itcm	00000318 plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)
00001f30  w    F .text.itcm	00000088 Encoder::isr11()
000085e8 g     F .text.itcm	00000118 plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
00011dd4 g     F .text.itcm	00000024 plaits::WavetableEngine::Init(stmlib::BufferAllocator*)
0000fa80 g     F .text.itcm	000000cc plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)
2000431c g     O .data	00000202 plaits::lut_ws_inverse_sin
20058724 g     O .bss	00000004 usb_midi_handlePitchChange
20057ed0 g     O .bss	00000008 AudioOutputI2SHex::dma
200587ea g     O .bss	00000002 AudioStream::cpu_cycles_total
00007b80 g     F .text.itcm	00000024 plaits::LPCSpeechSynthWordBank::Reset()
00014b00 g     F .text.itcm	000000a8 Sd2Card::cardCommand(unsigned char, unsigned long)
000075cc g     F .text.itcm	0000003c plaits::LPCSpeechSynth::Init()
000142b8 g     F .text.itcm	00000080 SdVolume::cacheFlush()
00002150  w    F .text.itcm	00000088 Encoder::isr15()
20058574 g     O .bss	00000004 usb_midi_handleTimeCodeQuarterFrame
600018a8 g       .text.progmem	00000000 __init_array_start
00016798 g     F .text.itcm	00000068 analogRead
20020824 g     O .data	00000004 F_BUS_ACTUAL
0000738c g     F .text.itcm	00000240 plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)
20020474 g     O .data	00000018 plaits::lookup_table_i16_table
2005a6c8 g     O .bss	00000122 usb_midi_msg_sysex
00014d94 g     F .text.itcm	0000007c Sd2Card::SD_readBlock(unsigned long, unsigned char*)
00013d28 g     F .text.itcm	00000158 AudioOutputI2S::isr()
2001fb38 g     O .data	0000001c pin_to_channel
2001f724 g     O .data	00000014 vtable for plaits::WaveshapingEngine
000026a0  w    F .text.itcm	00000088 Encoder::isr25()
00019a80 g     F .text.itcm	00000630 __kernel_rem_pio2f
00018068 g     F .text.itcm	000000f4 expf
2001f760 g     O .data	00000014 vtable for plaits::ParticleEngine
00013f18 g     F .text.itcm	000000cc AudioOutputI2S::config_i2s()
000050a8 g     F .text.itcm	000000b4 AudioFilterMoog_F32::update_variable(float const*, float const*, float*)
2001f9cc g     O .data	00000014 vtable for plaits::GrainEngine
00000000 g       .text.itcm	00000000 _stext
000176d8 g     F .text.itcm	000000a0 DMAChannel::begin(bool)
20020a80 g     O .data	00000004 IntervalTimer::nvic_priorites
0000188c g     F .text.itcm	000000cc TeensySynth::updateChorusAndReverb()
00007ba4 g     F .text.itcm	00000576 plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)
0000013c  w    F .text.itcm	0000000c IntervalTimer::~IntervalTimer()
00011654 g     F .text.itcm	00000780 plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
6000172c g     O .text.progmem	00000018 usb_string_product_name_default
20057ea0 g     O .bss	00000008 AudioOutputI2SQuad::dma
0001a884 g     F .text.itcm	00000090 floorf
000154fe g     F .text.itcm	00000000 memcpy_tointerleaveR
60001444 g     F .text.progmem	000000f8 configure_cache
00012be0 g     F .text.itcm	00000078 plaits::String::Init(stmlib::BufferAllocator*)
000023f8  w    F .text.itcm	00000088 Encoder::isr20()
00013574 g     F .text.itcm	0000001c plaits::String::Process(float, float, float, float, float const*, float*, unsigned int)
20057ed8 g     O .bss	00000008 AudioOutputSPDIF2::dma
0000619c g     F .text.itcm	00000bf4 plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
20020468 g     O .data	00000008 myTimer
20057e70 g     O .bss	00000008 AudioInputAnalog::dma
20058768 g     O .bss	00000002 AudioStream::cpu_cycles_total_max
2001f860 g     O .data	00000014 vtable for plaits::ChordEngine
600018a8 g       .text.progmem	00000000 __preinit_array_start
0001621c g     F .text.itcm	00000024 usb_receive
20000000  w    O .data	0000000c vtable for AudioStream
00017e30 g     F .text.itcm	0000008c arm_add_f32
000164a8 g     F .text.itcm	00000068 tx_queue_transfer
0001a5ec g     F .text.itcm	00000274 expm1f
0003e018 g       *ABS*	00000000 _flashimagelen
20057ee8 g     O .bss	000000a0 Encoder::interruptArgs
0001aa24 g     F .text.itcm	0000000a __aeabi_atexit
20058680 g     O .bss	00000004 usb_midi_handleSongSelect
00000000  w      *UND*	00000000 __register_frame_info
00000ee4 g     F .text.itcm	00000214 TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)
0000d01c g     F .text.itcm	000005a4 plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)
00017870 g     F .text.itcm	00000004 pendablesrvreq_isr
20057e58 g     O .bss	00000008 AudioInputSPDIF3::dma
0001428c  w    F .text.itcm	00000004 Print::availableForWrite()
000087c4 g     F .text.itcm	00000008 plaits::SpeechEngine::Reset()
00017904 g     F .text.itcm	0000007e Print::printNumber(unsigned long, unsigned char, unsigned char)
0001615c g     F .text.itcm	00000068 usb_config_tx
200206d0 g     O .data	00000008 plaits::LPCSpeechSynthWordBank::k7_lut_
200585a0 g     O .bss	00000004 usb_midi_handleActiveSensing
200581e4 g     O .bss	00000001 SdVolume::cacheDirty_
2001f710 g     O .data	00000014 vtable for plaits::SpeechEngine
20020a64  w    O .data	00000016 usb_string_serial_number



Disassembly of section .text.progmem:

60000000 <FlexSPI_NOR_Config>:
60000000:	FCFB...V........
	...
60000044:	.............. .
	...
60000080:	.....2.&........
60000090:	...$............
	...
600000b0:	................
	...
600000d0:	 ...............
	...
60000100:	................
60000110:	..... ..........
	...
60000130:	`...............
	...
600001c0:	................
600001d0:	................
	...
60000200:	................
60000210:	................
60000220:	................
60000230:	................
60000240:	................
60000250:	................
60000260:	................
60000270:	................
60000280:	................
60000290:	................
600002a0:	................
600002b0:	................
600002c0:	................
600002d0:	................
600002e0:	................
600002f0:	................
60000300:	................
60000310:	................
60000320:	................
60000330:	................
60000340:	................
60000350:	................
60000360:	................
60000370:	................
60000380:	................
60000390:	................
600003a0:	................
600003b0:	................
600003c0:	................
600003d0:	................
600003e0:	................
600003f0:	................
60000400:	................
60000410:	................
60000420:	................
60000430:	................
60000440:	................
60000450:	................
60000460:	................
60000470:	................
60000480:	................
60000490:	................
600004a0:	................
600004b0:	................
600004c0:	................
600004d0:	................
600004e0:	................
600004f0:	................
60000500:	................
60000510:	................
60000520:	................
60000530:	................
60000540:	................
60000550:	................
60000560:	................
60000570:	................
60000580:	................
60000590:	................
600005a0:	................
600005b0:	................
600005c0:	................
600005d0:	................
600005e0:	................
600005f0:	................
60000600:	................
60000610:	................
60000620:	................
60000630:	................
60000640:	................
60000650:	................
60000660:	................
60000670:	................
60000680:	................
60000690:	................
600006a0:	................
600006b0:	................
600006c0:	................
600006d0:	................
600006e0:	................
600006f0:	................
60000700:	................
60000710:	................
60000720:	................
60000730:	................
60000740:	................
60000750:	................
60000760:	................
60000770:	................
60000780:	................
60000790:	................
600007a0:	................
600007b0:	................
600007c0:	................
600007d0:	................
600007e0:	................
600007f0:	................
60000800:	................
60000810:	................
60000820:	................
60000830:	................
60000840:	................
60000850:	................
60000860:	................
60000870:	................
60000880:	................
60000890:	................
600008a0:	................
600008b0:	................
600008c0:	................
600008d0:	................
600008e0:	................
600008f0:	................
60000900:	................
60000910:	................
60000920:	................
60000930:	................
60000940:	................
60000950:	................
60000960:	................
60000970:	................
60000980:	................
60000990:	................
600009a0:	................
600009b0:	................
600009c0:	................
600009d0:	................
600009e0:	................
600009f0:	................
60000a00:	................
60000a10:	................
60000a20:	................
60000a30:	................
60000a40:	................
60000a50:	................
60000a60:	................
60000a70:	................
60000a80:	................
60000a90:	................
60000aa0:	................
60000ab0:	................
60000ac0:	................
60000ad0:	................
60000ae0:	................
60000af0:	................
60000b00:	................
60000b10:	................
60000b20:	................
60000b30:	................
60000b40:	................
60000b50:	................
60000b60:	................
60000b70:	................
60000b80:	................
60000b90:	................
60000ba0:	................
60000bb0:	................
60000bc0:	................
60000bd0:	................
60000be0:	................
60000bf0:	................
60000c00:	................
60000c10:	................
60000c20:	................
60000c30:	................
60000c40:	................
60000c50:	................
60000c60:	................
60000c70:	................
60000c80:	................
60000c90:	................
60000ca0:	................
60000cb0:	................
60000cc0:	................
60000cd0:	................
60000ce0:	................
60000cf0:	................
60000d00:	................
60000d10:	................
60000d20:	................
60000d30:	................
60000d40:	................
60000d50:	................
60000d60:	................
60000d70:	................
60000d80:	................
60000d90:	................
60000da0:	................
60000db0:	................
60000dc0:	................
60000dd0:	................
60000de0:	................
60000df0:	................
60000e00:	................
60000e10:	................
60000e20:	................
60000e30:	................
60000e40:	................
60000e50:	................
60000e60:	................
60000e70:	................
60000e80:	................
60000e90:	................
60000ea0:	................
60000eb0:	................
60000ec0:	................
60000ed0:	................
60000ee0:	................
60000ef0:	................
60000f00:	................
60000f10:	................
60000f20:	................
60000f30:	................
60000f40:	................
60000f50:	................
60000f60:	................
60000f70:	................
60000f80:	................
60000f90:	................
60000fa0:	................
60000fb0:	................
60000fc0:	................
60000fd0:	................
60000fe0:	................
60000ff0:	................

60001000 <ImageVectorTable>:
60001000:	.. @,..`........
60001010:	 ..`...`........

60001020 <BootData>:
60001020:	...`........

6000102c <vector_table>:
6000102c:	... 5..`

60001034 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001034:	ldr	r3, [pc, #472]	; (60001210 <ResetHandler+0x1dc>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001036:	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103a:	ldr	r2, [pc, #472]	; (60001214 <ResetHandler+0x1e0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
6000103c:	ldr	r0, [pc, #472]	; (60001218 <ResetHandler+0x1e4>)
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103e:	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001040:	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001042:	ldr	r2, [pc, #472]	; (6000121c <ResetHandler+0x1e8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001044:	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001046:	mov	sp, r2
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001048:	ldr	r2, [pc, #468]	; (60001220 <ResetHandler+0x1ec>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000104a:	add.w	r3, r3, #180224	; 0x2c000
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000104e:	ldr	r1, [pc, #468]	; (60001224 <ResetHandler+0x1f0>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001050:	movs	r0, #8
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001052:	cmp	r2, r1
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001054:	str.w	r0, [r3, #340]	; 0x154
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001058:	beq.n	6000107a <ResetHandler+0x46>
	while (dest < dest_end) {
6000105a:	ldr	r3, [pc, #460]	; (60001228 <ResetHandler+0x1f4>)
6000105c:	cmp	r2, r3
6000105e:	bcs.n	6000107a <ResetHandler+0x46>
60001060:	mvns	r4, r2
60001062:	mov	r0, r1
60001064:	add	r3, r4
60001066:	bic.w	r3, r3, #3
6000106a:	adds	r3, #4
6000106c:	add	r3, r1
		*dest++ = *src++;
6000106e:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001072:	cmp	r0, r3
		*dest++ = *src++;
60001074:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001078:	bne.n	6000106e <ResetHandler+0x3a>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000107a:	ldr	r2, [pc, #432]	; (6000122c <ResetHandler+0x1f8>)
6000107c:	ldr	r1, [pc, #432]	; (60001230 <ResetHandler+0x1fc>)
6000107e:	cmp	r2, r1
60001080:	beq.n	600010a2 <ResetHandler+0x6e>
	while (dest < dest_end) {
60001082:	ldr	r3, [pc, #432]	; (60001234 <ResetHandler+0x200>)
60001084:	cmp	r2, r3
60001086:	bcs.n	600010a2 <ResetHandler+0x6e>
60001088:	mvns	r4, r2
6000108a:	mov	r0, r1
6000108c:	add	r3, r4
6000108e:	bic.w	r3, r3, #3
60001092:	adds	r3, #4
60001094:	add	r3, r1
		*dest++ = *src++;
60001096:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000109a:	cmp	r0, r3
		*dest++ = *src++;
6000109c:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
600010a0:	bne.n	60001096 <ResetHandler+0x62>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
600010a2:	ldr	r2, [pc, #404]	; (60001238 <ResetHandler+0x204>)
600010a4:	ldr	r3, [pc, #404]	; (6000123c <ResetHandler+0x208>)
600010a6:	cmp	r2, r3
600010a8:	bcs.n	600010c2 <ResetHandler+0x8e>
600010aa:	mvns	r0, r2
600010ac:	mov	r1, r2
		*dest++ = 0;
600010ae:	movs	r4, #0
600010b0:	add	r3, r0
600010b2:	bic.w	r3, r3, #3
600010b6:	adds	r3, #4
600010b8:	add	r3, r2
600010ba:	str.w	r4, [r1], #4
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
600010be:	cmp	r3, r1
600010c0:	bne.n	600010ba <ResetHandler+0x86>
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
600010c2:	ldr	r2, [pc, #380]	; (60001240 <ResetHandler+0x20c>)
600010c4:	mov.w	r1, #15728640	; 0xf00000
600010c8:	ldr	r3, [pc, #376]	; (60001244 <ResetHandler+0x210>)
600010ca:	str	r1, [r2, #0]
600010cc:	add.w	r1, r3, #704	; 0x2c0
600010d0:	ldr	r2, [pc, #372]	; (60001248 <ResetHandler+0x214>)

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
600010d2:	str.w	r2, [r3, #4]!
600010d6:	cmp	r1, r3
600010d8:	bne.n	600010d2 <ResetHandler+0x9e>
600010da:	ldr	r3, [pc, #368]	; (6000124c <ResetHandler+0x218>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600010dc:	movs	r1, #128	; 0x80
600010de:	ldr	r2, [pc, #368]	; (60001250 <ResetHandler+0x21c>)
600010e0:	strb.w	r1, [r3], #1
600010e4:	cmp	r3, r2
600010e6:	bne.n	600010e0 <ResetHandler+0xac>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600010e8:	ldr	r4, [pc, #360]	; (60001254 <ResetHandler+0x220>)
600010ea:	mov.w	r7, #2155905152	; 0x80808080
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600010ee:	ldr	r6, [pc, #360]	; (60001258 <ResetHandler+0x224>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010f0:	mov.w	r2, #4294967295
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010f4:	ldr.w	sl, [pc, #416]	; 60001298 <ResetHandler+0x264>
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600010f8:	movs	r5, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600010fa:	ldr.w	r9, [pc, #416]	; 6000129c <ResetHandler+0x268>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600010fe:	ldr.w	r8, [pc, #416]	; 600012a0 <ResetHandler+0x26c>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
60001102:	ldr	r3, [pc, #344]	; (6000125c <ResetHandler+0x228>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001104:	ldr	r1, [pc, #264]	; (60001210 <ResetHandler+0x1dc>)
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
60001106:	str.w	sl, [r3]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
6000110a:	str.w	r7, [r4, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
6000110e:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001112:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001116:	str.w	r8, [r4, #240]	; 0xf0
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
6000111a:	ldr	r3, [r6, #28]
6000111c:	bic.w	r3, r3, #127	; 0x7f
60001120:	orr.w	r3, r3, #64	; 0x40
60001124:	str	r3, [r6, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
60001126:	ldr	r3, [r6, #36]	; 0x24
60001128:	bic.w	r3, r3, #127	; 0x7f
6000112c:	orr.w	r3, r3, #64	; 0x40
60001130:	str	r3, [r6, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001132:	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
60001134:	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
60001136:	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
60001138:	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
6000113a:	bl	60001444 <configure_cache>
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
6000113e:	ldr	r2, [pc, #288]	; (60001260 <ResetHandler+0x22c>)
60001140:	movs	r0, #99	; 0x63
	SYST_CVR = 0;
60001142:	ldr	r3, [pc, #288]	; (60001264 <ResetHandler+0x230>)
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
60001144:	ldr	r1, [pc, #288]	; (60001268 <ResetHandler+0x234>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001146:	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001148:	movs	r2, #3
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
6000114a:	str	r5, [r3, #0]
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
6000114c:	str.w	r1, [sl, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001150:	str.w	r2, [r3, #-8]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001154:	ldr	r1, [pc, #276]	; (6000126c <ResetHandler+0x238>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001156:	ldr	r2, [pc, #280]	; (60001270 <ResetHandler+0x23c>)

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
60001158:	ldr	r0, [pc, #280]	; (60001274 <ResetHandler+0x240>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
6000115a:	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000115e:	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001160:	ldr	r2, [pc, #276]	; (60001278 <ResetHandler+0x244>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001162:	orr.w	r3, r3, #16777216	; 0x1000000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
60001166:	str.w	r0, [sl, #60]	; 0x3c
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000116a:	ldr	r0, [pc, #272]	; (6000127c <ResetHandler+0x248>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000116c:	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000116e:	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001170:	ldr	r1, [pc, #268]	; (60001280 <ResetHandler+0x24c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001172:	orr.w	r3, r3, #1
60001176:	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001178:	ldr	r3, [r0, #0]
6000117a:	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
6000117c:	bl	6000153c <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001180:	str.w	r7, [r4, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001184:	ldr	r0, [pc, #252]	; (60001284 <ResetHandler+0x250>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001186:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000118a:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000118e:	str.w	r8, [r4, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001192:	bl	60001868 <__set_arm_clock_veneer>
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?
60001196:	nop
60001198:	nop
6000119a:	nop
6000119c:	nop

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000119e:	ldr	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
600011a0:	ldr	r2, [pc, #228]	; (60001288 <ResetHandler+0x254>)
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
600011a2:	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
600011a6:	ldr	r3, [pc, #228]	; (6000128c <ResetHandler+0x258>)
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
600011a8:	str	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
600011aa:	str	r5, [r2, #0]
	PIT_TCTRL0 = 0;
600011ac:	str.w	r5, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
600011b0:	str.w	r5, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
600011b4:	str.w	r5, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
600011b8:	str.w	r5, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
600011bc:	ldr	r2, [r3, #56]	; 0x38
600011be:	lsls	r2, r2, #31
600011c0:	bmi.n	600011d4 <ResetHandler+0x1a0>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011c2:	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
600011c6:	ldr	r1, [pc, #200]	; (60001290 <ResetHandler+0x25c>)
600011c8:	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011ca:	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
600011cc:	ldr	r2, [r3, #56]	; 0x38
600011ce:	orr.w	r2, r2, #1
600011d2:	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600011d4:	ldr	r2, [pc, #180]	; (6000128c <ResetHandler+0x258>)
600011d6:	ldr	r4, [pc, #188]	; (60001294 <ResetHandler+0x260>)
600011d8:	ldr	r3, [r2, #8]
600011da:	orr.w	r3, r3, #65537	; 0x10001
600011de:	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
#endif
	startup_early_hook();
600011e0:	bl	60001888 <__startup_early_hook_veneer>
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
600011e4:	ldr	r3, [r4, #0]
	while (millis() < 20) ; // wait at least 20ms before starting USB
600011e6:	cmp	r3, #19
600011e8:	bls.n	600011e4 <ResetHandler+0x1b0>
	usb_init();
600011ea:	bl	60001300 <usb_init>
	analog_init();
600011ee:	bl	600013ec <analog_init>
	pwm_init();
600011f2:	bl	60001878 <__pwm_init_veneer>
	tempmon_init();
600011f6:	bl	600015a0 <tempmon_init>

	startup_late_hook();
600011fa:	bl	60001870 <__startup_late_hook_veneer>
600011fe:	ldr	r3, [r4, #0]
	while (millis() < 300) ; // wait at least 300ms before calling user code
60001200:	cmp.w	r3, #300	; 0x12c
60001204:	bcc.n	600011fe <ResetHandler+0x1ca>
	//printf("before C++ constructors\n");
	__libc_init_array();
60001206:	bl	60001860 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
6000120a:	bl	600018a0 <__main_veneer>
6000120e:	b.n	6000120e <ResetHandler+0x1da>
60001210:	.word	0x400ac000
60001214:	.word	0xaaaaaaff
60001218:	.word	0x00200007
6000121c:	.word	0x20060000
60001220:	.word	0x00000000
60001224:	.word	0x60001920
60001228:	.word	0x0001b418
6000122c:	.word	0x20000000
60001230:	.word	0x6001cd3c
60001234:	.word	0x200212e0
60001238:	.word	0x200212e0
6000123c:	.word	0x2005a820
60001240:	.word	0xe000ed88
60001244:	.word	0x2005a3fc
60001248:	.word	0x000169c1
6000124c:	.word	0xe000e400
60001250:	.word	0xe000e4a0
60001254:	.word	0x400d8000
60001258:	.word	0x400fc000
6000125c:	.word	0xe000ed08
60001260:	.word	0xe000e014
60001264:	.word	0xe000e018
60001268:	.word	0x00017871
6000126c:	.word	0xe000edfc
60001270:	.word	0x20200000
60001274:	.word	0x00017875
60001278:	.word	0xe0001000
6000127c:	.word	0xe0001004
60001280:	.word	0x20058540
60001284:	.word	0x2aea5400
60001288:	.word	0x40084000
6000128c:	.word	0x400d4000
60001290:	.word	0x56c00000
60001294:	.word	0x20058548
60001298:	.word	0x2005a400
6000129c:	.word	0x2018101b
600012a0:	.word	0x13110d0c

600012a4 <set_audioClock(int, long, unsigned long, bool)>:
#if defined(__IMXRT1052__) || defined(__IMXRT1062__)
#include "imxrt_hw.h"

FLASHMEM
void set_audioClock(int nfact, int32_t nmult, uint32_t ndiv, bool force) // sets PLL4
{
600012a4:	push	{r4}
	if (!force && (CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_ENABLE)) return;
600012a6:	cbnz	r3, 600012b0 <set_audioClock(int, long, unsigned long, bool)+0xc>
600012a8:	ldr	r3, [pc, #76]	; (600012f8 <set_audioClock(int, long, unsigned long, bool)+0x54>)
600012aa:	ldr	r3, [r3, #112]	; 0x70
600012ac:	lsls	r3, r3, #18
600012ae:	bmi.n	600012f2 <set_audioClock(int, long, unsigned long, bool)+0x4e>

	CCM_ANALOG_PLL_AUDIO = CCM_ANALOG_PLL_AUDIO_BYPASS | CCM_ANALOG_PLL_AUDIO_ENABLE
			     | CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT(2) // 2: 1/4; 1: 1/2; 0: 1/1
			     | CCM_ANALOG_PLL_AUDIO_DIV_SELECT(nfact);
600012b0:	and.w	r0, r0, #63	; 0x3f
600012b4:	ldr	r3, [pc, #64]	; (600012f8 <set_audioClock(int, long, unsigned long, bool)+0x54>)

	CCM_ANALOG_PLL_AUDIO_NUM   = nmult & CCM_ANALOG_PLL_AUDIO_NUM_MASK;
	CCM_ANALOG_PLL_AUDIO_DENOM = ndiv & CCM_ANALOG_PLL_AUDIO_DENOM_MASK;
600012b6:	bic.w	r2, r2, #3758096384	; 0xe0000000

	CCM_ANALOG_PLL_AUDIO = CCM_ANALOG_PLL_AUDIO_BYPASS | CCM_ANALOG_PLL_AUDIO_ENABLE
			     | CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT(2) // 2: 1/4; 1: 1/2; 0: 1/1
			     | CCM_ANALOG_PLL_AUDIO_DIV_SELECT(nfact);

	CCM_ANALOG_PLL_AUDIO_NUM   = nmult & CCM_ANALOG_PLL_AUDIO_NUM_MASK;
600012ba:	bic.w	r1, r1, #3758096384	; 0xe0000000
{
	if (!force && (CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_ENABLE)) return;

	CCM_ANALOG_PLL_AUDIO = CCM_ANALOG_PLL_AUDIO_BYPASS | CCM_ANALOG_PLL_AUDIO_ENABLE
			     | CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT(2) // 2: 1/4; 1: 1/2; 0: 1/1
			     | CCM_ANALOG_PLL_AUDIO_DIV_SELECT(nfact);
600012be:	orr.w	r0, r0, #1122304	; 0x112000

	CCM_ANALOG_PLL_AUDIO_NUM   = nmult & CCM_ANALOG_PLL_AUDIO_NUM_MASK;
	CCM_ANALOG_PLL_AUDIO_DENOM = ndiv & CCM_ANALOG_PLL_AUDIO_DENOM_MASK;
	
	CCM_ANALOG_PLL_AUDIO &= ~CCM_ANALOG_PLL_AUDIO_POWERDOWN;//Switch on PLL
	while (!(CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_LOCK)) {}; //Wait for pll-lock
600012c2:	mov	r4, r3
{
	if (!force && (CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_ENABLE)) return;

	CCM_ANALOG_PLL_AUDIO = CCM_ANALOG_PLL_AUDIO_BYPASS | CCM_ANALOG_PLL_AUDIO_ENABLE
			     | CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT(2) // 2: 1/4; 1: 1/2; 0: 1/1
			     | CCM_ANALOG_PLL_AUDIO_DIV_SELECT(nfact);
600012c4:	str	r0, [r3, #112]	; 0x70

	CCM_ANALOG_PLL_AUDIO_NUM   = nmult & CCM_ANALOG_PLL_AUDIO_NUM_MASK;
600012c6:	str.w	r1, [r3, #128]	; 0x80
	CCM_ANALOG_PLL_AUDIO_DENOM = ndiv & CCM_ANALOG_PLL_AUDIO_DENOM_MASK;
600012ca:	str.w	r2, [r3, #144]	; 0x90
	
	CCM_ANALOG_PLL_AUDIO &= ~CCM_ANALOG_PLL_AUDIO_POWERDOWN;//Switch on PLL
600012ce:	ldr	r2, [r3, #112]	; 0x70
600012d0:	bic.w	r2, r2, #4096	; 0x1000
600012d4:	str	r2, [r3, #112]	; 0x70
	while (!(CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_LOCK)) {}; //Wait for pll-lock
600012d6:	ldr	r3, [r4, #112]	; 0x70
600012d8:	ldr	r2, [pc, #28]	; (600012f8 <set_audioClock(int, long, unsigned long, bool)+0x54>)
600012da:	cmp	r3, #0
600012dc:	bge.n	600012d6 <set_audioClock(int, long, unsigned long, bool)+0x32>
	
	const int div_post_pll = 1; // other values: 2,4
	CCM_ANALOG_MISC2 &= ~(CCM_ANALOG_MISC2_DIV_MSB | CCM_ANALOG_MISC2_DIV_LSB);
600012de:	ldr.w	r1, [r2, #368]	; 0x170
600012e2:	ldr	r3, [pc, #24]	; (600012fc <set_audioClock(int, long, unsigned long, bool)+0x58>)
600012e4:	ands	r3, r1
600012e6:	str.w	r3, [r2, #368]	; 0x170
	if(div_post_pll>1) CCM_ANALOG_MISC2 |= CCM_ANALOG_MISC2_DIV_LSB;
	if(div_post_pll>3) CCM_ANALOG_MISC2 |= CCM_ANALOG_MISC2_DIV_MSB;
	
	CCM_ANALOG_PLL_AUDIO &= ~CCM_ANALOG_PLL_AUDIO_BYPASS;//Disable Bypass
600012ea:	ldr	r3, [r2, #112]	; 0x70
600012ec:	bic.w	r3, r3, #65536	; 0x10000
600012f0:	str	r3, [r2, #112]	; 0x70
}
600012f2:	ldr.w	r4, [sp], #4
600012f6:	bx	lr
600012f8:	.word	0x400d8000
600012fc:	.word	0xff7f7fff

60001300 <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001300:	ldr	r3, [pc, #192]	; (600013c4 <usb_init+0xc4>)
60001302:	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
60001306:	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
60001308:	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
6000130c:	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001310:	bl	60001880 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001314:	ldr	r1, [pc, #176]	; (600013c8 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001316:	ldr	r0, [pc, #180]	; (600013cc <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001318:	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
6000131c:	ldr	r4, [pc, #176]	; (600013d0 <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
6000131e:	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001322:	ldr	r3, [pc, #176]	; (600013d4 <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001324:	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001328:	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
6000132c:	ldr	r2, [r4, #0]
6000132e:	ands	r3, r2
60001330:	cbnz	r3, 6000133a <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
60001332:	ldr.w	r3, [r0, #424]	; 0x1a8
60001336:	lsls	r2, r3, #30
60001338:	beq.n	60001370 <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
6000133a:	ldr	r3, [pc, #144]	; (600013cc <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
6000133c:	mov.w	r1, #2147483648	; 0x80000000
60001340:	ldr	r2, [pc, #140]	; (600013d0 <usb_init+0xd0>)
60001342:	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001344:	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
60001346:	ldr.w	r1, [r3, #320]	; 0x140
6000134a:	orr.w	r1, r1, #2
6000134e:	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
60001352:	ldr.w	r3, [r2, #320]	; 0x140
60001356:	lsls	r3, r3, #30
60001358:	bmi.n	60001352 <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
6000135a:	mov.w	r0, #131072	; 0x20000
6000135e:	ldr	r1, [pc, #120]	; (600013d8 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001360:	ldr	r3, [pc, #108]	; (600013d0 <usb_init+0xd0>)
60001362:	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001366:	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001368:	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
6000136a:	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
6000136c:	bl	60001890 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001370:	ldr	r5, [pc, #104]	; (600013dc <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001372:	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001374:	ldr	r3, [pc, #88]	; (600013d0 <usb_init+0xd0>)
60001376:	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000137a:	ldr	r4, [pc, #80]	; (600013cc <usb_init+0xcc>)
6000137c:	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000137e:	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001380:	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
60001382:	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001384:	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001386:	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000138a:	mov.w	r2, #640	; 0x280
6000138e:	bl	60001898 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
60001392:	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
60001396:	mov.w	r0, #4194304	; 0x400000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000139a:	movw	r3, #323	; 0x143
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
6000139e:	ldr	r2, [pc, #64]	; (600013e0 <usb_init+0xe0>)
600013a0:	ldr	r1, [pc, #64]	; (600013e4 <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
600013a2:	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
600013a4:	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
600013a6:	str.w	r5, [r4, #344]	; 0x158
600013aa:	str.w	r1, [r2, #516]	; 0x204
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
600013ae:	str.w	r3, [r4, #328]	; 0x148
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
600013b2:	ldr	r2, [pc, #52]	; (600013e8 <usb_init+0xe8>)
600013b4:	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600013b8:	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
600013ba:	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600013bc:	str.w	r3, [r4, #320]	; 0x140
600013c0:	pop	{r4, r5, r6, pc}
600013c2:	nop
600013c4:	.word	0x400d8000
600013c8:	.word	0x400fc000
600013cc:	.word	0x402e0000
600013d0:	.word	0x400d9000
600013d4:	.word	0x001e1c00
600013d8:	.word	0xe000e28c
600013dc:	.word	0x2005a000
600013e0:	.word	0x2005a400
600013e4:	.word	0x00015ab9
600013e8:	.word	0xe000e10c

600013ec <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600013ec:	ldr	r3, [pc, #68]	; (60001434 <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
600013ee:	ldr	r1, [pc, #72]	; (60001438 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600013f0:	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600013f2:	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600013f4:	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
600013f8:	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600013fa:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
600013fc:	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001400:	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001402:	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001404:	orr.w	r0, r0, #768	; 0x300
60001408:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
6000140a:	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
6000140c:	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
6000140e:	ldr	r3, [r2, #72]	; 0x48
60001410:	lsls	r3, r3, #24
60001412:	bmi.n	6000140e <analog_init+0x22>
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001414:	ldr	r3, [pc, #36]	; (6000143c <analog_init+0x50>)
60001416:	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
6000141a:	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
6000141c:	mov	r2, r3
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
6000141e:	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001420:	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
60001422:	ldr	r3, [r2, #72]	; 0x48
60001424:	ands.w	r3, r3, #128	; 0x80
60001428:	bne.n	60001422 <analog_init+0x36>
	calibrating = 0;
6000142a:	ldr	r2, [pc, #20]	; (60001440 <analog_init+0x54>)
6000142c:	strb	r3, [r2, #0]
}
6000142e:	pop	{r4, r5}
60001430:	bx	lr
60001432:	nop
60001434:	.word	0x400fc000
60001438:	.word	0x400c4000
6000143c:	.word	0x400c8000
60001440:	.word	0x2005854c

60001444 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
60001444:	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001446:	ldr	r2, [pc, #160]	; (600014e8 <configure_cache+0xa4>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
60001448:	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
6000144a:	ldr	r3, [pc, #160]	; (600014ec <configure_cache+0xa8>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
6000144c:	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
60001450:	ldr	r4, [pc, #156]	; (600014f0 <configure_cache+0xac>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001452:	movs	r7, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001454:	ldr.w	lr, [pc, #216]	; 60001530 <configure_cache+0xec>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001458:	movs	r6, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
6000145a:	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
6000145c:	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
6000145e:	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001462:	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001466:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
60001468:	ldr.w	lr, [pc, #200]	; 60001534 <configure_cache+0xf0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
6000146c:	ldr	r7, [pc, #132]	; (600014f4 <configure_cache+0xb0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
6000146e:	str.w	lr, [r3]

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001472:	str	r6, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
60001474:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
60001476:	ldr	r6, [pc, #128]	; (600014f8 <configure_cache+0xb4>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
60001478:	ldr	r7, [pc, #128]	; (600014fc <configure_cache+0xb8>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
6000147a:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
6000147c:	ldr	r1, [pc, #128]	; (60001500 <configure_cache+0xbc>)
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
6000147e:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
60001480:	ldr	r6, [pc, #128]	; (60001504 <configure_cache+0xc0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001482:	orr.w	r1, r1, #21

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
60001486:	ldr	r7, [pc, #128]	; (60001508 <configure_cache+0xc4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
60001488:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
6000148a:	str	r7, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
6000148c:	add.w	r7, r7, #196608	; 0x30000

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001490:	ldr	r6, [pc, #120]	; (6000150c <configure_cache+0xc8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
60001492:	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
60001494:	adds	r7, #2

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
60001496:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
60001498:	ldr.w	lr, [pc, #156]	; 60001538 <configure_cache+0xf4>
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
6000149c:	ldr	r6, [pc, #112]	; (60001510 <configure_cache+0xcc>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
6000149e:	ldr	r1, [pc, #116]	; (60001514 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600014a0:	str.w	lr, [r2]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600014a4:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600014a6:	str	r6, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600014a8:	ldr	r7, [pc, #108]	; (60001518 <configure_cache+0xd4>)

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600014aa:	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600014ac:	ldr	r6, [pc, #108]	; (6000151c <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600014ae:	ldr	r1, [pc, #112]	; (60001520 <configure_cache+0xdc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600014b0:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600014b2:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;
600014b4:	ldr	r7, [pc, #108]	; (60001524 <configure_cache+0xe0>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600014b6:	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600014b8:	ldr	r6, [pc, #108]	; (60001528 <configure_cache+0xe4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600014ba:	ldr	r1, [pc, #112]	; (6000152c <configure_cache+0xe8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;
600014bc:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600014be:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600014c0:	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600014c2:	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
600014c4:	dsb	sy
	asm("isb");
600014c8:	isb	sy
	SCB_CACHE_ICIALLU = 0;
600014cc:	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
600014d0:	dsb	sy
	asm("isb");
600014d4:	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
600014d8:	ldr.w	r3, [r2, #-136]
600014dc:	orr.w	r3, r3, #196608	; 0x30000
600014e0:	str.w	r3, [r2, #-136]
600014e4:	pop	{r4, r5, r6, r7, pc}
600014e6:	nop
600014e8:	.word	0xe000ed9c
600014ec:	.word	0xe000eda0
600014f0:	.word	0xe000ed94
600014f4:	.word	0x00100009
600014f8:	.word	0x00200013
600014fc:	.word	0x07020021
60001500:	.word	0x2005a820
60001504:	.word	0x20000014
60001508:	.word	0x13080025
6000150c:	.word	0x10000009
60001510:	.word	0x40000017
60001514:	.word	0x13100033
60001518:	.word	0x60000018
6000151c:	.word	0x070b002f
60001520:	.word	0x70000019
60001524:	.word	0x170b0037
60001528:	.word	0x7000001a
6000152c:	.word	0x130b002f
60001530:	.word	0x1000003f
60001534:	.word	0x03080025
60001538:	.word	0x20200016

6000153c <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
6000153c:	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
6000153e:	ldr	r2, [pc, #92]	; (6000159c <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001540:	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001542:	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001546:	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000154a:	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000154e:	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001552:	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001556:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001558:	tst.w	r3, #2
6000155c:	beq.n	6000156c <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000155e:	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001560:	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001562:	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001564:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001566:	tst.w	r3, #2
6000156a:	bne.n	6000155e <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
6000156c:	tst.w	r3, #8192	; 0x2000
60001570:	bne.n	60001576 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001572:	str	r5, [r2, #20]
			continue;
60001574:	b.n	60001556 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001576:	tst.w	r3, #4096	; 0x1000
6000157a:	bne.n	60001580 <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000157c:	str	r6, [r2, #20]
			continue;
6000157e:	b.n	60001556 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001580:	cmp	r3, #0
60001582:	bge.n	60001556 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001584:	tst.w	r3, #65536	; 0x10000
60001588:	beq.n	6000158e <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
6000158a:	str	r1, [r2, #24]
			continue;
6000158c:	b.n	60001556 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
6000158e:	lsls	r3, r3, #25
60001590:	bmi.n	60001596 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001592:	str	r7, [r2, #20]
			continue;
60001594:	b.n	60001556 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001596:	pop	{r4, r5, r6, r7}
60001598:	bx	lr
6000159a:	nop
6000159c:	.word	0x400d8000

600015a0 <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600015a0:	ldr	r2, [pc, #236]	; (60001690 <tempmon_init+0xf0>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600015a2:	vmov.f32	s13, #57	; 0x41c80000  25.0

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600015a6:	ldr	r1, [pc, #236]	; (60001694 <tempmon_init+0xf4>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600015a8:	movs	r0, #0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600015aa:	ldr	r3, [r2, #0]
  asm volatile ("dsb":::"memory");
  while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
600015ac:	push	{r4, r5, r6, r7, lr}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600015ae:	bic.w	r3, r3, #1

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600015b2:	movs	r4, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600015b4:	ldr.w	lr, [pc, #256]	; 600016b8 <tempmon_init+0x118>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600015b8:	str	r3, [r2, #0]

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600015ba:	str.w	r4, [r2, #144]	; 0x90
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600015be:	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
600015c2:	ldr	r7, [pc, #212]	; (60001698 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600015c4:	uxtb	r5, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600015c6:	ubfx	r4, r3, #8, #12
600015ca:	ldr	r6, [pc, #208]	; (6000169c <tempmon_init+0xfc>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
600015cc:	rsb	r3, r4, r3, lsr #20
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600015d0:	vmov	s15, r5
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600015d4:	sub.w	r1, r5, #85	; 0x55
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600015d8:	str.w	r5, [lr]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600015dc:	vcvt.f32.s32	s14, s15
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600015e0:	add.w	r5, r3, r3, lsl #2
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600015e4:	vmov	s15, r4
600015e8:	mul.w	r1, r3, r1
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
600015ec:	str	r3, [r7, #0]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600015ee:	add.w	r3, r3, r3, lsl #6
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600015f2:	vcvt.f32.s32	s10, s15
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600015f6:	vmov	s15, r1
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600015fa:	subs	r1, r1, r5
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600015fc:	vsub.f32	s13, s14, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001600:	vcvt.f32.u32	s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001604:	ldr	r5, [pc, #152]	; (600016a0 <tempmon_init+0x100>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001606:	vmov	s15, r1
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000160a:	add	r3, r1
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
6000160c:	vstr	s13, [r5]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001610:	vcvt.f32.u32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001614:	str	r4, [r6, #0]
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001616:	vdiv.f32	s11, s14, s13
6000161a:	ldr	r6, [pc, #136]	; (600016a4 <tempmon_init+0x104>)
6000161c:	ldr	r5, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000161e:	ldr	r1, [pc, #136]	; (600016a8 <tempmon_init+0x108>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001620:	ldr	r4, [pc, #136]	; (600016ac <tempmon_init+0x10c>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001622:	vdiv.f32	s12, s15, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001626:	vmov	s15, r3
6000162a:	ldr	r3, [pc, #132]	; (600016b0 <tempmon_init+0x110>)
6000162c:	str.w	r3, [r6, #320]	; 0x140
60001630:	vcvt.f32.u32	s15, s15
60001634:	vdiv.f32	s14, s15, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001638:	vadd.f32	s11, s11, s10
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000163c:	vadd.f32	s13, s12, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001640:	vcvt.u32.f32	s11, s11
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001644:	vcvt.u32.f32	s13, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001648:	vmov	r3, s11
6000164c:	orr.w	r3, r5, r3, lsl #20
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001650:	vmov	r5, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001654:	vadd.f32	s15, s14, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001658:	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000165a:	and.w	r1, r1, r5, lsl #16
6000165e:	ldr.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001662:	vcvt.u32.f32	s15, s15
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001666:	orrs	r3, r1
60001668:	str.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000166c:	vmov	r3, s15
60001670:	ldr.w	r1, [r2, #272]	; 0x110
60001674:	ubfx	r3, r3, #0, #12
60001678:	orrs	r3, r1
6000167a:	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
6000167e:	ldr	r3, [r2, #0]
60001680:	orr.w	r3, r3, #2
60001684:	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001686:	strb	r0, [r4, #0]
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001688:	ldr	r3, [pc, #40]	; (600016b4 <tempmon_init+0x114>)
6000168a:	movs	r2, #1
6000168c:	str	r2, [r3, #0]
6000168e:	pop	{r4, r5, r6, r7, pc}
60001690:	.word	0x400d8180
60001694:	.word	0x401f4400
60001698:	.word	0x20058558
6000169c:	.word	0x2005855c
600016a0:	.word	0x20058554
600016a4:	.word	0x2005a400
600016a8:	.word	0x0fff0000
600016ac:	.word	0xe000e440
600016b0:	.word	0x00016af1
600016b4:	.word	0xe000e108
600016b8:	.word	0x20058550

600016bc <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>:


// Set up the pool of audio data blocks
// placing them all onto the free list
FLASHMEM void AudioStream::initialize_memory(audio_block_t *data, unsigned int num)
{
600016bc:	cmp.w	r1, #896	; 0x380
600016c0:	push	{r4, r5, r6, r7}
600016c2:	it	cs
600016c4:	movcs.w	r1, #896	; 0x380
	unsigned int maxnum = MAX_AUDIO_MEMORY / AUDIO_BLOCK_SAMPLES / 2;

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
600016c8:	cpsid	i
	memory_pool = data;
	memory_pool_first_mask = 0;
600016ca:	movs	r5, #0
600016cc:	ldr	r3, [pc, #76]	; (6000171c <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x60>)

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
600016ce:	ldr	r7, [pc, #80]	; (60001720 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x64>)
	memory_pool_first_mask = 0;
600016d0:	ldr	r6, [pc, #80]	; (60001724 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x68>)
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
600016d2:	mov	r4, r5
600016d4:	add.w	r2, r3, #112	; 0x70

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
600016d8:	str	r0, [r7, #0]
	memory_pool_first_mask = 0;
600016da:	strh	r5, [r6, #0]
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
600016dc:	str.w	r4, [r3, #4]!
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
600016e0:	cmp	r3, r2
600016e2:	bne.n	600016dc <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x20>
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
600016e4:	cbz	r1, 60001716 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x5a>
600016e6:	movs	r3, #0
600016e8:	ldr	r6, [pc, #60]	; (60001728 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x6c>)
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
600016ea:	movs	r7, #1
600016ec:	lsrs	r5, r3, #5
600016ee:	and.w	r4, r3, #31
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
600016f2:	adds	r3, #1
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
600016f4:	ldr.w	r2, [r6, r5, lsl #2]
600016f8:	lsl.w	r4, r7, r4
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
600016fc:	cmp	r3, r1
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
600016fe:	orr.w	r2, r2, r4
60001702:	str.w	r2, [r6, r5, lsl #2]
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
60001706:	bne.n	600016ec <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x30>
60001708:	movs	r3, #0
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
		data[i].memory_pool_index = i;
6000170a:	strh	r3, [r0, #2]
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
6000170c:	adds	r3, #1
6000170e:	add.w	r0, r0, #260	; 0x104
60001712:	cmp	r3, r1
60001714:	bne.n	6000170a <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x4e>
		data[i].memory_pool_index = i;
	}
	__enable_irq();
60001716:	cpsie	i

}
60001718:	pop	{r4, r5, r6, r7}
6000171a:	bx	lr
6000171c:	.word	0x2005876c
60001720:	.word	0x200587e0
60001724:	.word	0x200587e6
60001728:	.word	0x20058770

6000172c <usb_string_product_name_default>:
6000172c:	..T.e.e.n.s.y. .
6000173c:	M.I.D.I.

60001744 <usb_string_manufacturer_name_default>:
60001744:	..T.e.e.n.s.y.d.
60001754:	u.i.n.o.

6000175c <string0>:
6000175c:	....

60001760 <usb_config_descriptor_12>:
60001760:	..s.....2.......
60001770:	...$...%..$.....
60001780:	$.....$........$
60001790:	...........@....
600017a0:	.%.......@.....%
600017b0:	.............!..
600017c0:	.."!.....@......
600017d0:	 ...

600017d4 <usb_config_descriptor_480>:
600017d4:	..s.....2.......
600017e4:	...$...%..$.....
600017f4:	$.....$........$
60001804:	................
60001814:	.%.............%
60001824:	.............!..
60001834:	.."!.....@......
60001844:	 ...

60001848 <qualifier_descriptor>:
60001848:	.......@..

60001852 <_serialEvent_default>:
60001852:	..

60001854 <_init>:
60001854:	push	{r3, r4, r5, r6, r7, lr}
60001856:	nop
60001858:	pop	{r3, r4, r5, r6, r7}
6000185a:	pop	{r3}
6000185c:	mov	lr, r3
6000185e:	bx	lr

60001860 <____libc_init_array_veneer>:
60001860:	ldr.w	pc, [pc]	; 60001864 <____libc_init_array_veneer+0x4>
60001864:	.word	0x0001aa49

60001868 <__set_arm_clock_veneer>:
60001868:	ldr.w	pc, [pc]	; 6000186c <__set_arm_clock_veneer+0x4>
6000186c:	.word	0x000156ad

60001870 <__startup_late_hook_veneer>:
60001870:	ldr.w	pc, [pc]	; 60001874 <__startup_late_hook_veneer+0x4>
60001874:	.word	0x000169dd

60001878 <__pwm_init_veneer>:
60001878:	ldr.w	pc, [pc]	; 6000187c <__pwm_init_veneer+0x4>
6000187c:	.word	0x00016bed

60001880 <__usb_init_serialnumber_veneer>:
60001880:	ldr.w	pc, [pc]	; 60001884 <__usb_init_serialnumber_veneer+0x4>
60001884:	.word	0x00016969

60001888 <__startup_early_hook_veneer>:
60001888:	ldr.w	pc, [pc]	; 6000188c <__startup_early_hook_veneer+0x4>
6000188c:	.word	0x000169d9

60001890 <__delay_veneer>:
60001890:	ldr.w	pc, [pc]	; 60001894 <__delay_veneer+0x4>
60001894:	.word	0x000166cd

60001898 <__memset_veneer>:
60001898:	ldr.w	pc, [pc]	; 6000189c <__memset_veneer+0x4>
6000189c:	.word	0x0001b019

600018a0 <__main_veneer>:
600018a0:	ldr.w	pc, [pc]	; 600018a4 <__main_veneer+0x4>
600018a4:	.word	0x0001799d

600018a8 <__init_array_start>:
600018a8:	.word	0x00000101
600018ac:	.word	0x00000b4d
600018b0:	.word	0x00013cc9
600018b4:	.word	0x00013ce1
600018b8:	.word	0x00013cf9
600018bc:	.word	0x00013d11
600018c0:	.word	0x000140c5
600018c4:	.word	0x000140dd
600018c8:	.word	0x000140f5
600018cc:	.word	0x0001410d
600018d0:	.word	0x00014125
600018d4:	.word	0x0001413d
600018d8:	.word	0x00014155
600018dc:	.word	0x0001416d
600018e0:	.word	0x00014185
600018e4:	.word	0x0001419d
600018e8:	.word	0x000141b5
600018ec:	.word	0x000141cd
600018f0:	.word	0x000141e5
600018f4:	.word	0x000141fd
600018f8:	.word	0x00014215
600018fc:	.word	0x0001422d
60001900:	.word	0x00014245
60001904:	.word	0x0001425d
60001908:	.word	0x00014275
6000190c:	.word	0x00014295
60001910:	.word	0x00014f1d

60001914 <__init_array_end>:
60001914:	.word	0xffffffff
60001918:	.word	0xffffffff
6000191c:	.word	0xffffffff

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <irq_gpio6789>:
    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);

    return tmeas;
      20:	.word	0x4284f04f
      24:	push	{r3, r4, r5, r6, r7, lr}
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);
      26:	.short	0x6993

    return tmeas;
      28:	ldr	r5, [r2, #20]
      2a:	.short	0x401d
      2c:	beq.n	4a <__rtc_localtime+0x19>
      2e:	.short	0x4f24
      30:	movs	r6, #1
      32:	.short	0x6195
      34:	rbit	r4, r5
      38:	.word	0xf484fab4
      3c:	ldr.w	r3, [r7, r4, lsl #2]
}
      40:	.word	0xf404fa06
      44:	blx	r3
      46:	bics	r5, r4
      48:	bne.n	34 <__rtc_localtime+0x3>
      4a:	ldr	r2, [pc, #120]	; (c4 <__rtc_localtime+0x93>)
      4c:	.word	0x69556993
      50:	ands	r5, r3
      52:	.short	0xd00d
      54:	ldr	r7, [pc, #112]	; (c8 <__rtc_localtime+0x97>)
      56:	.short	0x2601
      58:	str	r5, [r2, #24]
      5a:	.short	0xfa95
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      5c:	bl	ffca55c8 <_flexram_bank_config+0x551faac9>
      60:	.word	0xf857f484
      64:	adds	r0, #36	; 0x24
      66:	lsl.w	r4, r6, r4
	dst.numConnections--;
	if (dst.numConnections == 0) {
		dst.active = false;
	}

	isConnected = false;
      6a:	blx	r3

	__enable_irq();
      6c:	bics	r5, r4
      6e:	bne.n	5a <__rtc_localtime+0x29>
		src.active = false;
	}

	dst.numConnections--;
	if (dst.numConnections == 0) {
		dst.active = false;
      70:	.word	0x69934a16
	if (p == NULL) {
//>>> PAH re-enable the IRQ
		__enable_irq();
		return;
	} else if (p == this) {
		if (p->next_dest) {
      74:	ldr	r5, [r2, #20]
			src.destination_list = next_dest;
		} else {
			src.destination_list = NULL;
      76:	.short	0x401d
      78:	beq.n	96 <__rtc_localtime+0x65>
  
  if(num >= 4){
      ADC1_GC |= ADC_GC_AVGE;// turns on averaging
      ADC2_GC |= ADC_GC_AVGE;// turns on averaging
  }
}
      7a:	.short	0x4f15
      7c:	movs	r6, #1
      7e:	str	r5, [r2, #24]
      80:	rbit	r4, r5
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 20000000; nn++) ;
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
	// digitalWrite(13, LOW);
    for (nn = 0; nn < 10000000; nn++) ;
      84:	.word	0xf484fab4
	uint32_t status = gpio[ISR] & gpio[IMR];
	if (status) {
		gpio[ISR] = status;
		while (status) {
			uint32_t index = __builtin_ctz(status);
			table[index]();
      88:	ldr.w	r3, [r7, r4, lsl #2]
			status = status & ~(1 << index);
      8c:	.word	0xf404fa06
	uint32_t status = gpio[ISR] & gpio[IMR];
	if (status) {
		gpio[ISR] = status;
		while (status) {
			uint32_t index = __builtin_ctz(status);
			table[index]();
      90:	blx	r3
inline void irq_anyport(volatile uint32_t *gpio, voidFuncPtr *table)
{
	uint32_t status = gpio[ISR] & gpio[IMR];
	if (status) {
		gpio[ISR] = status;
		while (status) {
      92:	.short	0x43a5
      94:	bne.n	80 <__rtc_localtime+0x4f>

#if defined(__IMXRT1062__)
FASTRUN static inline __attribute__((always_inline))
inline void irq_anyport(volatile uint32_t *gpio, voidFuncPtr *table)
{
	uint32_t status = gpio[ISR] & gpio[IMR];
      96:	ldr	r2, [pc, #60]	; (d4 <__rtc_localtime+0xa3>)
      98:	.word	0x69556993
	if (status) {
      9c:	ands	r5, r3
      9e:	beq.n	be <__rtc_localtime+0x8d>
      a0:	.word	0x26014f0d
		gpio[ISR] = status;
      a4:	str	r5, [r2, #24]
		while (status) {
			uint32_t index = __builtin_ctz(status);
      a6:	.short	0xfa95
      a8:	bl	ffca5614 <_flexram_bank_config+0x551fab15>
      ac:	.word	0xf857f484
			table[index]();
      b0:	adds	r0, #36	; 0x24
			status = status & ~(1 << index);
      b2:	.short	0xfa06
      b4:	and.w	r7, r4, #19456	; 0x4c00
inline void irq_anyport(volatile uint32_t *gpio, voidFuncPtr *table)
{
	uint32_t status = gpio[ISR] & gpio[IMR];
	if (status) {
		gpio[ISR] = status;
		while (status) {
      b8:	.word	0xd1f443a5
      bc:	pop	{r3, r4, r5, r6, r7, pc}
      be:	.short	0xbdf8
      c0:	lsrs	r4, r5, #32
      c2:	.short	0x2002
      c4:	ands	r0, r0
      c6:	.short	0x4200
      c8:	lsrs	r4, r5, #2
      ca:	.short	0x2002
      cc:	strh	r0, [r0, #0]
      ce:	.short	0x4200
      d0:	lsrs	r4, r5, #4
      d2:	.short	0x2002
      d4:	stmia	r0!, {}
      d6:	tst	r0, r0
      d8:	.word	0x200209ac

000000dc <__do_global_dtors_aux>:
	hardware->ccm_register |= hardware->ccm_value;

//	uint32_t fastio = IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);

	*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
	*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
      dc:	push	{r4, lr}
      de:	.short	0x4c05
      e0:	ldrb	r3, [r4, #0]
      e2:	.short	0xb933
      e4:	ldr	r3, [pc, #16]	; (f8 <__do_global_dtors_aux+0x1c>)
      e6:	.short	0xb113
      e8:	ldr	r0, [pc, #16]	; (fc <__do_global_dtors_aux+0x20>)
      ea:	.short	0xf3af
      ec:	strh	r0, [r0, #0]
      ee:	.short	0x2301
      f0:	strb	r3, [r4, #0]
      f2:	.short	0xbd10
	if (hardware->rx_pins[rx_pin_index_].select_input_register) {
      f4:	asrs	r0, r4, #11
      f6:	movs	r0, #2
	 	*(hardware->rx_pins[rx_pin_index_].select_input_register) =  hardware->rx_pins[rx_pin_index_].select_val;		
      f8:	.word	0x00000000
	}	

	*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
      fc:	push	{r2, r4}
      fe:	.short	0x0001

00000100 <frame_dummy>:
     100:	ldr	r3, [pc, #32]	; (124 <frame_dummy+0x24>)
     102:	.short	0xb510
     104:	cbz	r3, 10e <frame_dummy+0xe>
     106:	.short	0x4908
     108:	ldr	r0, [pc, #32]	; (12c <frame_dummy+0x2c>)
     10a:	nop.w
     10e:	ldr	r0, [pc, #32]	; (130 <frame_dummy+0x30>)
	*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
     110:	ldr	r3, [r0, #0]
     112:	cbnz	r3, 116 <frame_dummy+0x16>
     114:	pop	{r4, pc}
     116:	ldr	r3, [pc, #28]	; (134 <frame_dummy+0x34>)
     118:	cmp	r3, #0
     11a:	.short	0xd0fb
     11c:	ldmia.w	sp!, {r4, lr}
     120:	bx	r3
     122:	nop
     124:	movs	r0, r0
     126:	.short	0x0000
     128:	asrs	r4, r4, #11

	if (hardware->tx_pins[tx_pin_index_].select_input_register) {
     12a:	.short	0x2002
     12c:	push	{r2, r4}
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
     12e:	.short	0x0001
     130:	asrs	r0, r4, #11
	}	
	//hardware->rx_mux_register = hardware->rx_mux_val;
	//hardware->tx_mux_register = hardware->tx_mux_val;

	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
     132:	movs	r0, #2
#define DMA_NUM_CHANNELS        32

#ifdef __cplusplus
extern "C" void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
     134:	movs	r0, r0
	...

00000138 <TeensySynth::~TeensySynth()>:
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     138:	bx	lr
     13a:	.short	0xbf00

0000013c <IntervalTimer::~IntervalTimer()>:
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (24000000 / 1000000);
public:
	constexpr IntervalTimer() {
	}
	~IntervalTimer() {
     13c:	push	{r4, lr}
     13e:	mov	r4, r0
		end();
     140:	bl	1758c <IntervalTimer::end()>
	}
     144:	mov	r0, r4
     146:	pop	{r4, pc}

00000148 <AudioConvert_F32toI16::update()>:
class AudioConvert_F32toI16 : public AudioStream_F32 //receive Float and transmits Int
{
  //GUI: inputs:1, outputs:1  //this line used for automatic generation of GUI node
  public:
    AudioConvert_F32toI16(void) : AudioStream_F32(1, inputQueueArray_Float) {};
    void update(void) {
     148:	push	{r4, r5, r6, lr}
      //get the float block
      audio_block_f32_t *float_block;
      float_block = AudioStream_F32::receiveReadOnly_f32(); //float data block
     14a:	movs	r1, #0
class AudioConvert_F32toI16 : public AudioStream_F32 //receive Float and transmits Int
{
  //GUI: inputs:1, outputs:1  //this line used for automatic generation of GUI node
  public:
    AudioConvert_F32toI16(void) : AudioStream_F32(1, inputQueueArray_Float) {};
    void update(void) {
     14c:	sub	sp, #8
     14e:	mov	r5, r0
      //get the float block
      audio_block_f32_t *float_block;
      float_block = AudioStream_F32::receiveReadOnly_f32(); //float data block
     150:	.word	0xf8acf015
      if (!float_block) return;
     154:	cbz	r0, 1c0 <AudioConvert_F32toI16::update()+0x78>
     156:	mov	r4, r0

      //allocate a Int16 block
      audio_block_t *int_block;
      int_block = AudioStream::allocate(); 
     158:	.word	0xfc5cf017
      if (int_block == NULL) {
     15c:	mov	r6, r0
     15e:	.short	0xb348
      	  AudioStream_F32::release(float_block);
      	  return;
      }
      
      //convert back to int16
      convertAudio_F32toI16(float_block, int_block, float_block->length);
     160:	ldr.w	r3, [r4, #520]	; 0x208
    };

   static void convertAudio_F32toI16(audio_block_f32_t *in, audio_block_t *out, int len) {
      //WEA Method.  Should look at CMSIS arm_float_to_q15 instead: https://www.keil.com/pack/doc/CMSIS/DSP/html/group__float__to__x.html#ga215456e35a18db86882e1d3f0d24e1f2	
      const float MAX_INT = 32678.0;
      for (int i = 0; i < len; i++) {
     164:	.word	0xdd1d2b00
     168:	adds	r0, r3, #1
     16a:	.short	0x1cb1
     16c:	adds	r3, r4, #4
        out->data[i] = (int16_t)(max(min( (in->data[i] * MAX_INT), MAX_INT), -MAX_INT));
     16e:	.short	0xed9f
     170:	ldrb	r1, [r3, #8]
     172:	.short	0xeb04
     174:	lsls	r0, r0, #2
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
}
template<class A, class B>
constexpr auto max(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a >= b ? std::forward<A>(a) : std::forward<B>(b);
     176:	.short	0xeddf
     178:	ldr	r0, [r3, #32]
     17a:	.short	0xecf3
     17c:	ldrb	r1, [r0, #8]
//#include <algorithm> // this isn't really needed, is it?  (slows down compiling)
#include <utility>
// https://forum.pjrc.com/threads/44596-Teensyduino-1-37-Beta-2-(Arduino-1-8-3-support)?p=145150&viewfull=1#post145150
template<class A, class B>
constexpr auto min(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a < b ? std::forward<A>(a) : std::forward<B>(b);
     17e:	.short	0xf647
     180:	strb	r6, [r4, #10]
     182:	.short	0xee67
     184:	ldrb	r7, [r0, #10]
     186:	.short	0xeef4
     188:	ldrb	r7, [r0, #11]
     18a:	.short	0xeef1
     18c:			; <UNDEFINED> instruction: 0xfa10d505
}
template<class A, class B>
constexpr auto max(A&& a, B&& b) -> decltype(a < b ? std::forward<A>(a) : std::forward<B>(b)) {
  return a >= b ? std::forward<A>(a) : std::forward<B>(b);
     190:	.word	0x7ae6eef4
     194:	ldr	r2, [pc, #68]	; (1dc <AudioConvert_F32toI16::update()+0x94>)
     196:	.short	0xeef1
     198:			; <UNDEFINED> instruction: 0xfa10da13
    };

   static void convertAudio_F32toI16(audio_block_f32_t *in, audio_block_t *out, int len) {
      //WEA Method.  Should look at CMSIS arm_float_to_q15 instead: https://www.keil.com/pack/doc/CMSIS/DSP/html/group__float__to__x.html#ga215456e35a18db86882e1d3f0d24e1f2	
      const float MAX_INT = 32678.0;
      for (int i = 0; i < len; i++) {
     19c:	.word	0xf8214283
        out->data[i] = (int16_t)(max(min( (in->data[i] * MAX_INT), MAX_INT), -MAX_INT));
     1a0:	cmp	r7, #2
    };

   static void convertAudio_F32toI16(audio_block_f32_t *in, audio_block_t *out, int len) {
      //WEA Method.  Should look at CMSIS arm_float_to_q15 instead: https://www.keil.com/pack/doc/CMSIS/DSP/html/group__float__to__x.html#ga215456e35a18db86882e1d3f0d24e1f2	
      const float MAX_INT = 32678.0;
      for (int i = 0; i < len; i++) {
     1a2:	.short	0xd1ea
      
      //convert back to int16
      convertAudio_F32toI16(float_block, int_block, float_block->length);

      //return audio to the system
      AudioStream::transmit(int_block);
     1a4:	mov	r0, r5
     1a6:	.short	0x2200
     1a8:	mov	r1, r6
     1aa:	bl	17b10 <AudioStream::transmit(audio_block_struct*, unsigned char)>
      AudioStream::release(int_block);
     1ae:	.short	0x4630
     1b0:	bl	17abc <AudioStream::release(audio_block_struct*)>
      AudioStream_F32::release(float_block);
     1b4:	.word	0xb0024620
    };
     1b8:	ldmia.w	sp!, {r4, r5, r6, lr}
      convertAudio_F32toI16(float_block, int_block, float_block->length);

      //return audio to the system
      AudioStream::transmit(int_block);
      AudioStream::release(int_block);
      AudioStream_F32::release(float_block);
     1bc:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    };
     1c0:	add	sp, #8
     1c2:	.short	0xbd70
     1c4:	vcvt.s32.f32	s15, s15
     1c8:	.word	0x7a01edcd
     1cc:	ldrsh.w	r2, [sp, #4]
     1d0:	b.n	19c <AudioConvert_F32toI16::update()+0x54>
     1d2:	nop
     1d4:	ldr	r4, [pc, #0]	; (1d8 <AudioConvert_F32toI16::update()+0x90>)
     1d6:	.short	0x46ff
     1d8:	ldr	r4, [pc, #0]	; (1dc <AudioConvert_F32toI16::update()+0x94>)
     1da:	.short	0xc6ff
     1dc:	strh	r2, [r3, #2]
     1de:	.short	0xffff

000001e0 <TeensySynth::TeensySynth()>:
	// write out computed CTRL
	port->CTRL = ctrl;

	// Bit 3 10 bit - Will assume that begin already cleared it.
	// process some other bits which change other registers.
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
     1e0:	.word	0x4ff0e92d
     1e4:	ldr	r5, [pc, #660]	; (47c <TeensySynth::TeensySynth()+0x29c>)
     1e6:	mov	r9, r0

	// Bit 4 RXINVERT 
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
     1e8:	.word	0xf04f4604
     1ec:	lsrs	r1, r0, #32
     1ee:	.short	0x4405
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
     1f0:	movs	r6, #0
     1f2:	.short	0xf8df
     1f4:	uxtb	r0, r6
	port->STAT = c;
     1f6:	ldr.w	sl, [pc, #752]	; 4e8 <TeensySynth::TeensySynth()+0x308>

	// bit 8 can turn on 2 stop bit mote
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
     1fa:	.short	0xed2d
     1fc:	ldrh	r2, [r0, #24]
     1fe:	.short	0xeddf
     200:	ldrh	r0, [r4, #20]
     202:	.short	0xb085

	//Serial.printf("    stat:%x ctrl:%x fifo:%x water:%x\n", port->STAT, port->CTRL, port->FIFO, port->WATER );
	// Only if the user implemented their own...
	if (!(*hardware->serial_event_handler_default)) addToSerialEventsList(); 		// Enable the processing of serialEvent for this object
     204:	vldr	s16, [pc, #636]	; 484 <TeensySynth::TeensySynth()+0x2a4>
     208:	.word	0x0124f104
}


void HardwareSerial::addToSerialEventsList() {
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     20c:	ldr	r2, [pc, #632]	; (488 <TeensySynth::TeensySynth()+0x2a8>)
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
     20e:	.short	0x2300
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     210:	strb.w	r8, [r4, #9]
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
     214:	.word	0x460a6022
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     218:	strb	r6, [r4, #8]
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
     21a:	.short	0x60e6
     21c:	str	r1, [r4, #16]
     21e:	.short	0xe000
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     220:	ldr	r2, [r4, #16]
     222:	.short	0xf842
     224:	str	r3, [r4, #0]
     226:	.short	0x3301
     228:	ldrb	r2, [r4, #9]
     22a:	.short	0x429a
     22c:	bgt.n	220 <TeensySynth::TeensySynth()+0x40>
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
     22e:	.short	0x4b97
     230:	ldr	r2, [r3, #0]
     232:	cbnz	r2, 238 <TeensySynth::TeensySynth()+0x58>
     234:	.word	0x461ae3c1
     238:	ldr	r3, [r2, #20]
     23a:	.short	0x2b00
     23c:	bne.n	236 <TeensySynth::TeensySynth()+0x56>
     23e:	str	r4, [r2, #20]
     240:	.word	0xf2414f93
     244:	strh	r4, [r1, r4]
     246:	.short	0xf44f
     248:	cmp	r0, r0
     24a:	.short	0x6166
     24c:	str	r7, [r4, #0]
     24e:	.short	0x4423
     250:	ldr	r7, [pc, #576]	; (494 <TeensySynth::TeensySynth()+0x2b4>)
     252:	.short	0x4669
     254:	strh	r6, [r4, #4]
     256:	.short	0xf104
     258:	lsls	r0, r7, #1
     25a:	str	r7, [r4, #120]	; 0x78
     25c:	.word	0x80e64f8e
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
     260:	str.w	r7, [r4, #448]	; 0x1c0
     264:	.word	0x72a64f8d

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     268:	str.w	r7, [r4, #632]	; 0x278
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
     26c:	ldr	r7, [pc, #560]	; (4a0 <TeensySynth::TeensySynth()+0x2c0>)
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     26e:	strb	r6, [r4, #24]
     270:	str.w	r7, [r4, #968]	; 0x3c8

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     274:	ldr	r7, [pc, #556]	; (4a4 <TeensySynth::TeensySynth()+0x2c4>)
     276:	str	r6, [r4, #32]
     278:	str.w	r7, [r4, #1024]	; 0x400
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     27c:	ldr	r7, [pc, #552]	; (4a8 <TeensySynth::TeensySynth()+0x2c8>)
     27e:	str	r6, [r4, #28]

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     280:	.word	0x7484f8c4
     284:	ldr	r7, [pc, #548]	; (4ac <TeensySynth::TeensySynth()+0x2cc>)
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     286:	.short	0xf8c4
     288:	cbnz	r4, 2b0 <TeensySynth::TeensySynth()+0xd0>

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     28a:	str.w	r7, [r4, #1484]	; 0x5cc
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     28e:	.short	0x4f88
     290:	str.w	sl, [r4, #2980]	; 0xba4

			if (d && clkhz/d > _clock) d++;
     294:	.word	0x7710f8c4
     298:	ldr	r7, [pc, #536]	; (4b4 <TeensySynth::TeensySynth()+0x2d4>)
     29a:	str	r3, [sp, #4]
     29c:	str.w	r7, [r4, #1936]	; 0x790
			if (d > 257) d= 257;  // max div
			if (d > 2) {
     2a0:	.word	0x93004f85
     2a4:	str.w	r7, [r4, #2160]	; 0x870
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
     2a8:	ldr	r7, [pc, #528]	; (4bc <TeensySynth::TeensySynth()+0x2dc>)
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
     2aa:	str	r2, [sp, #12]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
     2ac:	.word	0x7cf0f8c4
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
     2b0:	ldr	r7, [pc, #524]	; (4c0 <TeensySynth::TeensySynth()+0x2e0>)
		port().CCR = _ccr;
		port().TCR = settings.tcr;
     2b2:	.short	0x9202
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
     2b4:	str.w	r7, [r4, #3840]	; 0xf00
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
     2b8:	.word	0xf8c44f82
		port().CCR = _ccr;
     2bc:	ldrb	r4, [r4, #30]
		port().TCR = settings.tcr;
     2be:	.short	0x4f82
		port().CR = LPSPI_CR_MEN;
     2c0:	str.w	r7, [r4, #4088]	; 0xff8
		}
		digitalWriteFast(SPIRAM_CS_PIN, HIGH);
		SPI.endTransaction();	
	} else if (memory_type == AUDIO_MEMORY_MEMORYBOARD) {		
		SPI.beginTransaction(SPISETTING);
		while (count) {
     2c4:	.word	0xfe10f005
			if (pin == 0) {
				CORE_PIN0_PORTCLEAR = CORE_PIN0_BITMASK;
			} else if (pin == 1) {
				CORE_PIN1_PORTCLEAR = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTCLEAR = CORE_PIN2_BITMASK;
     2c8:	cmp	r5, r4
     2ca:	.short	0x66e6
     2cc:	vstr	s17, [r4, #80]	; 0x50
			} else if (pin == 3) {
				CORE_PIN3_PORTCLEAR = CORE_PIN3_BITMASK;
     2d0:	.word	0x8a0bed84
			} else if (pin == 4) {
				CORE_PIN4_PORTCLEAR = CORE_PIN4_BITMASK;
     2d4:	vstr	s16, [r4, #40]	; 0x28
			uint32_t chip = (addr >> 16) + 1;
			digitalWriteFast(MEMBOARD_CS0_PIN, chip & 1);
     2d8:	.word	0x8a0ced84
void digitalWrite(uint8_t pin, uint8_t val);
static inline void digitalWriteFast(uint8_t pin, uint8_t val) __attribute__((always_inline, unused));
static inline void digitalWriteFast(uint8_t pin, uint8_t val)
{
	if (__builtin_constant_p(pin)) {
		if (val) {
     2dc:	vstr	s16, [r4, #52]	; 0x34
     2e0:	vstr	s16, [r4, #60]	; 0x3c
			if (pin == 0) {
				CORE_PIN0_PORTSET = CORE_PIN0_BITMASK;
			} else if (pin == 1) {
				CORE_PIN1_PORTSET = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTSET = CORE_PIN2_BITMASK;
     2e4:	.word	0x8a11ed84
void digitalWrite(uint8_t pin, uint8_t val);
static inline void digitalWriteFast(uint8_t pin, uint8_t val) __attribute__((always_inline, unused));
static inline void digitalWriteFast(uint8_t pin, uint8_t val)
{
	if (__builtin_constant_p(pin)) {
		if (val) {
     2e8:	vstr	s16, [r4, #64]	; 0x40
			} else if (pin == 1) {
				CORE_PIN1_PORTSET = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTSET = CORE_PIN2_BITMASK;
			} else if (pin == 3) {
				CORE_PIN3_PORTSET = CORE_PIN3_BITMASK;
     2ec:	strb.w	r6, [r4, #72]	; 0x48
void digitalWrite(uint8_t pin, uint8_t val);
static inline void digitalWriteFast(uint8_t pin, uint8_t val) __attribute__((always_inline, unused));
static inline void digitalWriteFast(uint8_t pin, uint8_t val)
{
	if (__builtin_constant_p(pin)) {
		if (val) {
     2f0:	strb.w	r6, [r4, #73]	; 0x49
     2f4:	.word	0x804af884
			} else if (pin == 2) {
				CORE_PIN2_PORTSET = CORE_PIN2_BITMASK;
			} else if (pin == 3) {
				CORE_PIN3_PORTSET = CORE_PIN3_BITMASK;
			} else if (pin == 4) {
				CORE_PIN4_PORTSET = CORE_PIN4_BITMASK;
     2f8:	strb.w	r8, [r4, #75]	; 0x4b
		//port().PUSHR = data;
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
     2fc:	.word	0x604cf884
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     300:	beq.n	30a <TeensySynth::TeensySynth()+0x12a>
		port().TDR = data;		// output 16 bit data.
     302:	.short	0xf504
     304:	add	sl, r5
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     306:	.short	0x340c
     308:	b.n	208 <TeensySynth::TeensySynth()+0x28>
		port().TDR = data;		// output 16 bit data.
     30a:	.short	0x4b70
     30c:	mov.w	sl, #1065353216	; 0x3f800000
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     310:	ldr	r4, [pc, #444]	; (4d0 <TeensySynth::TeensySynth()+0x2f0>)
		port().TDR = data;		// output 16 bit data.
     312:	.short	0xf04f
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     314:	lsrs	r1, r0, #24
     316:	.short	0x444b
		port().TDR = data;		// output 16 bit data.
     318:	movs	r1, #0
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
     31a:	.short	0x444c
     31c:	ldr.w	fp, [pc, #364]	; 48c <TeensySynth::TeensySynth()+0x2ac>
		port().TCR = tcr;	// restore back
     320:	.word	0xf1a32704
     324:	lsrs	r4, r4, #32
		return port().RDR;
     326:	.short	0x4e58
     328:	sub.w	ip, r3, #72	; 0x48
		//port().PUSHR = data;
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
     32c:	sub.w	r5, r3, #32
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     330:	movs	r2, #0
     332:	.short	0x4640
     334:	str.w	r6, [r3, #-72]
		port().TDR = data;		// output 16 bit data.
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
     338:	.word	0xec3ff803
     33c:	strb.w	r1, [r3, #-64]
		port().TCR = tcr;	// restore back
     340:	.word	0x1c3cf843
			digitalWriteFast(MEMBOARD_CS1_PIN, chip & 2);
			digitalWriteFast(MEMBOARD_CS2_PIN, chip & 4);
			uint32_t chipaddr = (addr & 0xFFFF) << 1;
			SPI.transfer16((0x02 << 8) | (chipaddr >> 16));
			SPI.transfer16(chipaddr & 0xFFFF);
			uint32_t num = 0x10000 - (addr & 0xFFFF);
     344:	str.w	r8, [r3, #-56]
     348:	.word	0xf853e001
     34c:	lsrs	r0, r7, #16
			if (num > count) num = count;
			count -= num;
     34e:	.short	0xf840
			addr += num;
     350:	asrs	r2, r4, #32
			do {
				int16_t w = 0;
				if (data) w = *data++;
     352:	.short	0x3201
     354:	ldrb.w	r0, [r3, #-63]
     358:	.word	0xdcf64290
		//port().PUSHR = data;
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
     35c:	ldr	r2, [pc, #300]	; (48c <TeensySynth::TeensySynth()+0x2ac>)
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     35e:	.short	0x6810
     360:	cbnz	r0, 366 <TeensySynth::TeensySynth()+0x186>
     362:	.short	0xe327
     364:	mov	r0, r2
     366:	.short	0x6942
		port().TDR = data;		// output 16 bit data.
     368:	cmp	r2, #0
     36a:	.short	0xd1fb
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
     36c:	str.w	ip, [r0, #20]
     370:	.word	0x5c28f843
		port().TCR = tcr;	// restore back
     374:	adds	r3, #72	; 0x48
		return port().RDR;
     376:	.short	0xf843
			SPI.transfer16(chipaddr & 0xFFFF);
			uint32_t num = 0x10000 - (addr & 0xFFFF);
			if (num > count) num = count;
			count -= num;
			addr += num;
			do {
     378:	adds	r4, r7, #1
		}
		digitalWriteFast(SPIRAM_CS_PIN, HIGH);
		SPI.endTransaction();	
	} else if (memory_type == AUDIO_MEMORY_MEMORYBOARD) {		
		SPI.beginTransaction(SPISETTING);
		while (count) {
     37a:	.short	0x2000
     37c:	strh.w	r1, [r3, #-140]
			if (pin == 0) {
				CORE_PIN0_PORTCLEAR = CORE_PIN0_BITMASK;
			} else if (pin == 1) {
				CORE_PIN1_PORTCLEAR = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTCLEAR = CORE_PIN2_BITMASK;
     380:	.word	0x1c8af823
			} else if (pin == 3) {
				CORE_PIN3_PORTCLEAR = CORE_PIN3_BITMASK;
			} else if (pin == 4) {
				CORE_PIN4_PORTCLEAR = CORE_PIN4_BITMASK;
     384:	strb.w	r1, [r3, #-134]
			if (pin == 0) {
				CORE_PIN0_PORTCLEAR = CORE_PIN0_BITMASK;
			} else if (pin == 1) {
				CORE_PIN1_PORTCLEAR = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTCLEAR = CORE_PIN2_BITMASK;
     388:	.word	0x7c78f803
			} else if (pin == 3) {
				CORE_PIN3_PORTCLEAR = CORE_PIN3_BITMASK;
     38c:	str.w	r1, [r3, #-116]
			} else if (pin == 4) {
				CORE_PIN4_PORTCLEAR = CORE_PIN4_BITMASK;
     390:	.word	0x1c68f843
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
     394:	str	r1, [r5, #4]
     396:	.short	0xf853
     398:	cmp	r4, #112	; 0x70
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
     39a:	.short	0x6091
     39c:	ldr.w	r2, [r3, #-112]
     3a0:	.word	0x4a4c60d1
     3a4:	str.w	sl, [r3, #-88]
     3a8:	.word	0x2c90f843
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
     3ac:	str.w	sl, [r3, #-84]
     3b0:	.word	0xac50f843
     3b4:	str.w	sl, [r3, #-76]
     3b8:	.word	0xd1b2429c
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
     3bc:	ldr	r3, [pc, #280]	; (4d8 <TeensySynth::TeensySynth()+0x2f8>)
     3be:	.short	0x2101
     3c0:	ldr	r6, [pc, #196]	; (488 <TeensySynth::TeensySynth()+0x2a8>)
     3c2:	.short	0x4602
     3c4:	mov	r7, r3
     3c6:	.short	0x444b
     3c8:	mov	r5, r0
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
     3ca:	.short	0xf849
     3cc:	str	r7, [r0, #0]
     3ce:	add.w	r7, r3, #36	; 0x24
     3d2:	.short	0x7218
     3d4:	str	r0, [r3, #12]
     3d6:	.short	0xf103
     3d8:	movs	r0, r5
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
     3da:	.short	0x7259
     3dc:	mov	r1, r7
     3de:	str	r7, [r3, #16]
     3e0:	b.n	3e4 <TeensySynth::TeensySynth()+0x204>
     3e2:	.short	0x6919
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;

			if (d && clkhz/d > _clock) d++;
     3e4:	str.w	r5, [r1, r2, lsl #2]
     3e8:	.word	0x7a593201
     3ec:	cmp	r1, r2
			if (d > 257) d= 257;  // max div
			if (d > 2) {
     3ee:	.short	0xdcf8
     3f0:	ldr	r2, [pc, #152]	; (48c <TeensySynth::TeensySynth()+0x2ac>)
     3f2:	.short	0x6811
     3f4:	cbnz	r1, 3fa <TeensySynth::TeensySynth()+0x21a>
     3f6:	.short	0xe2ec
     3f8:	mov	r1, r2
     3fa:	.short	0x694a
     3fc:	cmp	r2, #0
     3fe:	bne.n	3f8 <TeensySynth::TeensySynth()+0x218>
			} else if (pin == 1) {
				CORE_PIN1_PORTCLEAR = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTCLEAR = CORE_PIN2_BITMASK;
			} else if (pin == 3) {
				CORE_PIN3_PORTCLEAR = CORE_PIN3_BITMASK;
     400:	.word	0x2500614b
     404:	movs	r7, #8
			if (pin == 0) {
				CORE_PIN0_PORTCLEAR = CORE_PIN0_BITMASK;
			} else if (pin == 1) {
				CORE_PIN1_PORTCLEAR = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTCLEAR = CORE_PIN2_BITMASK;
     406:	mov	r1, r0
     408:	.word	0x462a6218
     40c:	str	r5, [r3, #20]
     40e:	.short	0x809d
				div = d-2;
     410:	mov	r0, r5
     412:	strh	r5, [r3, #6]
     414:	.word	0x61dd729d
     418:	strb	r7, [r3, #24]
     41a:	.short	0xe000
     41c:	ldr	r1, [r3, #32]
     41e:	.short	0x5088
     420:	adds	r2, #4
     422:	cmp	r2, #32
     424:	.word	0x4b2dd1fa
     428:	mov.w	r2, #1065353216	; 0x3f800000
     42c:	.word	0x482c492a
     430:	add	r3, r9
     432:	.short	0xf849
     434:	movs	r1, r0
     436:	.short	0xf844
     438:	cmp	r3, #4
     43a:	cmp	r4, r3
     43c:	.word	0x2500d1fb
     440:	add.w	r4, r3, #36	; 0x24
     444:	ldr	r0, [pc, #148]	; (4dc <TeensySynth::TeensySynth()+0x2fc>)
     446:	.short	0xf04f
     448:	lsrs	r1, r0, #24
     44a:	.short	0x4e0f
     44c:	mov	r2, r5
     44e:	.short	0x4621
     450:	add.w	r7, r3, #40	; 0x28
     454:	str.w	r6, [r9, r0]
     458:	.word	0x721d4628
     45c:	str	r5, [r3, #12]
     45e:	.short	0x611c

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
     460:	strb.w	lr, [r3, #9]
     464:	b.n	468 <TeensySynth::TeensySynth()+0x288>
     466:	.short	0x6919
     468:	str.w	r0, [r1, r2, lsl #2]
			__disable_irq();
			if (interruptMasksUsed & 0x01) {
     46c:	adds	r2, #1
     46e:	.short	0x7a59
     470:	cmp	r1, r2
     472:	bgt.n	466 <TeensySynth::TeensySynth()+0x286>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
     474:	.word	0x68114a05
     478:	cbnz	r1, 4ee <TeensySynth::TeensySynth()+0x30e>
     47a:	.short	0xe2ac
     47c:	strb	r0, [r6, r0]
     47e:	.short	0x0001
     480:	movs	r0, r0
				NVIC_ICER0 = interruptSave[0];
     482:	negs	r0, r0
     484:	.word	0x00000000
			}
			if (interruptMasksUsed & 0x02) {
     488:	movs	r0, r1
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
     48a:	.short	0x2000
     48c:	strh	r4, [r5, #58]	; 0x3a
     48e:	.short	0x2005
     490:	lsls	r0, r7, #20
     492:	.short	0x2000
				NVIC_ICER1 = interruptSave[1];
     494:	vst1.8	{d18[0]}, [r0], r1
			}
			if (interruptMasksUsed & 0x04) {
     498:	.word	0x2001fa5c
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
     49c:	str??.w	r2, [r8, r1]
     4a0:	.word	0x2001f9fc
     4a4:	ldr??.w	r2, [r4, #1]
				NVIC_ICER2 = interruptSave[2];
     4a8:			; <UNDEFINED> instruction: 0xf7942001
			}
			if (interruptMasksUsed & 0x08) {
     4ac:	.word	0x2001f704
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
     4b0:			; <UNDEFINED> instruction: 0xfa702001
     4b4:	.word	0x2001f768
				NVIC_ICER3 = interruptSave[3];
     4b8:			; <UNDEFINED> instruction: 0xfa482001
			}
			if (interruptMasksUsed & 0x10) {
     4bc:	.word	0x2001f9e8
     4c0:			; <UNDEFINED> instruction: 0xf7542001
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
				NVIC_ICER4 = interruptSave[4];
			}
			__enable_irq();
     4c4:	.word	0x2001f72c
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
     4c8:			; <UNDEFINED> instruction: 0xfa842001
     4cc:	add	r1, sp, #528	; 0x210
     4ce:	movs	r1, r0
     4d0:	.word	0x0001aaec
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
     4d4:	smlawb	r0, r4, r1, r2
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     4d8:	.word	0x0001aaa4
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     4dc:	add	r3, sp, #48	; 0x30
     4de:	.short	0x0001
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
     4e0:	smlad	r0, r8, r1, r2

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     4e4:	.word	0x2001f718
     4e8:			; <UNDEFINED> instruction: 0xfa202001
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     4ec:	.word	0x694a4611

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     4f0:	cmp	r2, #0
     4f2:	bne.n	4ec <TeensySynth::TeensySynth()+0x30c>
     4f4:	.word	0x2400614b
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     4f8:	movs	r5, #1

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
     4fa:	.short	0xf04f
     4fc:	str	r6, [r7, r1]
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     4fe:	.short	0xf8df
     500:	b.n	b44 <loop+0x10>

			if (d && clkhz/d > _clock) d++;
     502:	.short	0x4ab5
     504:	ldr	r1, [pc, #724]	; (7dc <TeensySynth::TeensySynth()+0x5fc>)
     506:	str	r7, [r3, #32]
     508:	.word	0x615c761d
     50c:	strh	r4, [r3, #4]
     50e:	.short	0x80dc
     510:	strb	r4, [r3, #10]
			if (d > 257) d= 257;  // max div
			if (d > 2) {
     512:	.short	0x61dc
     514:	str.w	r4, [r9, lr]
     518:	str.w	r1, [r9, r2]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
     51c:	.word	0x49b02200
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
     520:	str	r0, [r3, #44]	; 0x2c
     522:	ldr	r0, [pc, #704]	; (7e4 <TeensySynth::TeensySynth()+0x604>)
		port().CCR = _ccr;
		port().TCR = settings.tcr;
     524:	.word	0x631a645d
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
     528:	add	r0, r9
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
		port().CCR = _ccr;
		port().TCR = settings.tcr;
		port().CR = LPSPI_CR_MEN;
     52a:	.short	0x635a
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
     52c:	str	r2, [r3, #56]	; 0x38
     52e:	.short	0x63da
			} else if (pin == 4) {
				CORE_PIN4_PORTCLEAR = CORE_PIN4_BITMASK;
			} else if (pin == 5) {
				CORE_PIN5_PORTCLEAR = CORE_PIN5_BITMASK;
			} else if (pin == 6) {
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
     530:	str	r1, [r3, #64]	; 0x40
     532:	.short	0xf005
		port().CCR = _ccr;
     534:			; <UNDEFINED> instruction: 0xfaeb4bac
		port().TCR = settings.tcr;
     538:	ldr	r6, [pc, #688]	; (7ec <TeensySynth::TeensySynth()+0x60c>)
     53a:	.short	0x4622
		port().CR = LPSPI_CR_MEN;
     53c:	mov	r1, r3
     53e:	.short	0x444b
     540:	mov	r0, r4
     542:	.short	0xf103
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
     544:	lsls	r4, r4, #28
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
     546:	str.w	r6, [r9, r1]
			if (fifo > 0) return port().RDR;
     54a:	.short	0x725d
     54c:	add.w	r5, r3, #40	; 0x28
			} else if (pin == 4) {
				CORE_PIN4_PORTSET = CORE_PIN4_BITMASK;
			} else if (pin == 5) {
				CORE_PIN5_PORTSET = CORE_PIN5_BITMASK;
			} else if (pin == 6) {
				CORE_PIN6_PORTSET = CORE_PIN6_BITMASK;
     550:	.word	0x4639721c
     554:	str	r4, [r3, #12]
     556:	str	r7, [r3, #16]
     558:	.word	0x6919e000

		SPI.beginTransaction(SPISETTING);
		digitalWriteFast(SPIRAM_CS_PIN, LOW);
		SPI.transfer(0x06); //write-enable before every write
		digitalWriteFast(SPIRAM_CS_PIN, HIGH);
		asm volatile ("NOP\n NOP\n NOP\n NOP\n NOP\n NOP\n");
     55c:	str.w	r0, [r1, r2, lsl #2]
     560:	.word	0x7a593201
     564:	cmp	r1, r2
     566:	.short	0xdcf8
			} else if (pin == 4) {
				CORE_PIN4_PORTCLEAR = CORE_PIN4_BITMASK;
			} else if (pin == 5) {
				CORE_PIN5_PORTCLEAR = CORE_PIN5_BITMASK;
			} else if (pin == 6) {
				CORE_PIN6_PORTCLEAR = CORE_PIN6_BITMASK;
     568:	ldr	r2, [pc, #644]	; (7f0 <TeensySynth::TeensySynth()+0x610>)
     56a:	ldr	r1, [r2, #0]
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     56c:	.word	0xe234b909
		//port().PUSHR = data;
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
     570:	mov	r1, r2
     572:	.short	0x694a
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
		port().TDR = data;		// output 16 bit data.
     574:	cmp	r2, #0
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     576:	bne.n	570 <TeensySynth::TeensySynth()+0x390>
     578:	str	r3, [r1, #20]
		port().TDR = data;		// output 16 bit data.
     57a:	movs	r4, #0
     57c:	.word	0x4a9d2004
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     580:	mov.w	r1, #1065353216	; 0x3f800000
		port().TDR = data;		// output 16 bit data.
     584:	.word	0x615c621d
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
     588:	strh	r4, [r3, #4]
     58a:	strh	r4, [r3, #6]
		port().TCR = tcr;	// restore back
     58c:	strb	r4, [r3, #10]
     58e:	.short	0x61dc
     590:	strb	r0, [r3, #24]
		return port().RDR;
     592:	.short	0xf849
		//port().PUSHR = data;
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
     594:	ands	r2, r0
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     596:	.short	0x6a1a
     598:	ldr	r5, [pc, #588]	; (7e8 <TeensySynth::TeensySynth()+0x608>)
     59a:	.short	0x6054
     59c:	ldr	r2, [r3, #32]
     59e:	.short	0x4896
		port().TDR = data;		// output 16 bit data.
     5a0:	str	r4, [r2, #8]
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
     5a2:	ldr	r2, [r3, #32]
     5a4:	add	r0, r9
     5a6:	.short	0x4e91
		port().TCR = tcr;	// restore back
     5a8:	str	r4, [r2, #12]
		return port().RDR;
     5aa:	.short	0x4a94
		digitalWriteFast(SPIRAM_CS_PIN, LOW);
		SPI.transfer16((0x02 << 8) | (addr >> 16));
		SPI.transfer16(addr & 0xFFFF);
		while (count) {
     5ac:	str.w	r2, [r9, r5]
			int16_t w = 0;
			if (data) w = *data++;
     5b0:	.word	0x63d96399
     5b4:	str	r1, [r3, #64]	; 0x40
		//port().PUSHR = data;
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
     5b6:	.short	0x6459
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     5b8:	bl	4d80 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()>
     5bc:	.word	0x21014b90
     5c0:	mov	r2, r4
		port().TDR = data;		// output 16 bit data.
     5c2:	.short	0x461d
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
     5c4:	add	r3, r9
     5c6:	.short	0x4620
     5c8:	str.w	r6, [r9, r5]
		port().TCR = tcr;	// restore back
     5cc:	.word	0x0524f103
		digitalWriteFast(SPIRAM_CS_PIN, HIGH);
		asm volatile ("NOP\n NOP\n NOP\n NOP\n NOP\n NOP\n");
		digitalWriteFast(SPIRAM_CS_PIN, LOW);
		SPI.transfer16((0x02 << 8) | (addr >> 16));
		SPI.transfer16(addr & 0xFFFF);
		while (count) {
     5d0:	strb	r4, [r3, #8]
			} else if (pin == 4) {
				CORE_PIN4_PORTSET = CORE_PIN4_BITMASK;
			} else if (pin == 5) {
				CORE_PIN5_PORTSET = CORE_PIN5_BITMASK;
			} else if (pin == 6) {
				CORE_PIN6_PORTSET = CORE_PIN6_BITMASK;
     5d2:	str	r4, [r3, #12]
     5d4:	.word	0x0428f103
     5d8:	strb	r1, [r3, #9]
     5da:	.short	0x4629
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
     5dc:	str	r5, [r3, #16]
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
     5de:	b.n	5e2 <TeensySynth::TeensySynth()+0x402>
     5e0:	.word	0xf8416919
     5e4:	movs	r2, r4
     5e6:	.short	0x3201
     5e8:	ldrb	r1, [r3, #9]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
     5ea:	cmp	r1, r2
     5ec:	.word	0x4a80dcf8
     5f0:	ldr	r1, [r2, #0]
     5f2:	cbnz	r1, 5f8 <TeensySynth::TeensySynth()+0x418>
     5f4:	.word	0x4611e1f3
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
     5f8:	ldr	r2, [r1, #20]
     5fa:	.short	0x2a00
     5fc:	bne.n	5f6 <TeensySynth::TeensySynth()+0x416>
     5fe:	.short	0x614b
     600:	movs	r5, #0
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
     602:	.short	0x2004
     604:	ldr	r2, [pc, #508]	; (804 <TeensySynth::TeensySynth()+0x624>)
     606:	.short	0xf04f
     608:	ldrb	r6, [r7, r1]
     60a:	.short	0x621c
     60c:	movs	r7, #1
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
     60e:	.short	0x7618
     610:	mov	r1, r5
     612:	.short	0x615d
     614:	strh	r5, [r3, #4]
     616:	.short	0x80dd
     618:	strb	r5, [r3, #10]
     61a:	.short	0x61dd
     61c:	str.w	r5, [r9, r2]
     620:	.word	0x6a183220
			d = _clock ? clkhz/_clock : clkhz;

			if (d && clkhz/d > _clock) d++;
			if (d > 257) d= 257;  // max div
			if (d > 2) {
				div = d-2;
     624:	add	r2, r9
     626:	.short	0x4e75
     628:	str	r5, [r0, #4]
     62a:	.short	0x6a18
     62c:	add.w	lr, r2, #36	; 0x24
     630:	.word	0x46746085
     634:	ldr	r0, [r3, #32]
     636:	.short	0x60c5
     638:	ldr	r0, [pc, #452]	; (800 <TeensySynth::TeensySynth()+0x620>)
     63a:	.short	0xf849
     63c:	str	r0, [r0, #0]
     63e:	.short	0xf8c3
     640:	stmia	r0!, {r3, r4, r5}
     642:	.short	0xf8c3
     644:	stmia	r0!, {r2, r3, r4, r5}
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;

			if (d && clkhz/d > _clock) d++;
     646:	.short	0xf8c3
     648:	stmia	r0!, {r6}
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			if (interruptMasksUsed & 0x10) {
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
     64a:	.short	0xf8c3
     64c:	stmia	r0!, {r2, r6}
     64e:	.short	0xf102
     650:	lsrs	r0, r5, #16
     652:	.short	0x4866
				NVIC_ICER4 = interruptSave[4];
     654:	ldr	r3, [pc, #432]	; (808 <TeensySynth::TeensySynth()+0x628>)
     656:	.short	0xf849
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			if (interruptMasksUsed & 0x10) {
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
     658:	movs	r3, r0
     65a:	.short	0x4628
     65c:	strb	r5, [r2, #8]
     65e:	.short	0x60d5
     660:	strb	r7, [r2, #9]
				NVIC_ICER4 = interruptSave[4];
     662:	.short	0xf8c2
     664:	b.n	688 <TeensySynth::TeensySynth()+0x4a8>
     666:	.short	0xe000
     668:	ldr	r4, [r2, #16]
     66a:	.short	0xf844
     66c:	movs	r1, r4
     66e:	.short	0x3101
     670:	ldrb	r3, [r2, #9]
     672:	.short	0x428b
     674:	bgt.n	668 <TeensySynth::TeensySynth()+0x488>
     676:	.short	0x4b5e
     678:	ldr	r1, [r3, #0]
     67a:	.short	0xb909
     67c:	b.n	9c2 <TeensySynth::TeensySynth()+0x7e2>
     67e:	.short	0x4619
     680:	ldr	r3, [r1, #20]
     682:	.short	0x2b00
     684:	bne.n	67e <TeensySynth::TeensySynth()+0x49e>
     686:	.short	0x614a
     688:	movs	r4, #0
     68a:	.short	0x2504
     68c:	ldr	r3, [pc, #380]	; (80c <TeensySynth::TeensySynth()+0x62c>)
     68e:	.short	0xeef7
     690:	ldrb	r0, [r0, #8]
     692:	.short	0xf8c2
     694:	stmia	r0!, {r5}
     696:	.short	0x4621
     698:	str	r4, [r2, #20]
     69a:	.short	0xf04f
     69c:	lsrs	r1, r0, #24
     69e:	.short	0x8094
     6a0:	vmov	fp, s15
     6a4:	.word	0xf04f80d4
     6a8:	lsrs	r0, r0, #8
     6aa:	.short	0x7294
class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
      //active_f32 = false;
      destination_list_f32 = NULL;
     6ac:	str	r4, [r2, #28]


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     6ae:	.short	0x7615
      //active_f32 = false;
      destination_list_f32 = NULL;
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
     6b0:	str.w	r4, [r9, r3]
     6b4:	.word	0x6a103380
     6b8:	ldr	r5, [pc, #340]	; (810 <TeensySynth::TeensySynth()+0x630>)
     6ba:	.short	0x444b
     6bc:	str	r4, [r0, #4]
     6be:	.short	0x6a16
     6c0:	add	r5, r9
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
     6c2:	.short	0x4851
     6c4:	str	r4, [r6, #8]
     6c6:	.short	0x6a16
     6c8:	ldr.w	r8, [pc, #344]	; 824 <TeensySynth::TeensySynth()+0x644>
     6cc:	.word	0xeddf60f4
	{
		if (freq < 20.0)
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
			freq = AUDIO_SAMPLE_RATE_EXACT / 2.5;
		g = 1 - expf(-2 * tanf(2 * M_PI * freq / (2 * AUDIO_SAMPLE_RATE_EXACT)));
     6d0:	ldr	r1, [r2, #36]	; 0x24

class AudioMixer4_F32 : public AudioStream_F32 {
//GUI: inputs:4, outputs:1  //this line used for automatic generation of GUI node
//GUI: shortName:Mixer4
public:
    AudioMixer4_F32() : AudioStream_F32(4, inputQueueArray) { setDefaultValues(); }
     6d2:	.short	0x4c4a
		if (setf)
			basef = freq;
     6d4:	vldr	s14, [pc, #320]	; 818 <TeensySynth::TeensySynth()+0x638>
     6d8:	.word	0x4000f849
	AudioMixer4_F32(const AudioSettings_F32 &settings) : AudioStream_F32(4, inputQueueArray) { setDefaultValues(); }
	
	void setDefaultValues(void) {
		for (int i=0; i<4; i++) multiplier[i] = 1.0;
     6dc:	vstr	s15, [r2, #56]	; 0x38
     6e0:	.word	0x7a0fedc2
     6e4:	vstr	s15, [r2, #64]	; 0x40
     6e8:	.word	0x7a11edc2
     6ec:	sub.w	ip, r3, #60	; 0x3c

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     6f0:	.word	0xf1a34f3e
     6f4:	lsls	r0, r4, #25
     6f6:	.short	0xf1a3
     6f8:	lsls	r0, r1, #16
			active = false;
			destination_list = NULL;
     6fa:	.short	0x2200
     6fc:	mov	r0, ip

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     6fe:	.short	0xf843
     700:	ldrb	r0, [r4, #17]
     702:	.short	0xf803
     704:	mrrc	8, 0, pc, r7, cr3	; <UNPREDICTABLE>
			active = false;
     708:	.word	0xf8431c58
			destination_list = NULL;
     70c:	adds	r4, r2, #1

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     70e:	.short	0xf843
     710:	ldmia	r4, {r4, r6}
     712:	.short	0xe001
     714:	ldr.w	r0, [r3, #-80]
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     718:	.word	0x1022f840
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     71c:	adds	r2, #1
     71e:	.short	0xf813
     720:	lsrs	r7, r2, #17
     722:	.short	0x4290
     724:	bgt.n	714 <TeensySynth::TeensySynth()+0x534>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
     726:	.short	0x4a32
     728:	ldr	r0, [r2, #0]
     72a:	.short	0xb908
     72c:	b.n	9be <TeensySynth::TeensySynth()+0x7de>
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
     72e:	.short	0x4610
     730:	ldr	r2, [r0, #20]
     732:	.short	0x2a00
     734:	bne.n	72e <TeensySynth::TeensySynth()+0x54e>
				p->next_update = this;
     736:	.short	0x6146


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     738:	mov.w	r6, #2
			}
			next_update = NULL;
     73c:	.word	0x1c4cf843
			cpu_cycles = 0;
     740:	strh.w	r1, [r3, #-92]
     744:	.word	0xf8233360
			cpu_cycles_max = 0;
     748:	adds	r2, r7, #2
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
     74a:	.short	0x2200
			cpu_cycles = 0;
			cpu_cycles_max = 0;
			numConnections = 0;
     74c:	strb.w	r1, [r3, #-182]
     750:	.word	0x6ca8f803
     754:	str.w	r4, [r3, #-160]
      //active_f32 = false;
      destination_list_f32 = NULL;
     758:	.word	0x1ca4f843
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
     75c:	str.w	r1, [r3, #-104]
     760:	.word	0x1c64f843
	float y_c;
	float y_d;
	float y_d_1;

public:
	AudioFilterMoog_F32() : AudioStream_F32(2, inputQueueArray_f32)
     764:	str.w	r8, [r3, #-192]
	{
		if (freq < 20.0)
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
			freq = AUDIO_SAMPLE_RATE_EXACT / 2.5;
		g = 1 - expf(-2 * tanf(2 * M_PI * freq / (2 * AUDIO_SAMPLE_RATE_EXACT)));
     768:	.word	0x6a26ed43
		if (setf)
			basef = freq;
     76c:	vstr	s14, [r3, #-136]	; 0xffffff78
	{
		if (qi < 0.7)
			qi = 0.7;
		else if (qi > 5.0)
			qi = 5.0;
		q = qi;
     770:	.word	0xbc94f843
	{
		if (d > 10.0f)
			d = 10.0f;
		if (d < 0.1f)
			d = 0.1f;
		driv = d;
     774:	str.w	fp, [r3, #-144]
	{
		if (n < 0.0)
			n = 0.0;
		else if (n > 6.9999)
			n = 6.9999;
		oct = n;
     778:	.word	0xbc8cf843
	{
		frequency(1000);
		resonance(1);
		drive(1);
		octaveControl(1);
		y_a = 0;
     77c:	str.w	sl, [r3, #-132]
		y_b = 0;
     780:	.word	0xac80f843
		y_c = 0;
     784:	str.w	sl, [r3, #-124]
		y_d = 0;
     788:	.word	0xac78f843
		y_d_1 = 0;
     78c:	str.w	sl, [r3, #-116]
		state_lowpass = 0;
     790:	.word	0x1c70f843
		state_bandpass = 0;
     794:	str.w	r1, [r3, #-108]
     798:	.word	0xd1a742ab

class AudioConvert_F32toI16 : public AudioStream_F32 //receive Float and transmits Int
{
  //GUI: inputs:1, outputs:1  //this line used for automatic generation of GUI node
  public:
    AudioConvert_F32toI16(void) : AudioStream_F32(1, inputQueueArray_Float) {};
     79c:	ldr	r1, [pc, #124]	; (81c <TeensySynth::TeensySynth()+0x63c>)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     79e:	.short	0x2601
     7a0:	ldr	r7, [pc, #72]	; (7ec <TeensySynth::TeensySynth()+0x60c>)
			active = false;
			destination_list = NULL;
     7a2:	.short	0x4613
     7a4:	mov	r5, r1
     7a6:	.short	0x4449
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     7a8:	mov	r4, r2

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     7aa:	.short	0xf849
     7ac:	strb	r5, [r0, #0]


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     7ae:	.short	0xf101
     7b0:	lsls	r4, r4, #20
			active = false;
     7b2:	.short	0x720a
     7b4:	add.w	r0, r1, #40	; 0x28
			destination_list = NULL;
     7b8:	.word	0x462a60ca

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     7bc:	strb	r6, [r1, #9]
     7be:	.short	0x610d
     7c0:	b.n	7c4 <TeensySynth::TeensySynth()+0x5e4>
     7c2:	.short	0x690a
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     7c4:	str.w	r4, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     7c8:	.word	0x7a4a3301
     7cc:	cmp	r2, r3
     7ce:	.short	0xdcf8
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
     7d0:	ldr	r3, [pc, #28]	; (7f0 <TeensySynth::TeensySynth()+0x610>)
     7d2:	.short	0x681a
     7d4:	cbnz	r2, 82a <TeensySynth::TeensySynth()+0x64a>
     7d6:	.short	0xe0f6
     7d8:	add	r3, sp, #48	; 0x30
     7da:	.short	0x0001
     7dc:	smlabb	r0, ip, r1, r2
     7e0:	.word	0x473b8000
     7e4:	add	r3, sp, #448	; 0x1c0
     7e6:	.short	0x0001
     7e8:	subs	r3, #212	; 0xd4
     7ea:	.short	0x0003
     7ec:	movs	r0, r1
     7ee:	.short	0x2000
     7f0:	strh	r4, [r5, #58]	; 0x3a
     7f2:	movs	r0, #5
     7f4:	.word	0x00033bfc
     7f8:	subs	r4, #28
     7fa:	.short	0x0003
     7fc:	smlawb	r0, r4, r1, r2
     800:	str	r4, [r4, #52]	; 0x34
     802:	.short	0x0003
     804:	str	r4, [r1, #56]	; 0x38
     806:	.short	0x0003
     808:	str	r4, [r5, #56]	; 0x38
     80a:	.short	0x0003
     80c:	str	r4, [r2, #60]	; 0x3c
     80e:	.short	0x0003
     810:	str	r4, [r2, #80]	; 0x50
     812:	.short	0x0003
     814:	ldr	r5, [sp, #224]	; 0xe0
     816:	.short	0x3dfb
     818:	.word	0x447a0000
     81c:	.word	0x000364b4
     820:	.word	0x0001ab34
     824:	.word	0x20000544
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
     828:	mov	r2, r3
     82a:	ldr	r3, [r2, #20]
     82c:	cmp	r3, #0
     82e:	bne.n	828 <TeensySynth::TeensySynth()+0x648>
				p->next_update = this;
     830:	str	r1, [r2, #20]
     832:	ldr	r2, [pc, #432]	; (9e4 <TeensySynth::TeensySynth()+0x804>)
			}
			next_update = NULL;
     834:	movs	r7, #0
     836:	mov.w	lr, #1
      //active_f32 = false;
      destination_list_f32 = NULL;
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
     83a:	ldr	r5, [pc, #428]	; (9e8 <TeensySynth::TeensySynth()+0x808>)
     83c:	add	r2, r9


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     83e:	str	r0, [r1, #32]
     840:	str	r7, [r1, #20]
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
     842:	mov	r3, r7
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
			cpu_cycles = 0;
     844:	strh	r7, [r1, #4]
     846:	add.w	ip, r2, #36	; 0x24
			cpu_cycles_max = 0;
     84a:	strh	r7, [r1, #6]
     84c:	add.w	r6, r2, #40	; 0x28
			numConnections = 0;
     850:	strb	r7, [r1, #10]
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     852:	mov	r4, r7
      //active_f32 = false;
      destination_list_f32 = NULL;
     854:	str	r7, [r1, #28]


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     856:	strb.w	lr, [r1, #24]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     85a:	ldr	r0, [pc, #400]	; (9ec <TeensySynth::TeensySynth()+0x80c>)
      //active_f32 = false;
      destination_list_f32 = NULL;
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
     85c:	str.w	r7, [r9, r5]
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
     860:	ldr.w	r8, [pc, #460]	; a30 <TeensySynth::TeensySynth()+0x850>
     864:	ldr	r5, [pc, #392]	; (9f0 <TeensySynth::TeensySynth()+0x810>)
     866:	ldr	r1, [pc, #380]	; (9e4 <TeensySynth::TeensySynth()+0x804>)
     868:	str.w	r5, [r9, r8]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     86c:	str.w	r0, [r9, r1]
			active = false;
			destination_list = NULL;
     870:	mov	r0, ip

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     872:	str.w	ip, [r2, #16]
     876:	strb.w	lr, [r2, #9]
			active = false;
     87a:	strb	r7, [r2, #8]
			destination_list = NULL;
     87c:	str	r7, [r2, #12]
     87e:	b.n	882 <TeensySynth::TeensySynth()+0x6a2>
     880:	ldr	r0, [r2, #16]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     882:	str.w	r4, [r0, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     886:	adds	r3, #1
     888:	ldrb	r1, [r2, #9]
     88a:	cmp	r1, r3
     88c:	bgt.n	880 <TeensySynth::TeensySynth()+0x6a0>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
     88e:	ldr	r3, [pc, #356]	; (9f4 <TeensySynth::TeensySynth()+0x814>)
     890:	ldr	r1, [r3, #0]
     892:	cbnz	r1, 898 <TeensySynth::TeensySynth()+0x6b8>
     894:	b.n	9ca <TeensySynth::TeensySynth()+0x7ea>
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
     896:	mov	r1, r3
     898:	ldr	r3, [r1, #20]
     89a:	cmp	r3, #0
     89c:	bne.n	896 <TeensySynth::TeensySynth()+0x6b6>
				p->next_update = this;
     89e:	str	r2, [r1, #20]


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     8a0:	movs	r0, #1
     8a2:	ldr	r1, [pc, #340]	; (9f8 <TeensySynth::TeensySynth()+0x818>)
			}
			next_update = NULL;
     8a4:	movs	r4, #0
     8a6:	ldr.w	lr, [pc, #316]	; 9e4 <TeensySynth::TeensySynth()+0x804>
     8aa:	strb	r0, [r2, #24]
     8ac:	add	r1, r9
      //active_f32 = false;
      destination_list_f32 = NULL;
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
     8ae:	ldr	r0, [pc, #332]	; (9fc <TeensySynth::TeensySynth()+0x81c>)

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     8b0:	mov.w	ip, #2


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
     8b4:	str	r6, [r2, #32]
#include "DMAChannel.h"

class AudioOutputI2S : public AudioStream
{
public:
	AudioOutputI2S(void) : AudioStream(2, inputQueueArray) { begin(); }
     8b6:	add.w	r6, r1, #24
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
     8ba:	str	r4, [r2, #20]
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
     8bc:	mov	r3, r4
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
				p->next_update = this;
			}
			next_update = NULL;
			cpu_cycles = 0;
     8be:	strh	r4, [r2, #4]
			cpu_cycles_max = 0;
     8c0:	strh	r4, [r2, #6]
			numConnections = 0;
     8c2:	strb	r4, [r2, #10]
      //active_f32 = false;
      destination_list_f32 = NULL;
     8c4:	str	r4, [r2, #28]
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
     8c6:	mov	r2, r6
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
     8c8:	str.w	r4, [r9, r0]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     8cc:	mov	r0, r4
     8ce:	str.w	r5, [r9, lr]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     8d2:	ldr	r7, [pc, #280]	; (9ec <TeensySynth::TeensySynth()+0x80c>)
     8d4:	ldr	r5, [pc, #288]	; (9f8 <TeensySynth::TeensySynth()+0x818>)
     8d6:	str.w	r7, [r9, r5]
			active = false;
     8da:	strb	r4, [r1, #8]
			destination_list = NULL;
     8dc:	str	r4, [r1, #12]

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
     8de:	strb.w	ip, [r1, #9]
     8e2:	str	r6, [r1, #16]
     8e4:	b.n	8e8 <TeensySynth::TeensySynth()+0x708>
     8e6:	ldr	r2, [r1, #16]
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
     8e8:	str.w	r0, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
     8ec:	adds	r3, #1
     8ee:	ldrb	r2, [r1, #9]
     8f0:	cmp	r2, r3
     8f2:	bgt.n	8e6 <TeensySynth::TeensySynth()+0x706>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
     8f4:	ldr	r3, [pc, #252]	; (9f4 <TeensySynth::TeensySynth()+0x814>)
     8f6:	ldr	r2, [r3, #0]
     8f8:	cbnz	r2, 8fe <TeensySynth::TeensySynth()+0x71e>
     8fa:	b.n	9ce <TeensySynth::TeensySynth()+0x7ee>
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
     8fc:	mov	r2, r3
     8fe:	ldr	r3, [r2, #20]
     900:	cmp	r3, #0
     902:	bne.n	8fc <TeensySynth::TeensySynth()+0x71c>
				p->next_update = this;
     904:	str	r1, [r2, #20]
			}
			next_update = NULL;
     906:	movs	r4, #0
     908:	ldr	r3, [pc, #236]	; (9f8 <TeensySynth::TeensySynth()+0x818>)
     90a:	ldr	r2, [pc, #244]	; (a00 <TeensySynth::TeensySynth()+0x820>)
     90c:	mov	r0, r1
     90e:	str	r4, [r1, #20]
     910:	movs	r6, #255	; 0xff
			cpu_cycles = 0;
     912:	strh	r4, [r1, #4]
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     914:	mov.w	r5, #1065353216	; 0x3f800000
			cpu_cycles_max = 0;
     918:	strh	r4, [r1, #6]
			numConnections = 0;
     91a:	strb	r4, [r1, #10]
     91c:	str.w	r2, [r9, r3]
     920:	bl	13fe4 <AudioOutputI2S::begin()>
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     924:	ldr	r1, [pc, #220]	; (a04 <TeensySynth::TeensySynth()+0x824>)
     926:	ldr	r2, [pc, #224]	; (a08 <TeensySynth::TeensySynth()+0x828>)
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     928:	mov.w	lr, #200	; 0xc8
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     92c:	add	r1, r9
     92e:	ldr	r7, [pc, #212]	; (a04 <TeensySynth::TeensySynth()+0x824>)
     930:	add	r2, r9
     932:	ldr	r0, [pc, #212]	; (a08 <TeensySynth::TeensySynth()+0x828>)
     934:	str.w	r4, [r9, r7]
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     938:	ldr	r3, [pc, #208]	; (a0c <TeensySynth::TeensySynth()+0x82c>)
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     93a:	strb	r4, [r1, #4]
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     93c:	movs	r1, #1
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     93e:	strb.w	r6, [r9, r7]
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     942:	add	r3, r9
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     944:	str.w	r4, [r9, r0]
     948:	strb	r4, [r2, #4]
     94a:	mov.w	r2, #1216	; 0x4c0
     94e:	strb.w	r6, [r9, r0]
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     952:	adds	r0, #67	; 0x43
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     954:	ldr	r6, [pc, #184]	; (a10 <TeensySynth::TeensySynth()+0x830>)
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     956:	ldr	r7, [pc, #188]	; (a14 <TeensySynth::TeensySynth()+0x834>)
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     958:	strb.w	r4, [r9, r6]
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     95c:	str.w	r4, [r9, r0]
     960:	ldr	r0, [pc, #180]	; (a18 <TeensySynth::TeensySynth()+0x838>)
     962:	strb.w	r4, [r3, #56]	; 0x38
     966:	strb.w	r4, [r3, #60]	; 0x3c
     96a:	strb.w	r1, [r3, #61]	; 0x3d
     96e:	movs	r1, #0
     970:	ldr	r4, [pc, #168]	; (a1c <TeensySynth::TeensySynth()+0x83c>)
     972:	str	r0, [r3, #68]	; 0x44
     974:	ldr	r6, [pc, #168]	; (a20 <TeensySynth::TeensySynth()+0x840>)
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     976:	ldr	r0, [pc, #172]	; (a24 <TeensySynth::TeensySynth()+0x844>)
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     978:	strh.w	lr, [r3, #58]	; 0x3a
     97c:	str	r7, [r3, #64]	; 0x40
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     97e:	add	r0, r9
        float sustain = 1.0f;
        float release = 0.0f;
    };

    //Structure for storing presets and current instrument settings
    struct Patch
     980:	str	r6, [r3, #72]	; 0x48
     982:	str	r1, [r3, #4]
     984:	str	r1, [r3, #8]
     986:	str	r1, [r3, #12]
     988:	str	r1, [r3, #16]
     98a:	str	r1, [r3, #28]
     98c:	str	r1, [r3, #32]
     98e:	str	r1, [r3, #36]	; 0x24
     990:	str	r1, [r3, #40]	; 0x28
     992:	str	r5, [r3, #20]
     994:	str	r5, [r3, #24]
     996:	str	r5, [r3, #48]	; 0x30
     998:	str	r5, [r3, #52]	; 0x34
     99a:	str	r4, [r3, #44]	; 0x2c
#include "dsp/filter_moog_f32.h"
#include "dsp/effect_ensemble_f32.h"
#include "dsp/effect_freeverb_f32.h"
#include <OpenAudio_ArduinoLibrary.h>

class TeensySynth
     99c:	ldr	r1, [pc, #136]	; (a28 <TeensySynth::TeensySynth()+0x848>)
     99e:	bl	15578 <memcpy>
     9a2:	ldr	r3, [pc, #136]	; (a2c <TeensySynth::TeensySynth()+0x84c>)
     9a4:	mov	r0, r9
     9a6:	add	r3, r9
     9a8:	str	r4, [r3, #0]
     9aa:	add	sp, #20
     9ac:	vpop	{d8}
     9b0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
				first_update = this;
     9b4:	str.w	ip, [fp]
     9b8:	b.n	370 <TeensySynth::TeensySynth()+0x190>
     9ba:	str	r4, [r3, #0]
     9bc:	b.n	240 <TeensySynth::TeensySynth()+0x60>
     9be:	str	r6, [r2, #0]
     9c0:	b.n	738 <TeensySynth::TeensySynth()+0x558>
     9c2:	str	r2, [r3, #0]
     9c4:	b.n	688 <TeensySynth::TeensySynth()+0x4a8>
     9c6:	str	r1, [r3, #0]
     9c8:	b.n	832 <TeensySynth::TeensySynth()+0x652>
     9ca:	str	r2, [r3, #0]
     9cc:	b.n	8a0 <TeensySynth::TeensySynth()+0x6c0>
     9ce:	str	r1, [r3, #0]
     9d0:	b.n	906 <TeensySynth::TeensySynth()+0x726>
     9d2:	str	r3, [r2, #0]
     9d4:	b.n	402 <TeensySynth::TeensySynth()+0x222>
     9d6:	str	r3, [r2, #0]
     9d8:	b.n	4f6 <TeensySynth::TeensySynth()+0x316>
     9da:	str	r3, [r2, #0]
     9dc:	b.n	57a <TeensySynth::TeensySynth()+0x39a>
     9de:	str	r3, [r2, #0]
     9e0:	b.n	600 <TeensySynth::TeensySynth()+0x420>
     9e2:	nop
     9e4:	.word	0x000364e0
     9e8:	.word	0x000364dc
     9ec:	.word	0x20000008
     9f0:	.word	0x20000014
     9f4:	.word	0x2005876c
     9f8:	.word	0x0003650c
     9fc:	.word	0x00036508
     a00:	.word	0x2001fa98
     a04:	.word	0x000365ac
     a08:	.word	0x000365b1
     a0c:	.word	0x000365f4
     a10:	.word	0x000365b6
     a14:	.word	0x3f333333
     a18:	.word	0x3dcccccd
     a1c:	.word	0x46960000
     a20:	.word	0x3f4ccccd
     a24:	.word	0x00036640
     a28:	.word	0x20000018
     a2c:	.word	0x00036b10
     a30:	.word	0x000364b4

00000a34 <readMidi()>:
    }
}
#endif

void readMidi()
{
     a34:	push	{r4, r5, lr}
        uint8_t analog2velocity(uint16_t val, uint8_t range);
        bool read(uint8_t channel=0) __attribute__((always_inline)) {
		return usb_midi_read(channel);
	}
        uint8_t getType(void) __attribute__((always_inline)) {
                return usb_midi_msg_type;
     a36:	ldr	r4, [pc, #96]	; (a98 <readMidi()+0x64>)
     a38:	sub	sp, #12
        }
        uint8_t getData1(void) __attribute__((always_inline)) {
                return usb_midi_msg_data1;
        }
        uint8_t getData2(void) __attribute__((always_inline)) {
                return usb_midi_msg_data2;
     a3a:	ldr	r5, [pc, #96]	; (a9c <readMidi()+0x68>)
        void send_now(void) __attribute__((always_inline)) {
		usb_midi_flush_output();
	}
        uint8_t analog2velocity(uint16_t val, uint8_t range);
        bool read(uint8_t channel=0) __attribute__((always_inline)) {
		return usb_midi_read(channel);
     a3c:	movs	r0, #7
     a3e:	bl	171bc <usb_midi_read>
    while (usbMIDI.read(SYNTH_MIDICHANNEL))
     a42:	cbz	r0, a70 <readMidi()+0x3c>
    {
        switch (usbMIDI.getType())
     a44:	ldrb	r3, [r4, #0]
     a46:	cmp	r3, #144	; 0x90
     a48:	beq.n	a86 <readMidi()+0x52>
     a4a:	cmp	r3, #176	; 0xb0
     a4c:	beq.n	a74 <readMidi()+0x40>
     a4e:	cmp	r3, #128	; 0x80
     a50:	bne.n	a3c <readMidi()+0x8>
    void noteOn(uint8_t channel, uint8_t note, uint8_t velocity);

    //Kill an existing voice
    inline void noteOff(uint8_t channel, uint8_t note, uint8_t velocity)
    {
        noteOffReal(channel, note, velocity, false);
     a52:	movs	r0, #0
        }
        uint8_t getCable(void) __attribute__((always_inline)) {
                return usb_midi_msg_cable;
        }
        uint8_t getChannel(void) __attribute__((always_inline)) {
                return usb_midi_msg_channel;
     a54:	ldr	r3, [pc, #72]	; (aa0 <readMidi()+0x6c>)
        }
        uint8_t getData1(void) __attribute__((always_inline)) {
                return usb_midi_msg_data1;
     a56:	ldr	r2, [pc, #76]	; (aa4 <readMidi()+0x70>)
     a58:	ldrb	r1, [r3, #0]
     a5a:	ldrb	r2, [r2, #0]
     a5c:	ldrb	r3, [r5, #0]
     a5e:	str	r0, [sp, #0]
     a60:	ldr	r0, [pc, #68]	; (aa8 <readMidi()+0x74>)
     a62:	bl	c04 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)>
        void send_now(void) __attribute__((always_inline)) {
		usb_midi_flush_output();
	}
        uint8_t analog2velocity(uint16_t val, uint8_t range);
        bool read(uint8_t channel=0) __attribute__((always_inline)) {
		return usb_midi_read(channel);
     a66:	movs	r0, #7
     a68:	bl	171bc <usb_midi_read>
}
#endif

void readMidi()
{
    while (usbMIDI.read(SYNTH_MIDICHANNEL))
     a6c:	cmp	r0, #0
     a6e:	bne.n	a44 <readMidi()+0x10>
            break;
        default:
            break;
        }
    }
}
     a70:	add	sp, #12
     a72:	pop	{r4, r5, pc}
        }
        uint8_t getCable(void) __attribute__((always_inline)) {
                return usb_midi_msg_cable;
        }
        uint8_t getChannel(void) __attribute__((always_inline)) {
                return usb_midi_msg_channel;
     a74:	ldr	r3, [pc, #40]	; (aa0 <readMidi()+0x6c>)
        }
        uint8_t getData1(void) __attribute__((always_inline)) {
                return usb_midi_msg_data1;
     a76:	ldr	r2, [pc, #44]	; (aa4 <readMidi()+0x70>)
            break;
        case usbMIDI.NoteOff:
            ts.noteOff(usbMIDI.getChannel(), usbMIDI.getData1(), usbMIDI.getData2());
            break;
        case usbMIDI.ControlChange:
            ts.OnControlChange(usbMIDI.getChannel(), usbMIDI.getData1(), usbMIDI.getData2()); //TODO: move handling midi stuff to its own class
     a78:	ldrb	r1, [r3, #0]
     a7a:	ldrb	r2, [r2, #0]
     a7c:	ldrb	r3, [r5, #0]
     a7e:	ldr	r0, [pc, #40]	; (aa8 <readMidi()+0x74>)
     a80:	bl	10f8 <TeensySynth::OnControlChange(unsigned char, unsigned char, unsigned char)>
            break;
     a84:	b.n	a3c <readMidi()+0x8>
        }
        uint8_t getCable(void) __attribute__((always_inline)) {
                return usb_midi_msg_cable;
        }
        uint8_t getChannel(void) __attribute__((always_inline)) {
                return usb_midi_msg_channel;
     a86:	ldr	r3, [pc, #24]	; (aa0 <readMidi()+0x6c>)
        }
        uint8_t getData1(void) __attribute__((always_inline)) {
                return usb_midi_msg_data1;
     a88:	ldr	r2, [pc, #24]	; (aa4 <readMidi()+0x70>)
    while (usbMIDI.read(SYNTH_MIDICHANNEL))
    {
        switch (usbMIDI.getType())
        {
        case usbMIDI.NoteOn:
            ts.noteOn(usbMIDI.getChannel(), usbMIDI.getData1(), usbMIDI.getData2());
     a8a:	ldrb	r1, [r3, #0]
     a8c:	ldrb	r2, [r2, #0]
     a8e:	ldrb	r3, [r5, #0]
     a90:	ldr	r0, [pc, #20]	; (aa8 <readMidi()+0x74>)
     a92:	bl	ee4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)>
            break;
     a96:	b.n	a3c <readMidi()+0x8>
     a98:	.word	0x2005a6c0
     a9c:	.word	0x2005a6c5
     aa0:	.word	0x2005a6c7
     aa4:	.word	0x2005a6c4
     aa8:	.word	0x200212fc

00000aac <setup>:
    }
}

//************SETUP**************
void setup()
{
     aac:	push	{r3, r4, r5, r6, r7, lr}
#if SYNTH_DEBUG > 0
    // Open serial communications and wait for port to open:
    Serial.begin(115200);
#endif
    //Allocate audio memory. Floating point and integer versions need their own blocks.
    AudioMemory(2);
     aae:	movs	r1, #2
     ab0:	ldr	r0, [pc, #112]	; (b24 <setup+0x78>)
     ab2:	bl	1b3f0 <___ZN11AudioStream17initialize_memoryEP18audio_block_structj_veneer>
    AudioMemory_F32(11);
     ab6:	movs	r0, #11
     ab8:	bl	15180 <AudioMemory_F32(int)>

    //Initialize the synth only after Serial is ok and audiomemory is allocated
    ts.init();
     abc:	ldr	r0, [pc, #104]	; (b28 <setup+0x7c>)
     abe:	bl	12dc <TeensySynth::init()>

    //Initialize hardware controls and pass a pointer to the main synth stuff
    hw = new HardwareControls(&ts);
     ac2:	movs	r0, #152	; 0x98
     ac4:	bl	17c08 <operator new(unsigned int)>

class HardwareControls
{
public:
    HardwareControls(TeensySynth *tsPointer)
    {
     ac8:	ldr	r2, [pc, #96]	; (b2c <setup+0x80>)
     aca:	mov	r4, r0
     acc:	movs	r0, #14
     ace:	mov	r3, r2
     ad0:	add.w	r6, r2, #76	; 0x4c
     ad4:	ldr.w	r5, [r2, #4]!
     ad8:	add.w	r1, r4, #11
     adc:	strb	r0, [r4, #4]
     ade:	ldrh	r2, [r2, #4]
     ae0:	ldr.w	r0, [r3], #12
     ae4:	str.w	r5, [r4, #5]
     ae8:	str	r0, [r4, #0]
     aea:	strh.w	r2, [r4, #9]
     aee:	ldr	r7, [r3, #0]
     af0:	adds	r3, #16
     af2:	ldr.w	r5, [r3, #-12]
     af6:	adds	r1, #16
     af8:	ldr.w	r0, [r3, #-8]
     afc:	ldr.w	r2, [r3, #-4]
     b00:	cmp	r3, r6
     b02:	str.w	r7, [r1, #-16]
     b06:	str.w	r5, [r1, #-12]
     b0a:	str.w	r0, [r1, #-8]
     b0e:	str.w	r2, [r1, #-4]
     b12:	bne.n	aee <setup+0x42>
        init();
     b14:	mov	r0, r4
     b16:	bl	3624 <HardwareControls::init()>
        ts = tsPointer;
     b1a:	ldr	r2, [pc, #12]	; (b28 <setup+0x7c>)
     b1c:	ldr	r3, [pc, #16]	; (b30 <setup+0x84>)
     b1e:	str	r2, [r4, #76]	; 0x4c
     b20:	str	r4, [r3, #0]
     b22:	pop	{r3, r4, r5, r6, r7, pc}
     b24:	.word	0x20200000
     b28:	.word	0x200212fc
     b2c:	.word	0x200004d8
     b30:	.word	0x20057e10

00000b34 <loop>:
}

//************LOOP**************
void loop()
{
     b34:	push	{r3, lr}
    readMidi();
     b36:	bl	a34 <readMidi()>
    hw->update();
     b3a:	ldr	r3, [pc, #12]	; (b48 <loop+0x14>)
    }

    void update()
    {
        checkControlValues(1);
     b3c:	movs	r1, #1
     b3e:	ldr	r0, [r3, #0]
#if SYNTH_DEBUG > 0
    performanceCheck();
    while (Serial.available())
        selectCommand(Serial.read());
#endif
}
     b40:	ldmia.w	sp!, {r3, lr}
     b44:	b.w	341c <HardwareControls::checkControlValues(bool)>
     b48:	.word	0x20057e10

00000b4c <_GLOBAL__sub_I_ts>:
     b4c:	push	{r3, r4, r5, lr}
//************LIBRARIES USED**************
#include "settings.h"
#include "teensy_synth.h"
#include "hardware_controls.h"

TeensySynth ts;
     b4e:	ldr	r5, [pc, #32]	; (b70 <_GLOBAL__sub_I_ts+0x24>)
     b50:	ldr	r4, [pc, #32]	; (b74 <_GLOBAL__sub_I_ts+0x28>)
     b52:	mov	r0, r5
     b54:	bl	1e0 <TeensySynth::TeensySynth()>
     b58:	mov	r2, r4
     b5a:	mov	r0, r5
     b5c:	ldr	r1, [pc, #24]	; (b78 <_GLOBAL__sub_I_ts+0x2c>)
     b5e:	bl	1aa24 <__aeabi_atexit>
HardwareControls *hw;

IntervalTimer myTimer;
     b62:	mov	r2, r4
     b64:	ldr	r1, [pc, #20]	; (b7c <_GLOBAL__sub_I_ts+0x30>)
     b66:	ldr	r0, [pc, #24]	; (b80 <_GLOBAL__sub_I_ts+0x34>)
#if SYNTH_DEBUG > 0
    performanceCheck();
    while (Serial.available())
        selectCommand(Serial.read());
#endif
}
     b68:	ldmia.w	sp!, {r3, r4, r5, lr}
#include "hardware_controls.h"

TeensySynth ts;
HardwareControls *hw;

IntervalTimer myTimer;
     b6c:	b.w	1aa24 <__aeabi_atexit>
     b70:	.word	0x200212fc
     b74:	.word	0x20020464
     b78:	.word	0x00000139
     b7c:	.word	0x0000013d
     b80:	.word	0x20020468

00000b84 <TeensySynth::notesDel(signed char*, unsigned char)>:
}

int8_t TeensySynth::notesDel(int8_t *notes, uint8_t note)
{
    int8_t lastNote = -1;
    int8_t *pos = notes, *end = notes + NVOICES;
     b84:	mov	r0, r1
        }
    } while (++notes < end);
}

int8_t TeensySynth::notesDel(int8_t *notes, uint8_t note)
{
     b86:	push	{r4, r5, r6, r7}
    int8_t lastNote = -1;
    int8_t *pos = notes, *end = notes + NVOICES;
    while (++pos < end && *(pos - 1) != note)
     b88:	adds	r3, r0, #1
}

int8_t TeensySynth::notesDel(int8_t *notes, uint8_t note)
{
    int8_t lastNote = -1;
    int8_t *pos = notes, *end = notes + NVOICES;
     b8a:	adds	r6, r1, #5
    while (++pos < end && *(pos - 1) != note)
     b8c:	cmp	r6, r3
     b8e:	beq.n	ba0 <TeensySynth::notesDel(signed char*, unsigned char)+0x1c>
     b90:	ldrsb.w	r4, [r3, #-1]
     b94:	cmp	r4, r2
     b96:	beq.n	bb8 <TeensySynth::notesDel(signed char*, unsigned char)+0x34>
     b98:	mov	r0, r3
     b9a:	adds	r3, r0, #1
     b9c:	cmp	r6, r3
     b9e:	bne.n	b90 <TeensySynth::notesDel(signed char*, unsigned char)+0xc>
        ;
    if (pos - 1 != notes)
     ba0:	cmp	r0, r1
     ba2:	beq.n	be8 <TeensySynth::notesDel(signed char*, unsigned char)+0x64>
        lastNote = *(pos - 2);
     ba4:	ldrsb.w	r0, [r6, #-2]
    {
        *(pos - 1) = *pos;
        if (*pos++ == -1)
            break;
    }
    if (*(end - 1) == note || pos == end)
     ba8:	ldrsb.w	r4, [r1, #4]
     bac:	cmp	r4, r2
     bae:	beq.n	bec <TeensySynth::notesDel(signed char*, unsigned char)+0x68>
     bb0:	cmp	r3, r6
     bb2:	beq.n	bec <TeensySynth::notesDel(signed char*, unsigned char)+0x68>
        *(end - 1) = -1;
    return lastNote;
}
     bb4:	pop	{r4, r5, r6, r7}
     bb6:	bx	lr
{
    int8_t lastNote = -1;
    int8_t *pos = notes, *end = notes + NVOICES;
    while (++pos < end && *(pos - 1) != note)
        ;
    if (pos - 1 != notes)
     bb8:	cmp	r0, r1
     bba:	bne.n	bf8 <TeensySynth::notesDel(signed char*, unsigned char)+0x74>
    } while (++notes < end);
}

int8_t TeensySynth::notesDel(int8_t *notes, uint8_t note)
{
    int8_t lastNote = -1;
     bbc:	mov.w	r0, #4294967295
        ;
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
    while (pos < end)
    {
        *(pos - 1) = *pos;
     bc0:	ldrsb.w	r5, [r3]
        if (*pos++ == -1)
     bc4:	adds	r4, r3, #1
        ;
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
    while (pos < end)
    {
        *(pos - 1) = *pos;
     bc6:	strb.w	r5, [r3, #-1]
        if (*pos++ == -1)
     bca:	adds	r5, #1
     bcc:	beq.n	bf4 <TeensySynth::notesDel(signed char*, unsigned char)+0x70>
     bce:	subs	r7, r3, #1
     bd0:	b.n	be0 <TeensySynth::notesDel(signed char*, unsigned char)+0x5c>
        ;
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
    while (pos < end)
    {
        *(pos - 1) = *pos;
     bd2:	ldrsb.w	r5, [r4], #1
     bd6:	strb.w	r5, [r7, #1]!
        if (*pos++ == -1)
     bda:	adds	r5, #1
     bdc:	mov	r3, r4
     bde:	beq.n	ba8 <TeensySynth::notesDel(signed char*, unsigned char)+0x24>
    int8_t *pos = notes, *end = notes + NVOICES;
    while (++pos < end && *(pos - 1) != note)
        ;
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
    while (pos < end)
     be0:	cmp	r6, r4
     be2:	mov	r3, r4
     be4:	bhi.n	bd2 <TeensySynth::notesDel(signed char*, unsigned char)+0x4e>
     be6:	b.n	ba8 <TeensySynth::notesDel(signed char*, unsigned char)+0x24>
    } while (++notes < end);
}

int8_t TeensySynth::notesDel(int8_t *notes, uint8_t note)
{
    int8_t lastNote = -1;
     be8:	mov.w	r0, #4294967295
        *(pos - 1) = *pos;
        if (*pos++ == -1)
            break;
    }
    if (*(end - 1) == note || pos == end)
        *(end - 1) = -1;
     bec:	movs	r3, #255	; 0xff
     bee:	strb	r3, [r1, #4]
    return lastNote;
}
     bf0:	pop	{r4, r5, r6, r7}
     bf2:	bx	lr
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
    while (pos < end)
    {
        *(pos - 1) = *pos;
        if (*pos++ == -1)
     bf4:	mov	r3, r4
     bf6:	b.n	ba8 <TeensySynth::notesDel(signed char*, unsigned char)+0x24>
    int8_t *pos = notes, *end = notes + NVOICES;
    while (++pos < end && *(pos - 1) != note)
        ;
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
    while (pos < end)
     bf8:	cmp	r6, r3
    int8_t lastNote = -1;
    int8_t *pos = notes, *end = notes + NVOICES;
    while (++pos < end && *(pos - 1) != note)
        ;
    if (pos - 1 != notes)
        lastNote = *(pos - 2);
     bfa:	ldrsb.w	r0, [r3, #-2]
    while (pos < end)
     bfe:	bhi.n	bc0 <TeensySynth::notesDel(signed char*, unsigned char)+0x3c>
     c00:	b.n	ba8 <TeensySynth::notesDel(signed char*, unsigned char)+0x24>
     c02:	nop

00000c04 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)>:

    return;
}

TeensySynth::Oscillator *TeensySynth::noteOffReal(uint8_t channel, uint8_t note, uint8_t velocity, bool ignoreSustain)
{
     c04:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!omniOn && channel != SYNTH_MIDICHANNEL)
     c08:	subs	r1, #7
     c0a:	ldr	r4, [pc, #672]	; (eac <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2a8>)

    return;
}

TeensySynth::Oscillator *TeensySynth::noteOffReal(uint8_t channel, uint8_t note, uint8_t velocity, bool ignoreSustain)
{
     c0c:	sub	sp, #12
    if (!omniOn && channel != SYNTH_MIDICHANNEL)
     c0e:	it	ne
     c10:	movne	r1, #1
     c12:	ldrb	r4, [r0, r4]

    return;
}

TeensySynth::Oscillator *TeensySynth::noteOffReal(uint8_t channel, uint8_t note, uint8_t velocity, bool ignoreSustain)
{
     c14:	ldrb.w	r8, [sp, #48]	; 0x30
    if (!omniOn && channel != SYNTH_MIDICHANNEL)
     c18:	cmp	r4, r1
     c1a:	bcc.n	c9e <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x9a>
        return 0;

    int8_t lastNote = notesDel(notesPressed, note);
     c1c:	ldr	r7, [pc, #656]	; (eb0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2ac>)
     c1e:	mov	r5, r0
     c20:	mov	r9, r3
     c22:	add	r7, r0
     c24:	mov	r1, r7
     c26:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>

    if (sustainPressed && !ignoreSustain)
     c2a:	ldr	r3, [pc, #648]	; (eb4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2b0>)
TeensySynth::Oscillator *TeensySynth::noteOffReal(uint8_t channel, uint8_t note, uint8_t velocity, bool ignoreSustain)
{
    if (!omniOn && channel != SYNTH_MIDICHANNEL)
        return 0;

    int8_t lastNote = notesDel(notesPressed, note);
     c2c:	mov	sl, r0

    if (sustainPressed && !ignoreSustain)
     c2e:	ldrb	r3, [r5, r3]
     c30:	cmp	r3, r8
     c32:	bhi.n	c9e <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x9a>
     c34:	mov	r6, r2
        return 0;

    Oscillator *o = oscs;
     c36:	ldr.w	r8, [pc, #644]	; ebc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2b8>
    if (currentPatch.portamentoOn)
     c3a:	ldr	r2, [pc, #636]	; (eb8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2b4>)
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     c3c:	add	r8, r5
     c3e:	ldr	r3, [pc, #636]	; (ebc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2b8>)
    if (currentPatch.portamentoOn)
     c40:	ldrb	r2, [r5, r2]
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     c42:	mov	r4, r8
    if (currentPatch.portamentoOn)
     c44:	cbnz	r2, c8e <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x8a>
            {
                oscOff(*o);
            }
        }
    }
    else if (currentPatch.polyOn)
     c46:	ldr	r2, [pc, #632]	; (ec0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2bc>)
     c48:	ldrb.w	fp, [r5, r2]
     c4c:	cmp.w	fp, #0
     c50:	beq.n	ca6 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0xa2>
    {
        Oscillator *end = oscs + NVOICES;
     c52:	subs	r2, #61	; 0x3d
     c54:	add	r2, r5
     c56:	b.n	c5e <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x5a>
        do
     c58:	adds	r4, #12
     c5a:	cmp	r2, r4
     c5c:	bls.n	c66 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x62>
        {
            if (o->note == note)
     c5e:	ldrsb.w	r3, [r4, #8]
     c62:	cmp	r3, r6
     c64:	bne.n	c58 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x54>
                break;
        } while (++o < end);
        if (o == end)
     c66:	cmp	r4, r2
     c68:	beq.n	c9e <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x9a>
    }
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
     c6a:	ldr	r1, [pc, #600]	; (ec4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c0>)
     c6c:	mov	r0, r5
     c6e:	ldrb	r2, [r4, #8]
     c70:	add	r1, r5
    osc.note = -1;
     c72:	movs	r5, #255	; 0xff
    }
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
     c74:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
    osc.note = -1;
    osc.velocity = 0;
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     c78:	ldr	r3, [r4, #0]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     c7a:	movs	r2, #0

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
    osc.velocity = 0;
     c7c:	movs	r1, #0
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     c7e:	mov	r0, r4
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
     c80:	strb	r5, [r4, #8]
    osc.velocity = 0;
     c82:	strb	r1, [r4, #9]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     c84:	str	r2, [r3, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     c86:	str	r2, [r3, #112]	; 0x70
            }
        }
    }

    return o;
}
     c88:	add	sp, #12
     c8a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return 0;

    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
    {
        if (o->note == note)
     c8e:	ldrsb.w	fp, [r8, #8]
     c92:	cmp	fp, r6
     c94:	beq.n	cb8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0xb4>
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     c96:	mov	r0, r4
            }
        }
    }

    return o;
}
     c98:	add	sp, #12
     c9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}

TeensySynth::Oscillator *TeensySynth::noteOffReal(uint8_t channel, uint8_t note, uint8_t velocity, bool ignoreSustain)
{
    if (!omniOn && channel != SYNTH_MIDICHANNEL)
        return 0;
     c9e:	movs	r0, #0
            }
        }
    }

    return o;
}
     ca0:	add	sp, #12
     ca2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return 0;
        oscOff(*o);
    }
    else
    {
        if (oscs->note == note)
     ca6:	ldr	r2, [pc, #544]	; (ec8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c4>)
     ca8:	ldrsb	r2, [r5, r2]
     caa:	cmp	r2, r6
     cac:	beq.w	db6 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x1b2>
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     cb0:	mov	r0, r8
            }
        }
    }

    return o;
}
     cb2:	add	sp, #12
     cb4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
    {
        if (o->note == note)
        {
            if (lastNote != -1)
     cb8:	cmp.w	r0, #4294967295
     cbc:	beq.w	e16 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x212>
            {
                notesDel(notesOn, note);
     cc0:	ldr	r4, [pc, #512]	; (ec4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c0>)
     cc2:	mov	r2, fp
     cc4:	mov	r0, r5
     cc6:	add	r4, r5
     cc8:	mov	r1, r4
     cca:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
                if (currentPatch.portamentoTime == 0)
     cce:	ldr	r3, [pc, #508]	; (ecc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c8>)
                {
                    portamentoPos = lastNote;
     cd0:	vmov	s15, sl
     cd4:	ldr	r2, [pc, #504]	; (ed0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2cc>)
        if (o->note == note)
        {
            if (lastNote != -1)
            {
                notesDel(notesOn, note);
                if (currentPatch.portamentoTime == 0)
     cd6:	ldrh	r3, [r5, r3]
                {
                    portamentoPos = lastNote;
     cd8:	vcvt.f32.s32	s15, s15
        if (o->note == note)
        {
            if (lastNote != -1)
            {
                notesDel(notesOn, note);
                if (currentPatch.portamentoTime == 0)
     cdc:	cmp	r3, #0
     cde:	beq.w	e0a <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x206>
                    portamentoPos = lastNote;
                    portamentoDir = 0;
                }
                else
                {
                    portamentoDir = lastNote > portamentoPos ? 1 : -1;
     ce2:	add	r2, r5
                    portamentoStep = fabs(lastNote - portamentoPos) / (currentPatch.portamentoTime);
     ce4:	vmov	s14, r3
     ce8:	ldr	r3, [pc, #488]	; (ed4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d0>)
     cea:	vcvt.f64.s32	d6, s14
                    portamentoPos = lastNote;
                    portamentoDir = 0;
                }
                else
                {
                    portamentoDir = lastNote > portamentoPos ? 1 : -1;
     cee:	vldr	s14, [r2]
     cf2:	ldr	r1, [pc, #484]	; (ed8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d4>)
                    portamentoStep = fabs(lastNote - portamentoPos) / (currentPatch.portamentoTime);
     cf4:	add	r3, r5
     cf6:	vsub.f32	s10, s15, s14
                    portamentoPos = lastNote;
                    portamentoDir = 0;
                }
                else
                {
                    portamentoDir = lastNote > portamentoPos ? 1 : -1;
     cfa:	vcmpe.f32	s15, s14
                    portamentoStep = fabs(lastNote - portamentoPos) / (currentPatch.portamentoTime);
     cfe:	vabs.f32	s10, s10
                    portamentoPos = lastNote;
                    portamentoDir = 0;
                }
                else
                {
                    portamentoDir = lastNote > portamentoPos ? 1 : -1;
     d02:	vmrs	APSR_nzcv, fpscr
                    portamentoStep = fabs(lastNote - portamentoPos) / (currentPatch.portamentoTime);
     d06:	vcvt.f64.f32	d5, s10
                    portamentoPos = lastNote;
                    portamentoDir = 0;
                }
                else
                {
                    portamentoDir = lastNote > portamentoPos ? 1 : -1;
     d0a:	ite	gt
     d0c:	movgt	r2, #1
     d0e:	movle.w	r2, #4294967295
                    portamentoStep = fabs(lastNote - portamentoPos) / (currentPatch.portamentoTime);
     d12:	vdiv.f64	d4, d5, d6
                    portamentoPos = lastNote;
                    portamentoDir = 0;
                }
                else
                {
                    portamentoDir = lastNote > portamentoPos ? 1 : -1;
     d16:	strb	r2, [r5, r1]
                    portamentoStep = fabs(lastNote - portamentoPos) / (currentPatch.portamentoTime);
     d18:	vcvt.f32.f64	s8, d4
     d1c:	vstr	s8, [r3]
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     d20:	ldrsb.w	r3, [r8, #8]
     d24:	ldr	r2, [pc, #404]	; (ebc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2b8>)
     d26:	cmp	r3, sl
     d28:	beq.w	e80 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x27c>
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     d2c:	ldr	r1, [pc, #428]	; (edc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d8>)
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     d2e:	mov.w	r0, #1065353216	; 0x3f800000
void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
     d32:	ldr	r2, [r5, r2]
     d34:	mov	r3, r4
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     d36:	add	r1, r5
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     d38:	vstr	s15, [r2, #80]	; 0x50
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     d3c:	ldr	r1, [r1, #0]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     d3e:	str	r0, [r2, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     d40:	str	r1, [r2, #112]	; 0x70
     d42:	b.n	d48 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x144>
}

void TeensySynth::notesAdd(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
     d44:	cmp	r7, r3
     d46:	bls.n	d58 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x154>
     d48:	mov	r2, r3
     d4a:	adds	r3, #1
    {
        if (*notes == -1)
     d4c:	ldrsb.w	r1, [r2]
     d50:	adds	r1, #1
     d52:	bne.n	d44 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x140>
        {
            *notes = note;
     d54:	strb.w	sl, [r2]
                oscOff(*o);
                portamentoPos = -1;
                portamentoDir = 0;
            }
        }
        if (oscs->note == note)
     d58:	cmp	fp, sl
        if (!osc.velocity)
        {
            // osc.flt_env->noteOn();
        }
        // osc.amp->gain(GAIN_OSC * v);
        osc.velocity = velocity;
     d5a:	strb.w	r9, [r8, #9]
        osc.note = note;
     d5e:	strb.w	sl, [r8, #8]
                oscOff(*o);
                portamentoPos = -1;
                portamentoDir = 0;
            }
        }
        if (oscs->note == note)
     d62:	bne.n	cb0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0xac>
        {
            if (lastNote != -1)
            {
                notesDel(notesOn, o->note);
     d64:	mov	r1, r4
     d66:	uxtb.w	r2, sl
     d6a:	mov	r0, r5
     d6c:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     d70:	ldrsb.w	r3, [r8, #8]
     d74:	ldr	r1, [pc, #324]	; (ebc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2b8>)
     d76:	cmp	r3, sl
     d78:	beq.n	cb0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0xac>
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     d7a:	ldr	r2, [pc, #352]	; (edc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d8>)
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     d7c:	mov.w	r0, #1065353216	; 0x3f800000
void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
     d80:	ldr	r3, [r5, r1]
     d82:	mov	r1, r4
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     d84:	add	r2, r5
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     d86:	vstr	s15, [r3, #80]	; 0x50
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     d8a:	ldr	r2, [r2, #0]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     d8c:	str	r0, [r3, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     d8e:	str	r2, [r3, #112]	; 0x70
     d90:	b.n	d96 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x192>
}

void TeensySynth::notesAdd(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
     d92:	cmp	r7, r1
     d94:	bls.n	da6 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x1a2>
     d96:	mov	r3, r1
     d98:	adds	r1, #1
    {
        if (*notes == -1)
     d9a:	ldrsb.w	r2, [r3]
     d9e:	adds	r2, #1
     da0:	bne.n	d92 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x18e>
        {
            *notes = note;
     da2:	strb.w	sl, [r3]
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     da6:	mov	r0, r8
        if (!osc.velocity)
        {
            // osc.flt_env->noteOn();
        }
        // osc.amp->gain(GAIN_OSC * v);
        osc.velocity = velocity;
     da8:	strb.w	r9, [r8, #9]
        osc.note = note;
     dac:	strb.w	sl, [r8, #8]
            }
        }
    }

    return o;
}
     db0:	add	sp, #12
     db2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
    else
    {
        if (oscs->note == note)
        {
            if (lastNote != -1)
     db6:	cmp.w	r0, #4294967295
     dba:	str	r3, [sp, #4]
     dbc:	beq.n	e8a <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x286>
            {
                notesDel(notesOn, o->note);
     dbe:	ldr	r4, [pc, #260]	; (ec4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c0>)
     dc0:	uxtb	r2, r2
     dc2:	mov	r0, r5
     dc4:	add	r4, r5
     dc6:	mov	r1, r4
     dc8:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     dcc:	ldrsb.w	r2, [r8, #8]
     dd0:	cmp	r2, sl
     dd2:	beq.w	cb0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0xac>
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     dd6:	ldr	r2, [pc, #260]	; (edc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d8>)
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     dd8:	vmov	s15, sl
void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
     ddc:	ldr	r3, [sp, #4]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     dde:	mov.w	r0, #1065353216	; 0x3f800000
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     de2:	add	r2, r5
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     de4:	vcvt.f32.s32	s15, s15
void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
     de8:	ldr	r3, [r5, r3]
     dea:	mov	r1, r4
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     dec:	ldr	r2, [r2, #0]
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     dee:	vstr	s15, [r3, #80]	; 0x50
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     df2:	str	r0, [r3, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     df4:	str	r2, [r3, #112]	; 0x70
     df6:	b.n	dfc <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x1f8>
}

void TeensySynth::notesAdd(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
     df8:	cmp	r7, r1
     dfa:	bls.n	da6 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x1a2>
     dfc:	mov	r3, r1
     dfe:	adds	r1, #1
    {
        if (*notes == -1)
     e00:	ldrsb.w	r2, [r3]
     e04:	adds	r2, #1
     e06:	bne.n	df8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x1f4>
     e08:	b.n	da2 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x19e>
            {
                notesDel(notesOn, note);
                if (currentPatch.portamentoTime == 0)
                {
                    portamentoPos = lastNote;
                    portamentoDir = 0;
     e0a:	ldr	r1, [pc, #204]	; (ed8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d4>)
            if (lastNote != -1)
            {
                notesDel(notesOn, note);
                if (currentPatch.portamentoTime == 0)
                {
                    portamentoPos = lastNote;
     e0c:	add	r2, r5
     e0e:	vstr	s15, [r2]
                    portamentoDir = 0;
     e12:	strb	r3, [r5, r1]
     e14:	b.n	d20 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x11c>
    }
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
     e16:	ldr	r7, [pc, #172]	; (ec4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c0>)
     e18:	uxtb.w	r9, fp
     e1c:	mov	r0, r5
     e1e:	str	r3, [sp, #4]
     e20:	add	r7, r5
     e22:	mov	r2, r9
    osc.note = -1;
    osc.velocity = 0;
     e24:	mov.w	r8, #0
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     e28:	movs	r6, #0
    }
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
     e2a:	mov	r1, r7
     e2c:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
                oscOn(*o, lastNote, velocity);
            }
            else
            {
                oscOff(*o);
                portamentoPos = -1;
     e30:	ldr	r2, [pc, #156]	; (ed0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2cc>)
void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
    osc.velocity = 0;
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     e32:	ldr	r3, [sp, #4]
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
     e34:	strb.w	sl, [r4, #8]
                oscOn(*o, lastNote, velocity);
            }
            else
            {
                oscOff(*o);
                portamentoPos = -1;
     e38:	add	r2, r5

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
    osc.velocity = 0;
     e3a:	strb.w	r8, [r4, #9]
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
     e3e:	mov.w	sl, #255	; 0xff
    osc.velocity = 0;
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     e42:	ldr	r1, [r5, r3]
                oscOn(*o, lastNote, velocity);
            }
            else
            {
                oscOff(*o);
                portamentoPos = -1;
     e44:	ldr.w	lr, [pc, #152]	; ee0 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2dc>
                portamentoDir = 0;
            }
        }
        if (oscs->note == note)
     e48:	ldr	r0, [pc, #124]	; (ec8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c4>)
     e4a:	str	r6, [r1, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     e4c:	str	r6, [r1, #112]	; 0x70
                oscOn(*o, lastNote, velocity);
            }
            else
            {
                oscOff(*o);
                portamentoPos = -1;
     e4e:	str.w	lr, [r2]
                portamentoDir = 0;
            }
        }
        if (oscs->note == note)
     e52:	ldrsb	r2, [r5, r0]
            }
            else
            {
                oscOff(*o);
                portamentoPos = -1;
                portamentoDir = 0;
     e54:	ldr	r1, [pc, #128]	; (ed8 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2d4>)
            }
        }
        if (oscs->note == note)
     e56:	cmp	fp, r2
            }
            else
            {
                oscOff(*o);
                portamentoPos = -1;
                portamentoDir = 0;
     e58:	strb.w	r8, [r5, r1]
            }
        }
        if (oscs->note == note)
     e5c:	bne.w	c96 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x92>
    }
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
     e60:	mov	r2, r9
     e62:	mov	r1, r7
     e64:	mov	r0, r5
     e66:	str	r3, [sp, #4]
     e68:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
    osc.note = -1;
    osc.velocity = 0;
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     e6c:	ldr	r3, [sp, #4]
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
     e6e:	strb.w	sl, [r4, #8]
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     e72:	mov	r0, r4

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
    osc.velocity = 0;
     e74:	strb.w	r8, [r4, #9]
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     e78:	ldr	r3, [r5, r3]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     e7a:	str	r6, [r3, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     e7c:	str	r6, [r3, #112]	; 0x70
     e7e:	b.n	c98 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x94>
                oscOff(*o);
                portamentoPos = -1;
                portamentoDir = 0;
            }
        }
        if (oscs->note == note)
     e80:	cmp	r6, sl
     e82:	beq.w	d64 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x160>
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     e86:	mov	r0, r8
     e88:	b.n	cb2 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0xae>
    }
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
     e8a:	ldr	r1, [pc, #56]	; (ec4 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x2c0>)
     e8c:	uxtb	r2, r2
     e8e:	mov	r0, r5
     e90:	add	r1, r5
     e92:	bl	b84 <TeensySynth::notesDel(signed char*, unsigned char)>
    osc.note = -1;
    osc.velocity = 0;
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     e96:	ldr	r3, [sp, #4]
}

void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
     e98:	strb.w	sl, [r8, #8]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     e9c:	movs	r2, #0
    osc.velocity = 0;
     e9e:	strb.w	fp, [r8, #9]
    int8_t lastNote = notesDel(notesPressed, note);

    if (sustainPressed && !ignoreSustain)
        return 0;

    Oscillator *o = oscs;
     ea2:	mov	r0, r8
void TeensySynth::oscOff(Oscillator &osc)
{
    notesDel(notesOn, osc.note);
    osc.note = -1;
    osc.velocity = 0;
    osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 0.0f);
     ea4:	ldr	r3, [r5, r3]
     ea6:	str	r2, [r3, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     ea8:	str	r2, [r3, #112]	; 0x70
     eaa:	b.n	c98 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)+0x94>
     eac:	.word	0x000365b6
     eb0:	.word	0x000365b1
     eb4:	.word	0x00036b0c
     eb8:	.word	0x0003662c
     ebc:	.word	0x000365b8
     ec0:	.word	0x00036631
     ec4:	.word	0x000365ac
     ec8:	.word	0x000365c0
     ecc:	.word	0x0003662e
     ed0:	.word	0x00036b08
     ed4:	.word	0x00036b04
     ed8:	.word	0x00036b00
     edc:	.word	0x00036608
     ee0:	.word	0xbf800000

00000ee4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)>:
    resetAll();
}

//Handles MIDI note on events
void TeensySynth::noteOn(uint8_t channel, uint8_t note, uint8_t velocity)
{
     ee4:	push	{r4, r5, r6, r7, lr}
    if (omniOn || channel != SYNTH_MIDICHANNEL)
     ee6:	ldr	r5, [pc, #476]	; (10c4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1e0>)
    resetAll();
}

//Handles MIDI note on events
void TeensySynth::noteOn(uint8_t channel, uint8_t note, uint8_t velocity)
{
     ee8:	sub	sp, #12
    if (omniOn || channel != SYNTH_MIDICHANNEL)
     eea:	mov	r4, r5
     eec:	ldrb	r7, [r0, r5]
     eee:	add	r4, r0
     ef0:	cmp	r7, #0
     ef2:	bne.n	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
     ef4:	cmp	r1, #7
     ef6:	bne.n	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
        return;

    notesAdd(notesPressed, note);
     ef8:	ldr	r7, [pc, #460]	; (10c8 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1e4>)
     efa:	add	r7, r0
     efc:	mov	r1, r7
     efe:	b.n	f04 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x20>
}

void TeensySynth::notesAdd(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
     f00:	cmp	r4, r1
     f02:	bls.n	f12 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x2e>
     f04:	mov	r5, r1
     f06:	adds	r1, #1
    {
        if (*notes == -1)
     f08:	ldrsb.w	r6, [r5]
     f0c:	adds	r6, #1
     f0e:	bne.n	f00 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1c>
        {
            *notes = note;
     f10:	strb	r2, [r5, #0]

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;

    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
     f12:	ldr	r1, [pc, #440]	; (10cc <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1e8>)
{
    if (omniOn || channel != SYNTH_MIDICHANNEL)
        return;

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;
     f14:	movs	r5, #1
     f16:	ldr	r4, [pc, #440]	; (10d0 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1ec>)

    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
     f18:	ldrb	r1, [r0, r1]
{
    if (omniOn || channel != SYNTH_MIDICHANNEL)
        return;

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;
     f1a:	strb	r5, [r0, r4]

    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
     f1c:	cmp	r1, #0
     f1e:	beq.n	f9c <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb8>
    {
        if (currentPatch.portamentoTime == 0 || portamentoPos < 0)
     f20:	ldr	r1, [pc, #432]	; (10d4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f0>)
     f22:	ldrh	r4, [r0, r1]
     f24:	cmp	r4, #0
     f26:	bne.w	1036 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x152>
     f2a:	addw	r1, r1, #1242	; 0x4da
     f2e:	add	r1, r0
        {
            portamentoPos = note;
     f30:	vmov	s15, r2
            portamentoDir = 0;
     f34:	ldr	r4, [pc, #416]	; (10d8 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f4>)
     f36:	movs	r5, #0
    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
    {
        if (currentPatch.portamentoTime == 0 || portamentoPos < 0)
        {
            portamentoPos = note;
     f38:	vcvt.f32.u32	s15, s15
     f3c:	vstr	s15, [r1]
            portamentoDir = 0;
     f40:	strb	r5, [r0, r4]
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     f42:	ldr.w	lr, [pc, #412]	; 10e0 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1fc>
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
        }
        *notesOn = -1;
     f46:	movs	r5, #255	; 0xff
     f48:	ldr	r4, [pc, #400]	; (10dc <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f8>)
        oscOn(*o, note, velocity);
     f4a:	sxtb	r2, r2
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     f4c:	add	lr, r0
     f4e:	ldr	r6, [pc, #400]	; (10e0 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1fc>)
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
        }
        *notesOn = -1;
     f50:	mov	r1, r4
     f52:	strb	r5, [r0, r4]
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     f54:	ldrsb.w	r4, [lr, #8]
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
        }
        *notesOn = -1;
     f58:	add	r1, r0
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     f5a:	cmp	r4, r2
     f5c:	beq.n	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     f5e:	ldr	r5, [pc, #388]	; (10e4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x200>)
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     f60:	vmov	s15, r2
void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
     f64:	ldr	r4, [r0, r6]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     f66:	mov.w	ip, #1065353216	; 0x3f800000
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     f6a:	add	r5, r0
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     f6c:	vcvt.f32.s32	s15, s15
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     f70:	ldr	r0, [r5, #0]
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     f72:	vstr	s15, [r4, #80]	; 0x50
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     f76:	str.w	ip, [r4, #64]	; 0x40
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     f7a:	str	r0, [r4, #112]	; 0x70
     f7c:	b.n	f82 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x9e>
}

void TeensySynth::notesAdd(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
     f7e:	cmp	r7, r1
     f80:	bls.n	f90 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xac>
     f82:	mov	r0, r1
     f84:	adds	r1, #1
    {
        if (*notes == -1)
     f86:	ldrsb.w	r4, [r0]
     f8a:	adds	r4, #1
     f8c:	bne.n	f7e <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x9a>
        {
            *notes = note;
     f8e:	strb	r2, [r0, #0]
        if (!osc.velocity)
        {
            // osc.flt_env->noteOn();
        }
        // osc.amp->gain(GAIN_OSC * v);
        osc.velocity = velocity;
     f90:	strb.w	r3, [lr, #9]
        osc.note = note;
     f94:	strb.w	r2, [lr, #8]
        *notesOn = -1;
        oscOn(*o, note, velocity);
    }

    return;
}
     f98:	add	sp, #12
     f9a:	pop	{r4, r5, r6, r7, pc}
     f9c:	mov	r6, r3
        return;

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;

    Oscillator *o = oscs;
     f9e:	ldr.w	lr, [pc, #320]	; 10e0 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1fc>
        oscOn(*o, note, velocity);
    }
    else if (currentPatch.polyOn)
    {
        Oscillator *curOsc = 0, *end = oscs + NVOICES;
        if (sustainPressed && notesFind(notesOn, note))
     fa2:	ldr	r3, [pc, #324]	; (10e8 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x204>)
     fa4:	mov	r4, r0
     fa6:	mov	r5, r2
        return;

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;

    Oscillator *o = oscs;
     fa8:	add	lr, r0
        *notesOn = -1;
        oscOn(*o, note, velocity);
    }
    else if (currentPatch.polyOn)
    {
        Oscillator *curOsc = 0, *end = oscs + NVOICES;
     faa:	ldr	r2, [pc, #320]	; (10ec <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x208>)
        if (sustainPressed && notesFind(notesOn, note))
     fac:	ldrb	r3, [r0, r3]
        return;

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;

    Oscillator *o = oscs;
     fae:	mov	r0, lr
        *notesOn = -1;
        oscOn(*o, note, velocity);
    }
    else if (currentPatch.polyOn)
    {
        Oscillator *curOsc = 0, *end = oscs + NVOICES;
     fb0:	add	r2, r4
        if (sustainPressed && notesFind(notesOn, note))
     fb2:	cbz	r3, 101a <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x136>
     fb4:	ldr	r3, [pc, #292]	; (10dc <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f8>)
     fb6:	add	r3, r4
     fb8:	b.n	fbe <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xda>
}

bool TeensySynth::notesFind(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
     fba:	cmp	r7, r3
     fbc:	bls.n	101a <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x136>
    {
        if (*notes == note)
     fbe:	ldrsb.w	r1, [r3], #1
     fc2:	cmp	r5, r1
     fc4:	bne.n	fba <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xd6>
        return;

    notesAdd(notesPressed, note);
    currentPatch.polyOn = true;

    Oscillator *o = oscs;
     fc6:	mov	r3, lr
     fc8:	b.n	fd0 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xec>
    else if (currentPatch.polyOn)
    {
        Oscillator *curOsc = 0, *end = oscs + NVOICES;
        if (sustainPressed && notesFind(notesOn, note))
        {
            do
     fca:	adds	r3, #12
     fcc:	cmp	r2, r3
     fce:	bls.n	101a <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x136>
            {
                if (o->note == note)
     fd0:	ldrsb.w	r1, [r3, #8]
     fd4:	cmp	r1, r5
     fd6:	bne.n	fca <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xe6>
     fd8:	mov	r0, r3
#endif
            curOsc = noteOffReal(channel, *notesOn, velocity, true);
        }
        if (!curOsc)
            return;
        oscOn(*curOsc, note, velocity);
     fda:	sxtb	r5, r5
}

void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
     fdc:	cmp	r1, r5
     fde:	beq.n	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     fe0:	ldr	r1, [pc, #256]	; (10e4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x200>)
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     fe2:	vmov	s15, r5
        notesAdd(notesOn, note);
     fe6:	ldr	r2, [pc, #244]	; (10dc <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f8>)
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
     fe8:	add	r1, r4
     fea:	vcvt.f32.s32	s15, s15
void TeensySynth::oscOn(Oscillator &osc, int8_t note, uint8_t velocity)
{
    float v = currentPatch.velocityOn ? velocity / 127. : 1;
    if (osc.note != note)
    {
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::note, note);
     fee:	ldr	r3, [r0, #0]
        osc.wf->setModulationsParameter(AudioSynthPlaits_F32::Parameters::trigger, 1.0f);
        osc.wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
        notesAdd(notesOn, note);
     ff0:	add	r2, r4
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     ff2:	ldr	r1, [r1, #0]
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     ff4:	mov.w	r4, #1065353216	; 0x3f800000
        {
        case engine:
            patch.engine = value;
            break;
        case note:
            patch.note = value;
     ff8:	vstr	s15, [r3, #80]	; 0x50
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
            break;
        case decay:
            patch.decay = value;
     ffc:	str	r1, [r3, #112]	; 0x70
            break;
        case level:
            modulations.level = value;
            break;
        case trigger:
            modulations.trigger = value;
     ffe:	str	r4, [r3, #64]	; 0x40
    1000:	b.n	1006 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x122>
}

void TeensySynth::notesAdd(int8_t *notes, uint8_t note)
{
    int8_t *end = notes + NVOICES;
    do
    1002:	cmp	r7, r2
    1004:	bls.n	1014 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x130>
    1006:	mov	r3, r2
    1008:	adds	r2, #1
    {
        if (*notes == -1)
    100a:	ldrsb.w	r1, [r3]
    100e:	adds	r1, #1
    1010:	bne.n	1002 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x11e>
        {
            *notes = note;
    1012:	strb	r5, [r3, #0]
        if (!osc.velocity)
        {
            // osc.flt_env->noteOn();
        }
        // osc.amp->gain(GAIN_OSC * v);
        osc.velocity = velocity;
    1014:	strb	r6, [r0, #9]
        osc.note = note;
    1016:	strb	r5, [r0, #8]
    1018:	b.n	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
                    curOsc = o;
                    break;
                }
            } while (++o < end);
        }
        for (o = oscs; o < end && !curOsc; ++o)
    101a:	cmp	lr, r2
    101c:	bcs.n	109c <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1b8>
        {
            if (o->note < 0)
    101e:	ldrsb.w	r1, [lr, #8]
    1022:	cmp	r1, #0
    1024:	blt.n	fda <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xf6>
                    curOsc = o;
                    break;
                }
            } while (++o < end);
        }
        for (o = oscs; o < end && !curOsc; ++o)
    1026:	adds	r0, #12
    1028:	cmp	r2, r0
    102a:	bls.n	109c <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1b8>
        {
            if (o->note < 0)
    102c:	ldrsb.w	r1, [r0, #8]
    1030:	cmp	r1, #0
    1032:	bge.n	1026 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x142>
    1034:	b.n	fda <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xf6>
    currentPatch.polyOn = true;

    Oscillator *o = oscs;
    if (currentPatch.portamentoOn)
    {
        if (currentPatch.portamentoTime == 0 || portamentoPos < 0)
    1036:	ldr	r1, [pc, #184]	; (10f0 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x20c>)
    1038:	add	r1, r0
    103a:	vldr	s13, [r1]
    103e:	vcmpe.f32	s13, #0.0
    1042:	vmrs	APSR_nzcv, fpscr
    1046:	bmi.w	f30 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x4c>
        {
            portamentoPos = note;
            portamentoDir = 0;
        }
        else if (portamentoPos > -1)
    104a:	vmov.f32	s15, #240	; 0xbf800000 -1.0
    104e:	vcmpe.f32	s13, s15
    1052:	vmrs	APSR_nzcv, fpscr
    1056:	ble.w	f42 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x5e>
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
    105a:	vmov	s12, r2
    105e:	vmov	s15, r4
    1062:	ldr	r1, [pc, #144]	; (10f4 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x210>)
    1064:	vcvt.f32.s32	s11, s12
            portamentoPos = note;
            portamentoDir = 0;
        }
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
    1068:	ldr	r4, [pc, #108]	; (10d8 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f4>)
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
    106a:	vcvt.f64.s32	d7, s15
    106e:	add	r1, r0
    1070:	vsub.f32	s12, s11, s13
            portamentoPos = note;
            portamentoDir = 0;
        }
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
    1074:	vcmpe.f32	s13, s11
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
    1078:	vabs.f32	s12, s12
            portamentoPos = note;
            portamentoDir = 0;
        }
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
    107c:	vmrs	APSR_nzcv, fpscr
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
    1080:	vcvt.f64.f32	d6, s12
            portamentoPos = note;
            portamentoDir = 0;
        }
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
    1084:	ite	mi
    1086:	movmi	r5, #1
    1088:	movpl.w	r5, #4294967295
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
    108c:	vdiv.f64	d5, d6, d7
            portamentoPos = note;
            portamentoDir = 0;
        }
        else if (portamentoPos > -1)
        {
            portamentoDir = note > portamentoPos ? 1 : -1;
    1090:	strb	r5, [r0, r4]
            portamentoStep = fabs(note - portamentoPos) / (currentPatch.portamentoTime);
    1092:	vcvt.f32.f64	s10, d5
    1096:	vstr	s10, [r1]
    109a:	b.n	f42 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x5e>
            {
                curOsc = o;
                break;
            }
        }
        if (!curOsc && *notesOn != -1)
    109c:	ldr	r3, [pc, #60]	; (10dc <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0x1f8>)
    109e:	ldrsb	r2, [r4, r3]
    10a0:	adds	r3, r2, #1
    10a2:	beq.w	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
        {
#if SYNTH_DEBUG > 0
            Serial.println("Stealing voice");
#endif
            curOsc = noteOffReal(channel, *notesOn, velocity, true);
    10a6:	movs	r0, #1
    10a8:	uxtb	r2, r2
    10aa:	mov	r3, r6
    10ac:	movs	r1, #7
    10ae:	str	r0, [sp, #0]
    10b0:	mov	r0, r4
    10b2:	bl	c04 <TeensySynth::noteOffReal(unsigned char, unsigned char, unsigned char, bool)>
        }
        if (!curOsc)
    10b6:	cmp	r0, #0
    10b8:	beq.w	f98 <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xb4>
    10bc:	ldrsb.w	r1, [r0, #8]
    10c0:	b.n	fda <TeensySynth::noteOn(unsigned char, unsigned char, unsigned char)+0xf6>
    10c2:	nop
    10c4:	.word	0x000365b6
    10c8:	.word	0x000365b1
    10cc:	.word	0x0003662c
    10d0:	.word	0x00036631
    10d4:	.word	0x0003662e
    10d8:	.word	0x00036b00
    10dc:	.word	0x000365ac
    10e0:	.word	0x000365b8
    10e4:	.word	0x00036608
    10e8:	.word	0x00036b0c
    10ec:	.word	0x000365f4
    10f0:	.word	0x00036b08
    10f4:	.word	0x00036b04

000010f8 <TeensySynth::OnControlChange(unsigned char, unsigned char, unsigned char)>:
    } while (++o < end);
    notesReset(notesOn);
}

void TeensySynth::OnControlChange(uint8_t channel, uint8_t control, uint8_t value)
{
    10f8:	bx	lr
    10fa:	nop
    10fc:	movs	r0, r0
	...

00001100 <TeensySynth::updateFilter()>:
        break;
    };
}

void TeensySynth::updateFilter()
{
    1100:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1104:	ldr	r4, [pc, #272]	; (1218 <TeensySynth::updateFilter()+0x118>)
    1106:	ldr.w	r8, [pc, #308]	; 123c <TeensySynth::updateFilter()+0x13c>
    110a:	ldr	r7, [pc, #272]	; (121c <TeensySynth::updateFilter()+0x11c>)
    110c:	add	r4, r0
    110e:	ldr	r6, [pc, #272]	; (1220 <TeensySynth::updateFilter()+0x120>)
    1110:	add	r8, r0
    1112:	ldr	r5, [pc, #272]	; (1224 <TeensySynth::updateFilter()+0x124>)
    1114:	add	r7, r0
    1116:	add	r6, r0
    1118:	add	r5, r0
    111a:	vpush	{d8-d11}
    111e:	vldr	d11, [pc, #224]	; 1200 <TeensySynth::updateFilter()+0x100>
    1122:	vldr	d10, [pc, #228]	; 1208 <TeensySynth::updateFilter()+0x108>
	}
	void resonance(float qi)
	{
		if (qi < 0.7)
    1126:	vldr	d9, [pc, #232]	; 1210 <TeensySynth::updateFilter()+0x110>
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
    112a:	vldr	s17, [pc, #252]	; 1228 <TeensySynth::updateFilter()+0x128>
			n = 6.9999;
		oct = n;
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
    112e:	vmov.f32	s15, #52	; 0x41a00000  20.0
    for (int i = 0; i < 2; i++)
    {
        fxFlt[i].frequency(currentPatch.filterCutoff);
    1132:	vldr	s16, [r7]
    1136:	vcmpe.f32	s16, s15
    113a:	vmrs	APSR_nzcv, fpscr
    113e:	bmi.n	11da <TeensySynth::updateFilter()+0xda>
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
    1140:	vcmpe.f32	s16, s17
    1144:	vmrs	APSR_nzcv, fpscr
    1148:	bgt.n	11f0 <TeensySynth::updateFilter()+0xf0>
    114a:	vcvt.f64.f32	d7, s16
    114e:	vmul.f64	d7, d7, d11
    1152:	vdiv.f64	d0, d7, d10
    1156:	vcvt.f32.f64	s0, d0
    115a:	bl	17f60 <tanf>
    115e:	vmov.f32	s15, #128	; 0xc0000000 -2.0
    1162:	vmul.f32	s0, s0, s15
			freq = AUDIO_SAMPLE_RATE_EXACT / 2.5;
		g = 1 - expf(-2 * tanf(2 * M_PI * freq / (2 * AUDIO_SAMPLE_RATE_EXACT)));
    1166:	bl	18068 <expf>
    116a:	vmov.f32	s15, #112	; 0x3f800000  1.0
		if (setf)
			basef = freq;
    116e:	vstr	s16, [r4, #8]
	{
		if (freq < 20.0)
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
			freq = AUDIO_SAMPLE_RATE_EXACT / 2.5;
		g = 1 - expf(-2 * tanf(2 * M_PI * freq / (2 * AUDIO_SAMPLE_RATE_EXACT)));
    1172:	vsub.f32	s0, s15, s0
    1176:	vstr	s0, [r4, #-8]
        fxFlt[i].resonance(currentPatch.filterResonance);
    117a:	vldr	s15, [r6]
		state_lowpass = 0;
		state_bandpass = 0;
	}
	void resonance(float qi)
	{
		if (qi < 0.7)
    117e:	vcvt.f64.f32	d6, s15
    1182:	vcmpe.f64	d6, d9
    1186:	vmrs	APSR_nzcv, fpscr
    118a:	bmi.n	11ea <TeensySynth::updateFilter()+0xea>
			qi = 0.7;
		else if (qi > 5.0)
    118c:	vmov.f32	s14, #20	; 0x40a00000  5.0
			qi = 5.0;
    1190:	vcmp.f32	s15, s14
    1194:	vmrs	APSR_nzcv, fpscr
    1198:	it	gt
    119a:	vmovgt.f32	s15, s14
		q = qi;
	}
	void drive(float d)
	{
		if (d > 10.0f)
    119e:	vmov.f32	s14, #36	; 0x41200000  10.0
	{
		if (qi < 0.7)
			qi = 0.7;
		else if (qi > 5.0)
			qi = 5.0;
		q = qi;
    11a2:	vstr	s15, [r4, #-4]
        fxFlt[i].drive(currentPatch.filterDrive);
    11a6:	vldr	s15, [r5]
	}
	void drive(float d)
	{
		if (d > 10.0f)
    11aa:	vcmpe.f32	s15, s14
    11ae:	vmrs	APSR_nzcv, fpscr
    11b2:	bgt.n	11e4 <TeensySynth::updateFilter()+0xe4>
			d = 10.0f;
		if (d < 0.1f)
    11b4:	vldr	s14, [pc, #116]	; 122c <TeensySynth::updateFilter()+0x12c>
			d = 0.1f;
    11b8:	vcmp.f32	s15, s14
    11bc:	vmrs	APSR_nzcv, fpscr
    11c0:	it	mi
    11c2:	vmovmi.f32	s15, s14
		driv = d;
    11c6:	vmov	r3, s15
    11ca:	str.w	r3, [r4], #96
    };
}

void TeensySynth::updateFilter()
{
    for (int i = 0; i < 2; i++)
    11ce:	cmp	r4, r8
    11d0:	bne.n	112e <TeensySynth::updateFilter()+0x2e>
    {
        fxFlt[i].frequency(currentPatch.filterCutoff);
        fxFlt[i].resonance(currentPatch.filterResonance);
        fxFlt[i].drive(currentPatch.filterDrive);
    }
}
    11d2:	vpop	{d8-d11}
    11d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		oct = n;
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
			freq = 20.0;
    11da:	vmov.f32	s16, s15
			n = 6.9999;
		oct = n;
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
    11de:	vldr	s0, [pc, #80]	; 1230 <TeensySynth::updateFilter()+0x130>
    11e2:	b.n	1166 <TeensySynth::updateFilter()+0x66>
		q = qi;
	}
	void drive(float d)
	{
		if (d > 10.0f)
			d = 10.0f;
    11e4:	vmov.f32	s15, s14
    11e8:	b.n	11c6 <TeensySynth::updateFilter()+0xc6>
		state_bandpass = 0;
	}
	void resonance(float qi)
	{
		if (qi < 0.7)
			qi = 0.7;
    11ea:	vldr	s15, [pc, #72]	; 1234 <TeensySynth::updateFilter()+0x134>
    11ee:	b.n	119e <TeensySynth::updateFilter()+0x9e>
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
    11f0:	vldr	s0, [pc, #68]	; 1238 <TeensySynth::updateFilter()+0x138>
			freq = AUDIO_SAMPLE_RATE_EXACT / 2.5;
    11f4:	vldr	s16, [pc, #48]	; 1228 <TeensySynth::updateFilter()+0x128>
    11f8:	b.n	1166 <TeensySynth::updateFilter()+0x66>
    11fa:	nop
    11fc:	nop.w
    1200:	.word	0x54442d18
    1204:	.word	0x401921fb
    1208:	.word	0x00000000
    120c:	.word	0x40f77000
    1210:	.word	0x66666666
    1214:	.word	0x3fe66666
    1218:	.word	0x00036424
    121c:	.word	0x00036620
    1220:	.word	0x00036624
    1224:	.word	0x00036628
    1228:	.word	0x46960000
    122c:	.word	0x3dcccccd
    1230:	.word	0xbb2b92ac
    1234:	.word	0x3f333333
    1238:	.word	0xc0c4f8c6
    123c:	.word	0x000364e4

00001240 <TeensySynth::updateOscillator()>:

void TeensySynth::updateOscillator()
{
    Oscillator *o = oscs, *end = oscs + NVOICES;
    1240:	ldr	r3, [pc, #116]	; (12b8 <TeensySynth::updateOscillator()+0x78>)
    1242:	ldr.w	ip, [pc, #140]	; 12d0 <TeensySynth::updateOscillator()+0x90>
    1246:	ldr	r3, [r0, r3]
    1248:	add	ip, r0
    124a:	ldr	r2, [pc, #112]	; (12bc <TeensySynth::updateOscillator()+0x7c>)
    124c:	vmov	s15, r3
    1250:	ldr	r3, [pc, #108]	; (12c0 <TeensySynth::updateOscillator()+0x80>)
    1252:	add	r2, r0
    1254:	ldr.w	ip, [ip]
    1258:	vcvt.f32.s32	s15, s15
    125c:	add	r3, r0
        fxFlt[i].drive(currentPatch.filterDrive);
    }
}

void TeensySynth::updateOscillator()
{
    125e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1262:	ldr.w	r8, [pc, #112]	; 12d4 <TeensySynth::updateOscillator()+0x94>
    1266:	vcvt.s32.f32	s15, s15
    126a:	ldr.w	lr, [pc, #108]	; 12d8 <TeensySynth::updateOscillator()+0x98>
    126e:	ldr	r7, [pc, #84]	; (12c4 <TeensySynth::updateOscillator()+0x84>)
    1270:	add	r8, r0
    1272:	ldr	r6, [pc, #84]	; (12c8 <TeensySynth::updateOscillator()+0x88>)
    1274:	add	lr, r0
    1276:	ldr	r5, [pc, #84]	; (12cc <TeensySynth::updateOscillator()+0x8c>)
    1278:	add	r7, r0
    127a:	add	r6, r0
    Oscillator *o = oscs, *end = oscs + NVOICES;
    127c:	ldr	r4, [pc, #56]	; (12b8 <TeensySynth::updateOscillator()+0x78>)
    127e:	add	r5, r0
    1280:	vmov	r1, s15
    1284:	add	r4, r0
    1286:	ldr.w	r8, [r8]
    128a:	ldr.w	lr, [lr]
    128e:	ldr	r7, [r7, #0]
    1290:	ldr	r6, [r6, #0]
    1292:	ldr	r5, [r5, #0]
    1294:	ldr	r0, [r3, #0]
    do
    {
        o->wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::harmonics, currentPatch.harmonics);
    1296:	ldr.w	r3, [r2], #12
}

void TeensySynth::updateOscillator()
{
    Oscillator *o = oscs, *end = oscs + NVOICES;
    do
    129a:	cmp	r4, r2
            break;
        case note:
            patch.note = value;
            break;
        case harmonics:
            patch.harmonics = value;
    129c:	str.w	r8, [r3, #84]	; 0x54
            break;
        case timbre:
            patch.timbre = value;
    12a0:	str.w	ip, [r3, #88]	; 0x58
            break;
        case morph:
            patch.morph = value;
    12a4:	str.w	lr, [r3, #92]	; 0x5c
    void setPatchParameter(Parameters parameter, float value)
    {
        switch (parameter)
        {
        case engine:
            patch.engine = value;
    12a8:	str	r1, [r3, #108]	; 0x6c
            break;
        case decay:
            patch.decay = value;
            break;
        case lpgColour:
            patch.lpg_colour = value;
    12aa:	str	r7, [r3, #116]	; 0x74
            break;
        case timbreModulationAmount:
            patch.timbre_modulation_amount = value;
            break;
        case morphModulationAmount:
            patch.morph_modulation_amount = value;
    12ac:	str	r6, [r3, #104]	; 0x68
            break;
        case frequencyModulationAmount:
            patch.frequency_modulation_amount = value;
            break;
        case timbreModulationAmount:
            patch.timbre_modulation_amount = value;
    12ae:	str	r5, [r3, #100]	; 0x64
            break;
        case morph:
            patch.morph = value;
            break;
        case frequencyModulationAmount:
            patch.frequency_modulation_amount = value;
    12b0:	str	r0, [r3, #96]	; 0x60
    12b2:	bhi.n	1296 <TeensySynth::updateOscillator()+0x56>
        o->wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::lpgColour, currentPatch.lpgColour);
        o->wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::morphModulationAmount, currentPatch.morphMod);
        o->wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::timbreModulationAmount, currentPatch.timbreMod);
        o->wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::frequencyModulationAmount, currentPatch.freqMod);
    } while (++o < end);
}
    12b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    12b8:	.word	0x000365f4
    12bc:	.word	0x000365b8
    12c0:	.word	0x00036614
    12c4:	.word	0x00036610
    12c8:	.word	0x0003661c
    12cc:	.word	0x00036618
    12d0:	.word	0x000365fc
    12d4:	.word	0x000365f8
    12d8:	.word	0x00036600

000012dc <TeensySynth::init()>:
#include "teensy_synth.h"
#include "settings.h"

//Inititializes audio signal path and default values for its components
void TeensySynth::init()
{
    12dc:	ldr	r3, [pc, #776]	; (15e8 <TeensySynth::init()+0x30c>)
    12de:	ldr	r2, [pc, #780]	; (15ec <TeensySynth::init()+0x310>)
    12e0:	adds	r3, r0, r3
    12e2:	add	r2, r0
    12e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    12e8:	sub	sp, #20
    for (int i = 0; i < NVOICES; i++)
    12ea:	mov.w	r9, #0
    12ee:	ldr.w	r8, [pc, #868]	; 1654 <TeensySynth::init()+0x378>
    12f2:	mov	r7, r0
    12f4:	ldr.w	sl, [pc, #864]	; 1658 <TeensySynth::init()+0x37c>
    {
        //Store pointers for oscillator components
        oscs[i] = Oscillator({&waveform[i], &amp[i], -1, 0});
    12f8:	mov	r5, r9
    12fa:	str	r3, [sp, #4]
    12fc:	mov	fp, r9
    12fe:	ldr	r3, [pc, #752]	; (15f0 <TeensySynth::init()+0x314>)
    1300:	add	r8, r0
    1302:	add	sl, r0
    1304:	mov	r9, r0
    1306:	adds	r3, r0, r3
    1308:	str	r0, [sp, #12]
    130a:	str	r3, [sp, #0]
    130c:	ldr	r1, [pc, #740]	; (15f4 <TeensySynth::init()+0x318>)

        //Create audio signal path for voice components
        patchOscAmp[i] = new AudioConnection_F32(waveform[i], 0, amp[i], 0);           //Main output connection
    130e:	movs	r0, #16
void TeensySynth::init()
{
    for (int i = 0; i < NVOICES; i++)
    {
        //Store pointers for oscillator components
        oscs[i] = Oscillator({&waveform[i], &amp[i], -1, 0});
    1310:	ldr	r3, [pc, #740]	; (15f8 <TeensySynth::init()+0x31c>)
    1312:	add	r1, r9
    1314:	ldr	r6, [pc, #740]	; (15fc <TeensySynth::init()+0x320>)
    1316:	add	r3, r9
    1318:	ldr	r4, [pc, #740]	; (1600 <TeensySynth::init()+0x324>)
    131a:	str	r7, [r1, #0]
    131c:	add	r6, r9
    131e:	str.w	r8, [r3]
    1322:	add	r4, r9
    1324:	mov.w	r3, #4294967295
    1328:	str	r2, [sp, #8]
    132a:	add.w	r9, r9, #12
    132e:	strb	r3, [r6, #0]
    1330:	strb	r5, [r4, #0]
    1332:	movs	r4, #0

        //Create audio signal path for voice components
        patchOscAmp[i] = new AudioConnection_F32(waveform[i], 0, amp[i], 0);           //Main output connection
    1334:	bl	17c08 <operator new(unsigned int)>
    1338:	mov	r6, r0
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    133a:	strb	r5, [r0, #8]
    133c:	strb	r5, [r0, #9]
    133e:	str	r5, [r0, #12]
    1340:	stmia.w	r0, {r7, r8}
      { connect(); }
    1344:	bl	15308 <AudioConnection_F32::connect()>
    1348:	str.w	r6, [sl, #4]!
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
    134c:	movs	r0, #16
    134e:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    1352:	mov.w	r3, #1
    1356:	str	r7, [r0, #0]
    1358:	mov	r6, r0
    135a:	str.w	r8, [r0, #4]
    135e:	add.w	r7, r7, #21760	; 0x5500
    1362:	strb	r3, [r0, #8]
    1364:	strb	r3, [r0, #9]
    1366:	adds	r7, #12
    1368:	str	r5, [r0, #12]
      { connect(); }
    136a:	bl	15308 <AudioConnection_F32::connect()>
    136e:	ldr	r3, [sp, #0]
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    1370:	movs	r0, #16
        //Store pointers for oscillator components
        oscs[i] = Oscillator({&waveform[i], &amp[i], -1, 0});

        //Create audio signal path for voice components
        patchOscAmp[i] = new AudioConnection_F32(waveform[i], 0, amp[i], 0);           //Main output connection
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
    1372:	str.w	r6, [r3, #4]!
    1376:	str	r3, [sp, #0]
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    1378:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    137c:	ldr	r3, [sp, #4]
    137e:	mov	r6, r0
    1380:	strb.w	fp, [r0, #9]
#include "settings.h"

//Inititializes audio signal path and default values for its components
void TeensySynth::init()
{
    for (int i = 0; i < NVOICES; i++)
    1384:	add.w	fp, fp, #1
    1388:	str.w	r8, [r0]
    138c:	add.w	r8, r8, #72	; 0x48
    1390:	str	r3, [r0, #4]
    1392:	strb	r5, [r0, #8]
    1394:	str	r5, [r0, #12]
      { connect(); }
    1396:	bl	15308 <AudioConnection_F32::connect()>
        oscs[i] = Oscillator({&waveform[i], &amp[i], -1, 0});

        //Create audio signal path for voice components
        patchOscAmp[i] = new AudioConnection_F32(waveform[i], 0, amp[i], 0);           //Main output connection
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    139a:	ldr	r2, [sp, #8]
#include "settings.h"

//Inititializes audio signal path and default values for its components
void TeensySynth::init()
{
    for (int i = 0; i < NVOICES; i++)
    139c:	cmp.w	fp, #5
        oscs[i] = Oscillator({&waveform[i], &amp[i], -1, 0});

        //Create audio signal path for voice components
        patchOscAmp[i] = new AudioConnection_F32(waveform[i], 0, amp[i], 0);           //Main output connection
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    13a0:	str.w	r6, [r2, #4]!
#include "settings.h"

//Inititializes audio signal path and default values for its components
void TeensySynth::init()
{
    for (int i = 0; i < NVOICES; i++)
    13a4:	bne.n	130c <TeensySynth::init()+0x30>
    13a6:	ldr	r6, [sp, #12]
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    13a8:	movs	r0, #16
    13aa:	ldr.w	fp, [pc, #688]	; 165c <TeensySynth::init()+0x380>
    13ae:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    13b2:	ldr	r3, [sp, #4]
    13b4:	mov	r7, r0
    13b6:	add	fp, r6
    13b8:	strb	r4, [r0, #8]
    13ba:	strb	r4, [r0, #9]
    13bc:	str	r4, [r0, #12]
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    13be:	ldr.w	sl, [pc, #672]	; 1660 <TeensySynth::init()+0x384>
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    13c2:	ldr	r5, [pc, #576]	; (1604 <TeensySynth::init()+0x328>)
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    13c4:	add	sl, r6
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    13c6:	ldr.w	r9, [pc, #668]	; 1664 <TeensySynth::init()+0x388>
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    13ca:	add	r5, r6
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    13cc:	add	r9, r6
    13ce:	stmia.w	r0, {r3, fp}
      { connect(); }
    13d2:	bl	15308 <AudioConnection_F32::connect()>
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    13d6:	ldr	r3, [pc, #560]	; (1608 <TeensySynth::init()+0x32c>)
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    13d8:	movs	r0, #16
        patchOscAmp[i + NVOICES] = new AudioConnection_F32(waveform[i], 1, amp[i], 1); //Aux output connection
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    13da:	str	r7, [r6, r3]
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    13dc:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    13e0:	ldr	r3, [sp, #4]
    13e2:	strb	r4, [r0, #8]
    13e4:	mov	r8, r0
    13e6:	str	r3, [r0, #0]
    13e8:	strb	r4, [r0, #9]
    13ea:	str	r4, [r0, #12]
    13ec:	str.w	sl, [r0, #4]
      { connect(); }
    13f0:	bl	15308 <AudioConnection_F32::connect()>
    13f4:	ldr	r3, [pc, #532]	; (160c <TeensySynth::init()+0x330>)
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    13f6:	movs	r0, #16
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    13f8:	ldr	r7, [pc, #532]	; (1610 <TeensySynth::init()+0x334>)
        patchAmpMix[i] = new AudioConnection_F32(amp[i], 0, mixOsc, i);
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    13fa:	str.w	r8, [r6, r3]
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    13fe:	bl	17c08 <operator new(unsigned int)>
class AudioConnection_F32
{
  public:
    AudioConnection_F32(AudioStream_F32 &source, AudioStream_F32 &destination) :
      src(source), dst(destination), src_index(0), dest_index(0),
      next_dest(NULL)
    1402:	strb	r4, [r0, #8]
    1404:	strb	r4, [r0, #9]
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    1406:	add	r7, r6
    1408:	str	r4, [r0, #12]
    140a:	str	r5, [r0, #4]
    140c:	str.w	sl, [r0]
    1410:	str	r0, [sp, #0]
      { connect(); }
    1412:	bl	15308 <AudioConnection_F32::connect()>
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    1416:	ldr	r2, [pc, #508]	; (1614 <TeensySynth::init()+0x338>)
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    1418:	movs	r0, #16
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    141a:	ldr	r3, [sp, #0]
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    141c:	ldr.w	r8, [pc, #584]	; 1668 <TeensySynth::init()+0x38c>
    }

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    1420:	str	r3, [r6, r2]
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    1422:	bl	17c08 <operator new(unsigned int)>
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    1426:	mov.w	r1, #1
    142a:	strb	r4, [r0, #8]
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    142c:	add	r8, r6
    142e:	strb	r1, [r0, #9]
    1430:	str	r4, [r0, #12]
    1432:	str	r0, [sp, #0]
    1434:	stmia.w	r0, {r5, fp}
      { connect(); }
    1438:	bl	15308 <AudioConnection_F32::connect()>

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    143c:	ldr	r2, [pc, #472]	; (1618 <TeensySynth::init()+0x33c>)
    143e:	ldr	r3, [sp, #0]
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    1440:	movs	r0, #16

    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    1442:	str	r3, [r6, r2]
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    1444:	bl	17c08 <operator new(unsigned int)>
class AudioConnection_F32
{
  public:
    AudioConnection_F32(AudioStream_F32 &source, AudioStream_F32 &destination) :
      src(source), dst(destination), src_index(0), dest_index(0),
      next_dest(NULL)
    1448:	strb	r4, [r0, #8]
    144a:	strb	r4, [r0, #9]
    144c:	str	r4, [r0, #12]
    144e:	str	r7, [r0, #4]
    1450:	str.w	fp, [r0]
    1454:	str	r0, [sp, #0]
      { connect(); }
    1456:	bl	15308 <AudioConnection_F32::connect()>
    145a:	ldr	r3, [sp, #0]
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    145c:	movs	r0, #16
    //Create audio signal path for master & fx
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    145e:	ldr	r2, [pc, #444]	; (161c <TeensySynth::init()+0x340>)
    1460:	str	r3, [r6, r2]
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    1462:	bl	17c08 <operator new(unsigned int)>
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    1466:	ldr	r2, [sp, #4]
    1468:	strb	r4, [r0, #8]
    146a:	str	r2, [r0, #0]
    146c:	strb	r4, [r0, #9]
    146e:	str	r4, [r0, #12]
    1470:	str.w	r9, [r0, #4]
    1474:	str	r0, [sp, #0]
      { connect(); }
    1476:	bl	15308 <AudioConnection_F32::connect()>
    147a:	ldr	r3, [sp, #0]
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    147c:	movs	r0, #16
    patchMixOscMixChorus = new AudioConnection_F32(mixOsc, 0, mixChorus, 0);
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    147e:	ldr	r2, [pc, #416]	; (1620 <TeensySynth::init()+0x344>)
    1480:	str	r3, [r6, r2]
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    1482:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    1486:	ldr	r2, [sp, #4]
    1488:	strb	r4, [r0, #8]
    148a:	str	r2, [r0, #0]
    148c:	strb	r4, [r0, #9]
    148e:	str	r4, [r0, #12]
    1490:	str.w	r8, [r0, #4]
    1494:	str	r0, [sp, #0]
      { connect(); }
    1496:	bl	15308 <AudioConnection_F32::connect()>
    149a:	ldr	r2, [pc, #392]	; (1624 <TeensySynth::init()+0x348>)
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    149c:	movs	r0, #16
    patchMixOscFxReverbHighpass = new AudioConnection_F32(mixOsc, 0, fxReverbHighpass, 0);
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    149e:	ldr	r3, [sp, #0]
    14a0:	str	r3, [r6, r2]
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    14a2:	bl	17c08 <operator new(unsigned int)>
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    14a6:	ldr	r3, [pc, #384]	; (1628 <TeensySynth::init()+0x34c>)
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    14a8:	strb	r4, [r0, #8]
    14aa:	add	r3, r6
    14ac:	str	r4, [r0, #12]
    14ae:	str	r0, [sp, #0]
    14b0:	str	r3, [sp, #4]
    14b2:	mov.w	r3, #1
    14b6:	stmia.w	r0, {r7, r9}
    14ba:	strb	r3, [r0, #9]
      { connect(); }
    14bc:	bl	15308 <AudioConnection_F32::connect()>
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    14c0:	ldr	r1, [pc, #360]	; (162c <TeensySynth::init()+0x350>)
    14c2:	ldr	r2, [sp, #0]
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    14c4:	movs	r0, #16
    patchFxReverbHighpassFxReverb = new AudioConnection_F32(fxReverbHighpass, fxReverb);
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    14c6:	str	r2, [r6, r1]
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    14c8:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    14cc:	mov.w	r3, #1
    14d0:	str	r4, [r0, #12]
    14d2:	strb	r3, [r0, #8]
    14d4:	strb	r3, [r0, #9]
    14d6:	str	r0, [sp, #0]
    14d8:	stmia.w	r0, {r7, r8}
      { connect(); }
    14dc:	bl	15308 <AudioConnection_F32::connect()>
    14e0:	ldr	r2, [sp, #0]
    14e2:	ldr	r1, [pc, #332]	; (1630 <TeensySynth::init()+0x354>)
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    14e4:	movs	r0, #16
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    14e6:	ldr	r7, [pc, #332]	; (1634 <TeensySynth::init()+0x358>)
    patchFxReverbMixChorus = new AudioConnection_F32(fxReverb, 0, mixChorus, 1);
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    14e8:	str	r2, [r6, r1]
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    14ea:	bl	17c08 <operator new(unsigned int)>
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    14ee:	ldr	r1, [pc, #328]	; (1638 <TeensySynth::init()+0x35c>)
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    14f0:	mov.w	r3, #2
    14f4:	strb	r4, [r0, #8]
    14f6:	add	r1, r6
    14f8:	str	r4, [r0, #12]
    14fa:	strb	r3, [r0, #9]
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    14fc:	add	r7, r6
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    14fe:	str	r1, [sp, #12]
    1500:	str	r0, [sp, #0]
    1502:	stmia.w	r0, {r5, r9}
      { connect(); }
    1506:	bl	15308 <AudioConnection_F32::connect()>
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    150a:	ldr.w	lr, [pc, #352]	; 166c <TeensySynth::init()+0x390>
    150e:	ldr	r2, [sp, #0]
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    1510:	movs	r0, #16
    patchMixChorusFxchorus = new AudioConnection_F32(mixChorus, fxChorus);
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    1512:	str.w	r2, [r6, lr]
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    1516:	bl	17c08 <operator new(unsigned int)>
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
    151a:	mov.w	r3, #1
    151e:	str	r4, [r0, #12]
    1520:	strb	r3, [r0, #8]
    1522:	mov.w	r3, #2
    1526:	str	r0, [sp, #0]
    1528:	strb	r3, [r0, #9]
    152a:	stmia.w	r0, {r5, r8}
      { connect(); }
    152e:	bl	15308 <AudioConnection_F32::connect()>
    1532:	ldr	r5, [pc, #264]	; (163c <TeensySynth::init()+0x360>)
    1534:	ldr	r2, [sp, #0]
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    1536:	movs	r0, #16
    patchMixOscMixMaster[0] = new AudioConnection_F32(mixOsc, 0, mixMasterL, 0);
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    1538:	str	r2, [r6, r5]
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    153a:	bl	17c08 <operator new(unsigned int)>
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    153e:	ldr	r2, [pc, #256]	; (1640 <TeensySynth::init()+0x364>)
class AudioConnection_F32
{
  public:
    AudioConnection_F32(AudioStream_F32 &source, AudioStream_F32 &destination) :
      src(source), dst(destination), src_index(0), dest_index(0),
      next_dest(NULL)
    1540:	ldr	r3, [sp, #4]
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    1542:	mov	r5, r0
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    1544:	add	r2, r6
    1546:	strb	r4, [r0, #8]
    1548:	str	r3, [r0, #4]
    154a:	strb	r4, [r0, #9]
    154c:	str	r4, [r0, #12]
    154e:	str.w	r9, [r0]
    1552:	str	r2, [sp, #8]
      { connect(); }
    1554:	bl	15308 <AudioConnection_F32::connect()>
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    1558:	ldr.w	lr, [pc, #276]	; 1670 <TeensySynth::init()+0x394>
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    155c:	movs	r0, #16
    patchMixOscMixMaster[1] = new AudioConnection_F32(mixOsc, 0, mixMasterR, 0);
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    155e:	str.w	r5, [r6, lr]
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    1562:	bl	17c08 <operator new(unsigned int)>
class AudioConnection_F32
{
  public:
    AudioConnection_F32(AudioStream_F32 &source, AudioStream_F32 &destination) :
      src(source), dst(destination), src_index(0), dest_index(0),
      next_dest(NULL)
    1566:	ldr	r1, [sp, #12]
    1568:	strb	r4, [r0, #8]
    156a:	mov	r5, r0
    156c:	str	r1, [r0, #4]
    156e:	strb	r4, [r0, #9]
    1570:	str	r4, [r0, #12]
    1572:	str.w	r8, [r0]
    1576:	str	r1, [sp, #0]
      { connect(); }
    1578:	bl	15308 <AudioConnection_F32::connect()>
    157c:	ldr.w	lr, [pc, #244]	; 1674 <TeensySynth::init()+0x398>
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    1580:	movs	r0, #16
    patchFxChorusMixMaster[0] = new AudioConnection_F32(fxChorus, 0, mixMasterL, 1);
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    1582:	str.w	r5, [r6, lr]
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    1586:	bl	17c08 <operator new(unsigned int)>
class AudioConnection_F32
{
  public:
    AudioConnection_F32(AudioStream_F32 &source, AudioStream_F32 &destination) :
      src(source), dst(destination), src_index(0), dest_index(0),
      next_dest(NULL)
    158a:	ldr	r3, [sp, #4]
    158c:	strb	r4, [r0, #8]
    158e:	mov	r5, r0
    1590:	str	r3, [r0, #0]
    1592:	strb	r4, [r0, #9]
    1594:	str	r4, [r0, #12]
    1596:	str	r7, [r0, #4]
      { connect(); }
    1598:	bl	15308 <AudioConnection_F32::connect()>
    159c:	ldr	r3, [pc, #164]	; (1644 <TeensySynth::init()+0x368>)
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    159e:	movs	r0, #16
    patchFxChorusMixMaster[1] = new AudioConnection_F32(fxChorus, 1, mixMasterR, 1);
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    15a0:	str	r5, [r6, r3]
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    15a2:	bl	17c08 <operator new(unsigned int)>
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    15a6:	ldr	r3, [pc, #160]	; (1648 <TeensySynth::init()+0x36c>)
class AudioConnection_F32
{
  public:
    AudioConnection_F32(AudioStream_F32 &source, AudioStream_F32 &destination) :
      src(source), dst(destination), src_index(0), dest_index(0),
      next_dest(NULL)
    15a8:	ldr	r2, [sp, #8]
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    15aa:	mov	r5, r0
    15ac:	ldr	r1, [sp, #0]
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    15ae:	add	r3, r6
    15b0:	str	r2, [r0, #4]
    15b2:	str	r1, [r0, #0]
    15b4:	strb	r4, [r0, #8]
    15b6:	strb	r4, [r0, #9]
    15b8:	str	r4, [r0, #12]
    15ba:	str	r3, [sp, #0]
      { connect(); }
    15bc:	bl	15308 <AudioConnection_F32::connect()>
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    15c0:	ldr	r1, [pc, #136]	; (164c <TeensySynth::init()+0x370>)
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    15c2:	movs	r0, #20
    patchFxReverbMixMaster[0] = new AudioConnection_F32(fxReverb, 0, mixMasterL, 2);
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    15c4:	str	r5, [r6, r1]
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    15c6:	bl	17c08 <operator new(unsigned int)>
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    15ca:	ldr	r3, [sp, #0]
    15cc:	mov	r1, r0
    15ce:	str	r7, [r0, #0]
    15d0:	str	r3, [r0, #4]
    15d2:	strb	r4, [r0, #8]
    15d4:	strb	r4, [r0, #9]
    15d6:	str	r4, [r0, #12]
		{ isConnected = false;
    15d8:	strb	r4, [r0, #16]
    15da:	ldr	r7, [pc, #116]	; (1650 <TeensySynth::init()+0x374>)
    patchConverterI2s[1] = new AudioConnection(float2Int2, 0, i2s1, 1);

    //Initialize default values for signal path components
    {
        Oscillator *o = oscs, *end = oscs + NVOICES;
    15dc:	ldr	r5, [pc, #20]	; (15f4 <TeensySynth::init()+0x318>)
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    15de:	stmia.w	sp, {r1, r3}
		{ isConnected = false;
		  connect(); }
    15e2:	bl	17b5c <AudioConnection::connect()>
    15e6:	b.n	1678 <TeensySynth::init()+0x39c>
    15e8:	.word	0x0001aaa4
    15ec:	.word	0x00036550
    15f0:	.word	0x0003653c
    15f4:	.word	0x000365b8
    15f8:	.word	0x000365bc
    15fc:	.word	0x000365c0
    1600:	.word	0x000365c1
    1604:	.word	0x0001ab70
    1608:	.word	0x00036568
    160c:	.word	0x0003656c
    1610:	.word	0x00033c1c
    1614:	.word	0x00036570
    1618:	.word	0x00036574
    161c:	.word	0x00036580
    1620:	.word	0x00036584
    1624:	.word	0x00036588
    1628:	.word	0x000363f4
    162c:	.word	0x0003658c
    1630:	.word	0x00036590
    1634:	.word	0x000364b4
    1638:	.word	0x00036454
    163c:	.word	0x0003657c
    1640:	.word	0x000364e0
    1644:	.word	0x0003659c
    1648:	.word	0x0003650c
    164c:	.word	0x000365a0
    1650:	.word	0x000365a4
    1654:	.word	0x0001a93c
    1658:	.word	0x00036528
    165c:	.word	0x00033bd4
    1660:	.word	0x0001ab0c
    1664:	.word	0x00036364
    1668:	.word	0x000363ac
    166c:	.word	0x00036578
    1670:	.word	0x00036594
    1674:	.word	0x00036598
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    1678:	ldr	r1, [sp, #0]
    patchConverterI2s[1] = new AudioConnection(float2Int2, 0, i2s1, 1);
    167a:	movs	r0, #20

    //Initialize default values for signal path components
    {
        Oscillator *o = oscs, *end = oscs + NVOICES;
    167c:	add	r5, r6
    patchFxReverbMixMaster[1] = new AudioConnection_F32(fxReverb, 1, mixMasterR, 2);
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    167e:	str	r1, [r6, r7]
    patchConverterI2s[1] = new AudioConnection(float2Int2, 0, i2s1, 1);

    //Initialize default values for signal path components
    {
        Oscillator *o = oscs, *end = oscs + NVOICES;
    1680:	adds	r7, #80	; 0x50
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    patchConverterI2s[1] = new AudioConnection(float2Int2, 0, i2s1, 1);
    1682:	bl	17c08 <operator new(unsigned int)>
		  connect(); }
	AudioConnection(AudioStream &source, unsigned char sourceOutput,
		AudioStream &destination, unsigned char destinationInput) :
		src(source), dst(destination),
		src_index(sourceOutput), dest_index(destinationInput),
		next_dest(NULL)
    1686:	ldr	r3, [sp, #4]
    1688:	ldr	r2, [sp, #8]

    //Initialize default values for signal path components
    {
        Oscillator *o = oscs, *end = oscs + NVOICES;
    168a:	add	r7, r6
    168c:	str	r3, [r0, #4]
    168e:	mov.w	r3, #1
    1692:	str	r2, [r0, #0]
    1694:	strb	r4, [r0, #8]
    1696:	strb	r3, [r0, #9]
    1698:	str	r4, [r0, #12]
		{ isConnected = false;
    169a:	strb	r4, [r0, #16]
    169c:	str	r0, [sp, #0]
		  connect(); }
    169e:	bl	17b5c <AudioConnection::connect()>
	
    virtual void update(void);

    void gain(unsigned int channel, float gain) {
      if (channel >= 4 || channel < 0) return;
      multiplier[channel] = gain;
    16a2:	ldr	r4, [pc, #328]	; (17ec <TeensySynth::init()+0x510>)
    16a4:	mov	r3, r5
    patchMixMasterFxFlt[0] = new AudioConnection_F32(mixMasterL, fxFlt[0]);
    patchMixMasterFxFlt[1] = new AudioConnection_F32(mixMasterR, fxFlt[1]);
    patchFxFltConverter[0] = new AudioConnection_F32(fxFlt[0], float2Int1);
    patchFxFltConverter[1] = new AudioConnection_F32(fxFlt[1], float2Int2);
    patchConverterI2s[0] = new AudioConnection(float2Int1, 0, i2s1, 0);
    patchConverterI2s[1] = new AudioConnection(float2Int2, 0, i2s1, 1);
    16a6:	ldr	r2, [pc, #328]	; (17f0 <TeensySynth::init()+0x514>)
    16a8:	movs	r0, #0
    16aa:	ldr	r1, [sp, #0]
    16ac:	str	r1, [r6, r2]
    //Initialize default values for signal path components
    {
        Oscillator *o = oscs, *end = oscs + NVOICES;
        do
        {
            o->amp->gain(0, OSC_LEVEL);
    16ae:	ldr	r2, [r3, #4]
    patchConverterI2s[1] = new AudioConnection(float2Int2, 0, i2s1, 1);

    //Initialize default values for signal path components
    {
        Oscillator *o = oscs, *end = oscs + NVOICES;
        do
    16b0:	adds	r3, #12
    16b2:	ldr	r1, [pc, #312]	; (17ec <TeensySynth::init()+0x510>)
    16b4:	cmp	r7, r3
    16b6:	str	r4, [r2, #56]	; 0x38
    16b8:	str	r0, [r2, #60]	; 0x3c
    16ba:	bhi.n	16ae <TeensySynth::init()+0x3d2>
    16bc:	ldr	r0, [pc, #308]	; (17f4 <TeensySynth::init()+0x518>)
		coeff[0] = c[0];
		coeff[1] = c[1];
		coeff[2] = c[2];
		coeff[3] = -c[3];
		coeff[4] = -c[4];
		begin(coeff);
    16be:	add.w	r2, sl, #44	; 0x2c
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1.0 / (1.0+alpha); // which is equal to 1.0 / a0
		/* b0 */ coeff[0] = ((1.0 + cosW0) / 2.0) * scale;
    16c2:	ldr	r3, [pc, #308]	; (17f8 <TeensySynth::init()+0x51c>)
    16c4:	str.w	r1, [r9, #56]	; 0x38
	}

    void begin(const float32_t *cp, int n_stages = 1) {
      coeff_p = cp;
      // Initialize FIR instance (ARM DSP Math Library)
      if (coeff_p && (coeff_p != IIR_F32_PASSTHRU) && n_stages <= IIR_MAX_STAGES) {
    16c8:	cmp	r2, #1
    16ca:	str.w	r1, [r9, #60]	; 0x3c
    16ce:	str.w	r0, [r9, #64]	; 0x40
    16d2:	str.w	r0, [r8, #64]	; 0x40
    16d6:	str.w	r1, [r8, #56]	; 0x38
    16da:	str.w	r1, [r8, #60]	; 0x3c
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1.0 / (1.0+alpha); // which is equal to 1.0 / a0
		/* b0 */ coeff[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coeff[1] = -(1.0 + cosW0) * scale;
    16de:	ldr	r0, [pc, #284]	; (17fc <TeensySynth::init()+0x520>)
		double w0 = frequency * (2 * 3.141592654 / AUDIO_SAMPLE_RATE_EXACT);
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1.0 / (1.0+alpha); // which is equal to 1.0 / a0
		/* b0 */ coeff[0] = ((1.0 + cosW0) / 2.0) * scale;
    16e0:	str.w	r3, [sl, #44]	; 0x2c
		/* b1 */ coeff[1] = -(1.0 + cosW0) * scale;
		/* b2 */ coeff[2] = coeff[0];
    16e4:	str.w	r3, [sl, #52]	; 0x34
			return;
		}
		coeff[0] = c[0];
		coeff[1] = c[1];
		coeff[2] = c[2];
		coeff[3] = -c[3];
    16e8:	ldr	r1, [pc, #276]	; (1800 <TeensySynth::init()+0x524>)
		coeff[4] = -c[4];
    16ea:	ldr	r3, [pc, #280]	; (1804 <TeensySynth::init()+0x528>)
		double sinW0 = sin(w0);
		double alpha = sinW0 / ((double)q * 2.0);
		double cosW0 = cos(w0);
		double scale = 1.0 / (1.0+alpha); // which is equal to 1.0 / a0
		/* b0 */ coeff[0] = ((1.0 + cosW0) / 2.0) * scale;
		/* b1 */ coeff[1] = -(1.0 + cosW0) * scale;
    16ec:	str.w	r0, [sl, #48]	; 0x30
			return;
		}
		coeff[0] = c[0];
		coeff[1] = c[1];
		coeff[2] = c[2];
		coeff[3] = -c[3];
    16f0:	str.w	r1, [sl, #56]	; 0x38
		coeff[4] = -c[4];
    16f4:	str.w	r3, [sl, #60]	; 0x3c
		AudioStream_F32(1,inputQueueArray), coeff_p(IIR_F32_PASSTHRU) {
			setSampleRate_Hz(settings.sample_rate_Hz); 
	}

    void begin(const float32_t *cp, int n_stages = 1) {
      coeff_p = cp;
    16f8:	str.w	r2, [sl, #68]	; 0x44
      // Initialize FIR instance (ARM DSP Math Library)
      if (coeff_p && (coeff_p != IIR_F32_PASSTHRU) && n_stages <= IIR_MAX_STAGES) {
    16fc:	bhi.n	17da <TeensySynth::init()+0x4fe>
	{
		if (n > 1.0f)
			n = 1.0f;
		else if (n < 0.0)
			n = 0.0f;
		combfeeback = (n * 9175.04f / 32768.0f) + 22937.0 / 32768.0f;
    16fe:	ldr	r4, [pc, #264]	; (1808 <TeensySynth::init()+0x52c>)
    1700:	ldr	r3, [pc, #264]	; (180c <TeensySynth::init()+0x530>)
    1702:	add	r4, r6
    1704:	str	r3, [r4, #0]
			n = 1.0f;
		else if (n < 0.0)
			n = 0.0f;
		float x1 = (n * 13107.2f / 32768.0f);
		float x2 = 1.0 - x1;
		__disable_irq();
    1706:	cpsid	i
		combdamp1 = x1;
    1708:	ldr	r2, [pc, #260]	; (1810 <TeensySynth::init()+0x534>)
		combdamp2 = x2;
    170a:	ldr	r3, [pc, #264]	; (1814 <TeensySynth::init()+0x538>)
		else if (n < 0.0)
			n = 0.0f;
		float x1 = (n * 13107.2f / 32768.0f);
		float x2 = 1.0 - x1;
		__disable_irq();
		combdamp1 = x1;
    170c:	add	r2, r6
    170e:	ldr	r0, [pc, #264]	; (1818 <TeensySynth::init()+0x53c>)
		combdamp2 = x2;
    1710:	add	r3, r6
    1712:	ldr	r1, [pc, #264]	; (181c <TeensySynth::init()+0x540>)
		else if (n < 0.0)
			n = 0.0f;
		float x1 = (n * 13107.2f / 32768.0f);
		float x2 = 1.0 - x1;
		__disable_irq();
		combdamp1 = x1;
    1714:	str	r0, [r2, #0]
		combdamp2 = x2;
    1716:	str	r1, [r3, #0]
		__enable_irq();
    1718:	cpsie	i
    171a:	ldr	r3, [pc, #260]	; (1820 <TeensySynth::init()+0x544>)
        updateChorusAndReverb();
    }

    inline void resetAll()
    {
        updateOscillator();
    171c:	mov	r0, r6
    171e:	str.w	r3, [fp, #60]	; 0x3c
    1722:	bl	1240 <TeensySynth::updateOscillator()>
    1726:	ldr	r3, [pc, #252]	; (1824 <TeensySynth::init()+0x548>)
    1728:	vldr	s15, [pc, #252]	; 1828 <TeensySynth::init()+0x54c>
    172c:	add	r3, r6
    172e:	vldr	s14, [r3]
    1732:	vsub.f32	s15, s15, s14
void TeensySynth::updateOscillatorBalance()
{
    Oscillator *o = oscs, *end = oscs + NVOICES;
    do
    {
        o->amp->gain(0, OSC_LEVEL - currentPatch.balance);
    1736:	ldr	r3, [r5, #4]
}

void TeensySynth::updateOscillatorBalance()
{
    Oscillator *o = oscs, *end = oscs + NVOICES;
    do
    1738:	adds	r5, #12
    173a:	cmp	r7, r5
    173c:	vstr	s15, [r3, #56]	; 0x38
    1740:	vstr	s14, [r3, #60]	; 0x3c
    1744:	bhi.n	1736 <TeensySynth::init()+0x45a>
        updateOscillatorBalance();
        updateFilter();
    1746:	mov	r0, r6
    1748:	bl	1100 <TeensySynth::updateFilter()>
    } while (++o < end);
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    174c:	ldr	r3, [pc, #220]	; (182c <TeensySynth::init()+0x550>)
public:
    AudioEffectFreeverbStereo_F32();
	virtual void update();
	void roomsize(float n)
	{
		if (n > 1.0f)
    174e:	vmov.f32	s14, #112	; 0x3f800000  1.0
    1752:	add	r3, r6
    1754:	vldr	s15, [r3]
    1758:	vcmpe.f32	s15, s14
    175c:	vmrs	APSR_nzcv, fpscr
    1760:	ble.n	17b0 <TeensySynth::init()+0x4d4>
    1762:	vldr	s15, [pc, #204]	; 1830 <TeensySynth::init()+0x554>
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    1766:	ldr	r2, [pc, #204]	; (1834 <TeensySynth::init()+0x558>)
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    1768:	ldr	r3, [pc, #204]	; (1838 <TeensySynth::init()+0x55c>)
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    176a:	add	r2, r6
			n = 1.0f;
		else if (n < 0.0)
			n = 0.0f;
		combfeeback = (n * 9175.04f / 32768.0f) + 22937.0 / 32768.0f;
    176c:	vstr	s15, [r4]
    1770:	vldr	s15, [pc, #200]	; 183c <TeensySynth::init()+0x560>
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    1774:	add	r3, r6
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    1776:	vldr	s14, [r2]
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    177a:	vldr	s13, [r3]
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    177e:	vsub.f32	s15, s15, s14
    1782:	vldr	s12, [pc, #188]	; 1840 <TeensySynth::init()+0x564>
    1786:	vstr	s14, [r9, #64]	; 0x40
    178a:	vmul.f32	s12, s14, s12
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    178e:	vmul.f32	s13, s15, s13
    1792:	vstr	s15, [r9, #56]	; 0x38
    1796:	vstr	s13, [r9, #60]	; 0x3c
    179a:	vstr	s13, [r8, #60]	; 0x3c
    179e:	vstr	s15, [r8, #56]	; 0x38
    17a2:	vstr	s14, [r8, #64]	; 0x40
    17a6:	vstr	s12, [fp, #60]	; 0x3c
    fxReverb.damping(0.7f);

    mixChorus.gain(1, CHORUS_REV_LEVEL); // Reverb -> Chorus level

    resetAll();
}
    17aa:	add	sp, #20
    17ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	virtual void update();
	void roomsize(float n)
	{
		if (n > 1.0f)
			n = 1.0f;
		else if (n < 0.0)
    17b0:	vcmpe.f32	s15, #0.0
    17b4:	vmrs	APSR_nzcv, fpscr
    17b8:	bmi.n	17d4 <TeensySynth::init()+0x4f8>
    17ba:	vldr	s14, [pc, #136]	; 1844 <TeensySynth::init()+0x568>
    17be:	vldr	s13, [pc, #136]	; 1848 <TeensySynth::init()+0x56c>
    17c2:	vmul.f32	s15, s15, s14
    17c6:	vldr	s14, [pc, #132]	; 184c <TeensySynth::init()+0x570>
    17ca:	vfma.f32	s14, s15, s13
    17ce:	vmov.f32	s15, s14
    17d2:	b.n	1766 <TeensySynth::init()+0x48a>
    17d4:	vldr	s15, [pc, #116]	; 184c <TeensySynth::init()+0x570>
    17d8:	b.n	1766 <TeensySynth::init()+0x48a>
        //https://www.keil.com/pack/doc/CMSIS/DSP/html/group__BiquadCascadeDF1.html
        arm_biquad_cascade_df1_init_f32(&iir_inst, n_stages, (float32_t *)coeff_p,  &StateF32[0]);
    17da:	add.w	r3, sl, #84	; 0x54
    17de:	add.w	r0, sl, #72	; 0x48
    17e2:	movs	r1, #1
    17e4:	bl	17c10 <arm_biquad_cascade_df1_init_f32>
    17e8:	b.n	16fe <TeensySynth::init()+0x422>
    17ea:	nop
    17ec:	.word	0x3f333333
    17f0:	.word	0x000365a8
    17f4:	.word	0x3dcccccd
    17f8:	.word	0x3f7c7860
    17fc:	.word	0xbffc7860
    1800:	.word	0x3ffc7225
    1804:	.word	0xbf78fd36
    1808:	.word	0x00030978
    180c:	.word	0x3f655f0e
    1810:	.word	0x00030970
    1814:	.word	0x00030974
    1818:	.word	0x3e8f5c29
    181c:	.word	0x3f3851ec
    1820:	.word	0x3ecccccd
    1824:	.word	0x00036604
    1828:	.word	0x3f333333
    182c:	.word	0x00036634
    1830:	.word	0x3f7ae014
    1834:	.word	0x00036638
    1838:	.word	0x0003663c
    183c:	.word	0x3f4ccccd
    1840:	.word	0x3ecccccd
    1844:	.word	0x460f5c29
    1848:	.word	0x38000000
    184c:	.word	0x3f333200

00001850 <TeensySynth::updateOscillatorBalance()>:
            o->wf->setPatchParameter(AudioSynthPlaits_F32::Parameters::decay, currentPatch.decay);
    } while (++o < end);
}

void TeensySynth::updateOscillatorBalance()
{
    1850:	ldr	r2, [pc, #40]	; (187c <TeensySynth::updateOscillatorBalance()+0x2c>)
    1852:	vldr	s15, [pc, #44]	; 1880 <TeensySynth::updateOscillatorBalance()+0x30>
    1856:	add	r2, r0
    Oscillator *o = oscs, *end = oscs + NVOICES;
    1858:	ldr	r3, [pc, #40]	; (1884 <TeensySynth::updateOscillatorBalance()+0x34>)
    185a:	ldr	r1, [pc, #44]	; (1888 <TeensySynth::updateOscillatorBalance()+0x38>)
    185c:	vldr	s14, [r2]
    1860:	add	r3, r0
    1862:	add	r1, r0
    1864:	vsub.f32	s15, s15, s14
    do
    {
        o->amp->gain(0, OSC_LEVEL - currentPatch.balance);
    1868:	ldr	r2, [r3, #4]
}

void TeensySynth::updateOscillatorBalance()
{
    Oscillator *o = oscs, *end = oscs + NVOICES;
    do
    186a:	adds	r3, #12
    186c:	cmp	r1, r3
    186e:	vstr	s15, [r2, #56]	; 0x38
    1872:	vstr	s14, [r2, #60]	; 0x3c
    1876:	bhi.n	1868 <TeensySynth::updateOscillatorBalance()+0x18>
    {
        o->amp->gain(0, OSC_LEVEL - currentPatch.balance);
        o->amp->gain(1, currentPatch.balance);
    } while (++o < end);
}
    1878:	bx	lr
    187a:	nop
    187c:	.word	0x00036604
    1880:	.word	0x3f333333
    1884:	.word	0x000365b8
    1888:	.word	0x000365f4

0000188c <TeensySynth::updateChorusAndReverb()>:

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    188c:	ldr	r3, [pc, #148]	; (1924 <TeensySynth::updateChorusAndReverb()+0x98>)
public:
    AudioEffectFreeverbStereo_F32();
	virtual void update();
	void roomsize(float n)
	{
		if (n > 1.0f)
    188e:	vmov.f32	s14, #112	; 0x3f800000  1.0
    1892:	add	r3, r0
    1894:	vldr	s15, [r3]
    1898:	vcmpe.f32	s15, s14
    189c:	vmrs	APSR_nzcv, fpscr
    18a0:	ble.n	18fc <TeensySynth::updateChorusAndReverb()+0x70>
    18a2:	vldr	s14, [pc, #132]	; 1928 <TeensySynth::updateChorusAndReverb()+0x9c>
			n = 1.0f;
		else if (n < 0.0)
			n = 0.0f;
		combfeeback = (n * 9175.04f / 32768.0f) + 22937.0 / 32768.0f;
    18a6:	ldr	r1, [pc, #132]	; (192c <TeensySynth::updateChorusAndReverb()+0xa0>)
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    18a8:	ldr	r2, [pc, #132]	; (1930 <TeensySynth::updateChorusAndReverb()+0xa4>)
    18aa:	add	r1, r0
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    18ac:	ldr	r3, [pc, #132]	; (1934 <TeensySynth::updateChorusAndReverb()+0xa8>)
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    18ae:	add	r2, r0
    18b0:	vldr	s15, [pc, #132]	; 1938 <TeensySynth::updateChorusAndReverb()+0xac>
    18b4:	vstr	s14, [r1]
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    18b8:	add	r3, r0
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    18ba:	vldr	s14, [r2]
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    18be:	vldr	s13, [r3]
}

void TeensySynth::updateChorusAndReverb()
{
    fxReverb.roomsize(currentPatch.reverbSize);
    mixMasterL.gain(0, MIX_LEVEL - currentPatch.reverbDepth);                              //dry signal L
    18c2:	vsub.f32	s15, s15, s14
    18c6:	vldr	s12, [pc, #116]	; 193c <TeensySynth::updateChorusAndReverb()+0xb0>
    18ca:	ldr	r2, [pc, #116]	; (1940 <TeensySynth::updateChorusAndReverb()+0xb4>)
    18cc:	ldr	r3, [pc, #116]	; (1944 <TeensySynth::updateChorusAndReverb()+0xb8>)
    18ce:	vmul.f32	s12, s14, s12
    18d2:	ldr	r1, [pc, #116]	; (1948 <TeensySynth::updateChorusAndReverb()+0xbc>)
    mixMasterL.gain(1, currentPatch.chorusDepth * (MIX_LEVEL - currentPatch.reverbDepth)); //chorus signal L
    18d4:	vmul.f32	s13, s15, s13
    18d8:	add	r2, r0
    18da:	add	r3, r0
    18dc:	add	r1, r0
    18de:	vstr	s13, [r2, #60]	; 0x3c
    18e2:	vstr	s15, [r2, #56]	; 0x38
    18e6:	vstr	s14, [r2, #64]	; 0x40
    18ea:	vstr	s13, [r3, #60]	; 0x3c
    18ee:	vstr	s15, [r3, #56]	; 0x38
    18f2:	vstr	s14, [r3, #64]	; 0x40
    18f6:	vstr	s12, [r1, #60]	; 0x3c
    18fa:	bx	lr
	virtual void update();
	void roomsize(float n)
	{
		if (n > 1.0f)
			n = 1.0f;
		else if (n < 0.0)
    18fc:	vcmpe.f32	s15, #0.0
    1900:	vmrs	APSR_nzcv, fpscr
    1904:	bmi.n	191c <TeensySynth::updateChorusAndReverb()+0x90>
    1906:	vldr	s14, [pc, #68]	; 194c <TeensySynth::updateChorusAndReverb()+0xc0>
    190a:	vldr	s13, [pc, #68]	; 1950 <TeensySynth::updateChorusAndReverb()+0xc4>
    190e:	vmul.f32	s15, s15, s14
    1912:	vldr	s14, [pc, #64]	; 1954 <TeensySynth::updateChorusAndReverb()+0xc8>
    1916:	vfma.f32	s14, s15, s13
    191a:	b.n	18a6 <TeensySynth::updateChorusAndReverb()+0x1a>
    191c:	vldr	s14, [pc, #52]	; 1954 <TeensySynth::updateChorusAndReverb()+0xc8>
    1920:	b.n	18a6 <TeensySynth::updateChorusAndReverb()+0x1a>
    1922:	nop
    1924:	.word	0x00036634
    1928:	.word	0x3f7ae014
    192c:	.word	0x00030978
    1930:	.word	0x00036638
    1934:	.word	0x0003663c
    1938:	.word	0x3f4ccccd
    193c:	.word	0x3ecccccd
    1940:	.word	0x00036364
    1944:	.word	0x000363ac
    1948:	.word	0x00033bd4
    194c:	.word	0x460f5c29
    1950:	.word	0x38000000
    1954:	.word	0x3f333200

00001958 <Encoder::isr0()>:
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    1958:	ldr	r3, [pc, #128]	; (19dc <Encoder::isr0()+0x84>)
    195a:	ldr	r2, [r3, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    195c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    195e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1960:	ldr	r1, [r3, #0]
    1962:	ldr	r3, [r2, #8]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    1964:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1966:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1968:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    196a:	ldr	r0, [r2, #12]
    196c:	tst	r4, r0
    196e:	beq.n	19a8 <Encoder::isr0()+0x50>
		uint8_t state = arg->state & 3;
    1970:	ldrb	r3, [r2, #16]
    1972:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1976:	cbz	r1, 197c <Encoder::isr0()+0x24>
    1978:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    197c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1980:	asrs	r1, r3, #2
		switch (state) {
    1982:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1984:	strb	r1, [r2, #16]
		switch (state) {
    1986:	cmp	r3, #13
    1988:	bhi.n	19a2 <Encoder::isr0()+0x4a>
    198a:	tbb	[pc, r3]
    198e:	.short	0x0721
    1990:	.word	0x150a071b
    1994:	.word	0x0a152121
    1998:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    199c:	ldr	r3, [r2, #20]
    199e:	subs	r3, #1
    19a0:	str	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19a2:	ldr.w	r4, [sp], #4
    19a6:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    19a8:	ldrb	r3, [r2, #16]
    19aa:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    19ae:	cmp	r1, #0
    19b0:	beq.n	1980 <Encoder::isr0()+0x28>
    19b2:	orr.w	r3, r3, #4
    19b6:	b.n	1980 <Encoder::isr0()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    19b8:	ldr	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19ba:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    19be:	subs	r3, #2
    19c0:	str	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19c2:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    19c4:	ldr	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19c6:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    19ca:	adds	r3, #2
    19cc:	str	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19ce:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    19d0:	ldr	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19d2:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    19d6:	adds	r3, #1
    19d8:	str	r3, [r2, #20]
#endif // ENCODER_USE_INTERRUPTS


#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
    19da:	bx	lr
    19dc:	.word	0x20057ee8

000019e0 <Encoder::isr1()>:
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    19e0:	ldr	r3, [pc, #128]	; (1a64 <Encoder::isr1()+0x84>)
    19e2:	ldr	r2, [r3, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    19e4:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    19e6:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    19e8:	ldr	r1, [r3, #0]
    19ea:	ldr	r3, [r2, #8]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    19ec:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    19ee:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    19f0:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    19f2:	ldr	r0, [r2, #12]
    19f4:	tst	r4, r0
    19f6:	beq.n	1a30 <Encoder::isr1()+0x50>
		uint8_t state = arg->state & 3;
    19f8:	ldrb	r3, [r2, #16]
    19fa:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    19fe:	cbz	r1, 1a04 <Encoder::isr1()+0x24>
    1a00:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1a04:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1a08:	asrs	r1, r3, #2
		switch (state) {
    1a0a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1a0c:	strb	r1, [r2, #16]
		switch (state) {
    1a0e:	cmp	r3, #13
    1a10:	bhi.n	1a2a <Encoder::isr1()+0x4a>
    1a12:	tbb	[pc, r3]
    1a16:	.short	0x0721
    1a18:	.word	0x150a071b
    1a1c:	.word	0x0a152121
    1a20:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1a24:	ldr	r3, [r2, #20]
    1a26:	subs	r3, #1
    1a28:	str	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a2a:	ldr.w	r4, [sp], #4
    1a2e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1a30:	ldrb	r3, [r2, #16]
    1a32:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1a36:	cmp	r1, #0
    1a38:	beq.n	1a08 <Encoder::isr1()+0x28>
    1a3a:	orr.w	r3, r3, #4
    1a3e:	b.n	1a08 <Encoder::isr1()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1a40:	ldr	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a42:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1a46:	subs	r3, #2
    1a48:	str	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a4a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1a4c:	ldr	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a4e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1a52:	adds	r3, #2
    1a54:	str	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a56:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1a58:	ldr	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a5a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1a5e:	adds	r3, #1
    1a60:	str	r3, [r2, #20]
#if defined(ENCODER_USE_INTERRUPTS) && !defined(ENCODER_OPTIMIZE_INTERRUPTS)
	#ifdef CORE_INT0_PIN
	static void isr0(void) { update(interruptArgs[0]); }
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
    1a62:	bx	lr
    1a64:	.word	0x20057ee8

00001a68 <Encoder::isr4()>:
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1a68:	ldr	r3, [pc, #128]	; (1aec <Encoder::isr4()+0x84>)
    1a6a:	ldr	r2, [r3, #16]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1a6c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1a6e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1a70:	ldr	r1, [r3, #0]
    1a72:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1a74:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1a76:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1a78:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1a7a:	ldr	r0, [r2, #12]
    1a7c:	tst	r4, r0
    1a7e:	beq.n	1ab8 <Encoder::isr4()+0x50>
		uint8_t state = arg->state & 3;
    1a80:	ldrb	r3, [r2, #16]
    1a82:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1a86:	cbz	r1, 1a8c <Encoder::isr4()+0x24>
    1a88:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1a8c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1a90:	asrs	r1, r3, #2
		switch (state) {
    1a92:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1a94:	strb	r1, [r2, #16]
		switch (state) {
    1a96:	cmp	r3, #13
    1a98:	bhi.n	1ab2 <Encoder::isr4()+0x4a>
    1a9a:	tbb	[pc, r3]
    1a9e:	.short	0x0721
    1aa0:	.word	0x150a071b
    1aa4:	.word	0x0a152121
    1aa8:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1aac:	ldr	r3, [r2, #20]
    1aae:	subs	r3, #1
    1ab0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1ab2:	ldr.w	r4, [sp], #4
    1ab6:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1ab8:	ldrb	r3, [r2, #16]
    1aba:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1abe:	cmp	r1, #0
    1ac0:	beq.n	1a90 <Encoder::isr4()+0x28>
    1ac2:	orr.w	r3, r3, #4
    1ac6:	b.n	1a90 <Encoder::isr4()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1ac8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1aca:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1ace:	subs	r3, #2
    1ad0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1ad2:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1ad4:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1ad6:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1ada:	adds	r3, #2
    1adc:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1ade:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1ae0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1ae2:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1ae6:	adds	r3, #1
    1ae8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
    1aea:	bx	lr
    1aec:	.word	0x20057ee8

00001af0 <Encoder::isr5()>:
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1af0:	ldr	r3, [pc, #128]	; (1b74 <Encoder::isr5()+0x84>)
    1af2:	ldr	r2, [r3, #20]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1af4:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1af6:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1af8:	ldr	r1, [r3, #0]
    1afa:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1afc:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1afe:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1b00:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1b02:	ldr	r0, [r2, #12]
    1b04:	tst	r4, r0
    1b06:	beq.n	1b40 <Encoder::isr5()+0x50>
		uint8_t state = arg->state & 3;
    1b08:	ldrb	r3, [r2, #16]
    1b0a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1b0e:	cbz	r1, 1b14 <Encoder::isr5()+0x24>
    1b10:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1b14:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1b18:	asrs	r1, r3, #2
		switch (state) {
    1b1a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1b1c:	strb	r1, [r2, #16]
		switch (state) {
    1b1e:	cmp	r3, #13
    1b20:	bhi.n	1b3a <Encoder::isr5()+0x4a>
    1b22:	tbb	[pc, r3]
    1b26:	.short	0x0721
    1b28:	.word	0x150a071b
    1b2c:	.word	0x0a152121
    1b30:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1b34:	ldr	r3, [r2, #20]
    1b36:	subs	r3, #1
    1b38:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b3a:	ldr.w	r4, [sp], #4
    1b3e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1b40:	ldrb	r3, [r2, #16]
    1b42:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1b46:	cmp	r1, #0
    1b48:	beq.n	1b18 <Encoder::isr5()+0x28>
    1b4a:	orr.w	r3, r3, #4
    1b4e:	b.n	1b18 <Encoder::isr5()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1b50:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b52:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1b56:	subs	r3, #2
    1b58:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b5a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1b5c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b5e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1b62:	adds	r3, #2
    1b64:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b66:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1b68:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b6a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1b6e:	adds	r3, #1
    1b70:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT4_PIN
	static void isr4(void) { update(interruptArgs[4]); }
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
    1b72:	bx	lr
    1b74:	.word	0x20057ee8

00001b78 <Encoder::isr6()>:
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1b78:	ldr	r3, [pc, #128]	; (1bfc <Encoder::isr6()+0x84>)
    1b7a:	ldr	r2, [r3, #24]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1b7c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1b7e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1b80:	ldr	r1, [r3, #0]
    1b82:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1b84:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1b86:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1b88:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1b8a:	ldr	r0, [r2, #12]
    1b8c:	tst	r4, r0
    1b8e:	beq.n	1bc8 <Encoder::isr6()+0x50>
		uint8_t state = arg->state & 3;
    1b90:	ldrb	r3, [r2, #16]
    1b92:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1b96:	cbz	r1, 1b9c <Encoder::isr6()+0x24>
    1b98:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1b9c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1ba0:	asrs	r1, r3, #2
		switch (state) {
    1ba2:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1ba4:	strb	r1, [r2, #16]
		switch (state) {
    1ba6:	cmp	r3, #13
    1ba8:	bhi.n	1bc2 <Encoder::isr6()+0x4a>
    1baa:	tbb	[pc, r3]
    1bae:	.short	0x0721
    1bb0:	.word	0x150a071b
    1bb4:	.word	0x0a152121
    1bb8:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1bbc:	ldr	r3, [r2, #20]
    1bbe:	subs	r3, #1
    1bc0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1bc2:	ldr.w	r4, [sp], #4
    1bc6:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1bc8:	ldrb	r3, [r2, #16]
    1bca:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1bce:	cmp	r1, #0
    1bd0:	beq.n	1ba0 <Encoder::isr6()+0x28>
    1bd2:	orr.w	r3, r3, #4
    1bd6:	b.n	1ba0 <Encoder::isr6()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1bd8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1bda:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1bde:	subs	r3, #2
    1be0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1be2:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1be4:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1be6:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1bea:	adds	r3, #2
    1bec:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1bee:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1bf0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1bf2:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1bf6:	adds	r3, #1
    1bf8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT5_PIN
	static void isr5(void) { update(interruptArgs[5]); }
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
    1bfa:	bx	lr
    1bfc:	.word	0x20057ee8

00001c00 <Encoder::isr7()>:
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c00:	ldr	r3, [pc, #128]	; (1c84 <Encoder::isr7()+0x84>)
    1c02:	ldr	r2, [r3, #28]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1c04:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1c06:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1c08:	ldr	r1, [r3, #0]
    1c0a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c0c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1c0e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1c10:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1c12:	ldr	r0, [r2, #12]
    1c14:	tst	r4, r0
    1c16:	beq.n	1c50 <Encoder::isr7()+0x50>
		uint8_t state = arg->state & 3;
    1c18:	ldrb	r3, [r2, #16]
    1c1a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1c1e:	cbz	r1, 1c24 <Encoder::isr7()+0x24>
    1c20:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1c24:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1c28:	asrs	r1, r3, #2
		switch (state) {
    1c2a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1c2c:	strb	r1, [r2, #16]
		switch (state) {
    1c2e:	cmp	r3, #13
    1c30:	bhi.n	1c4a <Encoder::isr7()+0x4a>
    1c32:	tbb	[pc, r3]
    1c36:	.short	0x0721
    1c38:	.word	0x150a071b
    1c3c:	.word	0x0a152121
    1c40:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1c44:	ldr	r3, [r2, #20]
    1c46:	subs	r3, #1
    1c48:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c4a:	ldr.w	r4, [sp], #4
    1c4e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1c50:	ldrb	r3, [r2, #16]
    1c52:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1c56:	cmp	r1, #0
    1c58:	beq.n	1c28 <Encoder::isr7()+0x28>
    1c5a:	orr.w	r3, r3, #4
    1c5e:	b.n	1c28 <Encoder::isr7()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1c60:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c62:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1c66:	subs	r3, #2
    1c68:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c6a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1c6c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c6e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1c72:	adds	r3, #2
    1c74:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c76:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1c78:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c7a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1c7e:	adds	r3, #1
    1c80:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT6_PIN
	static void isr6(void) { update(interruptArgs[6]); }
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
    1c82:	bx	lr
    1c84:	.word	0x20057ee8

00001c88 <Encoder::isr2()>:
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1c88:	ldr	r3, [pc, #128]	; (1d0c <Encoder::isr2()+0x84>)
    1c8a:	ldr	r2, [r3, #8]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1c8c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1c8e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1c90:	ldr	r1, [r3, #0]
    1c92:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1c94:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1c96:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1c98:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1c9a:	ldr	r0, [r2, #12]
    1c9c:	tst	r4, r0
    1c9e:	beq.n	1cd8 <Encoder::isr2()+0x50>
		uint8_t state = arg->state & 3;
    1ca0:	ldrb	r3, [r2, #16]
    1ca2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1ca6:	cbz	r1, 1cac <Encoder::isr2()+0x24>
    1ca8:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1cac:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1cb0:	asrs	r1, r3, #2
		switch (state) {
    1cb2:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1cb4:	strb	r1, [r2, #16]
		switch (state) {
    1cb6:	cmp	r3, #13
    1cb8:	bhi.n	1cd2 <Encoder::isr2()+0x4a>
    1cba:	tbb	[pc, r3]
    1cbe:	.short	0x0721
    1cc0:	.word	0x150a071b
    1cc4:	.word	0x0a152121
    1cc8:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1ccc:	ldr	r3, [r2, #20]
    1cce:	subs	r3, #1
    1cd0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1cd2:	ldr.w	r4, [sp], #4
    1cd6:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1cd8:	ldrb	r3, [r2, #16]
    1cda:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1cde:	cmp	r1, #0
    1ce0:	beq.n	1cb0 <Encoder::isr2()+0x28>
    1ce2:	orr.w	r3, r3, #4
    1ce6:	b.n	1cb0 <Encoder::isr2()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1ce8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1cea:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1cee:	subs	r3, #2
    1cf0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1cf2:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1cf4:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1cf6:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1cfa:	adds	r3, #2
    1cfc:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1cfe:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1d00:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1d02:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1d06:	adds	r3, #1
    1d08:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT1_PIN
	static void isr1(void) { update(interruptArgs[1]); }
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
    1d0a:	bx	lr
    1d0c:	.word	0x20057ee8

00001d10 <Encoder::isr3()>:
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d10:	ldr	r3, [pc, #128]	; (1d94 <Encoder::isr3()+0x84>)
    1d12:	ldr	r2, [r3, #12]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1d14:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1d16:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1d18:	ldr	r1, [r3, #0]
    1d1a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d1c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1d1e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1d20:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1d22:	ldr	r0, [r2, #12]
    1d24:	tst	r4, r0
    1d26:	beq.n	1d60 <Encoder::isr3()+0x50>
		uint8_t state = arg->state & 3;
    1d28:	ldrb	r3, [r2, #16]
    1d2a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1d2e:	cbz	r1, 1d34 <Encoder::isr3()+0x24>
    1d30:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1d34:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1d38:	asrs	r1, r3, #2
		switch (state) {
    1d3a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1d3c:	strb	r1, [r2, #16]
		switch (state) {
    1d3e:	cmp	r3, #13
    1d40:	bhi.n	1d5a <Encoder::isr3()+0x4a>
    1d42:	tbb	[pc, r3]
    1d46:	.short	0x0721
    1d48:	.word	0x150a071b
    1d4c:	.word	0x0a152121
    1d50:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1d54:	ldr	r3, [r2, #20]
    1d56:	subs	r3, #1
    1d58:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d5a:	ldr.w	r4, [sp], #4
    1d5e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1d60:	ldrb	r3, [r2, #16]
    1d62:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1d66:	cmp	r1, #0
    1d68:	beq.n	1d38 <Encoder::isr3()+0x28>
    1d6a:	orr.w	r3, r3, #4
    1d6e:	b.n	1d38 <Encoder::isr3()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1d70:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d72:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1d76:	subs	r3, #2
    1d78:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d7a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1d7c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d7e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1d82:	adds	r3, #2
    1d84:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d86:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1d88:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d8a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1d8e:	adds	r3, #1
    1d90:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT2_PIN
	static void isr2(void) { update(interruptArgs[2]); }
	#endif
	#ifdef CORE_INT3_PIN
	static void isr3(void) { update(interruptArgs[3]); }
    1d92:	bx	lr
    1d94:	.word	0x20057ee8

00001d98 <Encoder::isr8()>:
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1d98:	ldr	r3, [pc, #128]	; (1e1c <Encoder::isr8()+0x84>)
    1d9a:	ldr	r2, [r3, #32]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1d9c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1d9e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1da0:	ldr	r1, [r3, #0]
    1da2:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1da4:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1da6:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1da8:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1daa:	ldr	r0, [r2, #12]
    1dac:	tst	r4, r0
    1dae:	beq.n	1de8 <Encoder::isr8()+0x50>
		uint8_t state = arg->state & 3;
    1db0:	ldrb	r3, [r2, #16]
    1db2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1db6:	cbz	r1, 1dbc <Encoder::isr8()+0x24>
    1db8:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1dbc:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1dc0:	asrs	r1, r3, #2
		switch (state) {
    1dc2:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1dc4:	strb	r1, [r2, #16]
		switch (state) {
    1dc6:	cmp	r3, #13
    1dc8:	bhi.n	1de2 <Encoder::isr8()+0x4a>
    1dca:	tbb	[pc, r3]
    1dce:	.short	0x0721
    1dd0:	.word	0x150a071b
    1dd4:	.word	0x0a152121
    1dd8:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1ddc:	ldr	r3, [r2, #20]
    1dde:	subs	r3, #1
    1de0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1de2:	ldr.w	r4, [sp], #4
    1de6:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1de8:	ldrb	r3, [r2, #16]
    1dea:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1dee:	cmp	r1, #0
    1df0:	beq.n	1dc0 <Encoder::isr8()+0x28>
    1df2:	orr.w	r3, r3, #4
    1df6:	b.n	1dc0 <Encoder::isr8()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1df8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1dfa:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1dfe:	subs	r3, #2
    1e00:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1e02:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1e04:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1e06:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1e0a:	adds	r3, #2
    1e0c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1e0e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1e10:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1e12:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1e16:	adds	r3, #1
    1e18:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT7_PIN
	static void isr7(void) { update(interruptArgs[7]); }
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
    1e1a:	bx	lr
    1e1c:	.word	0x20057ee8

00001e20 <Encoder::isr9()>:
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e20:	ldr	r3, [pc, #128]	; (1ea4 <Encoder::isr9()+0x84>)
    1e22:	ldr	r2, [r3, #36]	; 0x24
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1e24:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1e26:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1e28:	ldr	r1, [r3, #0]
    1e2a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e2c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1e2e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1e30:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1e32:	ldr	r0, [r2, #12]
    1e34:	tst	r4, r0
    1e36:	beq.n	1e70 <Encoder::isr9()+0x50>
		uint8_t state = arg->state & 3;
    1e38:	ldrb	r3, [r2, #16]
    1e3a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1e3e:	cbz	r1, 1e44 <Encoder::isr9()+0x24>
    1e40:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1e44:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1e48:	asrs	r1, r3, #2
		switch (state) {
    1e4a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1e4c:	strb	r1, [r2, #16]
		switch (state) {
    1e4e:	cmp	r3, #13
    1e50:	bhi.n	1e6a <Encoder::isr9()+0x4a>
    1e52:	tbb	[pc, r3]
    1e56:	.short	0x0721
    1e58:	.word	0x150a071b
    1e5c:	.word	0x0a152121
    1e60:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1e64:	ldr	r3, [r2, #20]
    1e66:	subs	r3, #1
    1e68:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e6a:	ldr.w	r4, [sp], #4
    1e6e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1e70:	ldrb	r3, [r2, #16]
    1e72:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1e76:	cmp	r1, #0
    1e78:	beq.n	1e48 <Encoder::isr9()+0x28>
    1e7a:	orr.w	r3, r3, #4
    1e7e:	b.n	1e48 <Encoder::isr9()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1e80:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e82:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1e86:	subs	r3, #2
    1e88:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e8a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1e8c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e8e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1e92:	adds	r3, #2
    1e94:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e96:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1e98:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1e9a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1e9e:	adds	r3, #1
    1ea0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT8_PIN
	static void isr8(void) { update(interruptArgs[8]); }
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
    1ea2:	bx	lr
    1ea4:	.word	0x20057ee8

00001ea8 <Encoder::isr10()>:
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1ea8:	ldr	r3, [pc, #128]	; (1f2c <Encoder::isr10()+0x84>)
    1eaa:	ldr	r2, [r3, #40]	; 0x28
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1eac:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1eae:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1eb0:	ldr	r1, [r3, #0]
    1eb2:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1eb4:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1eb6:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1eb8:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1eba:	ldr	r0, [r2, #12]
    1ebc:	tst	r4, r0
    1ebe:	beq.n	1ef8 <Encoder::isr10()+0x50>
		uint8_t state = arg->state & 3;
    1ec0:	ldrb	r3, [r2, #16]
    1ec2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1ec6:	cbz	r1, 1ecc <Encoder::isr10()+0x24>
    1ec8:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1ecc:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1ed0:	asrs	r1, r3, #2
		switch (state) {
    1ed2:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1ed4:	strb	r1, [r2, #16]
		switch (state) {
    1ed6:	cmp	r3, #13
    1ed8:	bhi.n	1ef2 <Encoder::isr10()+0x4a>
    1eda:	tbb	[pc, r3]
    1ede:	.short	0x0721
    1ee0:	.word	0x150a071b
    1ee4:	.word	0x0a152121
    1ee8:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1eec:	ldr	r3, [r2, #20]
    1eee:	subs	r3, #1
    1ef0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1ef2:	ldr.w	r4, [sp], #4
    1ef6:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1ef8:	ldrb	r3, [r2, #16]
    1efa:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1efe:	cmp	r1, #0
    1f00:	beq.n	1ed0 <Encoder::isr10()+0x28>
    1f02:	orr.w	r3, r3, #4
    1f06:	b.n	1ed0 <Encoder::isr10()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1f08:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1f0a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1f0e:	subs	r3, #2
    1f10:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1f12:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1f14:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1f16:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1f1a:	adds	r3, #2
    1f1c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1f1e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1f20:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1f22:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1f26:	adds	r3, #1
    1f28:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT9_PIN
	static void isr9(void) { update(interruptArgs[9]); }
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
    1f2a:	bx	lr
    1f2c:	.word	0x20057ee8

00001f30 <Encoder::isr11()>:
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1f30:	ldr	r3, [pc, #128]	; (1fb4 <Encoder::isr11()+0x84>)
    1f32:	ldr	r2, [r3, #44]	; 0x2c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1f34:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1f36:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1f38:	ldr	r1, [r3, #0]
    1f3a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1f3c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1f3e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1f40:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1f42:	ldr	r0, [r2, #12]
    1f44:	tst	r4, r0
    1f46:	beq.n	1f80 <Encoder::isr11()+0x50>
		uint8_t state = arg->state & 3;
    1f48:	ldrb	r3, [r2, #16]
    1f4a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1f4e:	cbz	r1, 1f54 <Encoder::isr11()+0x24>
    1f50:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1f54:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1f58:	asrs	r1, r3, #2
		switch (state) {
    1f5a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1f5c:	strb	r1, [r2, #16]
		switch (state) {
    1f5e:	cmp	r3, #13
    1f60:	bhi.n	1f7a <Encoder::isr11()+0x4a>
    1f62:	tbb	[pc, r3]
    1f66:	.short	0x0721
    1f68:	.word	0x150a071b
    1f6c:	.word	0x0a152121
    1f70:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1f74:	ldr	r3, [r2, #20]
    1f76:	subs	r3, #1
    1f78:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1f7a:	ldr.w	r4, [sp], #4
    1f7e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    1f80:	ldrb	r3, [r2, #16]
    1f82:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1f86:	cmp	r1, #0
    1f88:	beq.n	1f58 <Encoder::isr11()+0x28>
    1f8a:	orr.w	r3, r3, #4
    1f8e:	b.n	1f58 <Encoder::isr11()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1f90:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1f92:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    1f96:	subs	r3, #2
    1f98:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1f9a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1f9c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1f9e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    1fa2:	adds	r3, #2
    1fa4:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1fa6:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1fa8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1faa:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    1fae:	adds	r3, #1
    1fb0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT10_PIN
	static void isr10(void) { update(interruptArgs[10]); }
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
    1fb2:	bx	lr
    1fb4:	.word	0x20057ee8

00001fb8 <Encoder::isr12()>:
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    1fb8:	ldr	r3, [pc, #128]	; (203c <Encoder::isr12()+0x84>)
    1fba:	ldr	r2, [r3, #48]	; 0x30
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1fbc:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1fbe:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1fc0:	ldr	r1, [r3, #0]
    1fc2:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    1fc4:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1fc6:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    1fc8:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    1fca:	ldr	r0, [r2, #12]
    1fcc:	tst	r4, r0
    1fce:	beq.n	2008 <Encoder::isr12()+0x50>
		uint8_t state = arg->state & 3;
    1fd0:	ldrb	r3, [r2, #16]
    1fd2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    1fd6:	cbz	r1, 1fdc <Encoder::isr12()+0x24>
    1fd8:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    1fdc:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    1fe0:	asrs	r1, r3, #2
		switch (state) {
    1fe2:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    1fe4:	strb	r1, [r2, #16]
		switch (state) {
    1fe6:	cmp	r3, #13
    1fe8:	bhi.n	2002 <Encoder::isr12()+0x4a>
    1fea:	tbb	[pc, r3]
    1fee:	.short	0x0721
    1ff0:	.word	0x150a071b
    1ff4:	.word	0x0a152121
    1ff8:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    1ffc:	ldr	r3, [r2, #20]
    1ffe:	subs	r3, #1
    2000:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    2002:	ldr.w	r4, [sp], #4
    2006:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2008:	ldrb	r3, [r2, #16]
    200a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    200e:	cmp	r1, #0
    2010:	beq.n	1fe0 <Encoder::isr12()+0x28>
    2012:	orr.w	r3, r3, #4
    2016:	b.n	1fe0 <Encoder::isr12()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2018:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    201a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    201e:	subs	r3, #2
    2020:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    2022:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2024:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    2026:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    202a:	adds	r3, #2
    202c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    202e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2030:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    2032:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2036:	adds	r3, #1
    2038:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT11_PIN
	static void isr11(void) { update(interruptArgs[11]); }
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
    203a:	bx	lr
    203c:	.word	0x20057ee8

00002040 <Encoder::isr13()>:
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    2040:	ldr	r3, [pc, #128]	; (20c4 <Encoder::isr13()+0x84>)
    2042:	ldr	r2, [r3, #52]	; 0x34
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2044:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2046:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2048:	ldr	r1, [r3, #0]
    204a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    204c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    204e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2050:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2052:	ldr	r0, [r2, #12]
    2054:	tst	r4, r0
    2056:	beq.n	2090 <Encoder::isr13()+0x50>
		uint8_t state = arg->state & 3;
    2058:	ldrb	r3, [r2, #16]
    205a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    205e:	cbz	r1, 2064 <Encoder::isr13()+0x24>
    2060:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2064:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2068:	asrs	r1, r3, #2
		switch (state) {
    206a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    206c:	strb	r1, [r2, #16]
		switch (state) {
    206e:	cmp	r3, #13
    2070:	bhi.n	208a <Encoder::isr13()+0x4a>
    2072:	tbb	[pc, r3]
    2076:	.short	0x0721
    2078:	.word	0x150a071b
    207c:	.word	0x0a152121
    2080:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2084:	ldr	r3, [r2, #20]
    2086:	subs	r3, #1
    2088:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    208a:	ldr.w	r4, [sp], #4
    208e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2090:	ldrb	r3, [r2, #16]
    2092:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2096:	cmp	r1, #0
    2098:	beq.n	2068 <Encoder::isr13()+0x28>
    209a:	orr.w	r3, r3, #4
    209e:	b.n	2068 <Encoder::isr13()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    20a0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    20a2:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    20a6:	subs	r3, #2
    20a8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    20aa:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    20ac:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    20ae:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    20b2:	adds	r3, #2
    20b4:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    20b6:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    20b8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    20ba:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    20be:	adds	r3, #1
    20c0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT12_PIN
	static void isr12(void) { update(interruptArgs[12]); }
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
    20c2:	bx	lr
    20c4:	.word	0x20057ee8

000020c8 <Encoder::isr14()>:
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    20c8:	ldr	r3, [pc, #128]	; (214c <Encoder::isr14()+0x84>)
    20ca:	ldr	r2, [r3, #56]	; 0x38
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    20cc:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    20ce:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    20d0:	ldr	r1, [r3, #0]
    20d2:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    20d4:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    20d6:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    20d8:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    20da:	ldr	r0, [r2, #12]
    20dc:	tst	r4, r0
    20de:	beq.n	2118 <Encoder::isr14()+0x50>
		uint8_t state = arg->state & 3;
    20e0:	ldrb	r3, [r2, #16]
    20e2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    20e6:	cbz	r1, 20ec <Encoder::isr14()+0x24>
    20e8:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    20ec:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    20f0:	asrs	r1, r3, #2
		switch (state) {
    20f2:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    20f4:	strb	r1, [r2, #16]
		switch (state) {
    20f6:	cmp	r3, #13
    20f8:	bhi.n	2112 <Encoder::isr14()+0x4a>
    20fa:	tbb	[pc, r3]
    20fe:	.short	0x0721
    2100:	.word	0x150a071b
    2104:	.word	0x0a152121
    2108:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    210c:	ldr	r3, [r2, #20]
    210e:	subs	r3, #1
    2110:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    2112:	ldr.w	r4, [sp], #4
    2116:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2118:	ldrb	r3, [r2, #16]
    211a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    211e:	cmp	r1, #0
    2120:	beq.n	20f0 <Encoder::isr14()+0x28>
    2122:	orr.w	r3, r3, #4
    2126:	b.n	20f0 <Encoder::isr14()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2128:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    212a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    212e:	subs	r3, #2
    2130:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    2132:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2134:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    2136:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    213a:	adds	r3, #2
    213c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    213e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2140:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    2142:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2146:	adds	r3, #1
    2148:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT13_PIN
	static void isr13(void) { update(interruptArgs[13]); }
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
    214a:	bx	lr
    214c:	.word	0x20057ee8

00002150 <Encoder::isr15()>:
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    2150:	ldr	r3, [pc, #128]	; (21d4 <Encoder::isr15()+0x84>)
    2152:	ldr	r2, [r3, #60]	; 0x3c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2154:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2156:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2158:	ldr	r1, [r3, #0]
    215a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    215c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    215e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2160:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2162:	ldr	r0, [r2, #12]
    2164:	tst	r4, r0
    2166:	beq.n	21a0 <Encoder::isr15()+0x50>
		uint8_t state = arg->state & 3;
    2168:	ldrb	r3, [r2, #16]
    216a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    216e:	cbz	r1, 2174 <Encoder::isr15()+0x24>
    2170:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2174:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2178:	asrs	r1, r3, #2
		switch (state) {
    217a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    217c:	strb	r1, [r2, #16]
		switch (state) {
    217e:	cmp	r3, #13
    2180:	bhi.n	219a <Encoder::isr15()+0x4a>
    2182:	tbb	[pc, r3]
    2186:	.short	0x0721
    2188:	.word	0x150a071b
    218c:	.word	0x0a152121
    2190:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2194:	ldr	r3, [r2, #20]
    2196:	subs	r3, #1
    2198:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    219a:	ldr.w	r4, [sp], #4
    219e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    21a0:	ldrb	r3, [r2, #16]
    21a2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    21a6:	cmp	r1, #0
    21a8:	beq.n	2178 <Encoder::isr15()+0x28>
    21aa:	orr.w	r3, r3, #4
    21ae:	b.n	2178 <Encoder::isr15()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    21b0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    21b2:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    21b6:	subs	r3, #2
    21b8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    21ba:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    21bc:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    21be:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    21c2:	adds	r3, #2
    21c4:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    21c6:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    21c8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    21ca:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    21ce:	adds	r3, #1
    21d0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT14_PIN
	static void isr14(void) { update(interruptArgs[14]); }
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
    21d2:	bx	lr
    21d4:	.word	0x20057ee8

000021d8 <Encoder::isr16()>:
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    21d8:	ldr	r3, [pc, #128]	; (225c <Encoder::isr16()+0x84>)
    21da:	ldr	r2, [r3, #64]	; 0x40
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    21dc:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    21de:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    21e0:	ldr	r1, [r3, #0]
    21e2:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    21e4:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    21e6:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    21e8:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    21ea:	ldr	r0, [r2, #12]
    21ec:	tst	r4, r0
    21ee:	beq.n	2228 <Encoder::isr16()+0x50>
		uint8_t state = arg->state & 3;
    21f0:	ldrb	r3, [r2, #16]
    21f2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    21f6:	cbz	r1, 21fc <Encoder::isr16()+0x24>
    21f8:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    21fc:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2200:	asrs	r1, r3, #2
		switch (state) {
    2202:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2204:	strb	r1, [r2, #16]
		switch (state) {
    2206:	cmp	r3, #13
    2208:	bhi.n	2222 <Encoder::isr16()+0x4a>
    220a:	tbb	[pc, r3]
    220e:	.short	0x0721
    2210:	.word	0x150a071b
    2214:	.word	0x0a152121
    2218:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    221c:	ldr	r3, [r2, #20]
    221e:	subs	r3, #1
    2220:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    2222:	ldr.w	r4, [sp], #4
    2226:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2228:	ldrb	r3, [r2, #16]
    222a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    222e:	cmp	r1, #0
    2230:	beq.n	2200 <Encoder::isr16()+0x28>
    2232:	orr.w	r3, r3, #4
    2236:	b.n	2200 <Encoder::isr16()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2238:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    223a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    223e:	subs	r3, #2
    2240:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    2242:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2244:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    2246:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    224a:	adds	r3, #2
    224c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    224e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2250:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    2252:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2256:	adds	r3, #1
    2258:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT15_PIN
	static void isr15(void) { update(interruptArgs[15]); }
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
    225a:	bx	lr
    225c:	.word	0x20057ee8

00002260 <Encoder::isr17()>:
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    2260:	ldr	r3, [pc, #128]	; (22e4 <Encoder::isr17()+0x84>)
    2262:	ldr	r2, [r3, #68]	; 0x44
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2264:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2266:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2268:	ldr	r1, [r3, #0]
    226a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    226c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    226e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2270:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2272:	ldr	r0, [r2, #12]
    2274:	tst	r4, r0
    2276:	beq.n	22b0 <Encoder::isr17()+0x50>
		uint8_t state = arg->state & 3;
    2278:	ldrb	r3, [r2, #16]
    227a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    227e:	cbz	r1, 2284 <Encoder::isr17()+0x24>
    2280:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2284:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2288:	asrs	r1, r3, #2
		switch (state) {
    228a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    228c:	strb	r1, [r2, #16]
		switch (state) {
    228e:	cmp	r3, #13
    2290:	bhi.n	22aa <Encoder::isr17()+0x4a>
    2292:	tbb	[pc, r3]
    2296:	.short	0x0721
    2298:	.word	0x150a071b
    229c:	.word	0x0a152121
    22a0:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    22a4:	ldr	r3, [r2, #20]
    22a6:	subs	r3, #1
    22a8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22aa:	ldr.w	r4, [sp], #4
    22ae:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    22b0:	ldrb	r3, [r2, #16]
    22b2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    22b6:	cmp	r1, #0
    22b8:	beq.n	2288 <Encoder::isr17()+0x28>
    22ba:	orr.w	r3, r3, #4
    22be:	b.n	2288 <Encoder::isr17()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    22c0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22c2:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    22c6:	subs	r3, #2
    22c8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22ca:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    22cc:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22ce:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    22d2:	adds	r3, #2
    22d4:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22d6:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    22d8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22da:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    22de:	adds	r3, #1
    22e0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT16_PIN
	static void isr16(void) { update(interruptArgs[16]); }
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
    22e2:	bx	lr
    22e4:	.word	0x20057ee8

000022e8 <Encoder::isr18()>:
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    22e8:	ldr	r3, [pc, #128]	; (236c <Encoder::isr18()+0x84>)
    22ea:	ldr	r2, [r3, #72]	; 0x48
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    22ec:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    22ee:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    22f0:	ldr	r1, [r3, #0]
    22f2:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    22f4:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    22f6:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    22f8:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    22fa:	ldr	r0, [r2, #12]
    22fc:	tst	r4, r0
    22fe:	beq.n	2338 <Encoder::isr18()+0x50>
		uint8_t state = arg->state & 3;
    2300:	ldrb	r3, [r2, #16]
    2302:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2306:	cbz	r1, 230c <Encoder::isr18()+0x24>
    2308:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    230c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2310:	asrs	r1, r3, #2
		switch (state) {
    2312:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2314:	strb	r1, [r2, #16]
		switch (state) {
    2316:	cmp	r3, #13
    2318:	bhi.n	2332 <Encoder::isr18()+0x4a>
    231a:	tbb	[pc, r3]
    231e:	.short	0x0721
    2320:	.word	0x150a071b
    2324:	.word	0x0a152121
    2328:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    232c:	ldr	r3, [r2, #20]
    232e:	subs	r3, #1
    2330:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    2332:	ldr.w	r4, [sp], #4
    2336:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2338:	ldrb	r3, [r2, #16]
    233a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    233e:	cmp	r1, #0
    2340:	beq.n	2310 <Encoder::isr18()+0x28>
    2342:	orr.w	r3, r3, #4
    2346:	b.n	2310 <Encoder::isr18()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2348:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    234a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    234e:	subs	r3, #2
    2350:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    2352:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2354:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    2356:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    235a:	adds	r3, #2
    235c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    235e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2360:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    2362:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2366:	adds	r3, #1
    2368:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT17_PIN
	static void isr17(void) { update(interruptArgs[17]); }
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
    236a:	bx	lr
    236c:	.word	0x20057ee8

00002370 <Encoder::isr19()>:
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    2370:	ldr	r3, [pc, #128]	; (23f4 <Encoder::isr19()+0x84>)
    2372:	ldr	r2, [r3, #76]	; 0x4c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2374:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2376:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2378:	ldr	r1, [r3, #0]
    237a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    237c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    237e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2380:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2382:	ldr	r0, [r2, #12]
    2384:	tst	r4, r0
    2386:	beq.n	23c0 <Encoder::isr19()+0x50>
		uint8_t state = arg->state & 3;
    2388:	ldrb	r3, [r2, #16]
    238a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    238e:	cbz	r1, 2394 <Encoder::isr19()+0x24>
    2390:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2394:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2398:	asrs	r1, r3, #2
		switch (state) {
    239a:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    239c:	strb	r1, [r2, #16]
		switch (state) {
    239e:	cmp	r3, #13
    23a0:	bhi.n	23ba <Encoder::isr19()+0x4a>
    23a2:	tbb	[pc, r3]
    23a6:	.short	0x0721
    23a8:	.word	0x150a071b
    23ac:	.word	0x0a152121
    23b0:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    23b4:	ldr	r3, [r2, #20]
    23b6:	subs	r3, #1
    23b8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23ba:	ldr.w	r4, [sp], #4
    23be:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    23c0:	ldrb	r3, [r2, #16]
    23c2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    23c6:	cmp	r1, #0
    23c8:	beq.n	2398 <Encoder::isr19()+0x28>
    23ca:	orr.w	r3, r3, #4
    23ce:	b.n	2398 <Encoder::isr19()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    23d0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23d2:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    23d6:	subs	r3, #2
    23d8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23da:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    23dc:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23de:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    23e2:	adds	r3, #2
    23e4:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23e6:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    23e8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23ea:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    23ee:	adds	r3, #1
    23f0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT18_PIN
	static void isr18(void) { update(interruptArgs[18]); }
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
    23f2:	bx	lr
    23f4:	.word	0x20057ee8

000023f8 <Encoder::isr20()>:
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    23f8:	ldr	r3, [pc, #128]	; (247c <Encoder::isr20()+0x84>)
    23fa:	ldr	r2, [r3, #80]	; 0x50
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    23fc:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    23fe:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2400:	ldr	r1, [r3, #0]
    2402:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    2404:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2406:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2408:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    240a:	ldr	r0, [r2, #12]
    240c:	tst	r4, r0
    240e:	beq.n	2448 <Encoder::isr20()+0x50>
		uint8_t state = arg->state & 3;
    2410:	ldrb	r3, [r2, #16]
    2412:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2416:	cbz	r1, 241c <Encoder::isr20()+0x24>
    2418:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    241c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2420:	asrs	r1, r3, #2
		switch (state) {
    2422:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2424:	strb	r1, [r2, #16]
		switch (state) {
    2426:	cmp	r3, #13
    2428:	bhi.n	2442 <Encoder::isr20()+0x4a>
    242a:	tbb	[pc, r3]
    242e:	.short	0x0721
    2430:	.word	0x150a071b
    2434:	.word	0x0a152121
    2438:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    243c:	ldr	r3, [r2, #20]
    243e:	subs	r3, #1
    2440:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    2442:	ldr.w	r4, [sp], #4
    2446:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2448:	ldrb	r3, [r2, #16]
    244a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    244e:	cmp	r1, #0
    2450:	beq.n	2420 <Encoder::isr20()+0x28>
    2452:	orr.w	r3, r3, #4
    2456:	b.n	2420 <Encoder::isr20()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2458:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    245a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    245e:	subs	r3, #2
    2460:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    2462:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2464:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    2466:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    246a:	adds	r3, #2
    246c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    246e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2470:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    2472:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2476:	adds	r3, #1
    2478:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT19_PIN
	static void isr19(void) { update(interruptArgs[19]); }
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
    247a:	bx	lr
    247c:	.word	0x20057ee8

00002480 <Encoder::isr21()>:
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    2480:	ldr	r3, [pc, #128]	; (2504 <Encoder::isr21()+0x84>)
    2482:	ldr	r2, [r3, #84]	; 0x54
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2484:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2486:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2488:	ldr	r1, [r3, #0]
    248a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    248c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    248e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2490:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2492:	ldr	r0, [r2, #12]
    2494:	tst	r4, r0
    2496:	beq.n	24d0 <Encoder::isr21()+0x50>
		uint8_t state = arg->state & 3;
    2498:	ldrb	r3, [r2, #16]
    249a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    249e:	cbz	r1, 24a4 <Encoder::isr21()+0x24>
    24a0:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    24a4:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    24a8:	asrs	r1, r3, #2
		switch (state) {
    24aa:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    24ac:	strb	r1, [r2, #16]
		switch (state) {
    24ae:	cmp	r3, #13
    24b0:	bhi.n	24ca <Encoder::isr21()+0x4a>
    24b2:	tbb	[pc, r3]
    24b6:	.short	0x0721
    24b8:	.word	0x150a071b
    24bc:	.word	0x0a152121
    24c0:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    24c4:	ldr	r3, [r2, #20]
    24c6:	subs	r3, #1
    24c8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    24ca:	ldr.w	r4, [sp], #4
    24ce:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    24d0:	ldrb	r3, [r2, #16]
    24d2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    24d6:	cmp	r1, #0
    24d8:	beq.n	24a8 <Encoder::isr21()+0x28>
    24da:	orr.w	r3, r3, #4
    24de:	b.n	24a8 <Encoder::isr21()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    24e0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    24e2:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    24e6:	subs	r3, #2
    24e8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    24ea:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    24ec:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    24ee:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    24f2:	adds	r3, #2
    24f4:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    24f6:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    24f8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    24fa:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    24fe:	adds	r3, #1
    2500:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT20_PIN
	static void isr20(void) { update(interruptArgs[20]); }
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
    2502:	bx	lr
    2504:	.word	0x20057ee8

00002508 <Encoder::isr22()>:
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    2508:	ldr	r3, [pc, #128]	; (258c <Encoder::isr22()+0x84>)
    250a:	ldr	r2, [r3, #88]	; 0x58
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    250c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    250e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2510:	ldr	r1, [r3, #0]
    2512:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    2514:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2516:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2518:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    251a:	ldr	r0, [r2, #12]
    251c:	tst	r4, r0
    251e:	beq.n	2558 <Encoder::isr22()+0x50>
		uint8_t state = arg->state & 3;
    2520:	ldrb	r3, [r2, #16]
    2522:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2526:	cbz	r1, 252c <Encoder::isr22()+0x24>
    2528:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    252c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2530:	asrs	r1, r3, #2
		switch (state) {
    2532:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2534:	strb	r1, [r2, #16]
		switch (state) {
    2536:	cmp	r3, #13
    2538:	bhi.n	2552 <Encoder::isr22()+0x4a>
    253a:	tbb	[pc, r3]
    253e:	.short	0x0721
    2540:	.word	0x150a071b
    2544:	.word	0x0a152121
    2548:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    254c:	ldr	r3, [r2, #20]
    254e:	subs	r3, #1
    2550:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    2552:	ldr.w	r4, [sp], #4
    2556:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2558:	ldrb	r3, [r2, #16]
    255a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    255e:	cmp	r1, #0
    2560:	beq.n	2530 <Encoder::isr22()+0x28>
    2562:	orr.w	r3, r3, #4
    2566:	b.n	2530 <Encoder::isr22()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2568:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    256a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    256e:	subs	r3, #2
    2570:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    2572:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2574:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    2576:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    257a:	adds	r3, #2
    257c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    257e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2580:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    2582:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2586:	adds	r3, #1
    2588:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT21_PIN
	static void isr21(void) { update(interruptArgs[21]); }
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
    258a:	bx	lr
    258c:	.word	0x20057ee8

00002590 <Encoder::isr23()>:
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    2590:	ldr	r3, [pc, #128]	; (2614 <Encoder::isr23()+0x84>)
    2592:	ldr	r2, [r3, #92]	; 0x5c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2594:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2596:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2598:	ldr	r1, [r3, #0]
    259a:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    259c:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    259e:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    25a0:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    25a2:	ldr	r0, [r2, #12]
    25a4:	tst	r4, r0
    25a6:	beq.n	25e0 <Encoder::isr23()+0x50>
		uint8_t state = arg->state & 3;
    25a8:	ldrb	r3, [r2, #16]
    25aa:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    25ae:	cbz	r1, 25b4 <Encoder::isr23()+0x24>
    25b0:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    25b4:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    25b8:	asrs	r1, r3, #2
		switch (state) {
    25ba:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    25bc:	strb	r1, [r2, #16]
		switch (state) {
    25be:	cmp	r3, #13
    25c0:	bhi.n	25da <Encoder::isr23()+0x4a>
    25c2:	tbb	[pc, r3]
    25c6:	.short	0x0721
    25c8:	.word	0x150a071b
    25cc:	.word	0x0a152121
    25d0:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    25d4:	ldr	r3, [r2, #20]
    25d6:	subs	r3, #1
    25d8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    25da:	ldr.w	r4, [sp], #4
    25de:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    25e0:	ldrb	r3, [r2, #16]
    25e2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    25e6:	cmp	r1, #0
    25e8:	beq.n	25b8 <Encoder::isr23()+0x28>
    25ea:	orr.w	r3, r3, #4
    25ee:	b.n	25b8 <Encoder::isr23()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    25f0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    25f2:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    25f6:	subs	r3, #2
    25f8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    25fa:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    25fc:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    25fe:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2602:	adds	r3, #2
    2604:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    2606:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2608:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    260a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    260e:	adds	r3, #1
    2610:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT22_PIN
	static void isr22(void) { update(interruptArgs[22]); }
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
    2612:	bx	lr
    2614:	.word	0x20057ee8

00002618 <Encoder::isr24()>:
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    2618:	ldr	r3, [pc, #128]	; (269c <Encoder::isr24()+0x84>)
    261a:	ldr	r2, [r3, #96]	; 0x60
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    261c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    261e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2620:	ldr	r1, [r3, #0]
    2622:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    2624:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2626:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2628:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    262a:	ldr	r0, [r2, #12]
    262c:	tst	r4, r0
    262e:	beq.n	2668 <Encoder::isr24()+0x50>
		uint8_t state = arg->state & 3;
    2630:	ldrb	r3, [r2, #16]
    2632:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2636:	cbz	r1, 263c <Encoder::isr24()+0x24>
    2638:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    263c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2640:	asrs	r1, r3, #2
		switch (state) {
    2642:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2644:	strb	r1, [r2, #16]
		switch (state) {
    2646:	cmp	r3, #13
    2648:	bhi.n	2662 <Encoder::isr24()+0x4a>
    264a:	tbb	[pc, r3]
    264e:	.short	0x0721
    2650:	.word	0x150a071b
    2654:	.word	0x0a152121
    2658:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    265c:	ldr	r3, [r2, #20]
    265e:	subs	r3, #1
    2660:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    2662:	ldr.w	r4, [sp], #4
    2666:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2668:	ldrb	r3, [r2, #16]
    266a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    266e:	cmp	r1, #0
    2670:	beq.n	2640 <Encoder::isr24()+0x28>
    2672:	orr.w	r3, r3, #4
    2676:	b.n	2640 <Encoder::isr24()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2678:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    267a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    267e:	subs	r3, #2
    2680:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    2682:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2684:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    2686:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    268a:	adds	r3, #2
    268c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    268e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2690:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    2692:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2696:	adds	r3, #1
    2698:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT23_PIN
	static void isr23(void) { update(interruptArgs[23]); }
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
    269a:	bx	lr
    269c:	.word	0x20057ee8

000026a0 <Encoder::isr25()>:
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    26a0:	ldr	r3, [pc, #128]	; (2724 <Encoder::isr25()+0x84>)
    26a2:	ldr	r2, [r3, #100]	; 0x64
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    26a4:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    26a6:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    26a8:	ldr	r1, [r3, #0]
    26aa:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    26ac:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    26ae:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    26b0:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    26b2:	ldr	r0, [r2, #12]
    26b4:	tst	r4, r0
    26b6:	beq.n	26f0 <Encoder::isr25()+0x50>
		uint8_t state = arg->state & 3;
    26b8:	ldrb	r3, [r2, #16]
    26ba:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    26be:	cbz	r1, 26c4 <Encoder::isr25()+0x24>
    26c0:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    26c4:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    26c8:	asrs	r1, r3, #2
		switch (state) {
    26ca:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    26cc:	strb	r1, [r2, #16]
		switch (state) {
    26ce:	cmp	r3, #13
    26d0:	bhi.n	26ea <Encoder::isr25()+0x4a>
    26d2:	tbb	[pc, r3]
    26d6:	.short	0x0721
    26d8:	.word	0x150a071b
    26dc:	.word	0x0a152121
    26e0:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    26e4:	ldr	r3, [r2, #20]
    26e6:	subs	r3, #1
    26e8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    26ea:	ldr.w	r4, [sp], #4
    26ee:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    26f0:	ldrb	r3, [r2, #16]
    26f2:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    26f6:	cmp	r1, #0
    26f8:	beq.n	26c8 <Encoder::isr25()+0x28>
    26fa:	orr.w	r3, r3, #4
    26fe:	b.n	26c8 <Encoder::isr25()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2700:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    2702:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2706:	subs	r3, #2
    2708:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    270a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    270c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    270e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2712:	adds	r3, #2
    2714:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    2716:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2718:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    271a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    271e:	adds	r3, #1
    2720:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT24_PIN
	static void isr24(void) { update(interruptArgs[24]); }
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
    2722:	bx	lr
    2724:	.word	0x20057ee8

00002728 <Encoder::isr26()>:
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    2728:	ldr	r3, [pc, #128]	; (27ac <Encoder::isr26()+0x84>)
    272a:	ldr	r2, [r3, #104]	; 0x68
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    272c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    272e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2730:	ldr	r1, [r3, #0]
    2732:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    2734:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2736:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2738:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    273a:	ldr	r0, [r2, #12]
    273c:	tst	r4, r0
    273e:	beq.n	2778 <Encoder::isr26()+0x50>
		uint8_t state = arg->state & 3;
    2740:	ldrb	r3, [r2, #16]
    2742:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2746:	cbz	r1, 274c <Encoder::isr26()+0x24>
    2748:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    274c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2750:	asrs	r1, r3, #2
		switch (state) {
    2752:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2754:	strb	r1, [r2, #16]
		switch (state) {
    2756:	cmp	r3, #13
    2758:	bhi.n	2772 <Encoder::isr26()+0x4a>
    275a:	tbb	[pc, r3]
    275e:	.short	0x0721
    2760:	.word	0x150a071b
    2764:	.word	0x0a152121
    2768:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    276c:	ldr	r3, [r2, #20]
    276e:	subs	r3, #1
    2770:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    2772:	ldr.w	r4, [sp], #4
    2776:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2778:	ldrb	r3, [r2, #16]
    277a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    277e:	cmp	r1, #0
    2780:	beq.n	2750 <Encoder::isr26()+0x28>
    2782:	orr.w	r3, r3, #4
    2786:	b.n	2750 <Encoder::isr26()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2788:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    278a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    278e:	subs	r3, #2
    2790:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    2792:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2794:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    2796:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    279a:	adds	r3, #2
    279c:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    279e:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    27a0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    27a2:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    27a6:	adds	r3, #1
    27a8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT25_PIN
	static void isr25(void) { update(interruptArgs[25]); }
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
    27aa:	bx	lr
    27ac:	.word	0x20057ee8

000027b0 <Encoder::isr27()>:
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    27b0:	ldr	r3, [pc, #128]	; (2834 <Encoder::isr27()+0x84>)
    27b2:	ldr	r2, [r3, #108]	; 0x6c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    27b4:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    27b6:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    27b8:	ldr	r1, [r3, #0]
    27ba:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    27bc:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    27be:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    27c0:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    27c2:	ldr	r0, [r2, #12]
    27c4:	tst	r4, r0
    27c6:	beq.n	2800 <Encoder::isr27()+0x50>
		uint8_t state = arg->state & 3;
    27c8:	ldrb	r3, [r2, #16]
    27ca:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    27ce:	cbz	r1, 27d4 <Encoder::isr27()+0x24>
    27d0:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    27d4:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    27d8:	asrs	r1, r3, #2
		switch (state) {
    27da:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    27dc:	strb	r1, [r2, #16]
		switch (state) {
    27de:	cmp	r3, #13
    27e0:	bhi.n	27fa <Encoder::isr27()+0x4a>
    27e2:	tbb	[pc, r3]
    27e6:	.short	0x0721
    27e8:	.word	0x150a071b
    27ec:	.word	0x0a152121
    27f0:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    27f4:	ldr	r3, [r2, #20]
    27f6:	subs	r3, #1
    27f8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    27fa:	ldr.w	r4, [sp], #4
    27fe:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2800:	ldrb	r3, [r2, #16]
    2802:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2806:	cmp	r1, #0
    2808:	beq.n	27d8 <Encoder::isr27()+0x28>
    280a:	orr.w	r3, r3, #4
    280e:	b.n	27d8 <Encoder::isr27()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2810:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    2812:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2816:	subs	r3, #2
    2818:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    281a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    281c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    281e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2822:	adds	r3, #2
    2824:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    2826:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2828:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    282a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    282e:	adds	r3, #1
    2830:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT26_PIN
	static void isr26(void) { update(interruptArgs[26]); }
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
    2832:	bx	lr
    2834:	.word	0x20057ee8

00002838 <Encoder::isr28()>:
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    2838:	ldr	r3, [pc, #128]	; (28bc <Encoder::isr28()+0x84>)
    283a:	ldr	r2, [r3, #112]	; 0x70
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    283c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    283e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2840:	ldr	r1, [r3, #0]
    2842:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    2844:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2846:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2848:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    284a:	ldr	r0, [r2, #12]
    284c:	tst	r4, r0
    284e:	beq.n	2888 <Encoder::isr28()+0x50>
		uint8_t state = arg->state & 3;
    2850:	ldrb	r3, [r2, #16]
    2852:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2856:	cbz	r1, 285c <Encoder::isr28()+0x24>
    2858:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    285c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2860:	asrs	r1, r3, #2
		switch (state) {
    2862:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2864:	strb	r1, [r2, #16]
		switch (state) {
    2866:	cmp	r3, #13
    2868:	bhi.n	2882 <Encoder::isr28()+0x4a>
    286a:	tbb	[pc, r3]
    286e:	.short	0x0721
    2870:	.word	0x150a071b
    2874:	.word	0x0a152121
    2878:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    287c:	ldr	r3, [r2, #20]
    287e:	subs	r3, #1
    2880:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    2882:	ldr.w	r4, [sp], #4
    2886:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2888:	ldrb	r3, [r2, #16]
    288a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    288e:	cmp	r1, #0
    2890:	beq.n	2860 <Encoder::isr28()+0x28>
    2892:	orr.w	r3, r3, #4
    2896:	b.n	2860 <Encoder::isr28()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2898:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    289a:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    289e:	subs	r3, #2
    28a0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    28a2:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    28a4:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    28a6:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    28aa:	adds	r3, #2
    28ac:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    28ae:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    28b0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    28b2:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    28b6:	adds	r3, #1
    28b8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT27_PIN
	static void isr27(void) { update(interruptArgs[27]); }
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
    28ba:	bx	lr
    28bc:	.word	0x20057ee8

000028c0 <Encoder::isr29()>:
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    28c0:	ldr	r3, [pc, #128]	; (2944 <Encoder::isr29()+0x84>)
    28c2:	ldr	r2, [r3, #116]	; 0x74
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    28c4:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    28c6:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    28c8:	ldr	r1, [r3, #0]
    28ca:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    28cc:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    28ce:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    28d0:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    28d2:	ldr	r0, [r2, #12]
    28d4:	tst	r4, r0
    28d6:	beq.n	2910 <Encoder::isr29()+0x50>
		uint8_t state = arg->state & 3;
    28d8:	ldrb	r3, [r2, #16]
    28da:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    28de:	cbz	r1, 28e4 <Encoder::isr29()+0x24>
    28e0:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    28e4:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    28e8:	asrs	r1, r3, #2
		switch (state) {
    28ea:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    28ec:	strb	r1, [r2, #16]
		switch (state) {
    28ee:	cmp	r3, #13
    28f0:	bhi.n	290a <Encoder::isr29()+0x4a>
    28f2:	tbb	[pc, r3]
    28f6:	.short	0x0721
    28f8:	.word	0x150a071b
    28fc:	.word	0x0a152121
    2900:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2904:	ldr	r3, [r2, #20]
    2906:	subs	r3, #1
    2908:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    290a:	ldr.w	r4, [sp], #4
    290e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2910:	ldrb	r3, [r2, #16]
    2912:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2916:	cmp	r1, #0
    2918:	beq.n	28e8 <Encoder::isr29()+0x28>
    291a:	orr.w	r3, r3, #4
    291e:	b.n	28e8 <Encoder::isr29()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2920:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    2922:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2926:	subs	r3, #2
    2928:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    292a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    292c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    292e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2932:	adds	r3, #2
    2934:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    2936:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2938:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    293a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    293e:	adds	r3, #1
    2940:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT28_PIN
	static void isr28(void) { update(interruptArgs[28]); }
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
    2942:	bx	lr
    2944:	.word	0x20057ee8

00002948 <Encoder::isr30()>:
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    2948:	ldr	r3, [pc, #128]	; (29cc <Encoder::isr30()+0x84>)
    294a:	ldr	r2, [r3, #120]	; 0x78
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    294c:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    294e:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2950:	ldr	r1, [r3, #0]
    2952:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    2954:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2956:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2958:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    295a:	ldr	r0, [r2, #12]
    295c:	tst	r4, r0
    295e:	beq.n	2998 <Encoder::isr30()+0x50>
		uint8_t state = arg->state & 3;
    2960:	ldrb	r3, [r2, #16]
    2962:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2966:	cbz	r1, 296c <Encoder::isr30()+0x24>
    2968:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    296c:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2970:	asrs	r1, r3, #2
		switch (state) {
    2972:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2974:	strb	r1, [r2, #16]
		switch (state) {
    2976:	cmp	r3, #13
    2978:	bhi.n	2992 <Encoder::isr30()+0x4a>
    297a:	tbb	[pc, r3]
    297e:	.short	0x0721
    2980:	.word	0x150a071b
    2984:	.word	0x0a152121
    2988:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    298c:	ldr	r3, [r2, #20]
    298e:	subs	r3, #1
    2990:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    2992:	ldr.w	r4, [sp], #4
    2996:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2998:	ldrb	r3, [r2, #16]
    299a:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    299e:	cmp	r1, #0
    29a0:	beq.n	2970 <Encoder::isr30()+0x28>
    29a2:	orr.w	r3, r3, #4
    29a6:	b.n	2970 <Encoder::isr30()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    29a8:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    29aa:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    29ae:	subs	r3, #2
    29b0:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    29b2:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    29b4:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    29b6:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    29ba:	adds	r3, #2
    29bc:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    29be:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    29c0:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    29c2:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    29c6:	adds	r3, #1
    29c8:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT29_PIN
	static void isr29(void) { update(interruptArgs[29]); }
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
    29ca:	bx	lr
    29cc:	.word	0x20057ee8

000029d0 <Encoder::isr31()>:
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    29d0:	ldr	r3, [pc, #128]	; (2a54 <Encoder::isr31()+0x84>)
    29d2:	ldr	r2, [r3, #124]	; 0x7c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    29d4:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    29d6:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    29d8:	ldr	r1, [r3, #0]
    29da:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    29dc:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    29de:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    29e0:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    29e2:	ldr	r0, [r2, #12]
    29e4:	tst	r4, r0
    29e6:	beq.n	2a20 <Encoder::isr31()+0x50>
		uint8_t state = arg->state & 3;
    29e8:	ldrb	r3, [r2, #16]
    29ea:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    29ee:	cbz	r1, 29f4 <Encoder::isr31()+0x24>
    29f0:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    29f4:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    29f8:	asrs	r1, r3, #2
		switch (state) {
    29fa:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    29fc:	strb	r1, [r2, #16]
		switch (state) {
    29fe:	cmp	r3, #13
    2a00:	bhi.n	2a1a <Encoder::isr31()+0x4a>
    2a02:	tbb	[pc, r3]
    2a06:	.short	0x0721
    2a08:	.word	0x150a071b
    2a0c:	.word	0x0a152121
    2a10:	.word	0x21071b07
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2a14:	ldr	r3, [r2, #20]
    2a16:	subs	r3, #1
    2a18:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a1a:	ldr.w	r4, [sp], #4
    2a1e:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2a20:	ldrb	r3, [r2, #16]
    2a22:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2a26:	cmp	r1, #0
    2a28:	beq.n	29f8 <Encoder::isr31()+0x28>
    2a2a:	orr.w	r3, r3, #4
    2a2e:	b.n	29f8 <Encoder::isr31()+0x28>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2a30:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a32:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2a36:	subs	r3, #2
    2a38:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a3a:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2a3c:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a3e:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2a42:	adds	r3, #2
    2a44:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a46:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2a48:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a4a:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2a4e:	adds	r3, #1
    2a50:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT30_PIN
	static void isr30(void) { update(interruptArgs[30]); }
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
    2a52:	bx	lr
    2a54:	.word	0x20057ee8

00002a58 <Encoder::isr32()>:
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2a58:	ldr	r3, [pc, #132]	; (2ae0 <Encoder::isr32()+0x88>)
    2a5a:	ldr.w	r2, [r3, #128]	; 0x80
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2a5e:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2a60:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2a62:	ldr	r1, [r3, #0]
    2a64:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2a66:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2a68:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2a6a:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2a6c:	ldr	r0, [r2, #12]
    2a6e:	tst	r4, r0
    2a70:	beq.n	2aaa <Encoder::isr32()+0x52>
		uint8_t state = arg->state & 3;
    2a72:	ldrb	r3, [r2, #16]
    2a74:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2a78:	cbz	r1, 2a7e <Encoder::isr32()+0x26>
    2a7a:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2a7e:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2a82:	asrs	r1, r3, #2
		switch (state) {
    2a84:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2a86:	strb	r1, [r2, #16]
		switch (state) {
    2a88:	cmp	r3, #13
    2a8a:	bhi.n	2aa4 <Encoder::isr32()+0x4c>
    2a8c:	tbb	[pc, r3]
    2a90:	.word	0x071b0721
    2a94:	.word	0x2121150a
    2a98:	.word	0x1b070a15
    2a9c:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2a9e:	ldr	r3, [r2, #20]
    2aa0:	subs	r3, #1
    2aa2:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2aa4:	ldr.w	r4, [sp], #4
    2aa8:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2aaa:	ldrb	r3, [r2, #16]
    2aac:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2ab0:	cmp	r1, #0
    2ab2:	beq.n	2a82 <Encoder::isr32()+0x2a>
    2ab4:	orr.w	r3, r3, #4
    2ab8:	b.n	2a82 <Encoder::isr32()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2aba:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2abc:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2ac0:	subs	r3, #2
    2ac2:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2ac4:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2ac6:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2ac8:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2acc:	adds	r3, #2
    2ace:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2ad0:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2ad2:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2ad4:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2ad8:	adds	r3, #1
    2ada:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT31_PIN
	static void isr31(void) { update(interruptArgs[31]); }
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
    2adc:	bx	lr
    2ade:	nop
    2ae0:	.word	0x20057ee8

00002ae4 <Encoder::isr33()>:
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2ae4:	ldr	r3, [pc, #132]	; (2b6c <Encoder::isr33()+0x88>)
    2ae6:	ldr.w	r2, [r3, #132]	; 0x84
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2aea:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2aec:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2aee:	ldr	r1, [r3, #0]
    2af0:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2af2:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2af4:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2af6:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2af8:	ldr	r0, [r2, #12]
    2afa:	tst	r4, r0
    2afc:	beq.n	2b36 <Encoder::isr33()+0x52>
		uint8_t state = arg->state & 3;
    2afe:	ldrb	r3, [r2, #16]
    2b00:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2b04:	cbz	r1, 2b0a <Encoder::isr33()+0x26>
    2b06:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2b0a:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2b0e:	asrs	r1, r3, #2
		switch (state) {
    2b10:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2b12:	strb	r1, [r2, #16]
		switch (state) {
    2b14:	cmp	r3, #13
    2b16:	bhi.n	2b30 <Encoder::isr33()+0x4c>
    2b18:	tbb	[pc, r3]
    2b1c:	.word	0x071b0721
    2b20:	.word	0x2121150a
    2b24:	.word	0x1b070a15
    2b28:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2b2a:	ldr	r3, [r2, #20]
    2b2c:	subs	r3, #1
    2b2e:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b30:	ldr.w	r4, [sp], #4
    2b34:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2b36:	ldrb	r3, [r2, #16]
    2b38:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2b3c:	cmp	r1, #0
    2b3e:	beq.n	2b0e <Encoder::isr33()+0x2a>
    2b40:	orr.w	r3, r3, #4
    2b44:	b.n	2b0e <Encoder::isr33()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2b46:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b48:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2b4c:	subs	r3, #2
    2b4e:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b50:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2b52:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b54:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2b58:	adds	r3, #2
    2b5a:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b5c:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2b5e:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b60:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2b64:	adds	r3, #1
    2b66:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT32_PIN
	static void isr32(void) { update(interruptArgs[32]); }
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
    2b68:	bx	lr
    2b6a:	nop
    2b6c:	.word	0x20057ee8

00002b70 <Encoder::isr34()>:
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2b70:	ldr	r3, [pc, #132]	; (2bf8 <Encoder::isr34()+0x88>)
    2b72:	ldr.w	r2, [r3, #136]	; 0x88
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2b76:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2b78:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2b7a:	ldr	r1, [r3, #0]
    2b7c:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2b7e:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2b80:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2b82:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2b84:	ldr	r0, [r2, #12]
    2b86:	tst	r4, r0
    2b88:	beq.n	2bc2 <Encoder::isr34()+0x52>
		uint8_t state = arg->state & 3;
    2b8a:	ldrb	r3, [r2, #16]
    2b8c:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2b90:	cbz	r1, 2b96 <Encoder::isr34()+0x26>
    2b92:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2b96:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2b9a:	asrs	r1, r3, #2
		switch (state) {
    2b9c:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2b9e:	strb	r1, [r2, #16]
		switch (state) {
    2ba0:	cmp	r3, #13
    2ba2:	bhi.n	2bbc <Encoder::isr34()+0x4c>
    2ba4:	tbb	[pc, r3]
    2ba8:	.word	0x071b0721
    2bac:	.word	0x2121150a
    2bb0:	.word	0x1b070a15
    2bb4:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2bb6:	ldr	r3, [r2, #20]
    2bb8:	subs	r3, #1
    2bba:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2bbc:	ldr.w	r4, [sp], #4
    2bc0:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2bc2:	ldrb	r3, [r2, #16]
    2bc4:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2bc8:	cmp	r1, #0
    2bca:	beq.n	2b9a <Encoder::isr34()+0x2a>
    2bcc:	orr.w	r3, r3, #4
    2bd0:	b.n	2b9a <Encoder::isr34()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2bd2:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2bd4:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2bd8:	subs	r3, #2
    2bda:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2bdc:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2bde:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2be0:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2be4:	adds	r3, #2
    2be6:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2be8:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2bea:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2bec:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2bf0:	adds	r3, #1
    2bf2:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT33_PIN
	static void isr33(void) { update(interruptArgs[33]); }
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
    2bf4:	bx	lr
    2bf6:	nop
    2bf8:	.word	0x20057ee8

00002bfc <Encoder::isr35()>:
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2bfc:	ldr	r3, [pc, #132]	; (2c84 <Encoder::isr35()+0x88>)
    2bfe:	ldr.w	r2, [r3, #140]	; 0x8c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2c02:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2c04:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2c06:	ldr	r1, [r3, #0]
    2c08:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c0a:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2c0c:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2c0e:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2c10:	ldr	r0, [r2, #12]
    2c12:	tst	r4, r0
    2c14:	beq.n	2c4e <Encoder::isr35()+0x52>
		uint8_t state = arg->state & 3;
    2c16:	ldrb	r3, [r2, #16]
    2c18:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2c1c:	cbz	r1, 2c22 <Encoder::isr35()+0x26>
    2c1e:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2c22:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2c26:	asrs	r1, r3, #2
		switch (state) {
    2c28:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2c2a:	strb	r1, [r2, #16]
		switch (state) {
    2c2c:	cmp	r3, #13
    2c2e:	bhi.n	2c48 <Encoder::isr35()+0x4c>
    2c30:	tbb	[pc, r3]
    2c34:	.word	0x071b0721
    2c38:	.word	0x2121150a
    2c3c:	.word	0x1b070a15
    2c40:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2c42:	ldr	r3, [r2, #20]
    2c44:	subs	r3, #1
    2c46:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c48:	ldr.w	r4, [sp], #4
    2c4c:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2c4e:	ldrb	r3, [r2, #16]
    2c50:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2c54:	cmp	r1, #0
    2c56:	beq.n	2c26 <Encoder::isr35()+0x2a>
    2c58:	orr.w	r3, r3, #4
    2c5c:	b.n	2c26 <Encoder::isr35()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2c5e:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c60:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2c64:	subs	r3, #2
    2c66:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c68:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2c6a:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c6c:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2c70:	adds	r3, #2
    2c72:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c74:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2c76:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c78:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2c7c:	adds	r3, #1
    2c7e:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT34_PIN
	static void isr34(void) { update(interruptArgs[34]); }
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
    2c80:	bx	lr
    2c82:	nop
    2c84:	.word	0x20057ee8

00002c88 <Encoder::isr36()>:
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2c88:	ldr	r3, [pc, #132]	; (2d10 <Encoder::isr36()+0x88>)
    2c8a:	ldr.w	r2, [r3, #144]	; 0x90
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2c8e:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2c90:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2c92:	ldr	r1, [r3, #0]
    2c94:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2c96:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2c98:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2c9a:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2c9c:	ldr	r0, [r2, #12]
    2c9e:	tst	r4, r0
    2ca0:	beq.n	2cda <Encoder::isr36()+0x52>
		uint8_t state = arg->state & 3;
    2ca2:	ldrb	r3, [r2, #16]
    2ca4:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2ca8:	cbz	r1, 2cae <Encoder::isr36()+0x26>
    2caa:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2cae:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2cb2:	asrs	r1, r3, #2
		switch (state) {
    2cb4:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2cb6:	strb	r1, [r2, #16]
		switch (state) {
    2cb8:	cmp	r3, #13
    2cba:	bhi.n	2cd4 <Encoder::isr36()+0x4c>
    2cbc:	tbb	[pc, r3]
    2cc0:	.word	0x071b0721
    2cc4:	.word	0x2121150a
    2cc8:	.word	0x1b070a15
    2ccc:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2cce:	ldr	r3, [r2, #20]
    2cd0:	subs	r3, #1
    2cd2:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2cd4:	ldr.w	r4, [sp], #4
    2cd8:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2cda:	ldrb	r3, [r2, #16]
    2cdc:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2ce0:	cmp	r1, #0
    2ce2:	beq.n	2cb2 <Encoder::isr36()+0x2a>
    2ce4:	orr.w	r3, r3, #4
    2ce8:	b.n	2cb2 <Encoder::isr36()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2cea:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2cec:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2cf0:	subs	r3, #2
    2cf2:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2cf4:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2cf6:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2cf8:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2cfc:	adds	r3, #2
    2cfe:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2d00:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2d02:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2d04:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2d08:	adds	r3, #1
    2d0a:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT35_PIN
	static void isr35(void) { update(interruptArgs[35]); }
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
    2d0c:	bx	lr
    2d0e:	nop
    2d10:	.word	0x20057ee8

00002d14 <Encoder::isr37()>:
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d14:	ldr	r3, [pc, #132]	; (2d9c <Encoder::isr37()+0x88>)
    2d16:	ldr.w	r2, [r3, #148]	; 0x94
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2d1a:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2d1c:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2d1e:	ldr	r1, [r3, #0]
    2d20:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d22:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2d24:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2d26:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2d28:	ldr	r0, [r2, #12]
    2d2a:	tst	r4, r0
    2d2c:	beq.n	2d66 <Encoder::isr37()+0x52>
		uint8_t state = arg->state & 3;
    2d2e:	ldrb	r3, [r2, #16]
    2d30:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2d34:	cbz	r1, 2d3a <Encoder::isr37()+0x26>
    2d36:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2d3a:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2d3e:	asrs	r1, r3, #2
		switch (state) {
    2d40:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2d42:	strb	r1, [r2, #16]
		switch (state) {
    2d44:	cmp	r3, #13
    2d46:	bhi.n	2d60 <Encoder::isr37()+0x4c>
    2d48:	tbb	[pc, r3]
    2d4c:	.word	0x071b0721
    2d50:	.word	0x2121150a
    2d54:	.word	0x1b070a15
    2d58:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2d5a:	ldr	r3, [r2, #20]
    2d5c:	subs	r3, #1
    2d5e:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d60:	ldr.w	r4, [sp], #4
    2d64:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2d66:	ldrb	r3, [r2, #16]
    2d68:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2d6c:	cmp	r1, #0
    2d6e:	beq.n	2d3e <Encoder::isr37()+0x2a>
    2d70:	orr.w	r3, r3, #4
    2d74:	b.n	2d3e <Encoder::isr37()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2d76:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d78:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2d7c:	subs	r3, #2
    2d7e:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d80:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2d82:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d84:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2d88:	adds	r3, #2
    2d8a:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d8c:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2d8e:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d90:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2d94:	adds	r3, #1
    2d96:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT36_PIN
	static void isr36(void) { update(interruptArgs[36]); }
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
    2d98:	bx	lr
    2d9a:	nop
    2d9c:	.word	0x20057ee8

00002da0 <Encoder::isr38()>:
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2da0:	ldr	r3, [pc, #132]	; (2e28 <Encoder::isr38()+0x88>)
    2da2:	ldr.w	r2, [r3, #152]	; 0x98
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2da6:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2da8:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2daa:	ldr	r1, [r3, #0]
    2dac:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2dae:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2db0:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2db2:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2db4:	ldr	r0, [r2, #12]
    2db6:	tst	r4, r0
    2db8:	beq.n	2df2 <Encoder::isr38()+0x52>
		uint8_t state = arg->state & 3;
    2dba:	ldrb	r3, [r2, #16]
    2dbc:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2dc0:	cbz	r1, 2dc6 <Encoder::isr38()+0x26>
    2dc2:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2dc6:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2dca:	asrs	r1, r3, #2
		switch (state) {
    2dcc:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2dce:	strb	r1, [r2, #16]
		switch (state) {
    2dd0:	cmp	r3, #13
    2dd2:	bhi.n	2dec <Encoder::isr38()+0x4c>
    2dd4:	tbb	[pc, r3]
    2dd8:	.word	0x071b0721
    2ddc:	.word	0x2121150a
    2de0:	.word	0x1b070a15
    2de4:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2de6:	ldr	r3, [r2, #20]
    2de8:	subs	r3, #1
    2dea:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2dec:	ldr.w	r4, [sp], #4
    2df0:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2df2:	ldrb	r3, [r2, #16]
    2df4:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2df8:	cmp	r1, #0
    2dfa:	beq.n	2dca <Encoder::isr38()+0x2a>
    2dfc:	orr.w	r3, r3, #4
    2e00:	b.n	2dca <Encoder::isr38()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2e02:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2e04:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2e08:	subs	r3, #2
    2e0a:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2e0c:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2e0e:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2e10:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2e14:	adds	r3, #2
    2e16:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2e18:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2e1a:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2e1c:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2e20:	adds	r3, #1
    2e22:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT37_PIN
	static void isr37(void) { update(interruptArgs[37]); }
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
    2e24:	bx	lr
    2e26:	nop
    2e28:	.word	0x20057ee8

00002e2c <Encoder::isr39()>:
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2e2c:	ldr	r3, [pc, #132]	; (2eb4 <Encoder::isr39()+0x88>)
    2e2e:	ldr.w	r2, [r3, #156]	; 0x9c
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2e32:	ldr	r3, [r2, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2e34:	ldr	r0, [r2, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2e36:	ldr	r1, [r3, #0]
    2e38:	ldr	r3, [r2, #8]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2e3a:	push	{r4}
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2e3c:	ldr	r4, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    2e3e:	ands	r1, r3
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    2e40:	ldr	r0, [r2, #12]
    2e42:	tst	r4, r0
    2e44:	beq.n	2e7e <Encoder::isr39()+0x52>
		uint8_t state = arg->state & 3;
    2e46:	ldrb	r3, [r2, #16]
    2e48:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2e4c:	cbz	r1, 2e52 <Encoder::isr39()+0x26>
    2e4e:	orr.w	r3, r3, #4
		if (p2val) state |= 8;
    2e52:	orr.w	r3, r3, #8
		arg->state = (state >> 2);
    2e56:	asrs	r1, r3, #2
		switch (state) {
    2e58:	subs	r3, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    2e5a:	strb	r1, [r2, #16]
		switch (state) {
    2e5c:	cmp	r3, #13
    2e5e:	bhi.n	2e78 <Encoder::isr39()+0x4c>
    2e60:	tbb	[pc, r3]
    2e64:	.word	0x071b0721
    2e68:	.word	0x2121150a
    2e6c:	.word	0x1b070a15
    2e70:	.short	0x2107
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    2e72:	ldr	r3, [r2, #20]
    2e74:	subs	r3, #1
    2e76:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2e78:	ldr.w	r4, [sp], #4
    2e7c:	bx	lr
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    2e7e:	ldrb	r3, [r2, #16]
    2e80:	and.w	r3, r3, #3
		if (p1val) state |= 4;
    2e84:	cmp	r1, #0
    2e86:	beq.n	2e56 <Encoder::isr39()+0x2a>
    2e88:	orr.w	r3, r3, #4
    2e8c:	b.n	2e56 <Encoder::isr39()+0x2a>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2e8e:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2e90:	ldr.w	r4, [sp], #4
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    2e94:	subs	r3, #2
    2e96:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2e98:	bx	lr
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2e9a:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2e9c:	ldr.w	r4, [sp], #4
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    2ea0:	adds	r3, #2
    2ea2:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2ea4:	bx	lr
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2ea6:	ldr	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2ea8:	ldr.w	r4, [sp], #4
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    2eac:	adds	r3, #1
    2eae:	str	r3, [r2, #20]
	#endif
	#ifdef CORE_INT38_PIN
	static void isr38(void) { update(interruptArgs[38]); }
	#endif
	#ifdef CORE_INT39_PIN
	static void isr39(void) { update(interruptArgs[39]); }
    2eb0:	bx	lr
    2eb2:	nop
    2eb4:	.word	0x20057ee8

00002eb8 <HardwareControls::updateTeensySynth(unsigned char, int)>:
        }
    }
}

void HardwareControls::updateTeensySynth(uint8_t ctl, int value)
{
    2eb8:	push	{r4, lr}
    2eba:	vpush	{d8}
    2ebe:	sub	sp, #8
    2ec0:	mov	r4, r0
    2ec2:	str	r2, [sp, #4]
    switch (ctl)
    2ec4:	cmp	r1, #17
    2ec6:	bhi.w	335e <HardwareControls::updateTeensySynth(unsigned char, int)+0x4a6>
    2eca:	tbh	[pc, r1, lsl #1]
    2ece:	.short	0x001f
    2ed0:	.word	0x00530039
    2ed4:	.word	0x0087006d
    2ed8:	.word	0x00c600ac
    2edc:	.word	0x00fa00e0
    2ee0:	.word	0x02480248
    2ee4:	.word	0x013a011e
    2ee8:	.word	0x01880164
    2eec:	.word	0x022c01df
    2ef0:	.short	0x0012
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    2ef2:	ldrsh.w	r1, [r0, #122]	; 0x7a
    2ef6:	ldr	r0, [pc, #832]	; (3238 <HardwareControls::updateTeensySynth(unsigned char, int)+0x380>)
    2ef8:	bl	17984 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    2efc:	ldr	r0, [pc, #824]	; (3238 <HardwareControls::updateTeensySynth(unsigned char, int)+0x380>)
        break;
    }
    default:
        break;
    }
}
    2efe:	add	sp, #8
    2f00:	vpop	{d8}
    2f04:	ldmia.w	sp!, {r4, lr}
    2f08:	b.w	178e4 <Print::println()>
        break;
    case CTL_CHORUS_DEPTH:
        ts->setChorusDepth(((float)value / 1023.0f));
        break;
    case CTL_HARMONICS:
        ts->setOscillatorHarmonics((float)value / 1023.0f);
    2f0c:	vldr	s15, [sp, #4]
    2f10:	vldr	s14, [pc, #808]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    2f14:	vcvt.f32.s32	s13, s15
    2f18:	ldr	r2, [r0, #76]	; 0x4c
    2f1a:	vdiv.f32	s15, s13, s14
    }

    //Set oscillator parameter "harmonics". Affects all oscillators.
    inline void setOscillatorHarmonics(float harmonics)
    {
        CONSTRAIN(harmonics, 0.0f, 1.0f);
    2f1e:	vcmpe.f32	s15, #0.0
    2f22:	vmrs	APSR_nzcv, fpscr
    2f26:	bmi.w	339e <HardwareControls::updateTeensySynth(unsigned char, int)+0x4e6>
    2f2a:	vmov.f32	s14, #112	; 0x3f800000  1.0
    2f2e:	vcmp.f32	s15, s14
    2f32:	vmrs	APSR_nzcv, fpscr
    2f36:	it	gt
    2f38:	vmovgt.f32	s15, s14
        currentPatch.harmonics = harmonics;
    2f3c:	ldr	r3, [pc, #768]	; (3240 <HardwareControls::updateTeensySynth(unsigned char, int)+0x388>)
    2f3e:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_MORPH:
        ts->setOscillatorMorph((float)value / 1023.0f);
        break;
    case CTL_TIMBRE:
        ts->setOscillatorTimbre((float)value / 1023.0f);
    2f40:	vldr	s15, [sp, #4]
    2f44:	vldr	s14, [pc, #756]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    2f48:	vcvt.f32.s32	s13, s15
    2f4c:	ldr	r2, [r0, #76]	; 0x4c
    2f4e:	vdiv.f32	s15, s13, s14
    }

    //Set oscillator parameter "timbre". Affects all oscillators.
    inline void setOscillatorTimbre(float timbre)
    {
        CONSTRAIN(timbre, 0.0f, 1.0f);
    2f52:	vcmpe.f32	s15, #0.0
    2f56:	vmrs	APSR_nzcv, fpscr
    2f5a:	bmi.w	3398 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4e0>
    2f5e:	vmov.f32	s14, #112	; 0x3f800000  1.0
    2f62:	vcmp.f32	s15, s14
    2f66:	vmrs	APSR_nzcv, fpscr
    2f6a:	it	gt
    2f6c:	vmovgt.f32	s15, s14
        currentPatch.timbre = timbre;
    2f70:	ldr	r3, [pc, #720]	; (3244 <HardwareControls::updateTeensySynth(unsigned char, int)+0x38c>)
    2f72:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_HARMONICS:
        ts->setOscillatorHarmonics((float)value / 1023.0f);
        break;
    case CTL_MORPH:
        ts->setOscillatorMorph((float)value / 1023.0f);
    2f74:	vldr	s15, [sp, #4]
    2f78:	vldr	s14, [pc, #704]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    2f7c:	vcvt.f32.s32	s13, s15
    2f80:	ldr	r2, [r0, #76]	; 0x4c
    2f82:	vdiv.f32	s15, s13, s14
    }

    //Set oscillator parameter "morph". Affects all oscillators.
    inline void setOscillatorMorph(float morph)
    {
        CONSTRAIN(morph, 0.0f, 1.0f);
    2f86:	vcmpe.f32	s15, #0.0
    2f8a:	vmrs	APSR_nzcv, fpscr
    2f8e:	bmi.w	3392 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4da>
    2f92:	vmov.f32	s14, #112	; 0x3f800000  1.0
    2f96:	vcmp.f32	s15, s14
    2f9a:	vmrs	APSR_nzcv, fpscr
    2f9e:	it	gt
    2fa0:	vmovgt.f32	s15, s14
        currentPatch.morph = morph;
    2fa4:	ldr	r3, [pc, #672]	; (3248 <HardwareControls::updateTeensySynth(unsigned char, int)+0x390>)
    2fa6:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_LPG_COLOUR:
        ts->setLpgColour((float)value / 1023.0f);
        break;        
    case CTL_DECAY:
        ts->setOscillatorDecay((float)value / 1023.0f);
    2fa8:	vldr	s15, [sp, #4]
    2fac:	vldr	s14, [pc, #652]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    2fb0:	vcvt.f32.s32	s13, s15
    2fb4:	ldr	r2, [r0, #76]	; 0x4c
    2fb6:	vdiv.f32	s15, s13, s14
        return currentPatch.balance;
    }

    inline void setOscillatorDecay(float decay)
    {
        CONSTRAIN(decay, 0.0f, 1.0f);
    2fba:	vcmpe.f32	s15, #0.0
    2fbe:	vmrs	APSR_nzcv, fpscr
    2fc2:	bmi.w	3386 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4ce>
    2fc6:	vmov.f32	s14, #112	; 0x3f800000  1.0
    2fca:	vcmp.f32	s15, s14
    2fce:	vmrs	APSR_nzcv, fpscr
    2fd2:	it	gt
    2fd4:	vmovgt.f32	s15, s14
        currentPatch.decay = decay;
    2fd8:	ldr	r3, [pc, #624]	; (324c <HardwareControls::updateTeensySynth(unsigned char, int)+0x394>)
    2fda:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_TIMBRE:
        ts->setOscillatorTimbre((float)value / 1023.0f);
        break;
    case CTL_BALANCE:
        ts->setOscillatorBalance((float)value / 1023.0f);
    2fdc:	vldr	s15, [sp, #4]
    2fe0:	vldr	s14, [pc, #600]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    2fe4:	vcvt.f32.s32	s13, s15
    2fe8:	ldr	r2, [r0, #76]	; 0x4c
    2fea:	vdiv.f32	s15, s13, s14
        return currentPatch.morph;
    }

    inline void setOscillatorBalance(float balance)
    {
        CONSTRAIN(balance, 0.0f, 1.0f);
    2fee:	vcmpe.f32	s15, #0.0
    2ff2:	vmrs	APSR_nzcv, fpscr
    2ff6:	bmi.w	338c <HardwareControls::updateTeensySynth(unsigned char, int)+0x4d4>
    2ffa:	vmov.f32	s14, #112	; 0x3f800000  1.0
    2ffe:	vcmpe.f32	s15, s14
    3002:	vmrs	APSR_nzcv, fpscr
    3006:	ble.w	33dc <HardwareControls::updateTeensySynth(unsigned char, int)+0x524>
    300a:	vldr	s15, [pc, #580]	; 3250 <HardwareControls::updateTeensySynth(unsigned char, int)+0x398>
        balance = balance * OSC_LEVEL;
        currentPatch.balance = balance;
    300e:	ldr	r3, [pc, #580]	; (3254 <HardwareControls::updateTeensySynth(unsigned char, int)+0x39c>)
        updateOscillatorBalance();
    3010:	mov	r0, r2

    inline void setOscillatorBalance(float balance)
    {
        CONSTRAIN(balance, 0.0f, 1.0f);
        balance = balance * OSC_LEVEL;
        currentPatch.balance = balance;
    3012:	add	r3, r2
    3014:	vstr	s15, [r3]
        break;
    }
    default:
        break;
    }
}
    3018:	add	sp, #8
    301a:	vpop	{d8}
    301e:	ldmia.w	sp!, {r4, lr}
        updateOscillatorBalance();
    3022:	b.w	1850 <TeensySynth::updateOscillatorBalance()>
        break;
    case CTL_MORPHMOD_AMOUNT:
        ts->setMorphMod((float)value / 1023.0f);
        break;
    case CTL_LPG_COLOUR:
        ts->setLpgColour((float)value / 1023.0f);
    3026:	vldr	s15, [sp, #4]
    302a:	vldr	s14, [pc, #528]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    302e:	vcvt.f32.s32	s13, s15
    3032:	ldr	r2, [r0, #76]	; 0x4c
    3034:	vdiv.f32	s15, s13, s14
        return currentPatch.morphMod;
    }

    inline void setLpgColour(float lpgColour)
    {
        CONSTRAIN(lpgColour,0.0f,1.0f);
    3038:	vcmpe.f32	s15, #0.0
    303c:	vmrs	APSR_nzcv, fpscr
    3040:	bmi.w	33b6 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4fe>
    3044:	vmov.f32	s14, #112	; 0x3f800000  1.0
    3048:	vcmp.f32	s15, s14
    304c:	vmrs	APSR_nzcv, fpscr
    3050:	it	gt
    3052:	vmovgt.f32	s15, s14
        currentPatch.lpgColour = lpgColour;
    3056:	ldr	r3, [pc, #512]	; (3258 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3a0>)
    3058:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_ENC_2:
        Serial.println(currentCtlValue[CTL_ENC_2]);
        break;
    case CTL_FREQMOD_AMOUNT:
        ts->setFreqMod((float)value / 1023.0f);
    305a:	vldr	s15, [sp, #4]
    305e:	vldr	s14, [pc, #476]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    3062:	vcvt.f32.s32	s13, s15
    3066:	ldr	r2, [r0, #76]	; 0x4c
    3068:	vdiv.f32	s15, s13, s14
    }

    //Set frequency modulation amount. Range 0.0f-1.0f.
    inline void setFreqMod(float freqMod)
    {
        CONSTRAIN(freqMod,0.0f,1.0f);
    306c:	vcmpe.f32	s15, #0.0
    3070:	vmrs	APSR_nzcv, fpscr
    3074:	bmi.w	33b0 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4f8>
    3078:	vmov.f32	s14, #112	; 0x3f800000  1.0
    307c:	vcmp.f32	s15, s14
    3080:	vmrs	APSR_nzcv, fpscr
    3084:	it	gt
    3086:	vmovgt.f32	s15, s14
        currentPatch.freqMod = freqMod;
    308a:	ldr	r3, [pc, #464]	; (325c <HardwareControls::updateTeensySynth(unsigned char, int)+0x3a4>)
    308c:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_TIMBREMOD_AMOUNT:
        ts->setTimbreMod((float)value / 1023.0f);
    308e:	vldr	s15, [sp, #4]
    3092:	vldr	s14, [pc, #424]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    3096:	vcvt.f32.s32	s13, s15
    309a:	ldr	r2, [r0, #76]	; 0x4c
    309c:	vdiv.f32	s15, s13, s14
    }

    //Set timbre modulation amount. Range 0.0f-1.0f.
    inline void setTimbreMod(float timbreMod)
    {
        CONSTRAIN(timbreMod,0.0f,1.0f);
    30a0:	vcmpe.f32	s15, #0.0
    30a4:	vmrs	APSR_nzcv, fpscr
    30a8:	bmi.w	33c2 <HardwareControls::updateTeensySynth(unsigned char, int)+0x50a>
    30ac:	vmov.f32	s14, #112	; 0x3f800000  1.0
    30b0:	vcmp.f32	s15, s14
    30b4:	vmrs	APSR_nzcv, fpscr
    30b8:	it	gt
    30ba:	vmovgt.f32	s15, s14
        currentPatch.timbreMod = timbreMod;
    30be:	ldr	r3, [pc, #416]	; (3260 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3a8>)
    30c0:	b.n	30f4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23c>
        break;
    case CTL_MORPHMOD_AMOUNT:
        ts->setMorphMod((float)value / 1023.0f);
    30c2:	vldr	s15, [sp, #4]
    30c6:	vldr	s14, [pc, #372]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    30ca:	vcvt.f32.s32	s13, s15
    30ce:	ldr	r2, [r0, #76]	; 0x4c
    30d0:	vdiv.f32	s15, s13, s14
    }

    //Set morph modulation amount. Range 0.0f-1.0f.
    inline void setMorphMod(float morphMod)
    {
        CONSTRAIN(morphMod,0.0f,1.0f);
    30d4:	vcmpe.f32	s15, #0.0
    30d8:	vmrs	APSR_nzcv, fpscr
    30dc:	bmi.w	33bc <HardwareControls::updateTeensySynth(unsigned char, int)+0x504>
    30e0:	vmov.f32	s14, #112	; 0x3f800000  1.0
    30e4:	vcmp.f32	s15, s14
    30e8:	vmrs	APSR_nzcv, fpscr
    30ec:	it	gt
    30ee:	vmovgt.f32	s15, s14
        currentPatch.morphMod = morphMod;
    30f2:	ldr	r3, [pc, #368]	; (3264 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3ac>)

    //Set frequency modulation amount. Range 0.0f-1.0f.
    inline void setFreqMod(float freqMod)
    {
        CONSTRAIN(freqMod,0.0f,1.0f);
        currentPatch.freqMod = freqMod;
    30f4:	add	r3, r2
        updateOscillator();
    30f6:	mov	r0, r2

    //Set frequency modulation amount. Range 0.0f-1.0f.
    inline void setFreqMod(float freqMod)
    {
        CONSTRAIN(freqMod,0.0f,1.0f);
        currentPatch.freqMod = freqMod;
    30f8:	vstr	s15, [r3]
        break;
    }
    default:
        break;
    }
}
    30fc:	add	sp, #8
    30fe:	vpop	{d8}
    3102:	ldmia.w	sp!, {r4, lr}
        updateOscillator();
    3106:	b.w	1240 <TeensySynth::updateOscillator()>
        break;        
    case CTL_DECAY:
        ts->setOscillatorDecay((float)value / 1023.0f);
        break;
    case CTL_REV_SIZE:
        ts->setReverbSize((float)value / 1023.0f);
    310a:	vldr	s15, [sp, #4]
    310e:	vldr	s13, [pc, #300]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    3112:	vcvt.f32.s32	s12, s15
        return currentPatch.decay;
    }

    inline void setReverbSize(float size)
    {
        CONSTRAIN(size, 0.1f, 0.95f);
    3116:	vldr	s14, [pc, #336]	; 3268 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3b0>
    311a:	ldr	r2, [r0, #76]	; 0x4c
    311c:	vdiv.f32	s15, s12, s13
    3120:	vcmpe.f32	s15, s14
    3124:	vmrs	APSR_nzcv, fpscr
    3128:	bmi.w	3378 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4c0>
    312c:	vldr	s14, [pc, #316]	; 326c <HardwareControls::updateTeensySynth(unsigned char, int)+0x3b4>
    3130:	vcmp.f32	s15, s14
    3134:	vmrs	APSR_nzcv, fpscr
    3138:	it	gt
    313a:	vmovgt.f32	s15, s14
        currentPatch.reverbSize = size;
    313e:	ldr	r3, [pc, #304]	; (3270 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3b8>)
    3140:	b.n	31c8 <HardwareControls::updateTeensySynth(unsigned char, int)+0x310>
        break;
    case CTL_REV_DEPTH:
        ts->setReverbDepth(powf((value / 101.53), 3) / 1023.0f * MIX_LEVEL);
    3142:	vldr	s15, [sp, #4]
    3146:	vmov.f32	s1, #8	; 0x40400000  3.0
    314a:	ldr	r4, [r0, #76]	; 0x4c
    314c:	vcvt.f64.s32	d5, s15
    3150:	vldr	d6, [pc, #220]	; 3230 <HardwareControls::updateTeensySynth(unsigned char, int)+0x378>
    3154:	vdiv.f64	d7, d5, d6
    3158:	vcvt.f32.f64	s0, d7
    315c:	bl	18168 <powf>
    3160:	vldr	s14, [pc, #216]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    3164:	vldr	s15, [pc, #268]	; 3274 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3bc>
    3168:	vdiv.f32	s0, s0, s14
    316c:	vmul.f32	s0, s0, s15
        return currentPatch.reverbSize;
    }

    inline void setReverbDepth(float depth)
    {
        CONSTRAIN(depth, 0.0f, MIX_LEVEL);
    3170:	vcmpe.f32	s0, #0.0
    3174:	vmrs	APSR_nzcv, fpscr
    3178:	bmi.w	33aa <HardwareControls::updateTeensySynth(unsigned char, int)+0x4f2>
    317c:	vcmp.f32	s0, s15
    3180:	vmrs	APSR_nzcv, fpscr
    3184:	it	gt
    3186:	vmovgt.f32	s0, s15
        currentPatch.reverbDepth = depth;
    318a:	ldr	r3, [pc, #236]	; (3278 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3c0>)
        updateChorusAndReverb();
    318c:	mov	r0, r4
    }

    inline void setReverbDepth(float depth)
    {
        CONSTRAIN(depth, 0.0f, MIX_LEVEL);
        currentPatch.reverbDepth = depth;
    318e:	add	r3, r4
    3190:	vstr	s0, [r3]
    3194:	b.n	31d0 <HardwareControls::updateTeensySynth(unsigned char, int)+0x318>
        break;
    case CTL_CHORUS_DEPTH:
        ts->setChorusDepth(((float)value / 1023.0f));
    3196:	vldr	s15, [sp, #4]
    319a:	vldr	s14, [pc, #160]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    319e:	vcvt.f32.s32	s13, s15
    31a2:	ldr	r2, [r0, #76]	; 0x4c
    31a4:	vdiv.f32	s15, s13, s14
    }

    //Set chorus depth (mix%). Range 0.0f-1.0f.
    inline void setChorusDepth(float depth)
    {
        CONSTRAIN(depth, 0.0f, 1.0f);
    31a8:	vcmpe.f32	s15, #0.0
    31ac:	vmrs	APSR_nzcv, fpscr
    31b0:	bmi.w	33a4 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4ec>
    31b4:	vmov.f32	s14, #112	; 0x3f800000  1.0
    31b8:	vcmp.f32	s15, s14
    31bc:	vmrs	APSR_nzcv, fpscr
    31c0:	it	gt
    31c2:	vmovgt.f32	s15, s14
        currentPatch.chorusDepth = depth;
    31c6:	ldr	r3, [pc, #180]	; (327c <HardwareControls::updateTeensySynth(unsigned char, int)+0x3c4>)
    31c8:	add	r3, r2
        updateChorusAndReverb();
    31ca:	mov	r0, r2

    //Set chorus depth (mix%). Range 0.0f-1.0f.
    inline void setChorusDepth(float depth)
    {
        CONSTRAIN(depth, 0.0f, 1.0f);
        currentPatch.chorusDepth = depth;
    31cc:	vstr	s15, [r3]
        break;
    }
    default:
        break;
    }
}
    31d0:	add	sp, #8
    31d2:	vpop	{d8}
    31d6:	ldmia.w	sp!, {r4, lr}
        updateChorusAndReverb();
    31da:	b.w	188c <TeensySynth::updateChorusAndReverb()>
        ts->setFilterCutoff(new_cutoff);
        break;
    }
    case CTL_FLT_RESO:
    {
        float new_reso = ((float)value / 1023.0f) * 4.0f;
    31de:	vldr	s15, [sp, #4]
    31e2:	vmov.f32	s11, #16	; 0x40800000  4.0
    31e6:	vldr	s13, [pc, #84]	; 323c <HardwareControls::updateTeensySynth(unsigned char, int)+0x384>
    31ea:	vcvt.f32.s32	s15, s15
        if (ts->getFilterCutoff() > 10000 && new_reso > 3.0)
    31ee:	ldr	r2, [r0, #76]	; 0x4c
    31f0:	ldr	r3, [pc, #140]	; (3280 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3c8>)
        ts->setFilterCutoff(new_cutoff);
        break;
    }
    case CTL_FLT_RESO:
    {
        float new_reso = ((float)value / 1023.0f) * 4.0f;
    31f2:	vdiv.f32	s14, s15, s13
    31f6:	add	r3, r2
        if (ts->getFilterCutoff() > 10000 && new_reso > 3.0)
    31f8:	vldr	s13, [pc, #136]	; 3284 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3cc>
    31fc:	vldr	s12, [r3]
    3200:	vcmpe.f32	s12, s13
    3204:	vmrs	APSR_nzcv, fpscr
        ts->setFilterCutoff(new_cutoff);
        break;
    }
    case CTL_FLT_RESO:
    {
        float new_reso = ((float)value / 1023.0f) * 4.0f;
    3208:	vmul.f32	s15, s14, s11
        if (ts->getFilterCutoff() > 10000 && new_reso > 3.0)
    320c:	bgt.w	3366 <HardwareControls::updateTeensySynth(unsigned char, int)+0x4ae>
    }

    //Set lowpass filter resonance (Q value). Affects all oscillators. Range: 0.7f - 5.0f
    inline void setFilterResonance(float resonance)
    {
        CONSTRAIN(resonance, 0.1f, 10.0f);
    3210:	vldr	s14, [pc, #84]	; 3268 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3b0>
    3214:	vcmpe.f32	s15, s14
    3218:	vmrs	APSR_nzcv, fpscr
    321c:	bpl.w	33c8 <HardwareControls::updateTeensySynth(unsigned char, int)+0x510>
    3220:	vmov.f32	s15, s14
        currentPatch.filterResonance = resonance;
    3224:	ldr	r3, [pc, #96]	; (3288 <HardwareControls::updateTeensySynth(unsigned char, int)+0x3d0>)
        updateFilter();
    3226:	mov	r0, r2

    //Set lowpass filter resonance (Q value). Affects all oscillators. Range: 0.7f - 5.0f
    inline void setFilterResonance(float resonance)
    {
        CONSTRAIN(resonance, 0.1f, 10.0f);
        currentPatch.filterResonance = resonance;
    3228:	add	r3, r2
    322a:	vstr	s15, [r3]
    322e:	b.n	3318 <HardwareControls::updateTeensySynth(unsigned char, int)+0x460>
    3230:	.word	0x851eb852
    3234:	.word	0x405961eb
    3238:	.word	0x20020a88
    323c:	.word	0x447fc000
    3240:	.word	0x000365f8
    3244:	.word	0x000365fc
    3248:	.word	0x00036600
    324c:	.word	0x00036608
    3250:	.word	0x3f333333
    3254:	.word	0x00036604
    3258:	.word	0x00036610
    325c:	.word	0x00036614
    3260:	.word	0x00036618
    3264:	.word	0x0003661c
    3268:	.word	0x3dcccccd
    326c:	.word	0x3f733333
    3270:	.word	0x00036634
    3274:	.word	0x3f4ccccd
    3278:	.word	0x00036638
    327c:	.word	0x0003663c
    3280:	.word	0x00036620
    3284:	.word	0x461c4000
    3288:	.word	0x00036624
    case CTL_BALANCE:
        ts->setOscillatorBalance((float)value / 1023.0f);
        break;
    case CTL_FLT_CUTOFF:
    {
        float new_cutoff = 30 + 12 * powf((value / 101.53), 3);
    328c:	vldr	s15, [sp, #4]
    3290:	vmov.f32	s1, #8	; 0x40400000  3.0
    3294:	vmov.f32	s16, #62	; 0x41f00000  30.0
    3298:	vcvt.f64.s32	d5, s15
    329c:	vldr	d6, [pc, #328]	; 33e8 <HardwareControls::updateTeensySynth(unsigned char, int)+0x530>
    32a0:	vdiv.f64	d7, d5, d6
    32a4:	vcvt.f32.f64	s0, d7
    32a8:	bl	18168 <powf>

        // The filter has a pretty nasty self-oscillation in higher frequencies when the Q is large enough, trying to prevent this..
        if (ts->getFilterResonance() > 3.07 && new_cutoff > 10000)
    32ac:	ldr	r3, [r4, #76]	; 0x4c
    32ae:	ldr	r2, [pc, #328]	; (33f8 <HardwareControls::updateTeensySynth(unsigned char, int)+0x540>)
    case CTL_BALANCE:
        ts->setOscillatorBalance((float)value / 1023.0f);
        break;
    case CTL_FLT_CUTOFF:
    {
        float new_cutoff = 30 + 12 * powf((value / 101.53), 3);
    32b0:	vmov.f32	s15, #40	; 0x41400000  12.0
    32b4:	add	r2, r3
    32b6:	vfma.f32	s16, s0, s15

        // The filter has a pretty nasty self-oscillation in higher frequencies when the Q is large enough, trying to prevent this..
        if (ts->getFilterResonance() > 3.07 && new_cutoff > 10000)
    32ba:	vldr	s14, [r2]
    32be:	vldr	d6, [pc, #304]	; 33f0 <HardwareControls::updateTeensySynth(unsigned char, int)+0x538>
    32c2:	vcvt.f64.f32	d7, s14
    32c6:	vcmpe.f64	d7, d6
    32ca:	vmrs	APSR_nzcv, fpscr
    32ce:	ble.n	32ea <HardwareControls::updateTeensySynth(unsigned char, int)+0x432>
    32d0:	vldr	s15, [pc, #296]	; 33fc <HardwareControls::updateTeensySynth(unsigned char, int)+0x544>
    32d4:	vcmpe.f32	s16, s15
    32d8:	vmrs	APSR_nzcv, fpscr
    32dc:	ble.n	32ea <HardwareControls::updateTeensySynth(unsigned char, int)+0x432>
    32de:	ldr	r1, [pc, #288]	; (3400 <HardwareControls::updateTeensySynth(unsigned char, int)+0x548>)
        updateFilter();
    32e0:	mov	r0, r3

    //Set lowpass filter resonance (Q value). Affects all oscillators. Range: 0.7f - 5.0f
    inline void setFilterResonance(float resonance)
    {
        CONSTRAIN(resonance, 0.1f, 10.0f);
        currentPatch.filterResonance = resonance;
    32e2:	str	r1, [r2, #0]
        updateFilter();
    32e4:	bl	1100 <TeensySynth::updateFilter()>
    32e8:	ldr	r3, [r4, #76]	; 0x4c
    }

    //Set lowpass filter cutoff frequency in Hz. Affects all oscillators. Range: 20.0f - 19200.0f (on 48kHz sample rate)
    inline void setFilterCutoff(float cutoff)
    {
        CONSTRAIN(cutoff, 20.0f, filterMaxFreq);
    32ea:	vmov.f32	s15, #52	; 0x41a00000  20.0
    32ee:	vcmpe.f32	s16, s15
    32f2:	vmrs	APSR_nzcv, fpscr
    32f6:	bmi.n	330e <HardwareControls::updateTeensySynth(unsigned char, int)+0x456>
    32f8:	ldr	r2, [pc, #264]	; (3404 <HardwareControls::updateTeensySynth(unsigned char, int)+0x54c>)
    32fa:	add	r2, r3
    32fc:	vldr	s15, [r2]
    3300:	vcmpe.f32	s16, s15
    3304:	vmrs	APSR_nzcv, fpscr
    3308:	it	le
    330a:	vmovle.f32	s15, s16
        currentPatch.filterCutoff = cutoff;
    330e:	ldr	r2, [pc, #248]	; (3408 <HardwareControls::updateTeensySynth(unsigned char, int)+0x550>)
        updateFilter();
    3310:	mov	r0, r3

    //Set lowpass filter cutoff frequency in Hz. Affects all oscillators. Range: 20.0f - 19200.0f (on 48kHz sample rate)
    inline void setFilterCutoff(float cutoff)
    {
        CONSTRAIN(cutoff, 20.0f, filterMaxFreq);
        currentPatch.filterCutoff = cutoff;
    3312:	add	r2, r3
    3314:	vstr	s15, [r2]
        break;
    }
    default:
        break;
    }
}
    3318:	add	sp, #8
    331a:	vpop	{d8}
    331e:	ldmia.w	sp!, {r4, lr}
    //Set lowpass filter resonance (Q value). Affects all oscillators. Range: 0.7f - 5.0f
    inline void setFilterResonance(float resonance)
    {
        CONSTRAIN(resonance, 0.1f, 10.0f);
        currentPatch.filterResonance = resonance;
        updateFilter();
    3322:	b.w	1100 <TeensySynth::updateFilter()>
void HardwareControls::updateTeensySynth(uint8_t ctl, int value)
{
    switch (ctl)
    {
    case CTL_ENC_1:
        CONSTRAIN(currentCtlValue[CTL_ENC_1], 0, 16);
    3326:	ldrsh.w	r1, [r0, #120]	; 0x78
    332a:	cmp	r1, #0
    332c:	blt.n	337e <HardwareControls::updateTeensySynth(unsigned char, int)+0x4c6>
    332e:	cmp	r1, #16
    3330:	ble.n	333a <HardwareControls::updateTeensySynth(unsigned char, int)+0x482>
    3332:	movs	r3, #16
    3334:	mov	r1, r3
    3336:	strh.w	r3, [r0, #120]	; 0x78
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    333a:	ldr	r0, [pc, #208]	; (340c <HardwareControls::updateTeensySynth(unsigned char, int)+0x554>)
    333c:	bl	17984 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    3340:	ldr	r0, [pc, #200]	; (340c <HardwareControls::updateTeensySynth(unsigned char, int)+0x554>)
    3342:	bl	178e4 <Print::println()>
        Serial.println(currentCtlValue[CTL_ENC_1]);
        ts->setSynthEngine(currentCtlValue[CTL_ENC_1]);
    3346:	ldrsh.w	r3, [r4, #120]	; 0x78
    334a:	ldr	r2, [r4, #76]	; 0x4c
    334c:	cmp	r3, #16
    void OnControlChange(uint8_t channel, uint8_t control, uint8_t value);

    inline void setSynthEngine(int engine)
    {
        CONSTRAIN(engine, 0, 16);
        currentPatch.engine = engine;
    334e:	ldr	r1, [pc, #192]	; (3410 <HardwareControls::updateTeensySynth(unsigned char, int)+0x558>)
        updateOscillator();
    3350:	mov	r0, r2
    3352:	it	ge
    3354:	movge	r3, #16
    void OnControlChange(uint8_t channel, uint8_t control, uint8_t value);

    inline void setSynthEngine(int engine)
    {
        CONSTRAIN(engine, 0, 16);
        currentPatch.engine = engine;
    3356:	bic.w	r3, r3, r3, asr #31
    335a:	str	r3, [r2, r1]
    335c:	b.n	30fc <HardwareControls::updateTeensySynth(unsigned char, int)+0x244>
        break;
    }
    default:
        break;
    }
}
    335e:	add	sp, #8
    3360:	vpop	{d8}
    3364:	pop	{r4, pc}
        break;
    }
    case CTL_FLT_RESO:
    {
        float new_reso = ((float)value / 1023.0f) * 4.0f;
        if (ts->getFilterCutoff() > 10000 && new_reso > 3.0)
    3366:	vmov.f32	s14, #8	; 0x40400000  3.0
    336a:	vcmpe.f32	s15, s14
    336e:	vmrs	APSR_nzcv, fpscr
    3372:	bgt.w	3220 <HardwareControls::updateTeensySynth(unsigned char, int)+0x368>
    3376:	b.n	3210 <HardwareControls::updateTeensySynth(unsigned char, int)+0x358>
        return currentPatch.decay;
    }

    inline void setReverbSize(float size)
    {
        CONSTRAIN(size, 0.1f, 0.95f);
    3378:	vmov.f32	s15, s14
    337c:	b.n	313e <HardwareControls::updateTeensySynth(unsigned char, int)+0x286>
void HardwareControls::updateTeensySynth(uint8_t ctl, int value)
{
    switch (ctl)
    {
    case CTL_ENC_1:
        CONSTRAIN(currentCtlValue[CTL_ENC_1], 0, 16);
    337e:	movs	r1, #0
    3380:	strh.w	r1, [r0, #120]	; 0x78
    3384:	b.n	333a <HardwareControls::updateTeensySynth(unsigned char, int)+0x482>
        return currentPatch.balance;
    }

    inline void setOscillatorDecay(float decay)
    {
        CONSTRAIN(decay, 0.0f, 1.0f);
    3386:	vldr	s15, [pc, #140]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    338a:	b.n	2fd8 <HardwareControls::updateTeensySynth(unsigned char, int)+0x120>
        return currentPatch.morph;
    }

    inline void setOscillatorBalance(float balance)
    {
        CONSTRAIN(balance, 0.0f, 1.0f);
    338c:	vldr	s15, [pc, #132]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    3390:	b.n	300e <HardwareControls::updateTeensySynth(unsigned char, int)+0x156>
    }

    //Set oscillator parameter "morph". Affects all oscillators.
    inline void setOscillatorMorph(float morph)
    {
        CONSTRAIN(morph, 0.0f, 1.0f);
    3392:	vldr	s15, [pc, #128]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    3396:	b.n	2fa4 <HardwareControls::updateTeensySynth(unsigned char, int)+0xec>
    }

    //Set oscillator parameter "timbre". Affects all oscillators.
    inline void setOscillatorTimbre(float timbre)
    {
        CONSTRAIN(timbre, 0.0f, 1.0f);
    3398:	vldr	s15, [pc, #120]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    339c:	b.n	2f70 <HardwareControls::updateTeensySynth(unsigned char, int)+0xb8>
    }

    //Set oscillator parameter "harmonics". Affects all oscillators.
    inline void setOscillatorHarmonics(float harmonics)
    {
        CONSTRAIN(harmonics, 0.0f, 1.0f);
    339e:	vldr	s15, [pc, #116]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33a2:	b.n	2f3c <HardwareControls::updateTeensySynth(unsigned char, int)+0x84>
    }

    //Set chorus depth (mix%). Range 0.0f-1.0f.
    inline void setChorusDepth(float depth)
    {
        CONSTRAIN(depth, 0.0f, 1.0f);
    33a4:	vldr	s15, [pc, #108]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33a8:	b.n	31c6 <HardwareControls::updateTeensySynth(unsigned char, int)+0x30e>
        return currentPatch.reverbSize;
    }

    inline void setReverbDepth(float depth)
    {
        CONSTRAIN(depth, 0.0f, MIX_LEVEL);
    33aa:	vldr	s0, [pc, #104]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33ae:	b.n	318a <HardwareControls::updateTeensySynth(unsigned char, int)+0x2d2>
    }

    //Set frequency modulation amount. Range 0.0f-1.0f.
    inline void setFreqMod(float freqMod)
    {
        CONSTRAIN(freqMod,0.0f,1.0f);
    33b0:	vldr	s15, [pc, #96]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33b4:	b.n	308a <HardwareControls::updateTeensySynth(unsigned char, int)+0x1d2>
        return currentPatch.morphMod;
    }

    inline void setLpgColour(float lpgColour)
    {
        CONSTRAIN(lpgColour,0.0f,1.0f);
    33b6:	vldr	s15, [pc, #92]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33ba:	b.n	3056 <HardwareControls::updateTeensySynth(unsigned char, int)+0x19e>
    }

    //Set morph modulation amount. Range 0.0f-1.0f.
    inline void setMorphMod(float morphMod)
    {
        CONSTRAIN(morphMod,0.0f,1.0f);
    33bc:	vldr	s15, [pc, #84]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33c0:	b.n	30f2 <HardwareControls::updateTeensySynth(unsigned char, int)+0x23a>
    }

    //Set timbre modulation amount. Range 0.0f-1.0f.
    inline void setTimbreMod(float timbreMod)
    {
        CONSTRAIN(timbreMod,0.0f,1.0f);
    33c2:	vldr	s15, [pc, #80]	; 3414 <HardwareControls::updateTeensySynth(unsigned char, int)+0x55c>
    33c6:	b.n	30be <HardwareControls::updateTeensySynth(unsigned char, int)+0x206>
    }

    //Set lowpass filter resonance (Q value). Affects all oscillators. Range: 0.7f - 5.0f
    inline void setFilterResonance(float resonance)
    {
        CONSTRAIN(resonance, 0.1f, 10.0f);
    33c8:	vmov.f32	s14, #36	; 0x41200000  10.0
    33cc:	vcmp.f32	s15, s14
    33d0:	vmrs	APSR_nzcv, fpscr
    33d4:	it	gt
    33d6:	vmovgt.f32	s15, s14
    33da:	b.n	3224 <HardwareControls::updateTeensySynth(unsigned char, int)+0x36c>
    33dc:	vldr	s14, [pc, #56]	; 3418 <HardwareControls::updateTeensySynth(unsigned char, int)+0x560>
    33e0:	vmul.f32	s15, s15, s14
    33e4:	b.n	300e <HardwareControls::updateTeensySynth(unsigned char, int)+0x156>
    33e6:	nop
    33e8:	.word	0x851eb852
    33ec:	.word	0x405961eb
    33f0:	.word	0x28f5c28f
    33f4:	.word	0x40088f5c
    33f8:	.word	0x00036624
    33fc:	.word	0x461c4000
    3400:	.word	0x40400000
    3404:	.word	0x00036b10
    3408:	.word	0x00036620
    340c:	.word	0x20020a88
    3410:	.word	0x000365f4
    3414:	.word	0x00000000
    3418:	.word	0x3f333333

0000341c <HardwareControls::checkControlValues(bool)>:
#include "hardware_controls.h"
#include "settings.h"
#include <Encoder.h>

void HardwareControls::checkControlValues(bool update)
{
    341c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3420:	add.w	r3, r0, #16
    3424:	sub	sp, #20
    3426:	mov	r9, r0
    3428:	add.w	r7, r0, #88	; 0x58
    342c:	str	r3, [sp, #4]
    342e:	add.w	r8, r0, #11
    3432:	subs	r3, r0, #1
    3434:	mov	r6, r0
    3436:	adds	r5, r0, #3
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3438:	ldr.w	fp, [pc, #484]	; 3620 <HardwareControls::checkControlValues(bool)+0x204>
    343c:	str	r1, [sp, #12]
    343e:	str	r3, [sp, #8]
    3440:	ldr.w	sl, [sp, #8]
    3444:	mov	r4, r8

    //Switch multiplexer channel and read a value
    uint16_t readMux(uint8_t ch)
    {
        for (int i = 0; i < 4; i++)
            digitalWrite(muxControlPin[i], muxChannel[ch][i]);
    3446:	ldrb.w	r0, [sl, #1]!
    344a:	ldrb.w	r1, [r4], #1
    344e:	bl	16b60 <digitalWrite>
    uint8_t potThreshold[LAST_CTL];

    //Switch multiplexer channel and read a value
    uint16_t readMux(uint8_t ch)
    {
        for (int i = 0; i < 4; i++)
    3452:	cmp	sl, r5
    3454:	bne.n	3446 <HardwareControls::checkControlValues(bool)+0x2a>
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3456:	ldr	r3, [pc, #448]	; (3618 <HardwareControls::checkControlValues(bool)+0x1fc>)
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3458:	ldr.w	r1, [fp]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    345c:	ldr	r2, [r3, #0]
    345e:	ldr	r3, [pc, #444]	; (361c <HardwareControls::checkControlValues(bool)+0x200>)
    3460:	umull	r3, r2, r3, r2
    3464:	lsrs	r2, r2, #18
    3466:	add.w	r2, r2, r2, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    346a:	ldr.w	r3, [fp]
    346e:	subs	r3, r3, r1
    3470:	cmp	r2, r3
    3472:	bhi.n	346a <HardwareControls::checkControlValues(bool)+0x4e>
            digitalWrite(muxControlPin[i], muxChannel[ch][i]);
        delayMicroseconds(5); // A little delay so the multiplexer can sort itself out after switching channels
        return analogRead(muxValuePin);
    3474:	ldrb.w	r0, [r9, #4]
    3478:	bl	16798 <analogRead>
    347c:	uxth	r0, r0

    //Potentiometers: all are connected to a single multiplexer so we just read them in a for loop
    for (i = 0; i < 16; i++)
    {
        ctlValue = readMux(i);
        if (ctlValue < 10)
    347e:	cmp	r0, #9
    3480:	bgt.n	3510 <HardwareControls::checkControlValues(bool)+0xf4>
    3482:	ldrsh.w	r3, [r7]
            ctlValue = 0;
    3486:	movs	r0, #0
        if ((ctlValue == 1023 && currentCtlValue[i] != 1023) || ctlValue > currentCtlValue[i] + potThreshold[i] || ctlValue < currentCtlValue[i] - potThreshold[i])
    3488:	ldrb.w	r2, [r6, #132]	; 0x84
    348c:	adds	r1, r3, r2
    348e:	cmp	r1, r0
    3490:	blt.n	3498 <HardwareControls::checkControlValues(bool)+0x7c>
    3492:	subs	r3, r3, r2
    3494:	cmp	r3, r0
    3496:	ble.n	34b0 <HardwareControls::checkControlValues(bool)+0x94>
        {
            if (update == 1)
    3498:	ldr	r3, [sp, #12]
    349a:	cmp	r3, #0
    349c:	beq.n	3526 <HardwareControls::checkControlValues(bool)+0x10a>
            {
#if SYNTH_DEBUG > 1
                Serial.printf("Pot upd, num: %d, val: %d, currentVal: %d, th: %d\n", i, ctlValue, currentCtlValue[i], potThreshold[i]);
#endif
                if (ctlValue < currentCtlValue[i] + 50 && ctlValue > currentCtlValue[i] - 50) //prevent pot noise spikes
    349e:	ldrsh.w	r3, [r7]
    34a2:	add.w	r2, r3, #49	; 0x31
    34a6:	cmp	r2, r0
    34a8:	blt.n	34b0 <HardwareControls::checkControlValues(bool)+0x94>
    34aa:	subs	r3, #49	; 0x31
    34ac:	cmp	r3, r0
    34ae:	ble.n	352a <HardwareControls::checkControlValues(bool)+0x10e>
    34b0:	adds	r6, #1
void HardwareControls::checkControlValues(bool update)
{
    int i, ctlValue;

    //Potentiometers: all are connected to a single multiplexer so we just read them in a for loop
    for (i = 0; i < 16; i++)
    34b2:	ldr	r3, [sp, #4]
    34b4:	adds	r7, #2
    34b6:	add.w	r8, r8, #4
    34ba:	cmp	r6, r3
    34bc:	bne.n	3440 <HardwareControls::checkControlValues(bool)+0x24>
    34be:	add.w	r7, r9, #76	; 0x4c
    34c2:	add.w	r6, r9, #120	; 0x78
    34c6:	add.w	r5, r9, #128	; 0x80
    34ca:	movs	r4, #16
			update(&encoder);
		} else {
			noInterrupts();
		}
		int32_t ret = encoder.position;
		encoder.position = 0;
    34cc:	mov.w	r8, #0
        }
        else if (ctlValue > 0)
        {
            if (encValue[i] > 0)
                encValue[i] = 0;
            encValue[i]--;
    34d0:	movw	sl, #65535	; 0xffff
        if (ctlValue < 0)
        {
            //The crappy encoders that I bought from Aliexpress seem to be like 1 click = 4 increments.. trying to work around that
            if (encValue[i] < 0)
                encValue[i] = 0;
            encValue[i]++;
    34d4:	mov.w	fp, #1
    }

    //Check encoder readings. Sorry for this mess.
    for (i = 0; i < 2; i++)
    {
        ctlValue = encoder[i]->readAndReset();
    34d8:	ldr.w	r3, [r7, #4]!
		int32_t ret = encoder.position;
		interrupts();
		return ret;
	}
	inline int32_t readAndReset() {
		if (interrupts_in_use < 2) {
    34dc:	ldrb	r2, [r3, #24]
    34de:	cmp	r2, #1
    34e0:	bls.n	357c <HardwareControls::checkControlValues(bool)+0x160>
			noInterrupts();
			update(&encoder);
		} else {
			noInterrupts();
    34e2:	cpsid	i
    34e4:	ldr	r2, [r3, #20]
		}
		int32_t ret = encoder.position;
		encoder.position = 0;
    34e6:	str.w	r8, [r3, #20]
		interrupts();
    34ea:	cpsie	i
        if (ctlValue < 0)
    34ec:	cmp	r2, #0
    34ee:	blt.n	353c <HardwareControls::checkControlValues(bool)+0x120>
            {
                currentCtlValue[CTL_ENC_1 + i]++;
                updateTeensySynth(CTL_ENC_1 + i, currentCtlValue[CTL_ENC_1 + i]);
            }
        }
        else if (ctlValue > 0)
    34f0:	beq.n	34fe <HardwareControls::checkControlValues(bool)+0xe2>
        {
            if (encValue[i] > 0)
    34f2:	ldrsh.w	r3, [r5]
    34f6:	cmp	r3, #0
    34f8:	ble.n	3560 <HardwareControls::checkControlValues(bool)+0x144>
                encValue[i] = 0;
            encValue[i]--;
    34fa:	strh.w	sl, [r5]
    34fe:	adds	r4, #1
    3500:	adds	r6, #2
    3502:	adds	r5, #2
    3504:	uxtb	r4, r4
                currentCtlValue[i] = ctlValue;
        }
    }

    //Check encoder readings. Sorry for this mess.
    for (i = 0; i < 2; i++)
    3506:	cmp	r4, #18
    3508:	bne.n	34d8 <HardwareControls::checkControlValues(bool)+0xbc>
                currentCtlValue[CTL_ENC_1 + i]--;
                updateTeensySynth(CTL_ENC_1 + i, currentCtlValue[CTL_ENC_1 + i]);
            }
        }
    }
}
    350a:	add	sp, #20
    350c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < 16; i++)
    {
        ctlValue = readMux(i);
        if (ctlValue < 10)
            ctlValue = 0;
        if ((ctlValue == 1023 && currentCtlValue[i] != 1023) || ctlValue > currentCtlValue[i] + potThreshold[i] || ctlValue < currentCtlValue[i] - potThreshold[i])
    3510:	movw	r3, #1023	; 0x3ff
    3514:	cmp	r0, r3
    3516:	ldrsh.w	r3, [r7]
    351a:	bne.n	3488 <HardwareControls::checkControlValues(bool)+0x6c>
    351c:	cmp	r3, r0
    351e:	beq.n	3488 <HardwareControls::checkControlValues(bool)+0x6c>
        {
            if (update == 1)
    3520:	ldr	r3, [sp, #12]
    3522:	cmp	r3, #0
    3524:	bne.n	349e <HardwareControls::checkControlValues(bool)+0x82>
                    currentCtlValue[i] = ctlValue;
                    updateTeensySynth(i, ctlValue);
                }
            }
            else
                currentCtlValue[i] = ctlValue;
    3526:	strh	r0, [r7, #0]
    3528:	b.n	34b0 <HardwareControls::checkControlValues(bool)+0x94>
                Serial.printf("Pot upd, num: %d, val: %d, currentVal: %d, th: %d\n", i, ctlValue, currentCtlValue[i], potThreshold[i]);
#endif
                if (ctlValue < currentCtlValue[i] + 50 && ctlValue > currentCtlValue[i] - 50) //prevent pot noise spikes
                {
                    currentCtlValue[i] = ctlValue;
                    updateTeensySynth(i, ctlValue);
    352a:	rsb	r1, r9, r6
#if SYNTH_DEBUG > 1
                Serial.printf("Pot upd, num: %d, val: %d, currentVal: %d, th: %d\n", i, ctlValue, currentCtlValue[i], potThreshold[i]);
#endif
                if (ctlValue < currentCtlValue[i] + 50 && ctlValue > currentCtlValue[i] - 50) //prevent pot noise spikes
                {
                    currentCtlValue[i] = ctlValue;
    352e:	strh	r0, [r7, #0]
                    updateTeensySynth(i, ctlValue);
    3530:	mov	r2, r0
    3532:	mov	r0, r9
    3534:	uxtb	r1, r1
    3536:	bl	2eb8 <HardwareControls::updateTeensySynth(unsigned char, int)>
    353a:	b.n	34b0 <HardwareControls::checkControlValues(bool)+0x94>
    {
        ctlValue = encoder[i]->readAndReset();
        if (ctlValue < 0)
        {
            //The crappy encoders that I bought from Aliexpress seem to be like 1 click = 4 increments.. trying to work around that
            if (encValue[i] < 0)
    353c:	ldrsh.w	r3, [r5]
    3540:	cmp	r3, #0
    3542:	blt.n	35e8 <HardwareControls::checkControlValues(bool)+0x1cc>
                encValue[i] = 0;
            encValue[i]++;
    3544:	adds	r3, #1
    3546:	uxth	r3, r3
            if (encValue[i] % 4 == 0)
    3548:	lsls	r2, r3, #30
        if (ctlValue < 0)
        {
            //The crappy encoders that I bought from Aliexpress seem to be like 1 click = 4 increments.. trying to work around that
            if (encValue[i] < 0)
                encValue[i] = 0;
            encValue[i]++;
    354a:	strh	r3, [r5, #0]
            if (encValue[i] % 4 == 0)
    354c:	bne.n	34fe <HardwareControls::checkControlValues(bool)+0xe2>
            {
                currentCtlValue[CTL_ENC_1 + i]++;
    354e:	ldrh	r2, [r6, #0]
                updateTeensySynth(CTL_ENC_1 + i, currentCtlValue[CTL_ENC_1 + i]);
    3550:	mov	r1, r4
    3552:	mov	r0, r9
            if (encValue[i] < 0)
                encValue[i] = 0;
            encValue[i]++;
            if (encValue[i] % 4 == 0)
            {
                currentCtlValue[CTL_ENC_1 + i]++;
    3554:	adds	r2, #1
    3556:	sxth	r2, r2
    3558:	strh	r2, [r6, #0]
                updateTeensySynth(CTL_ENC_1 + i, currentCtlValue[CTL_ENC_1 + i]);
    355a:	bl	2eb8 <HardwareControls::updateTeensySynth(unsigned char, int)>
    355e:	b.n	34fe <HardwareControls::checkControlValues(bool)+0xe2>
        }
        else if (ctlValue > 0)
        {
            if (encValue[i] > 0)
                encValue[i] = 0;
            encValue[i]--;
    3560:	subs	r3, #1
    3562:	uxth	r3, r3
    3564:	strh	r3, [r5, #0]
            if (encValue[i] % 4 == 0)
    3566:	lsls	r3, r3, #30
    3568:	bne.n	34fe <HardwareControls::checkControlValues(bool)+0xe2>
            {
                currentCtlValue[CTL_ENC_1 + i]--;
    356a:	ldrh	r2, [r6, #0]
                updateTeensySynth(CTL_ENC_1 + i, currentCtlValue[CTL_ENC_1 + i]);
    356c:	mov	r1, r4
    356e:	mov	r0, r9
            if (encValue[i] > 0)
                encValue[i] = 0;
            encValue[i]--;
            if (encValue[i] % 4 == 0)
            {
                currentCtlValue[CTL_ENC_1 + i]--;
    3570:	subs	r2, #1
    3572:	sxth	r2, r2
    3574:	strh	r2, [r6, #0]
                updateTeensySynth(CTL_ENC_1 + i, currentCtlValue[CTL_ENC_1 + i]);
    3576:	bl	2eb8 <HardwareControls::updateTeensySynth(unsigned char, int)>
    357a:	b.n	34fe <HardwareControls::checkControlValues(bool)+0xe2>
		interrupts();
		return ret;
	}
	inline int32_t readAndReset() {
		if (interrupts_in_use < 2) {
			noInterrupts();
    357c:	cpsid	i
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    357e:	ldr	r1, [r3, #0]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    3580:	ldr	r0, [r3, #4]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    3582:	ldr	r2, [r1, #0]
    3584:	ldr	r1, [r3, #8]
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    3586:	ldr	r0, [r0, #0]
			"st	-X, r23"		"\n\t"
			"st	-X, r22"		"\n\t"
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
    3588:	ands	r1, r2
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
    358a:	ldr	r2, [r3, #12]
    358c:	tst	r0, r2
    358e:	beq.n	35ee <HardwareControls::checkControlValues(bool)+0x1d2>
		uint8_t state = arg->state & 3;
    3590:	ldrb	r2, [r3, #16]
    3592:	and.w	r2, r2, #3
		if (p1val) state |= 4;
    3596:	cbz	r1, 359c <HardwareControls::checkControlValues(bool)+0x180>
    3598:	orr.w	r2, r2, #4
		if (p2val) state |= 8;
    359c:	orr.w	r2, r2, #8
		arg->state = (state >> 2);
    35a0:	asrs	r1, r2, #2
		switch (state) {
    35a2:	subs	r2, #1
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
    35a4:	strb	r1, [r3, #16]
		switch (state) {
    35a6:	cmp	r2, #13
    35a8:	bhi.n	34e4 <HardwareControls::checkControlValues(bool)+0xc8>
    35aa:	add	r1, pc, #4	; (adr r1, 35b0 <HardwareControls::checkControlValues(bool)+0x194>)
    35ac:	ldr.w	pc, [r1, r2, lsl #2]
    35b0:	.word	0x00003611
    35b4:	.word	0x0000360b
    35b8:	.word	0x00003605
    35bc:	.word	0x0000360b
    35c0:	.word	0x000034e5
    35c4:	.word	0x000035ff
    35c8:	.word	0x00003611
    35cc:	.word	0x00003611
    35d0:	.word	0x000035ff
    35d4:	.word	0x000034e5
    35d8:	.word	0x0000360b
    35dc:	.word	0x00003605
    35e0:	.word	0x0000360b
    35e4:	.word	0x00003611
        if (ctlValue < 0)
        {
            //The crappy encoders that I bought from Aliexpress seem to be like 1 click = 4 increments.. trying to work around that
            if (encValue[i] < 0)
                encValue[i] = 0;
            encValue[i]++;
    35e8:	strh.w	fp, [r5]
    35ec:	b.n	34fe <HardwareControls::checkControlValues(bool)+0xe2>
		"L%=end:"				"\n"
		: : "x" (arg) : "r22", "r23", "r24", "r25", "r30", "r31");
#else
		uint8_t p1val = DIRECT_PIN_READ(arg->pin1_register, arg->pin1_bitmask);
		uint8_t p2val = DIRECT_PIN_READ(arg->pin2_register, arg->pin2_bitmask);
		uint8_t state = arg->state & 3;
    35ee:	ldrb	r2, [r3, #16]
    35f0:	and.w	r2, r2, #3
		if (p1val) state |= 4;
    35f4:	cmp	r1, #0
    35f6:	beq.n	35a0 <HardwareControls::checkControlValues(bool)+0x184>
    35f8:	orr.w	r2, r2, #4
    35fc:	b.n	35a0 <HardwareControls::checkControlValues(bool)+0x184>
				return;
			case 3: case 12:
				arg->position += 2;
				return;
			case 6: case 9:
				arg->position -= 2;
    35fe:	ldr	r2, [r3, #20]
    3600:	subs	r2, #2
    3602:	b.n	34e6 <HardwareControls::checkControlValues(bool)+0xca>
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
				return;
			case 3: case 12:
				arg->position += 2;
    3604:	ldr	r2, [r3, #20]
    3606:	adds	r2, #2
    3608:	b.n	34e6 <HardwareControls::checkControlValues(bool)+0xca>
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
				return;
			case 2: case 4: case 11: case 13:
				arg->position--;
    360a:	ldr	r2, [r3, #20]
    360c:	subs	r2, #1
    360e:	b.n	34e6 <HardwareControls::checkControlValues(bool)+0xca>
		if (p1val) state |= 4;
		if (p2val) state |= 8;
		arg->state = (state >> 2);
		switch (state) {
			case 1: case 7: case 8: case 14:
				arg->position++;
    3610:	ldr	r2, [r3, #20]
    3612:	adds	r2, #1
    3614:	b.n	34e6 <HardwareControls::checkControlValues(bool)+0xca>
    3616:	nop
    3618:	.word	0x20020828
    361c:	.word	0x431bde83
    3620:	.word	0xe0001004

00003624 <HardwareControls::init()>:
        break;
    }
}

void HardwareControls::init()
{
    3624:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3628:	mov	r4, r0
    encoder[0] = new Encoder(rotaryPin[0][0], rotaryPin[0][1]);
    362a:	movs	r0, #28
    362c:	bl	17c08 <operator new(unsigned int)>
class Encoder
{
public:
	Encoder(uint8_t pin1, uint8_t pin2) {
		#ifdef INPUT_PULLUP
		pinMode(pin1, INPUT_PULLUP);
    3630:	movs	r1, #2
    3632:	ldrb	r6, [r4, #5]
    3634:	mov	r5, r0
    3636:	ldrb.w	r9, [r4, #6]
    363a:	mov	r0, r6
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    363c:	ldr	r7, [pc, #588]	; (388c <HardwareControls::init()+0x268>)
class Encoder
{
public:
	Encoder(uint8_t pin1, uint8_t pin2) {
		#ifdef INPUT_PULLUP
		pinMode(pin1, INPUT_PULLUP);
    363e:	bl	16b6c <pinMode>
		pinMode(pin2, INPUT_PULLUP);
    3642:	mov	r0, r9
    3644:	movs	r1, #2

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3646:	ldr.w	r8, [pc, #596]	; 389c <HardwareControls::init()+0x278>
    364a:	bl	16b6c <pinMode>
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
		encoder.position = 0;
    364e:	movs	r1, #0
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    3650:	lsls	r2, r6, #4
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3652:	ldr	r3, [pc, #572]	; (3890 <HardwareControls::init()+0x26c>)
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    3654:	mov.w	ip, r9, lsl #4
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
		encoder.position = 0;
    3658:	str	r1, [r5, #20]
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    365a:	adds	r1, r7, r2
    365c:	ldr.w	sl, [r7, r2]
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    3660:	add.w	r0, r7, ip
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3664:	ldr.w	fp, [pc, #568]	; 38a0 <HardwareControls::init()+0x27c>
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
    3668:	ldr.w	lr, [r1, #12]
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    366c:	mov	r1, r3
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
    366e:	ldr	r0, [r0, #12]
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
    3670:	str.w	lr, [r5, #8]
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
    3674:	str	r0, [r5, #12]
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    3676:	ldr	r2, [r3, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    3678:	ldr.w	r3, [r8]
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    367c:	ldr.w	ip, [r7, ip]
    3680:	umull	r3, fp, fp, r3
    3684:	mov.w	r3, #2000	; 0x7d0
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    3688:	str.w	sl, [r5]
    368c:	mov.w	fp, fp, lsr #18
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    3690:	str.w	ip, [r5, #4]
    3694:	mul.w	fp, r3, fp
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    3698:	ldr	r3, [r1, #0]
    369a:	subs	r3, r3, r2
    369c:	cmp	fp, r3
    369e:	bhi.n	3698 <HardwareControls::init()+0x74>
		// allow time for a passive R-C filter to charge
		// through the pullup resistors, before reading
		// the initial state
		delayMicroseconds(2000);
		uint8_t s = 0;
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
    36a0:	ldr.w	r3, [sl]
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
    36a4:	ldr.w	r2, [ip]
		encoder.position = 0;
		// allow time for a passive R-C filter to charge
		// through the pullup resistors, before reading
		// the initial state
		delayMicroseconds(2000);
		uint8_t s = 0;
    36a8:	tst.w	lr, r3
    36ac:	ite	ne
    36ae:	movne	r3, #1
    36b0:	moveq	r3, #0
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
    36b2:	tst	r0, r2
    36b4:	beq.n	36bc <HardwareControls::init()+0x98>
    36b6:	orr.w	r3, r3, #2
    36ba:	uxtb	r3, r3
		encoder.state = s;
    36bc:	strb	r3, [r5, #16]
#ifdef ENCODER_USE_INTERRUPTS
	// this giant function is an unfortunate consequence of Arduino's
	// attachInterrupt function not supporting any way to pass a pointer
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
    36be:	cmp	r6, #39	; 0x27
    36c0:	bhi.w	48d4 <HardwareControls::init()+0x12b0>
    36c4:	tbh	[pc, r6, lsl #1]
    36c8:	.word	0x08e808f1
    36cc:	.word	0x08d408de
    36d0:	.word	0x08c008ca
    36d4:	.word	0x08ac08b6
    36d8:	.word	0x089808a2
    36dc:	.word	0x0884088e
    36e0:	.word	0x0870087a
    36e4:	.word	0x085c0866
    36e8:	.word	0x08480852
    36ec:	.word	0x0834083e
    36f0:	.word	0x0820082a
    36f4:	.word	0x080c0816
    36f8:	.word	0x07f80802
    36fc:	.word	0x07e407ee
    3700:	.word	0x07d007da
    3704:	.word	0x07770781
    3708:	.word	0x0761076c
    370c:	.word	0x074b0756
    3710:	.word	0x07350740
    3714:	.word	0x0028072a
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    3718:	ldr	r3, [pc, #376]	; (3894 <HardwareControls::init()+0x270>)
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    371a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
				attachInterrupt(39, isr39, CHANGE);
    371c:	movs	r2, #4
    371e:	ldr	r1, [pc, #376]	; (3898 <HardwareControls::init()+0x274>)
    3720:	movs	r0, #39	; 0x27
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    3722:	str.w	r5, [r3, #156]	; 0x9c
				attachInterrupt(39, isr39, CHANGE);
    3726:	bl	16804 <attachInterrupt>
		uint8_t s = 0;
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
		encoder.state = s;
#ifdef ENCODER_USE_INTERRUPTS
		interrupts_in_use = attach_interrupt(pin1, &encoder);
    372a:	strb	r6, [r5, #24]
#ifdef ENCODER_USE_INTERRUPTS
	// this giant function is an unfortunate consequence of Arduino's
	// attachInterrupt function not supporting any way to pass a pointer
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
    372c:	cmp.w	r9, #39	; 0x27
    3730:	bhi.w	48cc <HardwareControls::init()+0x12a8>
    3734:	tbh	[pc, r9, lsl #1]
    3738:	.word	0x06dc06e6
    373c:	.word	0x06c406d0
    3740:	.word	0x06ac06b8
    3744:	.word	0x069406a0
    3748:	.word	0x067c0688
    374c:	.word	0x06640670
    3750:	.word	0x064c0658
    3754:	.word	0x06340640
    3758:	.word	0x061c0628
    375c:	.word	0x06040610
    3760:	.word	0x05ec05f8
    3764:	.word	0x05d405e0
    3768:	.word	0x05750581
    376c:	.word	0x055d0569
    3770:	.word	0x05450551
    3774:	.word	0x052d0539
    3778:	.word	0x05130520
    377c:	.word	0x04f90506
    3780:	.word	0x04df04ec
    3784:	.word	0x002804d2
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    3788:	ldr	r3, [pc, #264]	; (3894 <HardwareControls::init()+0x270>)
				attachInterrupt(39, isr39, CHANGE);
    378a:	movs	r2, #4
    378c:	ldr	r1, [pc, #264]	; (3898 <HardwareControls::init()+0x274>)
    378e:	movs	r0, #39	; 0x27
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    3790:	str.w	r5, [r3, #156]	; 0x9c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3794:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
				attachInterrupt(39, isr39, CHANGE);
    3798:	bl	16804 <attachInterrupt>
    379c:	ldrb	r6, [r5, #24]
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
		encoder.state = s;
#ifdef ENCODER_USE_INTERRUPTS
		interrupts_in_use = attach_interrupt(pin1, &encoder);
		interrupts_in_use += attach_interrupt(pin2, &encoder);
    379e:	add	r6, r9
    37a0:	str	r5, [r4, #80]	; 0x50
    encoder[1] = new Encoder(rotaryPin[1][0], rotaryPin[1][1]);
    37a2:	movs	r0, #28

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    37a4:	ldr.w	fp, [pc, #248]	; 38a0 <HardwareControls::init()+0x27c>
    37a8:	strb	r6, [r5, #24]
    37aa:	bl	17c08 <operator new(unsigned int)>
    37ae:	ldrb.w	r9, [r4, #8]
    37b2:	ldrb	r6, [r4, #9]
    37b4:	mov	r5, r0
class Encoder
{
public:
	Encoder(uint8_t pin1, uint8_t pin2) {
		#ifdef INPUT_PULLUP
		pinMode(pin1, INPUT_PULLUP);
    37b6:	movs	r1, #2
    37b8:	mov	r0, r9
    37ba:	bl	16b6c <pinMode>
		pinMode(pin2, INPUT_PULLUP);
    37be:	mov	r0, r6
    37c0:	movs	r1, #2
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    37c2:	mov.w	sl, r6, lsl #4
{
public:
	Encoder(uint8_t pin1, uint8_t pin2) {
		#ifdef INPUT_PULLUP
		pinMode(pin1, INPUT_PULLUP);
		pinMode(pin2, INPUT_PULLUP);
    37c6:	bl	16b6c <pinMode>
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
		encoder.position = 0;
    37ca:	movs	r1, #0
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    37cc:	mov.w	r3, r9, lsl #4
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    37d0:	ldr	r2, [pc, #188]	; (3890 <HardwareControls::init()+0x26c>)
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
		encoder.position = 0;
    37d2:	str	r1, [r5, #20]
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    37d4:	add.w	r1, r7, sl
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    37d8:	adds	r0, r7, r3
    37da:	ldr.w	ip, [r7, r3]
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    37de:	ldr.w	r7, [r7, sl]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    37e2:	mov.w	r3, #2000	; 0x7d0
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
    37e6:	ldr.w	lr, [r0, #12]
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
    37ea:	ldr	r0, [r1, #12]
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
    37ec:	str.w	lr, [r5, #8]
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
		encoder.pin2_bitmask = PIN_TO_BITMASK(pin2);
    37f0:	str	r0, [r5, #12]
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    37f2:	ldr	r1, [r2, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    37f4:	ldr.w	r8, [r8]
		pinMode(pin1, INPUT);
		digitalWrite(pin1, HIGH);
		pinMode(pin2, INPUT);
		digitalWrite(pin2, HIGH);
		#endif
		encoder.pin1_register = PIN_TO_BASEREG(pin1);
    37f8:	str.w	ip, [r5]
    37fc:	umull	sl, r8, fp, r8
		encoder.pin1_bitmask = PIN_TO_BITMASK(pin1);
		encoder.pin2_register = PIN_TO_BASEREG(pin2);
    3800:	str	r7, [r5, #4]
    3802:	mov.w	r8, r8, lsr #18
    3806:	mul.w	r8, r3, r8
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    380a:	ldr	r3, [r2, #0]
    380c:	subs	r3, r3, r1
    380e:	cmp	r8, r3
    3810:	bhi.n	380a <HardwareControls::init()+0x1e6>
		// allow time for a passive R-C filter to charge
		// through the pullup resistors, before reading
		// the initial state
		delayMicroseconds(2000);
		uint8_t s = 0;
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
    3812:	ldr.w	r3, [ip]
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
    3816:	ldr	r2, [r7, #0]
		encoder.position = 0;
		// allow time for a passive R-C filter to charge
		// through the pullup resistors, before reading
		// the initial state
		delayMicroseconds(2000);
		uint8_t s = 0;
    3818:	tst.w	lr, r3
    381c:	ite	ne
    381e:	movne	r3, #1
    3820:	moveq	r3, #0
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
    3822:	tst	r0, r2
    3824:	beq.n	382c <HardwareControls::init()+0x208>
    3826:	orr.w	r3, r3, #2
    382a:	uxtb	r3, r3
		encoder.state = s;
    382c:	strb	r3, [r5, #16]
#ifdef ENCODER_USE_INTERRUPTS
	// this giant function is an unfortunate consequence of Arduino's
	// attachInterrupt function not supporting any way to pass a pointer
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
    382e:	cmp.w	r9, #39	; 0x27
    3832:	bhi.w	48c4 <HardwareControls::init()+0x12a0>
    3836:	tbh	[pc, r9, lsl #1]
    383a:	.short	0x0446
    383c:	.word	0x0433043d
    3840:	.word	0x041f0429
    3844:	.word	0x040b0415
    3848:	.word	0x03f70401
    384c:	.word	0x03e303ed
    3850:	.word	0x03cf03d9
    3854:	.word	0x03bb03c5
    3858:	.word	0x03a703b1
    385c:	.word	0x0393039d
    3860:	.word	0x03360340
    3864:	.word	0x0322032c
    3868:	.word	0x030e0318
    386c:	.word	0x02fa0304
    3870:	.word	0x02e602f0
    3874:	.word	0x02d202dc
    3878:	.word	0x02bd02c8
    387c:	.word	0x02a702b2
    3880:	.word	0x0291029c
    3884:	.word	0x027b0286
    3888:	.short	0x0035
    388a:	nop
    388c:	.word	0x2001fbd8
    3890:	.word	0xe0001004
    3894:	.word	0x20057ee8
    3898:	.word	0x00002e2d
    389c:	.word	0x20020828
    38a0:	.word	0x431bde83
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    38a4:	ldr	r3, [pc, #728]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(39, isr39, CHANGE);
    38a6:	movs	r2, #4
    38a8:	ldr	r1, [pc, #728]	; (3b84 <HardwareControls::init()+0x560>)
    38aa:	movs	r0, #39	; 0x27
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    38ac:	str.w	r5, [r3, #156]	; 0x9c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    38b0:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
				attachInterrupt(39, isr39, CHANGE);
    38b4:	bl	16804 <attachInterrupt>
		uint8_t s = 0;
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
		encoder.state = s;
#ifdef ENCODER_USE_INTERRUPTS
		interrupts_in_use = attach_interrupt(pin1, &encoder);
    38b8:	strb.w	r9, [r5, #24]
#ifdef ENCODER_USE_INTERRUPTS
	// this giant function is an unfortunate consequence of Arduino's
	// attachInterrupt function not supporting any way to pass a pointer
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
    38bc:	cmp	r6, #39	; 0x27
    38be:	bhi.w	48be <HardwareControls::init()+0x129a>
    38c2:	tbh	[pc, r6, lsl #1]
    38c6:	.short	0x022a
    38c8:	.word	0x02150220
    38cc:	.word	0x01ff020a
    38d0:	.word	0x01e901f4
    38d4:	.word	0x01d301de
    38d8:	.word	0x01bd01c8
    38dc:	.word	0x01a701b2
    38e0:	.word	0x0191019c
    38e4:	.word	0x01470152
    38e8:	.word	0x0131013c
    38ec:	.word	0x011b0126
    38f0:	.word	0x01050110
    38f4:	.word	0x00ef00fa
    38f8:	.word	0x00d900e4
    38fc:	.word	0x00c300ce
    3900:	.word	0x00ad00b8
    3904:	.word	0x009600a2
    3908:	.word	0x007e008a
    390c:	.word	0x00660072
    3910:	.word	0x004e005a
    3914:	.short	0x0028
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    3916:	ldr	r3, [pc, #616]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(39, isr39, CHANGE);
    3918:	movs	r2, #4
    391a:	ldr	r1, [pc, #616]	; (3b84 <HardwareControls::init()+0x560>)
    391c:	movs	r0, #39	; 0x27
				attachInterrupt(38, isr38, CHANGE);
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
    391e:	str.w	r5, [r3, #156]	; 0x9c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3922:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT39_PIN
			case CORE_INT39_PIN:
				interruptArgs[39] = state;
				attachInterrupt(39, isr39, CHANGE);
    3924:	bl	16804 <attachInterrupt>
    3928:	ldrb.w	r9, [r5, #24]
		if (DIRECT_PIN_READ(encoder.pin1_register, encoder.pin1_bitmask)) s |= 1;
		if (DIRECT_PIN_READ(encoder.pin2_register, encoder.pin2_bitmask)) s |= 2;
		encoder.state = s;
#ifdef ENCODER_USE_INTERRUPTS
		interrupts_in_use = attach_interrupt(pin1, &encoder);
		interrupts_in_use += attach_interrupt(pin2, &encoder);
    392c:	add	r6, r9
    392e:	subs	r7, r4, #1
    3930:	add.w	r8, r4, #3
    3934:	str	r5, [r4, #84]	; 0x54
    3936:	strb	r6, [r5, #24]

    //Set 16ch multiplexer control pins to mode OUTPUT
    for (uint8_t i = 0; i < 4; i++)
        pinMode(muxControlPin[i], OUTPUT);
    3938:	ldrb.w	r0, [r7, #1]!
    393c:	movs	r1, #1
    393e:	bl	16b6c <pinMode>
{
    encoder[0] = new Encoder(rotaryPin[0][0], rotaryPin[0][1]);
    encoder[1] = new Encoder(rotaryPin[1][0], rotaryPin[1][1]);

    //Set 16ch multiplexer control pins to mode OUTPUT
    for (uint8_t i = 0; i < 4; i++)
    3942:	cmp	r8, r7
    3944:	bne.n	3938 <HardwareControls::init()+0x314>
        pinMode(muxControlPin[i], OUTPUT);

    //Read current hardware control values to memory, but do not update synth parameters
    checkControlValues(false);
    3946:	mov	r0, r4
    3948:	movs	r1, #0
    394a:	bl	341c <HardwareControls::checkControlValues(bool)>
    394e:	add.w	r3, r4, #131	; 0x83

    //Initialize potentiometer threshold array
    for (uint8_t i = 0; i < LAST_CTL; i++)
        potThreshold[i] = POT_THRESHOLD;
    3952:	movs	r2, #5
    3954:	adds	r4, #151	; 0x97
    3956:	strb.w	r2, [r3, #1]!

    //Read current hardware control values to memory, but do not update synth parameters
    checkControlValues(false);

    //Initialize potentiometer threshold array
    for (uint8_t i = 0; i < LAST_CTL; i++)
    395a:	cmp	r4, r3
    395c:	bne.n	3956 <HardwareControls::init()+0x332>
        potThreshold[i] = POT_THRESHOLD;
    395e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    3962:	ldr	r3, [pc, #540]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(38, isr38, CHANGE);
    3964:	movs	r2, #4
    3966:	ldr	r1, [pc, #544]	; (3b88 <HardwareControls::init()+0x564>)
    3968:	movs	r0, #38	; 0x26
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    396a:	str.w	r5, [r3, #152]	; 0x98
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    396e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
				attachInterrupt(38, isr38, CHANGE);
    3970:	bl	16804 <attachInterrupt>
    3974:	ldrb.w	r9, [r5, #24]
    3978:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    397a:	ldr	r3, [pc, #516]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(37, isr37, CHANGE);
    397c:	movs	r2, #4
    397e:	ldr	r1, [pc, #524]	; (3b8c <HardwareControls::init()+0x568>)
    3980:	movs	r0, #37	; 0x25
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    3982:	str.w	r5, [r3, #148]	; 0x94
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3986:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
				attachInterrupt(37, isr37, CHANGE);
    3988:	bl	16804 <attachInterrupt>
    398c:	ldrb.w	r9, [r5, #24]
    3990:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    3992:	ldr	r3, [pc, #492]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(36, isr36, CHANGE);
    3994:	movs	r2, #4
    3996:	ldr	r1, [pc, #504]	; (3b90 <HardwareControls::init()+0x56c>)
    3998:	movs	r0, #36	; 0x24
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    399a:	str.w	r5, [r3, #144]	; 0x90
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    399e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
				attachInterrupt(36, isr36, CHANGE);
    39a0:	bl	16804 <attachInterrupt>
    39a4:	ldrb.w	r9, [r5, #24]
    39a8:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    39aa:	ldr	r3, [pc, #468]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(35, isr35, CHANGE);
    39ac:	movs	r2, #4
    39ae:	ldr	r1, [pc, #484]	; (3b94 <HardwareControls::init()+0x570>)
    39b0:	movs	r0, #35	; 0x23
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    39b2:	str.w	r5, [r3, #140]	; 0x8c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    39b6:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
				attachInterrupt(35, isr35, CHANGE);
    39b8:	bl	16804 <attachInterrupt>
    39bc:	ldrb.w	r9, [r5, #24]
    39c0:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    39c2:	ldr	r3, [pc, #444]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(34, isr34, CHANGE);
    39c4:	movs	r2, #4
    39c6:	ldr	r1, [pc, #464]	; (3b98 <HardwareControls::init()+0x574>)
    39c8:	movs	r0, #34	; 0x22
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    39ca:	str.w	r5, [r3, #136]	; 0x88
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    39ce:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
				attachInterrupt(34, isr34, CHANGE);
    39d0:	bl	16804 <attachInterrupt>
    39d4:	ldrb.w	r9, [r5, #24]
    39d8:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    39da:	ldr	r3, [pc, #420]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(33, isr33, CHANGE);
    39dc:	movs	r2, #4
    39de:	ldr	r1, [pc, #444]	; (3b9c <HardwareControls::init()+0x578>)
    39e0:	movs	r0, #33	; 0x21
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    39e2:	str.w	r5, [r3, #132]	; 0x84
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    39e6:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
				attachInterrupt(33, isr33, CHANGE);
    39e8:	bl	16804 <attachInterrupt>
    39ec:	ldrb.w	r9, [r5, #24]
    39f0:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    39f2:	ldr	r3, [pc, #396]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(32, isr32, CHANGE);
    39f4:	movs	r2, #4
    39f6:	ldr	r1, [pc, #424]	; (3ba0 <HardwareControls::init()+0x57c>)
    39f8:	movs	r0, #32
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    39fa:	str.w	r5, [r3, #128]	; 0x80
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    39fe:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
				attachInterrupt(32, isr32, CHANGE);
    3a00:	bl	16804 <attachInterrupt>
    3a04:	ldrb.w	r9, [r5, #24]
    3a08:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    3a0a:	ldr	r3, [pc, #372]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(31, isr31, CHANGE);
    3a0c:	movs	r2, #4
    3a0e:	ldr	r1, [pc, #404]	; (3ba4 <HardwareControls::init()+0x580>)
    3a10:	movs	r0, #31
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    3a12:	str	r5, [r3, #124]	; 0x7c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a14:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
				attachInterrupt(31, isr31, CHANGE);
    3a16:	bl	16804 <attachInterrupt>
    3a1a:	ldrb.w	r9, [r5, #24]
    3a1e:	b.n	392c <HardwareControls::init()+0x308>
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    3a20:	ldr	r3, [pc, #348]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(30, isr30, CHANGE);
    3a22:	movs	r2, #4
    3a24:	ldr	r1, [pc, #384]	; (3ba8 <HardwareControls::init()+0x584>)
    3a26:	movs	r0, #30
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    3a28:	str	r5, [r3, #120]	; 0x78
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a2a:	movs	r6, #1
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
				attachInterrupt(30, isr30, CHANGE);
    3a2c:	bl	16804 <attachInterrupt>
    3a30:	ldrb.w	r9, [r5, #24]
    3a34:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    3a36:	ldr	r3, [pc, #328]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(29, isr29, CHANGE);
    3a38:	movs	r2, #4
    3a3a:	ldr	r1, [pc, #368]	; (3bac <HardwareControls::init()+0x588>)
    3a3c:	movs	r0, #29
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    3a3e:	str	r5, [r3, #116]	; 0x74
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a40:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
				attachInterrupt(29, isr29, CHANGE);
    3a42:	bl	16804 <attachInterrupt>
    3a46:	ldrb.w	r9, [r5, #24]
    3a4a:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    3a4c:	ldr	r3, [pc, #304]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(28, isr28, CHANGE);
    3a4e:	movs	r2, #4
    3a50:	ldr	r1, [pc, #348]	; (3bb0 <HardwareControls::init()+0x58c>)
    3a52:	movs	r0, #28
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    3a54:	str	r5, [r3, #112]	; 0x70
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a56:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
				attachInterrupt(28, isr28, CHANGE);
    3a58:	bl	16804 <attachInterrupt>
    3a5c:	ldrb.w	r9, [r5, #24]
    3a60:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    3a62:	ldr	r3, [pc, #284]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(27, isr27, CHANGE);
    3a64:	movs	r2, #4
    3a66:	ldr	r1, [pc, #332]	; (3bb4 <HardwareControls::init()+0x590>)
    3a68:	movs	r0, #27
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    3a6a:	str	r5, [r3, #108]	; 0x6c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a6c:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
				attachInterrupt(27, isr27, CHANGE);
    3a6e:	bl	16804 <attachInterrupt>
    3a72:	ldrb.w	r9, [r5, #24]
    3a76:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    3a78:	ldr	r3, [pc, #260]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(26, isr26, CHANGE);
    3a7a:	movs	r2, #4
    3a7c:	ldr	r1, [pc, #312]	; (3bb8 <HardwareControls::init()+0x594>)
    3a7e:	movs	r0, #26
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    3a80:	str	r5, [r3, #104]	; 0x68
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a82:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
				attachInterrupt(26, isr26, CHANGE);
    3a84:	bl	16804 <attachInterrupt>
    3a88:	ldrb.w	r9, [r5, #24]
    3a8c:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    3a8e:	ldr	r3, [pc, #240]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(25, isr25, CHANGE);
    3a90:	movs	r2, #4
    3a92:	ldr	r1, [pc, #296]	; (3bbc <HardwareControls::init()+0x598>)
    3a94:	movs	r0, #25
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    3a96:	str	r5, [r3, #100]	; 0x64
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3a98:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
				attachInterrupt(25, isr25, CHANGE);
    3a9a:	bl	16804 <attachInterrupt>
    3a9e:	ldrb.w	r9, [r5, #24]
    3aa2:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    3aa4:	ldr	r3, [pc, #216]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(24, isr24, CHANGE);
    3aa6:	movs	r2, #4
    3aa8:	ldr	r1, [pc, #276]	; (3bc0 <HardwareControls::init()+0x59c>)
    3aaa:	movs	r0, #24
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    3aac:	str	r5, [r3, #96]	; 0x60
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3aae:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
				attachInterrupt(24, isr24, CHANGE);
    3ab0:	bl	16804 <attachInterrupt>
    3ab4:	ldrb.w	r9, [r5, #24]
    3ab8:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    3aba:	ldr	r3, [pc, #196]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(23, isr23, CHANGE);
    3abc:	movs	r2, #4
    3abe:	ldr	r1, [pc, #260]	; (3bc4 <HardwareControls::init()+0x5a0>)
    3ac0:	movs	r0, #23
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    3ac2:	str	r5, [r3, #92]	; 0x5c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3ac4:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
				attachInterrupt(23, isr23, CHANGE);
    3ac6:	bl	16804 <attachInterrupt>
    3aca:	ldrb.w	r9, [r5, #24]
    3ace:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    3ad0:	ldr	r3, [pc, #172]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(22, isr22, CHANGE);
    3ad2:	movs	r2, #4
    3ad4:	ldr	r1, [pc, #240]	; (3bc8 <HardwareControls::init()+0x5a4>)
    3ad6:	movs	r0, #22
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    3ad8:	str	r5, [r3, #88]	; 0x58
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3ada:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
				attachInterrupt(22, isr22, CHANGE);
    3adc:	bl	16804 <attachInterrupt>
    3ae0:	ldrb.w	r9, [r5, #24]
    3ae4:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    3ae6:	ldr	r3, [pc, #152]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(21, isr21, CHANGE);
    3ae8:	movs	r2, #4
    3aea:	ldr	r1, [pc, #224]	; (3bcc <HardwareControls::init()+0x5a8>)
    3aec:	movs	r0, #21
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    3aee:	str	r5, [r3, #84]	; 0x54
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3af0:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
				attachInterrupt(21, isr21, CHANGE);
    3af2:	bl	16804 <attachInterrupt>
    3af6:	ldrb.w	r9, [r5, #24]
    3afa:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    3afc:	ldr	r3, [pc, #128]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(20, isr20, CHANGE);
    3afe:	movs	r2, #4
    3b00:	ldr	r1, [pc, #204]	; (3bd0 <HardwareControls::init()+0x5ac>)
    3b02:	movs	r0, #20
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    3b04:	str	r5, [r3, #80]	; 0x50
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3b06:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
				attachInterrupt(20, isr20, CHANGE);
    3b08:	bl	16804 <attachInterrupt>
    3b0c:	ldrb.w	r9, [r5, #24]
    3b10:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    3b12:	ldr	r3, [pc, #108]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(19, isr19, CHANGE);
    3b14:	movs	r2, #4
    3b16:	ldr	r1, [pc, #188]	; (3bd4 <HardwareControls::init()+0x5b0>)
    3b18:	movs	r0, #19
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    3b1a:	str	r5, [r3, #76]	; 0x4c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3b1c:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
				attachInterrupt(19, isr19, CHANGE);
    3b1e:	bl	16804 <attachInterrupt>
    3b22:	ldrb.w	r9, [r5, #24]
    3b26:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    3b28:	ldr	r3, [pc, #84]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(18, isr18, CHANGE);
    3b2a:	movs	r2, #4
    3b2c:	ldr	r1, [pc, #168]	; (3bd8 <HardwareControls::init()+0x5b4>)
    3b2e:	movs	r0, #18
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    3b30:	str	r5, [r3, #72]	; 0x48
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3b32:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
				attachInterrupt(18, isr18, CHANGE);
    3b34:	bl	16804 <attachInterrupt>
    3b38:	ldrb.w	r9, [r5, #24]
    3b3c:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    3b3e:	ldr	r3, [pc, #64]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(17, isr17, CHANGE);
    3b40:	movs	r2, #4
    3b42:	ldr	r1, [pc, #152]	; (3bdc <HardwareControls::init()+0x5b8>)
    3b44:	movs	r0, #17
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    3b46:	str	r5, [r3, #68]	; 0x44
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3b48:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
				attachInterrupt(17, isr17, CHANGE);
    3b4a:	bl	16804 <attachInterrupt>
    3b4e:	ldrb.w	r9, [r5, #24]
    3b52:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    3b54:	ldr	r3, [pc, #40]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(16, isr16, CHANGE);
    3b56:	movs	r2, #4
    3b58:	ldr	r1, [pc, #132]	; (3be0 <HardwareControls::init()+0x5bc>)
    3b5a:	movs	r0, #16
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    3b5c:	str	r5, [r3, #64]	; 0x40
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3b5e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
				attachInterrupt(16, isr16, CHANGE);
    3b60:	bl	16804 <attachInterrupt>
    3b64:	ldrb.w	r9, [r5, #24]
    3b68:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    3b6a:	ldr	r3, [pc, #20]	; (3b80 <HardwareControls::init()+0x55c>)
				attachInterrupt(15, isr15, CHANGE);
    3b6c:	movs	r2, #4
    3b6e:	ldr	r1, [pc, #116]	; (3be4 <HardwareControls::init()+0x5c0>)
    3b70:	movs	r0, #15
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    3b72:	str	r5, [r3, #60]	; 0x3c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3b74:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
				attachInterrupt(15, isr15, CHANGE);
    3b76:	bl	16804 <attachInterrupt>
    3b7a:	ldrb.w	r9, [r5, #24]
    3b7e:	b.n	392c <HardwareControls::init()+0x308>
    3b80:	.word	0x20057ee8
    3b84:	.word	0x00002e2d
    3b88:	.word	0x00002da1
    3b8c:	.word	0x00002d15
    3b90:	.word	0x00002c89
    3b94:	.word	0x00002bfd
    3b98:	.word	0x00002b71
    3b9c:	.word	0x00002ae5
    3ba0:	.word	0x00002a59
    3ba4:	.word	0x000029d1
    3ba8:	.word	0x00002949
    3bac:	.word	0x000028c1
    3bb0:	.word	0x00002839
    3bb4:	.word	0x000027b1
    3bb8:	.word	0x00002729
    3bbc:	.word	0x000026a1
    3bc0:	.word	0x00002619
    3bc4:	.word	0x00002591
    3bc8:	.word	0x00002509
    3bcc:	.word	0x00002481
    3bd0:	.word	0x000023f9
    3bd4:	.word	0x00002371
    3bd8:	.word	0x000022e9
    3bdc:	.word	0x00002261
    3be0:	.word	0x000021d9
    3be4:	.word	0x00002151
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    3be8:	ldr	r3, [pc, #740]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(14, isr14, CHANGE);
    3bea:	movs	r2, #4
    3bec:	ldr	r1, [pc, #740]	; (3ed4 <HardwareControls::init()+0x8b0>)
    3bee:	movs	r0, #14
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    3bf0:	str	r5, [r3, #56]	; 0x38
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3bf2:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
				attachInterrupt(14, isr14, CHANGE);
    3bf4:	bl	16804 <attachInterrupt>
    3bf8:	ldrb.w	r9, [r5, #24]
    3bfc:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    3bfe:	ldr	r3, [pc, #720]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(13, isr13, CHANGE);
    3c00:	movs	r2, #4
    3c02:	ldr	r1, [pc, #724]	; (3ed8 <HardwareControls::init()+0x8b4>)
    3c04:	movs	r0, #13
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    3c06:	str	r5, [r3, #52]	; 0x34
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c08:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
				attachInterrupt(13, isr13, CHANGE);
    3c0a:	bl	16804 <attachInterrupt>
    3c0e:	ldrb.w	r9, [r5, #24]
    3c12:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    3c14:	ldr	r3, [pc, #696]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(12, isr12, CHANGE);
    3c16:	movs	r2, #4
    3c18:	ldr	r1, [pc, #704]	; (3edc <HardwareControls::init()+0x8b8>)
    3c1a:	movs	r0, #12
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    3c1c:	str	r5, [r3, #48]	; 0x30
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c1e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
				attachInterrupt(12, isr12, CHANGE);
    3c20:	bl	16804 <attachInterrupt>
    3c24:	ldrb.w	r9, [r5, #24]
    3c28:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    3c2a:	ldr	r3, [pc, #676]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(11, isr11, CHANGE);
    3c2c:	movs	r2, #4
    3c2e:	ldr	r1, [pc, #688]	; (3ee0 <HardwareControls::init()+0x8bc>)
    3c30:	movs	r0, #11
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    3c32:	str	r5, [r3, #44]	; 0x2c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c34:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
				attachInterrupt(11, isr11, CHANGE);
    3c36:	bl	16804 <attachInterrupt>
    3c3a:	ldrb.w	r9, [r5, #24]
    3c3e:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    3c40:	ldr	r3, [pc, #652]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(10, isr10, CHANGE);
    3c42:	movs	r2, #4
    3c44:	ldr	r1, [pc, #668]	; (3ee4 <HardwareControls::init()+0x8c0>)
    3c46:	movs	r0, #10
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    3c48:	str	r5, [r3, #40]	; 0x28
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c4a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
				attachInterrupt(10, isr10, CHANGE);
    3c4c:	bl	16804 <attachInterrupt>
    3c50:	ldrb.w	r9, [r5, #24]
    3c54:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    3c56:	ldr	r3, [pc, #632]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(9, isr9, CHANGE);
    3c58:	movs	r2, #4
    3c5a:	ldr	r1, [pc, #652]	; (3ee8 <HardwareControls::init()+0x8c4>)
    3c5c:	movs	r0, #9
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    3c5e:	str	r5, [r3, #36]	; 0x24
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c60:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
				attachInterrupt(9, isr9, CHANGE);
    3c62:	bl	16804 <attachInterrupt>
    3c66:	ldrb.w	r9, [r5, #24]
    3c6a:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    3c6c:	ldr	r3, [pc, #608]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(8, isr8, CHANGE);
    3c6e:	movs	r2, #4
    3c70:	ldr	r1, [pc, #632]	; (3eec <HardwareControls::init()+0x8c8>)
    3c72:	movs	r0, #8
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    3c74:	str	r5, [r3, #32]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c76:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
				attachInterrupt(8, isr8, CHANGE);
    3c78:	bl	16804 <attachInterrupt>
    3c7c:	ldrb.w	r9, [r5, #24]
    3c80:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    3c82:	ldr	r3, [pc, #588]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(7, isr7, CHANGE);
    3c84:	movs	r2, #4
    3c86:	ldr	r1, [pc, #616]	; (3ef0 <HardwareControls::init()+0x8cc>)
    3c88:	movs	r0, #7
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    3c8a:	str	r5, [r3, #28]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3c8c:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
				attachInterrupt(7, isr7, CHANGE);
    3c8e:	bl	16804 <attachInterrupt>
    3c92:	ldrb.w	r9, [r5, #24]
    3c96:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    3c98:	ldr	r3, [pc, #564]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(6, isr6, CHANGE);
    3c9a:	movs	r2, #4
    3c9c:	ldr	r1, [pc, #596]	; (3ef4 <HardwareControls::init()+0x8d0>)
    3c9e:	movs	r0, #6
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    3ca0:	str	r5, [r3, #24]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3ca2:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
				attachInterrupt(6, isr6, CHANGE);
    3ca4:	bl	16804 <attachInterrupt>
    3ca8:	ldrb.w	r9, [r5, #24]
    3cac:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    3cae:	ldr	r3, [pc, #544]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(5, isr5, CHANGE);
    3cb0:	movs	r2, #4
    3cb2:	ldr	r1, [pc, #580]	; (3ef8 <HardwareControls::init()+0x8d4>)
    3cb4:	movs	r0, #5
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    3cb6:	str	r5, [r3, #20]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3cb8:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
				attachInterrupt(5, isr5, CHANGE);
    3cba:	bl	16804 <attachInterrupt>
    3cbe:	ldrb.w	r9, [r5, #24]
    3cc2:	b.n	392c <HardwareControls::init()+0x308>
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    3cc4:	movs	r2, #4
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    3cc6:	ldr	r3, [pc, #520]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(4, isr4, CHANGE);
    3cc8:	ldr	r1, [pc, #560]	; (3efc <HardwareControls::init()+0x8d8>)
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3cca:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    3ccc:	mov	r0, r2
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    3cce:	str	r5, [r3, #16]
				attachInterrupt(4, isr4, CHANGE);
    3cd0:	bl	16804 <attachInterrupt>
    3cd4:	ldrb.w	r9, [r5, #24]
    3cd8:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    3cda:	ldr	r3, [pc, #500]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(3, isr3, CHANGE);
    3cdc:	movs	r2, #4
    3cde:	ldr	r1, [pc, #544]	; (3f00 <HardwareControls::init()+0x8dc>)
    3ce0:	movs	r0, #3
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    3ce2:	str	r5, [r3, #12]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3ce4:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
				attachInterrupt(3, isr3, CHANGE);
    3ce6:	bl	16804 <attachInterrupt>
    3cea:	ldrb.w	r9, [r5, #24]
    3cee:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    3cf0:	ldr	r3, [pc, #476]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(2, isr2, CHANGE);
    3cf2:	movs	r2, #4
    3cf4:	ldr	r1, [pc, #524]	; (3f04 <HardwareControls::init()+0x8e0>)
    3cf6:	movs	r0, #2
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    3cf8:	str	r5, [r3, #8]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3cfa:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
				attachInterrupt(2, isr2, CHANGE);
    3cfc:	bl	16804 <attachInterrupt>
    3d00:	ldrb.w	r9, [r5, #24]
    3d04:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    3d06:	ldr	r3, [pc, #456]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(1, isr1, CHANGE);
    3d08:	movs	r2, #4
    3d0a:	ldr	r1, [pc, #508]	; (3f08 <HardwareControls::init()+0x8e4>)
    3d0c:	movs	r0, #1
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    3d0e:	str	r5, [r3, #4]
				attachInterrupt(1, isr1, CHANGE);
    3d10:	bl	16804 <attachInterrupt>
    3d14:	ldrb.w	r9, [r5, #24]
    3d18:	b.n	392c <HardwareControls::init()+0x308>
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    3d1a:	ldr	r3, [pc, #436]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(0, isr0, CHANGE);
    3d1c:	movs	r2, #4
    3d1e:	ldr	r1, [pc, #492]	; (3f0c <HardwareControls::init()+0x8e8>)
    3d20:	movs	r0, #0
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    3d22:	str	r5, [r3, #0]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3d24:	movs	r6, #1
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
				attachInterrupt(0, isr0, CHANGE);
    3d26:	bl	16804 <attachInterrupt>
    3d2a:	ldrb.w	r9, [r5, #24]
    3d2e:	b.n	392c <HardwareControls::init()+0x308>
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    3d30:	ldr	r3, [pc, #412]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(38, isr38, CHANGE);
    3d32:	movs	r2, #4
    3d34:	ldr	r1, [pc, #472]	; (3f10 <HardwareControls::init()+0x8ec>)
    3d36:	movs	r0, #38	; 0x26
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    3d38:	str.w	r5, [r3, #152]	; 0x98
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3d3c:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
				attachInterrupt(38, isr38, CHANGE);
    3d40:	bl	16804 <attachInterrupt>
    3d44:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    3d46:	ldr	r3, [pc, #392]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(37, isr37, CHANGE);
    3d48:	movs	r2, #4
    3d4a:	ldr	r1, [pc, #456]	; (3f14 <HardwareControls::init()+0x8f0>)
    3d4c:	movs	r0, #37	; 0x25
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    3d4e:	str.w	r5, [r3, #148]	; 0x94
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3d52:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
				attachInterrupt(37, isr37, CHANGE);
    3d56:	bl	16804 <attachInterrupt>
    3d5a:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    3d5c:	ldr	r3, [pc, #368]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(36, isr36, CHANGE);
    3d5e:	movs	r2, #4
    3d60:	ldr	r1, [pc, #436]	; (3f18 <HardwareControls::init()+0x8f4>)
    3d62:	movs	r0, #36	; 0x24
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    3d64:	str.w	r5, [r3, #144]	; 0x90
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3d68:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
				attachInterrupt(36, isr36, CHANGE);
    3d6c:	bl	16804 <attachInterrupt>
    3d70:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    3d72:	ldr	r3, [pc, #348]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(35, isr35, CHANGE);
    3d74:	movs	r2, #4
    3d76:	ldr	r1, [pc, #420]	; (3f1c <HardwareControls::init()+0x8f8>)
    3d78:	movs	r0, #35	; 0x23
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    3d7a:	str.w	r5, [r3, #140]	; 0x8c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3d7e:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
				attachInterrupt(35, isr35, CHANGE);
    3d82:	bl	16804 <attachInterrupt>
    3d86:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    3d88:	ldr	r3, [pc, #324]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(34, isr34, CHANGE);
    3d8a:	movs	r2, #4
    3d8c:	ldr	r1, [pc, #400]	; (3f20 <HardwareControls::init()+0x8fc>)
    3d8e:	movs	r0, #34	; 0x22
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    3d90:	str.w	r5, [r3, #136]	; 0x88
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3d94:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
				attachInterrupt(34, isr34, CHANGE);
    3d98:	bl	16804 <attachInterrupt>
    3d9c:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    3d9e:	ldr	r3, [pc, #304]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(33, isr33, CHANGE);
    3da0:	movs	r2, #4
    3da2:	ldr	r1, [pc, #384]	; (3f24 <HardwareControls::init()+0x900>)
    3da4:	movs	r0, #33	; 0x21
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    3da6:	str.w	r5, [r3, #132]	; 0x84
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3daa:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
				attachInterrupt(33, isr33, CHANGE);
    3dae:	bl	16804 <attachInterrupt>
    3db2:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    3db4:	ldr	r3, [pc, #280]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(32, isr32, CHANGE);
    3db6:	movs	r2, #4
    3db8:	ldr	r1, [pc, #364]	; (3f28 <HardwareControls::init()+0x904>)
    3dba:	movs	r0, #32
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    3dbc:	str.w	r5, [r3, #128]	; 0x80
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3dc0:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
				attachInterrupt(32, isr32, CHANGE);
    3dc4:	bl	16804 <attachInterrupt>
    3dc8:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    3dca:	ldr	r3, [pc, #260]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(31, isr31, CHANGE);
    3dcc:	movs	r2, #4
    3dce:	ldr	r1, [pc, #348]	; (3f2c <HardwareControls::init()+0x908>)
    3dd0:	movs	r0, #31
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    3dd2:	str	r5, [r3, #124]	; 0x7c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3dd4:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
				attachInterrupt(31, isr31, CHANGE);
    3dd8:	bl	16804 <attachInterrupt>
    3ddc:	b.n	38b8 <HardwareControls::init()+0x294>
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    3dde:	ldr	r3, [pc, #240]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(30, isr30, CHANGE);
    3de0:	movs	r2, #4
    3de2:	ldr	r1, [pc, #332]	; (3f30 <HardwareControls::init()+0x90c>)
    3de4:	movs	r0, #30
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    3de6:	str	r5, [r3, #120]	; 0x78
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3de8:	mov.w	r9, #1
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
				attachInterrupt(30, isr30, CHANGE);
    3dec:	bl	16804 <attachInterrupt>
    3df0:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    3df2:	ldr	r3, [pc, #220]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(29, isr29, CHANGE);
    3df4:	movs	r2, #4
    3df6:	ldr	r1, [pc, #316]	; (3f34 <HardwareControls::init()+0x910>)
    3df8:	movs	r0, #29
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    3dfa:	str	r5, [r3, #116]	; 0x74
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3dfc:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
				attachInterrupt(29, isr29, CHANGE);
    3e00:	bl	16804 <attachInterrupt>
    3e04:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    3e06:	ldr	r3, [pc, #200]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(28, isr28, CHANGE);
    3e08:	movs	r2, #4
    3e0a:	ldr	r1, [pc, #300]	; (3f38 <HardwareControls::init()+0x914>)
    3e0c:	movs	r0, #28
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    3e0e:	str	r5, [r3, #112]	; 0x70
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e10:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
				attachInterrupt(28, isr28, CHANGE);
    3e14:	bl	16804 <attachInterrupt>
    3e18:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    3e1a:	ldr	r3, [pc, #180]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(27, isr27, CHANGE);
    3e1c:	movs	r2, #4
    3e1e:	ldr	r1, [pc, #284]	; (3f3c <HardwareControls::init()+0x918>)
    3e20:	movs	r0, #27
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    3e22:	str	r5, [r3, #108]	; 0x6c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e24:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
				attachInterrupt(27, isr27, CHANGE);
    3e28:	bl	16804 <attachInterrupt>
    3e2c:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    3e2e:	ldr	r3, [pc, #160]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(26, isr26, CHANGE);
    3e30:	movs	r2, #4
    3e32:	ldr	r1, [pc, #268]	; (3f40 <HardwareControls::init()+0x91c>)
    3e34:	movs	r0, #26
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    3e36:	str	r5, [r3, #104]	; 0x68
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e38:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
				attachInterrupt(26, isr26, CHANGE);
    3e3c:	bl	16804 <attachInterrupt>
    3e40:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    3e42:	ldr	r3, [pc, #140]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(25, isr25, CHANGE);
    3e44:	movs	r2, #4
    3e46:	ldr	r1, [pc, #252]	; (3f44 <HardwareControls::init()+0x920>)
    3e48:	movs	r0, #25
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    3e4a:	str	r5, [r3, #100]	; 0x64
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e4c:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
				attachInterrupt(25, isr25, CHANGE);
    3e50:	bl	16804 <attachInterrupt>
    3e54:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    3e56:	ldr	r3, [pc, #120]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(24, isr24, CHANGE);
    3e58:	movs	r2, #4
    3e5a:	ldr	r1, [pc, #236]	; (3f48 <HardwareControls::init()+0x924>)
    3e5c:	movs	r0, #24
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    3e5e:	str	r5, [r3, #96]	; 0x60
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e60:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
				attachInterrupt(24, isr24, CHANGE);
    3e64:	bl	16804 <attachInterrupt>
    3e68:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    3e6a:	ldr	r3, [pc, #100]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(23, isr23, CHANGE);
    3e6c:	movs	r2, #4
    3e6e:	ldr	r1, [pc, #220]	; (3f4c <HardwareControls::init()+0x928>)
    3e70:	movs	r0, #23
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    3e72:	str	r5, [r3, #92]	; 0x5c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e74:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
				attachInterrupt(23, isr23, CHANGE);
    3e78:	bl	16804 <attachInterrupt>
    3e7c:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    3e7e:	ldr	r3, [pc, #80]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(22, isr22, CHANGE);
    3e80:	movs	r2, #4
    3e82:	ldr	r1, [pc, #204]	; (3f50 <HardwareControls::init()+0x92c>)
    3e84:	movs	r0, #22
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    3e86:	str	r5, [r3, #88]	; 0x58
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e88:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
				attachInterrupt(22, isr22, CHANGE);
    3e8c:	bl	16804 <attachInterrupt>
    3e90:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    3e92:	ldr	r3, [pc, #60]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(21, isr21, CHANGE);
    3e94:	movs	r2, #4
    3e96:	ldr	r1, [pc, #188]	; (3f54 <HardwareControls::init()+0x930>)
    3e98:	movs	r0, #21
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    3e9a:	str	r5, [r3, #84]	; 0x54
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3e9c:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
				attachInterrupt(21, isr21, CHANGE);
    3ea0:	bl	16804 <attachInterrupt>
    3ea4:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    3ea6:	ldr	r3, [pc, #40]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(20, isr20, CHANGE);
    3ea8:	movs	r2, #4
    3eaa:	ldr	r1, [pc, #172]	; (3f58 <HardwareControls::init()+0x934>)
    3eac:	movs	r0, #20
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    3eae:	str	r5, [r3, #80]	; 0x50
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3eb0:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
				attachInterrupt(20, isr20, CHANGE);
    3eb4:	bl	16804 <attachInterrupt>
    3eb8:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    3eba:	ldr	r3, [pc, #20]	; (3ed0 <HardwareControls::init()+0x8ac>)
				attachInterrupt(19, isr19, CHANGE);
    3ebc:	movs	r2, #4
    3ebe:	ldr	r1, [pc, #156]	; (3f5c <HardwareControls::init()+0x938>)
    3ec0:	movs	r0, #19
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    3ec2:	str	r5, [r3, #76]	; 0x4c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3ec4:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
				attachInterrupt(19, isr19, CHANGE);
    3ec8:	bl	16804 <attachInterrupt>
    3ecc:	b.n	38b8 <HardwareControls::init()+0x294>
    3ece:	nop
    3ed0:	.word	0x20057ee8
    3ed4:	.word	0x000020c9
    3ed8:	.word	0x00002041
    3edc:	.word	0x00001fb9
    3ee0:	.word	0x00001f31
    3ee4:	.word	0x00001ea9
    3ee8:	.word	0x00001e21
    3eec:	.word	0x00001d99
    3ef0:	.word	0x00001c01
    3ef4:	.word	0x00001b79
    3ef8:	.word	0x00001af1
    3efc:	.word	0x00001a69
    3f00:	.word	0x00001d11
    3f04:	.word	0x00001c89
    3f08:	.word	0x000019e1
    3f0c:	.word	0x00001959
    3f10:	.word	0x00002da1
    3f14:	.word	0x00002d15
    3f18:	.word	0x00002c89
    3f1c:	.word	0x00002bfd
    3f20:	.word	0x00002b71
    3f24:	.word	0x00002ae5
    3f28:	.word	0x00002a59
    3f2c:	.word	0x000029d1
    3f30:	.word	0x00002949
    3f34:	.word	0x000028c1
    3f38:	.word	0x00002839
    3f3c:	.word	0x000027b1
    3f40:	.word	0x00002729
    3f44:	.word	0x000026a1
    3f48:	.word	0x00002619
    3f4c:	.word	0x00002591
    3f50:	.word	0x00002509
    3f54:	.word	0x00002481
    3f58:	.word	0x000023f9
    3f5c:	.word	0x00002371
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    3f60:	ldr	r3, [pc, #752]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(18, isr18, CHANGE);
    3f62:	movs	r2, #4
    3f64:	ldr	r1, [pc, #752]	; (4258 <HardwareControls::init()+0xc34>)
    3f66:	movs	r0, #18
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    3f68:	str	r5, [r3, #72]	; 0x48
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3f6a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
				attachInterrupt(18, isr18, CHANGE);
    3f6e:	bl	16804 <attachInterrupt>
    3f72:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    3f74:	ldr	r3, [pc, #732]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(17, isr17, CHANGE);
    3f76:	movs	r2, #4
    3f78:	ldr	r1, [pc, #736]	; (425c <HardwareControls::init()+0xc38>)
    3f7a:	movs	r0, #17
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    3f7c:	str	r5, [r3, #68]	; 0x44
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3f7e:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
				attachInterrupt(17, isr17, CHANGE);
    3f82:	bl	16804 <attachInterrupt>
    3f86:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    3f88:	ldr	r3, [pc, #712]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(16, isr16, CHANGE);
    3f8a:	movs	r2, #4
    3f8c:	ldr	r1, [pc, #720]	; (4260 <HardwareControls::init()+0xc3c>)
    3f8e:	movs	r0, #16
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    3f90:	str	r5, [r3, #64]	; 0x40
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3f92:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
				attachInterrupt(16, isr16, CHANGE);
    3f96:	bl	16804 <attachInterrupt>
    3f9a:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    3f9c:	ldr	r3, [pc, #692]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(15, isr15, CHANGE);
    3f9e:	movs	r2, #4
    3fa0:	ldr	r1, [pc, #704]	; (4264 <HardwareControls::init()+0xc40>)
    3fa2:	movs	r0, #15
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    3fa4:	str	r5, [r3, #60]	; 0x3c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3fa6:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
				attachInterrupt(15, isr15, CHANGE);
    3faa:	bl	16804 <attachInterrupt>
    3fae:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    3fb0:	ldr	r3, [pc, #672]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(14, isr14, CHANGE);
    3fb2:	movs	r2, #4
    3fb4:	ldr	r1, [pc, #688]	; (4268 <HardwareControls::init()+0xc44>)
    3fb6:	movs	r0, #14
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    3fb8:	str	r5, [r3, #56]	; 0x38
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3fba:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
				attachInterrupt(14, isr14, CHANGE);
    3fbe:	bl	16804 <attachInterrupt>
    3fc2:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    3fc4:	ldr	r3, [pc, #652]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(13, isr13, CHANGE);
    3fc6:	movs	r2, #4
    3fc8:	ldr	r1, [pc, #672]	; (426c <HardwareControls::init()+0xc48>)
    3fca:	movs	r0, #13
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    3fcc:	str	r5, [r3, #52]	; 0x34
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3fce:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
				attachInterrupt(13, isr13, CHANGE);
    3fd2:	bl	16804 <attachInterrupt>
    3fd6:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    3fd8:	ldr	r3, [pc, #632]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(12, isr12, CHANGE);
    3fda:	movs	r2, #4
    3fdc:	ldr	r1, [pc, #656]	; (4270 <HardwareControls::init()+0xc4c>)
    3fde:	movs	r0, #12
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    3fe0:	str	r5, [r3, #48]	; 0x30
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3fe2:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
				attachInterrupt(12, isr12, CHANGE);
    3fe6:	bl	16804 <attachInterrupt>
    3fea:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    3fec:	ldr	r3, [pc, #612]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(11, isr11, CHANGE);
    3fee:	movs	r2, #4
    3ff0:	ldr	r1, [pc, #640]	; (4274 <HardwareControls::init()+0xc50>)
    3ff2:	movs	r0, #11
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    3ff4:	str	r5, [r3, #44]	; 0x2c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    3ff6:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
				attachInterrupt(11, isr11, CHANGE);
    3ffa:	bl	16804 <attachInterrupt>
    3ffe:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    4000:	ldr	r3, [pc, #592]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(10, isr10, CHANGE);
    4002:	movs	r2, #4
    4004:	ldr	r1, [pc, #624]	; (4278 <HardwareControls::init()+0xc54>)
    4006:	movs	r0, #10
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    4008:	str	r5, [r3, #40]	; 0x28
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    400a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
				attachInterrupt(10, isr10, CHANGE);
    400e:	bl	16804 <attachInterrupt>
    4012:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    4014:	ldr	r3, [pc, #572]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(9, isr9, CHANGE);
    4016:	movs	r2, #4
    4018:	ldr	r1, [pc, #608]	; (427c <HardwareControls::init()+0xc58>)
    401a:	movs	r0, #9
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    401c:	str	r5, [r3, #36]	; 0x24
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    401e:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
				attachInterrupt(9, isr9, CHANGE);
    4022:	bl	16804 <attachInterrupt>
    4026:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    4028:	ldr	r3, [pc, #552]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(8, isr8, CHANGE);
    402a:	movs	r2, #4
    402c:	ldr	r1, [pc, #592]	; (4280 <HardwareControls::init()+0xc5c>)
    402e:	movs	r0, #8
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    4030:	str	r5, [r3, #32]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4032:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
				attachInterrupt(8, isr8, CHANGE);
    4036:	bl	16804 <attachInterrupt>
    403a:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    403c:	ldr	r3, [pc, #532]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(7, isr7, CHANGE);
    403e:	movs	r2, #4
    4040:	ldr	r1, [pc, #576]	; (4284 <HardwareControls::init()+0xc60>)
    4042:	movs	r0, #7
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    4044:	str	r5, [r3, #28]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4046:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
				attachInterrupt(7, isr7, CHANGE);
    404a:	bl	16804 <attachInterrupt>
    404e:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    4050:	ldr	r3, [pc, #512]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(6, isr6, CHANGE);
    4052:	movs	r2, #4
    4054:	ldr	r1, [pc, #560]	; (4288 <HardwareControls::init()+0xc64>)
    4056:	movs	r0, #6
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    4058:	str	r5, [r3, #24]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    405a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
				attachInterrupt(6, isr6, CHANGE);
    405e:	bl	16804 <attachInterrupt>
    4062:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    4064:	ldr	r3, [pc, #492]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(5, isr5, CHANGE);
    4066:	movs	r2, #4
    4068:	ldr	r1, [pc, #544]	; (428c <HardwareControls::init()+0xc68>)
    406a:	movs	r0, #5
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    406c:	str	r5, [r3, #20]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    406e:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
				attachInterrupt(5, isr5, CHANGE);
    4072:	bl	16804 <attachInterrupt>
    4076:	b.n	38b8 <HardwareControls::init()+0x294>
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    4078:	movs	r2, #4
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    407a:	ldr	r3, [pc, #472]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(4, isr4, CHANGE);
    407c:	ldr	r1, [pc, #528]	; (4290 <HardwareControls::init()+0xc6c>)
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    407e:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    4082:	mov	r0, r2
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    4084:	str	r5, [r3, #16]
				attachInterrupt(4, isr4, CHANGE);
    4086:	bl	16804 <attachInterrupt>
    408a:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    408c:	ldr	r3, [pc, #452]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(3, isr3, CHANGE);
    408e:	movs	r2, #4
    4090:	ldr	r1, [pc, #512]	; (4294 <HardwareControls::init()+0xc70>)
    4092:	movs	r0, #3
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    4094:	str	r5, [r3, #12]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4096:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
				attachInterrupt(3, isr3, CHANGE);
    409a:	bl	16804 <attachInterrupt>
    409e:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    40a0:	ldr	r3, [pc, #432]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(2, isr2, CHANGE);
    40a2:	movs	r2, #4
    40a4:	ldr	r1, [pc, #496]	; (4298 <HardwareControls::init()+0xc74>)
    40a6:	movs	r0, #2
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    40a8:	str	r5, [r3, #8]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    40aa:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
				attachInterrupt(2, isr2, CHANGE);
    40ae:	bl	16804 <attachInterrupt>
    40b2:	b.n	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    40b4:	ldr	r3, [pc, #412]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(1, isr1, CHANGE);
    40b6:	movs	r2, #4
    40b8:	ldr	r1, [pc, #480]	; (429c <HardwareControls::init()+0xc78>)
    40ba:	movs	r0, #1
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    40bc:	str	r5, [r3, #4]
				attachInterrupt(1, isr1, CHANGE);
    40be:	bl	16804 <attachInterrupt>
    40c2:	b.w	38b8 <HardwareControls::init()+0x294>
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    40c6:	ldr	r3, [pc, #396]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(0, isr0, CHANGE);
    40c8:	movs	r2, #4
    40ca:	ldr	r1, [pc, #468]	; (42a0 <HardwareControls::init()+0xc7c>)
    40cc:	movs	r0, #0
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    40ce:	str	r5, [r3, #0]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    40d0:	mov.w	r9, #1
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
				attachInterrupt(0, isr0, CHANGE);
    40d4:	bl	16804 <attachInterrupt>
    40d8:	b.w	38b8 <HardwareControls::init()+0x294>
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    40dc:	ldr	r3, [pc, #372]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(38, isr38, CHANGE);
    40de:	movs	r2, #4
    40e0:	ldr	r1, [pc, #448]	; (42a4 <HardwareControls::init()+0xc80>)
    40e2:	movs	r0, #38	; 0x26
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    40e4:	str.w	r5, [r3, #152]	; 0x98
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    40e8:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
				attachInterrupt(38, isr38, CHANGE);
    40ec:	bl	16804 <attachInterrupt>
    40f0:	ldrb	r6, [r5, #24]
    40f2:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    40f6:	ldr	r3, [pc, #348]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(37, isr37, CHANGE);
    40f8:	movs	r2, #4
    40fa:	ldr	r1, [pc, #428]	; (42a8 <HardwareControls::init()+0xc84>)
    40fc:	movs	r0, #37	; 0x25
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    40fe:	str.w	r5, [r3, #148]	; 0x94
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4102:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
				attachInterrupt(37, isr37, CHANGE);
    4106:	bl	16804 <attachInterrupt>
    410a:	ldrb	r6, [r5, #24]
    410c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    4110:	ldr	r3, [pc, #320]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(36, isr36, CHANGE);
    4112:	movs	r2, #4
    4114:	ldr	r1, [pc, #404]	; (42ac <HardwareControls::init()+0xc88>)
    4116:	movs	r0, #36	; 0x24
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    4118:	str.w	r5, [r3, #144]	; 0x90
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    411c:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
				attachInterrupt(36, isr36, CHANGE);
    4120:	bl	16804 <attachInterrupt>
    4124:	ldrb	r6, [r5, #24]
    4126:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    412a:	ldr	r3, [pc, #296]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(35, isr35, CHANGE);
    412c:	movs	r2, #4
    412e:	ldr	r1, [pc, #384]	; (42b0 <HardwareControls::init()+0xc8c>)
    4130:	movs	r0, #35	; 0x23
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    4132:	str.w	r5, [r3, #140]	; 0x8c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4136:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
				attachInterrupt(35, isr35, CHANGE);
    413a:	bl	16804 <attachInterrupt>
    413e:	ldrb	r6, [r5, #24]
    4140:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    4144:	ldr	r3, [pc, #268]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(34, isr34, CHANGE);
    4146:	movs	r2, #4
    4148:	ldr	r1, [pc, #360]	; (42b4 <HardwareControls::init()+0xc90>)
    414a:	movs	r0, #34	; 0x22
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    414c:	str.w	r5, [r3, #136]	; 0x88
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4150:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
				attachInterrupt(34, isr34, CHANGE);
    4154:	bl	16804 <attachInterrupt>
    4158:	ldrb	r6, [r5, #24]
    415a:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    415e:	ldr	r3, [pc, #244]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(33, isr33, CHANGE);
    4160:	movs	r2, #4
    4162:	ldr	r1, [pc, #340]	; (42b8 <HardwareControls::init()+0xc94>)
    4164:	movs	r0, #33	; 0x21
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    4166:	str.w	r5, [r3, #132]	; 0x84
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    416a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
				attachInterrupt(33, isr33, CHANGE);
    416e:	bl	16804 <attachInterrupt>
    4172:	ldrb	r6, [r5, #24]
    4174:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    4178:	ldr	r3, [pc, #216]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(32, isr32, CHANGE);
    417a:	movs	r2, #4
    417c:	ldr	r1, [pc, #316]	; (42bc <HardwareControls::init()+0xc98>)
    417e:	movs	r0, #32
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    4180:	str.w	r5, [r3, #128]	; 0x80
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4184:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
				attachInterrupt(32, isr32, CHANGE);
    4188:	bl	16804 <attachInterrupt>
    418c:	ldrb	r6, [r5, #24]
    418e:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    4192:	ldr	r3, [pc, #192]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(31, isr31, CHANGE);
    4194:	movs	r2, #4
    4196:	ldr	r1, [pc, #296]	; (42c0 <HardwareControls::init()+0xc9c>)
    4198:	movs	r0, #31
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    419a:	str	r5, [r3, #124]	; 0x7c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    419c:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
				attachInterrupt(31, isr31, CHANGE);
    41a0:	bl	16804 <attachInterrupt>
    41a4:	ldrb	r6, [r5, #24]
    41a6:	b.w	379e <HardwareControls::init()+0x17a>
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    41aa:	ldr	r3, [pc, #168]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(30, isr30, CHANGE);
    41ac:	movs	r2, #4
    41ae:	ldr	r1, [pc, #276]	; (42c4 <HardwareControls::init()+0xca0>)
    41b0:	movs	r0, #30
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    41b2:	str	r5, [r3, #120]	; 0x78
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    41b4:	mov.w	r9, #1
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
				attachInterrupt(30, isr30, CHANGE);
    41b8:	bl	16804 <attachInterrupt>
    41bc:	ldrb	r6, [r5, #24]
    41be:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    41c2:	ldr	r3, [pc, #144]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(29, isr29, CHANGE);
    41c4:	movs	r2, #4
    41c6:	ldr	r1, [pc, #256]	; (42c8 <HardwareControls::init()+0xca4>)
    41c8:	movs	r0, #29
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    41ca:	str	r5, [r3, #116]	; 0x74
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    41cc:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
				attachInterrupt(29, isr29, CHANGE);
    41d0:	bl	16804 <attachInterrupt>
    41d4:	ldrb	r6, [r5, #24]
    41d6:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    41da:	ldr	r3, [pc, #120]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(28, isr28, CHANGE);
    41dc:	movs	r2, #4
    41de:	ldr	r1, [pc, #236]	; (42cc <HardwareControls::init()+0xca8>)
    41e0:	movs	r0, #28
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    41e2:	str	r5, [r3, #112]	; 0x70
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    41e4:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
				attachInterrupt(28, isr28, CHANGE);
    41e8:	bl	16804 <attachInterrupt>
    41ec:	ldrb	r6, [r5, #24]
    41ee:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    41f2:	ldr	r3, [pc, #96]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(27, isr27, CHANGE);
    41f4:	movs	r2, #4
    41f6:	ldr	r1, [pc, #216]	; (42d0 <HardwareControls::init()+0xcac>)
    41f8:	movs	r0, #27
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    41fa:	str	r5, [r3, #108]	; 0x6c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    41fc:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
				attachInterrupt(27, isr27, CHANGE);
    4200:	bl	16804 <attachInterrupt>
    4204:	ldrb	r6, [r5, #24]
    4206:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    420a:	ldr	r3, [pc, #72]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(26, isr26, CHANGE);
    420c:	movs	r2, #4
    420e:	ldr	r1, [pc, #196]	; (42d4 <HardwareControls::init()+0xcb0>)
    4210:	movs	r0, #26
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    4212:	str	r5, [r3, #104]	; 0x68
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4214:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
				attachInterrupt(26, isr26, CHANGE);
    4218:	bl	16804 <attachInterrupt>
    421c:	ldrb	r6, [r5, #24]
    421e:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    4222:	ldr	r3, [pc, #48]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(25, isr25, CHANGE);
    4224:	movs	r2, #4
    4226:	ldr	r1, [pc, #176]	; (42d8 <HardwareControls::init()+0xcb4>)
    4228:	movs	r0, #25
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    422a:	str	r5, [r3, #100]	; 0x64
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    422c:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
				attachInterrupt(25, isr25, CHANGE);
    4230:	bl	16804 <attachInterrupt>
    4234:	ldrb	r6, [r5, #24]
    4236:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    423a:	ldr	r3, [pc, #24]	; (4254 <HardwareControls::init()+0xc30>)
				attachInterrupt(24, isr24, CHANGE);
    423c:	movs	r2, #4
    423e:	ldr	r1, [pc, #156]	; (42dc <HardwareControls::init()+0xcb8>)
    4240:	movs	r0, #24
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    4242:	str	r5, [r3, #96]	; 0x60
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4244:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
				attachInterrupt(24, isr24, CHANGE);
    4248:	bl	16804 <attachInterrupt>
    424c:	ldrb	r6, [r5, #24]
    424e:	b.w	379e <HardwareControls::init()+0x17a>
    4252:	nop
    4254:	.word	0x20057ee8
    4258:	.word	0x000022e9
    425c:	.word	0x00002261
    4260:	.word	0x000021d9
    4264:	.word	0x00002151
    4268:	.word	0x000020c9
    426c:	.word	0x00002041
    4270:	.word	0x00001fb9
    4274:	.word	0x00001f31
    4278:	.word	0x00001ea9
    427c:	.word	0x00001e21
    4280:	.word	0x00001d99
    4284:	.word	0x00001c01
    4288:	.word	0x00001b79
    428c:	.word	0x00001af1
    4290:	.word	0x00001a69
    4294:	.word	0x00001d11
    4298:	.word	0x00001c89
    429c:	.word	0x000019e1
    42a0:	.word	0x00001959
    42a4:	.word	0x00002da1
    42a8:	.word	0x00002d15
    42ac:	.word	0x00002c89
    42b0:	.word	0x00002bfd
    42b4:	.word	0x00002b71
    42b8:	.word	0x00002ae5
    42bc:	.word	0x00002a59
    42c0:	.word	0x000029d1
    42c4:	.word	0x00002949
    42c8:	.word	0x000028c1
    42cc:	.word	0x00002839
    42d0:	.word	0x000027b1
    42d4:	.word	0x00002729
    42d8:	.word	0x000026a1
    42dc:	.word	0x00002619
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    42e0:	ldr	r3, [pc, #764]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(23, isr23, CHANGE);
    42e2:	movs	r2, #4
    42e4:	ldr	r1, [pc, #764]	; (45e4 <HardwareControls::init()+0xfc0>)
    42e6:	movs	r0, #23
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    42e8:	str	r5, [r3, #92]	; 0x5c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    42ea:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
				attachInterrupt(23, isr23, CHANGE);
    42ee:	bl	16804 <attachInterrupt>
    42f2:	ldrb	r6, [r5, #24]
    42f4:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    42f8:	ldr	r3, [pc, #740]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(22, isr22, CHANGE);
    42fa:	movs	r2, #4
    42fc:	ldr	r1, [pc, #744]	; (45e8 <HardwareControls::init()+0xfc4>)
    42fe:	movs	r0, #22
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    4300:	str	r5, [r3, #88]	; 0x58
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4302:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
				attachInterrupt(22, isr22, CHANGE);
    4306:	bl	16804 <attachInterrupt>
    430a:	ldrb	r6, [r5, #24]
    430c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    4310:	ldr	r3, [pc, #716]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(21, isr21, CHANGE);
    4312:	movs	r2, #4
    4314:	ldr	r1, [pc, #724]	; (45ec <HardwareControls::init()+0xfc8>)
    4316:	movs	r0, #21
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    4318:	str	r5, [r3, #84]	; 0x54
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    431a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
				attachInterrupt(21, isr21, CHANGE);
    431e:	bl	16804 <attachInterrupt>
    4322:	ldrb	r6, [r5, #24]
    4324:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    4328:	ldr	r3, [pc, #692]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(20, isr20, CHANGE);
    432a:	movs	r2, #4
    432c:	ldr	r1, [pc, #704]	; (45f0 <HardwareControls::init()+0xfcc>)
    432e:	movs	r0, #20
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    4330:	str	r5, [r3, #80]	; 0x50
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4332:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
				attachInterrupt(20, isr20, CHANGE);
    4336:	bl	16804 <attachInterrupt>
    433a:	ldrb	r6, [r5, #24]
    433c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    4340:	ldr	r3, [pc, #668]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(19, isr19, CHANGE);
    4342:	movs	r2, #4
    4344:	ldr	r1, [pc, #684]	; (45f4 <HardwareControls::init()+0xfd0>)
    4346:	movs	r0, #19
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    4348:	str	r5, [r3, #76]	; 0x4c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    434a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
				attachInterrupt(19, isr19, CHANGE);
    434e:	bl	16804 <attachInterrupt>
    4352:	ldrb	r6, [r5, #24]
    4354:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    4358:	ldr	r3, [pc, #644]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(18, isr18, CHANGE);
    435a:	movs	r2, #4
    435c:	ldr	r1, [pc, #664]	; (45f8 <HardwareControls::init()+0xfd4>)
    435e:	movs	r0, #18
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    4360:	str	r5, [r3, #72]	; 0x48
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4362:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
				attachInterrupt(18, isr18, CHANGE);
    4366:	bl	16804 <attachInterrupt>
    436a:	ldrb	r6, [r5, #24]
    436c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    4370:	ldr	r3, [pc, #620]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(17, isr17, CHANGE);
    4372:	movs	r2, #4
    4374:	ldr	r1, [pc, #644]	; (45fc <HardwareControls::init()+0xfd8>)
    4376:	movs	r0, #17
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    4378:	str	r5, [r3, #68]	; 0x44
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    437a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
				attachInterrupt(17, isr17, CHANGE);
    437e:	bl	16804 <attachInterrupt>
    4382:	ldrb	r6, [r5, #24]
    4384:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    4388:	ldr	r3, [pc, #596]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(16, isr16, CHANGE);
    438a:	movs	r2, #4
    438c:	ldr	r1, [pc, #624]	; (4600 <HardwareControls::init()+0xfdc>)
    438e:	movs	r0, #16
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    4390:	str	r5, [r3, #64]	; 0x40
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4392:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
				attachInterrupt(16, isr16, CHANGE);
    4396:	bl	16804 <attachInterrupt>
    439a:	ldrb	r6, [r5, #24]
    439c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    43a0:	ldr	r3, [pc, #572]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(15, isr15, CHANGE);
    43a2:	movs	r2, #4
    43a4:	ldr	r1, [pc, #604]	; (4604 <HardwareControls::init()+0xfe0>)
    43a6:	movs	r0, #15
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    43a8:	str	r5, [r3, #60]	; 0x3c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    43aa:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
				attachInterrupt(15, isr15, CHANGE);
    43ae:	bl	16804 <attachInterrupt>
    43b2:	ldrb	r6, [r5, #24]
    43b4:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    43b8:	ldr	r3, [pc, #548]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(14, isr14, CHANGE);
    43ba:	movs	r2, #4
    43bc:	ldr	r1, [pc, #584]	; (4608 <HardwareControls::init()+0xfe4>)
    43be:	movs	r0, #14
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    43c0:	str	r5, [r3, #56]	; 0x38
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    43c2:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
				attachInterrupt(14, isr14, CHANGE);
    43c6:	bl	16804 <attachInterrupt>
    43ca:	ldrb	r6, [r5, #24]
    43cc:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    43d0:	ldr	r3, [pc, #524]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(13, isr13, CHANGE);
    43d2:	movs	r2, #4
    43d4:	ldr	r1, [pc, #564]	; (460c <HardwareControls::init()+0xfe8>)
    43d6:	movs	r0, #13
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    43d8:	str	r5, [r3, #52]	; 0x34
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    43da:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
				attachInterrupt(13, isr13, CHANGE);
    43de:	bl	16804 <attachInterrupt>
    43e2:	ldrb	r6, [r5, #24]
    43e4:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    43e8:	ldr	r3, [pc, #500]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(12, isr12, CHANGE);
    43ea:	movs	r2, #4
    43ec:	ldr	r1, [pc, #544]	; (4610 <HardwareControls::init()+0xfec>)
    43ee:	movs	r0, #12
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    43f0:	str	r5, [r3, #48]	; 0x30
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    43f2:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
				attachInterrupt(12, isr12, CHANGE);
    43f6:	bl	16804 <attachInterrupt>
    43fa:	ldrb	r6, [r5, #24]
    43fc:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    4400:	ldr	r3, [pc, #476]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(11, isr11, CHANGE);
    4402:	movs	r2, #4
    4404:	ldr	r1, [pc, #524]	; (4614 <HardwareControls::init()+0xff0>)
    4406:	movs	r0, #11
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    4408:	str	r5, [r3, #44]	; 0x2c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    440a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
				attachInterrupt(11, isr11, CHANGE);
    440e:	bl	16804 <attachInterrupt>
    4412:	ldrb	r6, [r5, #24]
    4414:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    4418:	ldr	r3, [pc, #452]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(10, isr10, CHANGE);
    441a:	movs	r2, #4
    441c:	ldr	r1, [pc, #504]	; (4618 <HardwareControls::init()+0xff4>)
    441e:	movs	r0, #10
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    4420:	str	r5, [r3, #40]	; 0x28
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4422:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
				attachInterrupt(10, isr10, CHANGE);
    4426:	bl	16804 <attachInterrupt>
    442a:	ldrb	r6, [r5, #24]
    442c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    4430:	ldr	r3, [pc, #428]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(9, isr9, CHANGE);
    4432:	movs	r2, #4
    4434:	ldr	r1, [pc, #484]	; (461c <HardwareControls::init()+0xff8>)
    4436:	movs	r0, #9
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    4438:	str	r5, [r3, #36]	; 0x24
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    443a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
				attachInterrupt(9, isr9, CHANGE);
    443e:	bl	16804 <attachInterrupt>
    4442:	ldrb	r6, [r5, #24]
    4444:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    4448:	ldr	r3, [pc, #404]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(8, isr8, CHANGE);
    444a:	movs	r2, #4
    444c:	ldr	r1, [pc, #464]	; (4620 <HardwareControls::init()+0xffc>)
    444e:	movs	r0, #8
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    4450:	str	r5, [r3, #32]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4452:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
				attachInterrupt(8, isr8, CHANGE);
    4456:	bl	16804 <attachInterrupt>
    445a:	ldrb	r6, [r5, #24]
    445c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    4460:	ldr	r3, [pc, #380]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(7, isr7, CHANGE);
    4462:	movs	r2, #4
    4464:	ldr	r1, [pc, #444]	; (4624 <HardwareControls::init()+0x1000>)
    4466:	movs	r0, #7
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    4468:	str	r5, [r3, #28]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    446a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
				attachInterrupt(7, isr7, CHANGE);
    446e:	bl	16804 <attachInterrupt>
    4472:	ldrb	r6, [r5, #24]
    4474:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    4478:	ldr	r3, [pc, #356]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(6, isr6, CHANGE);
    447a:	movs	r2, #4
    447c:	ldr	r1, [pc, #424]	; (4628 <HardwareControls::init()+0x1004>)
    447e:	movs	r0, #6
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    4480:	str	r5, [r3, #24]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4482:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
				attachInterrupt(6, isr6, CHANGE);
    4486:	bl	16804 <attachInterrupt>
    448a:	ldrb	r6, [r5, #24]
    448c:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    4490:	ldr	r3, [pc, #332]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(5, isr5, CHANGE);
    4492:	movs	r2, #4
    4494:	ldr	r1, [pc, #404]	; (462c <HardwareControls::init()+0x1008>)
    4496:	movs	r0, #5
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    4498:	str	r5, [r3, #20]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    449a:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
				attachInterrupt(5, isr5, CHANGE);
    449e:	bl	16804 <attachInterrupt>
    44a2:	ldrb	r6, [r5, #24]
    44a4:	b.w	379e <HardwareControls::init()+0x17a>
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    44a8:	movs	r2, #4
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    44aa:	ldr	r3, [pc, #308]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(4, isr4, CHANGE);
    44ac:	ldr	r1, [pc, #384]	; (4630 <HardwareControls::init()+0x100c>)
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    44ae:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    44b2:	mov	r0, r2
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    44b4:	str	r5, [r3, #16]
				attachInterrupt(4, isr4, CHANGE);
    44b6:	bl	16804 <attachInterrupt>
    44ba:	ldrb	r6, [r5, #24]
    44bc:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    44c0:	ldr	r3, [pc, #284]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(3, isr3, CHANGE);
    44c2:	movs	r2, #4
    44c4:	ldr	r1, [pc, #364]	; (4634 <HardwareControls::init()+0x1010>)
    44c6:	movs	r0, #3
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    44c8:	str	r5, [r3, #12]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    44ca:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
				attachInterrupt(3, isr3, CHANGE);
    44ce:	bl	16804 <attachInterrupt>
    44d2:	ldrb	r6, [r5, #24]
    44d4:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    44d8:	ldr	r3, [pc, #260]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(2, isr2, CHANGE);
    44da:	movs	r2, #4
    44dc:	ldr	r1, [pc, #344]	; (4638 <HardwareControls::init()+0x1014>)
    44de:	movs	r0, #2
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    44e0:	str	r5, [r3, #8]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    44e2:	mov.w	r9, #1
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
				attachInterrupt(2, isr2, CHANGE);
    44e6:	bl	16804 <attachInterrupt>
    44ea:	ldrb	r6, [r5, #24]
    44ec:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    44f0:	ldr	r3, [pc, #236]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(1, isr1, CHANGE);
    44f2:	movs	r2, #4
    44f4:	ldr	r1, [pc, #324]	; (463c <HardwareControls::init()+0x1018>)
    44f6:	movs	r0, #1
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    44f8:	str	r5, [r3, #4]
				attachInterrupt(1, isr1, CHANGE);
    44fa:	bl	16804 <attachInterrupt>
    44fe:	ldrb	r6, [r5, #24]
    4500:	b.w	379e <HardwareControls::init()+0x17a>
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    4504:	ldr	r3, [pc, #216]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(0, isr0, CHANGE);
    4506:	movs	r2, #4
    4508:	ldr	r1, [pc, #308]	; (4640 <HardwareControls::init()+0x101c>)
    450a:	movs	r0, #0
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    450c:	str	r5, [r3, #0]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    450e:	mov.w	r9, #1
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
				attachInterrupt(0, isr0, CHANGE);
    4512:	bl	16804 <attachInterrupt>
    4516:	ldrb	r6, [r5, #24]
    4518:	b.w	379e <HardwareControls::init()+0x17a>
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    451c:	ldr	r3, [pc, #192]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(38, isr38, CHANGE);
    451e:	movs	r2, #4
    4520:	ldr	r1, [pc, #288]	; (4644 <HardwareControls::init()+0x1020>)
    4522:	movs	r0, #38	; 0x26
				attachInterrupt(37, isr37, CHANGE);
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
    4524:	str.w	r5, [r3, #152]	; 0x98
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4528:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT38_PIN
			case CORE_INT38_PIN:
				interruptArgs[38] = state;
				attachInterrupt(38, isr38, CHANGE);
    452a:	bl	16804 <attachInterrupt>
    452e:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    4532:	ldr	r3, [pc, #172]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(37, isr37, CHANGE);
    4534:	movs	r2, #4
    4536:	ldr	r1, [pc, #272]	; (4648 <HardwareControls::init()+0x1024>)
    4538:	movs	r0, #37	; 0x25
				attachInterrupt(36, isr36, CHANGE);
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
    453a:	str.w	r5, [r3, #148]	; 0x94
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    453e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT37_PIN
			case CORE_INT37_PIN:
				interruptArgs[37] = state;
				attachInterrupt(37, isr37, CHANGE);
    4540:	bl	16804 <attachInterrupt>
    4544:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    4548:	ldr	r3, [pc, #148]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(36, isr36, CHANGE);
    454a:	movs	r2, #4
    454c:	ldr	r1, [pc, #252]	; (464c <HardwareControls::init()+0x1028>)
    454e:	movs	r0, #36	; 0x24
				attachInterrupt(35, isr35, CHANGE);
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
    4550:	str.w	r5, [r3, #144]	; 0x90
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4554:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT36_PIN
			case CORE_INT36_PIN:
				interruptArgs[36] = state;
				attachInterrupt(36, isr36, CHANGE);
    4556:	bl	16804 <attachInterrupt>
    455a:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    455e:	ldr	r3, [pc, #128]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(35, isr35, CHANGE);
    4560:	movs	r2, #4
    4562:	ldr	r1, [pc, #236]	; (4650 <HardwareControls::init()+0x102c>)
    4564:	movs	r0, #35	; 0x23
				attachInterrupt(34, isr34, CHANGE);
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
    4566:	str.w	r5, [r3, #140]	; 0x8c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    456a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT35_PIN
			case CORE_INT35_PIN:
				interruptArgs[35] = state;
				attachInterrupt(35, isr35, CHANGE);
    456c:	bl	16804 <attachInterrupt>
    4570:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    4574:	ldr	r3, [pc, #104]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(34, isr34, CHANGE);
    4576:	movs	r2, #4
    4578:	ldr	r1, [pc, #216]	; (4654 <HardwareControls::init()+0x1030>)
    457a:	movs	r0, #34	; 0x22
				attachInterrupt(33, isr33, CHANGE);
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
    457c:	str.w	r5, [r3, #136]	; 0x88
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4580:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT34_PIN
			case CORE_INT34_PIN:
				interruptArgs[34] = state;
				attachInterrupt(34, isr34, CHANGE);
    4582:	bl	16804 <attachInterrupt>
    4586:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    458a:	ldr	r3, [pc, #84]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(33, isr33, CHANGE);
    458c:	movs	r2, #4
    458e:	ldr	r1, [pc, #200]	; (4658 <HardwareControls::init()+0x1034>)
    4590:	movs	r0, #33	; 0x21
				attachInterrupt(32, isr32, CHANGE);
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
    4592:	str.w	r5, [r3, #132]	; 0x84
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4596:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT33_PIN
			case CORE_INT33_PIN:
				interruptArgs[33] = state;
				attachInterrupt(33, isr33, CHANGE);
    4598:	bl	16804 <attachInterrupt>
    459c:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    45a0:	ldr	r3, [pc, #60]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(32, isr32, CHANGE);
    45a2:	movs	r2, #4
    45a4:	ldr	r1, [pc, #180]	; (465c <HardwareControls::init()+0x1038>)
    45a6:	movs	r0, #32
				attachInterrupt(31, isr31, CHANGE);
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
    45a8:	str.w	r5, [r3, #128]	; 0x80
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    45ac:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT32_PIN
			case CORE_INT32_PIN:
				interruptArgs[32] = state;
				attachInterrupt(32, isr32, CHANGE);
    45ae:	bl	16804 <attachInterrupt>
    45b2:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    45b6:	ldr	r3, [pc, #40]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(31, isr31, CHANGE);
    45b8:	movs	r2, #4
    45ba:	ldr	r1, [pc, #164]	; (4660 <HardwareControls::init()+0x103c>)
    45bc:	movs	r0, #31
				attachInterrupt(30, isr30, CHANGE);
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
    45be:	str	r5, [r3, #124]	; 0x7c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    45c0:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT31_PIN
			case CORE_INT31_PIN:
				interruptArgs[31] = state;
				attachInterrupt(31, isr31, CHANGE);
    45c2:	bl	16804 <attachInterrupt>
    45c6:	b.w	372a <HardwareControls::init()+0x106>
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    45ca:	ldr	r3, [pc, #20]	; (45e0 <HardwareControls::init()+0xfbc>)
				attachInterrupt(30, isr30, CHANGE);
    45cc:	movs	r2, #4
    45ce:	ldr	r1, [pc, #148]	; (4664 <HardwareControls::init()+0x1040>)
    45d0:	movs	r0, #30
				break;
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
    45d2:	str	r5, [r3, #120]	; 0x78
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    45d4:	movs	r6, #1
		#endif

		#ifdef CORE_INT30_PIN
			case CORE_INT30_PIN:
				interruptArgs[30] = state;
				attachInterrupt(30, isr30, CHANGE);
    45d6:	bl	16804 <attachInterrupt>
    45da:	b.w	372a <HardwareControls::init()+0x106>
    45de:	nop
    45e0:	.word	0x20057ee8
    45e4:	.word	0x00002591
    45e8:	.word	0x00002509
    45ec:	.word	0x00002481
    45f0:	.word	0x000023f9
    45f4:	.word	0x00002371
    45f8:	.word	0x000022e9
    45fc:	.word	0x00002261
    4600:	.word	0x000021d9
    4604:	.word	0x00002151
    4608:	.word	0x000020c9
    460c:	.word	0x00002041
    4610:	.word	0x00001fb9
    4614:	.word	0x00001f31
    4618:	.word	0x00001ea9
    461c:	.word	0x00001e21
    4620:	.word	0x00001d99
    4624:	.word	0x00001c01
    4628:	.word	0x00001b79
    462c:	.word	0x00001af1
    4630:	.word	0x00001a69
    4634:	.word	0x00001d11
    4638:	.word	0x00001c89
    463c:	.word	0x000019e1
    4640:	.word	0x00001959
    4644:	.word	0x00002da1
    4648:	.word	0x00002d15
    464c:	.word	0x00002c89
    4650:	.word	0x00002bfd
    4654:	.word	0x00002b71
    4658:	.word	0x00002ae5
    465c:	.word	0x00002a59
    4660:	.word	0x000029d1
    4664:	.word	0x00002949
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    4668:	ldr	r3, [pc, #624]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(29, isr29, CHANGE);
    466a:	movs	r2, #4
    466c:	ldr	r1, [pc, #624]	; (48e0 <HardwareControls::init()+0x12bc>)
    466e:	movs	r0, #29
				attachInterrupt(28, isr28, CHANGE);
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
    4670:	str	r5, [r3, #116]	; 0x74
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4672:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT29_PIN
			case CORE_INT29_PIN:
				interruptArgs[29] = state;
				attachInterrupt(29, isr29, CHANGE);
    4674:	bl	16804 <attachInterrupt>
    4678:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    467c:	ldr	r3, [pc, #604]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(28, isr28, CHANGE);
    467e:	movs	r2, #4
    4680:	ldr	r1, [pc, #608]	; (48e4 <HardwareControls::init()+0x12c0>)
    4682:	movs	r0, #28
				attachInterrupt(27, isr27, CHANGE);
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
    4684:	str	r5, [r3, #112]	; 0x70
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4686:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT28_PIN
			case CORE_INT28_PIN:
				interruptArgs[28] = state;
				attachInterrupt(28, isr28, CHANGE);
    4688:	bl	16804 <attachInterrupt>
    468c:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    4690:	ldr	r3, [pc, #584]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(27, isr27, CHANGE);
    4692:	movs	r2, #4
    4694:	ldr	r1, [pc, #592]	; (48e8 <HardwareControls::init()+0x12c4>)
    4696:	movs	r0, #27
				attachInterrupt(26, isr26, CHANGE);
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
    4698:	str	r5, [r3, #108]	; 0x6c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    469a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT27_PIN
			case CORE_INT27_PIN:
				interruptArgs[27] = state;
				attachInterrupt(27, isr27, CHANGE);
    469c:	bl	16804 <attachInterrupt>
    46a0:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    46a4:	ldr	r3, [pc, #564]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(26, isr26, CHANGE);
    46a6:	movs	r2, #4
    46a8:	ldr	r1, [pc, #576]	; (48ec <HardwareControls::init()+0x12c8>)
    46aa:	movs	r0, #26
				attachInterrupt(25, isr25, CHANGE);
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
    46ac:	str	r5, [r3, #104]	; 0x68
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    46ae:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT26_PIN
			case CORE_INT26_PIN:
				interruptArgs[26] = state;
				attachInterrupt(26, isr26, CHANGE);
    46b0:	bl	16804 <attachInterrupt>
    46b4:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    46b8:	ldr	r3, [pc, #544]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(25, isr25, CHANGE);
    46ba:	movs	r2, #4
    46bc:	ldr	r1, [pc, #560]	; (48f0 <HardwareControls::init()+0x12cc>)
    46be:	movs	r0, #25
				attachInterrupt(24, isr24, CHANGE);
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
    46c0:	str	r5, [r3, #100]	; 0x64
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    46c2:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT25_PIN
			case CORE_INT25_PIN:
				interruptArgs[25] = state;
				attachInterrupt(25, isr25, CHANGE);
    46c4:	bl	16804 <attachInterrupt>
    46c8:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    46cc:	ldr	r3, [pc, #524]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(24, isr24, CHANGE);
    46ce:	movs	r2, #4
    46d0:	ldr	r1, [pc, #544]	; (48f4 <HardwareControls::init()+0x12d0>)
    46d2:	movs	r0, #24
				attachInterrupt(23, isr23, CHANGE);
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
    46d4:	str	r5, [r3, #96]	; 0x60
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    46d6:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT24_PIN
			case CORE_INT24_PIN:
				interruptArgs[24] = state;
				attachInterrupt(24, isr24, CHANGE);
    46d8:	bl	16804 <attachInterrupt>
    46dc:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    46e0:	ldr	r3, [pc, #504]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(23, isr23, CHANGE);
    46e2:	movs	r2, #4
    46e4:	ldr	r1, [pc, #528]	; (48f8 <HardwareControls::init()+0x12d4>)
    46e6:	movs	r0, #23
				attachInterrupt(22, isr22, CHANGE);
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
    46e8:	str	r5, [r3, #92]	; 0x5c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    46ea:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT23_PIN
			case CORE_INT23_PIN:
				interruptArgs[23] = state;
				attachInterrupt(23, isr23, CHANGE);
    46ec:	bl	16804 <attachInterrupt>
    46f0:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    46f4:	ldr	r3, [pc, #484]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(22, isr22, CHANGE);
    46f6:	movs	r2, #4
    46f8:	ldr	r1, [pc, #512]	; (48fc <HardwareControls::init()+0x12d8>)
    46fa:	movs	r0, #22
				attachInterrupt(21, isr21, CHANGE);
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
    46fc:	str	r5, [r3, #88]	; 0x58
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    46fe:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT22_PIN
			case CORE_INT22_PIN:
				interruptArgs[22] = state;
				attachInterrupt(22, isr22, CHANGE);
    4700:	bl	16804 <attachInterrupt>
    4704:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    4708:	ldr	r3, [pc, #464]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(21, isr21, CHANGE);
    470a:	movs	r2, #4
    470c:	ldr	r1, [pc, #496]	; (4900 <HardwareControls::init()+0x12dc>)
    470e:	movs	r0, #21
				attachInterrupt(20, isr20, CHANGE);
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
    4710:	str	r5, [r3, #84]	; 0x54
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4712:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT21_PIN
			case CORE_INT21_PIN:
				interruptArgs[21] = state;
				attachInterrupt(21, isr21, CHANGE);
    4714:	bl	16804 <attachInterrupt>
    4718:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    471c:	ldr	r3, [pc, #444]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(20, isr20, CHANGE);
    471e:	movs	r2, #4
    4720:	ldr	r1, [pc, #480]	; (4904 <HardwareControls::init()+0x12e0>)
    4722:	movs	r0, #20
				attachInterrupt(19, isr19, CHANGE);
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
    4724:	str	r5, [r3, #80]	; 0x50
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4726:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT20_PIN
			case CORE_INT20_PIN:
				interruptArgs[20] = state;
				attachInterrupt(20, isr20, CHANGE);
    4728:	bl	16804 <attachInterrupt>
    472c:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    4730:	ldr	r3, [pc, #424]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(19, isr19, CHANGE);
    4732:	movs	r2, #4
    4734:	ldr	r1, [pc, #464]	; (4908 <HardwareControls::init()+0x12e4>)
    4736:	movs	r0, #19
				attachInterrupt(18, isr18, CHANGE);
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
    4738:	str	r5, [r3, #76]	; 0x4c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    473a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT19_PIN
			case CORE_INT19_PIN:
				interruptArgs[19] = state;
				attachInterrupt(19, isr19, CHANGE);
    473c:	bl	16804 <attachInterrupt>
    4740:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    4744:	ldr	r3, [pc, #404]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(18, isr18, CHANGE);
    4746:	movs	r2, #4
    4748:	ldr	r1, [pc, #448]	; (490c <HardwareControls::init()+0x12e8>)
    474a:	movs	r0, #18
				attachInterrupt(17, isr17, CHANGE);
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
    474c:	str	r5, [r3, #72]	; 0x48
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    474e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT18_PIN
			case CORE_INT18_PIN:
				interruptArgs[18] = state;
				attachInterrupt(18, isr18, CHANGE);
    4750:	bl	16804 <attachInterrupt>
    4754:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    4758:	ldr	r3, [pc, #384]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(17, isr17, CHANGE);
    475a:	movs	r2, #4
    475c:	ldr	r1, [pc, #432]	; (4910 <HardwareControls::init()+0x12ec>)
    475e:	movs	r0, #17
				attachInterrupt(16, isr16, CHANGE);
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
    4760:	str	r5, [r3, #68]	; 0x44
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4762:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT17_PIN
			case CORE_INT17_PIN:
				interruptArgs[17] = state;
				attachInterrupt(17, isr17, CHANGE);
    4764:	bl	16804 <attachInterrupt>
    4768:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    476c:	ldr	r3, [pc, #364]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(16, isr16, CHANGE);
    476e:	movs	r2, #4
    4770:	ldr	r1, [pc, #416]	; (4914 <HardwareControls::init()+0x12f0>)
    4772:	movs	r0, #16
				attachInterrupt(15, isr15, CHANGE);
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
    4774:	str	r5, [r3, #64]	; 0x40
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4776:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT16_PIN
			case CORE_INT16_PIN:
				interruptArgs[16] = state;
				attachInterrupt(16, isr16, CHANGE);
    4778:	bl	16804 <attachInterrupt>
    477c:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    4780:	ldr	r3, [pc, #344]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(15, isr15, CHANGE);
    4782:	movs	r2, #4
    4784:	ldr	r1, [pc, #400]	; (4918 <HardwareControls::init()+0x12f4>)
    4786:	movs	r0, #15
				attachInterrupt(14, isr14, CHANGE);
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
    4788:	str	r5, [r3, #60]	; 0x3c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    478a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT15_PIN
			case CORE_INT15_PIN:
				interruptArgs[15] = state;
				attachInterrupt(15, isr15, CHANGE);
    478c:	bl	16804 <attachInterrupt>
    4790:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    4794:	ldr	r3, [pc, #324]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(14, isr14, CHANGE);
    4796:	movs	r2, #4
    4798:	ldr	r1, [pc, #384]	; (491c <HardwareControls::init()+0x12f8>)
    479a:	movs	r0, #14
				attachInterrupt(13, isr13, CHANGE);
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
    479c:	str	r5, [r3, #56]	; 0x38
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    479e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT14_PIN
			case CORE_INT14_PIN:
				interruptArgs[14] = state;
				attachInterrupt(14, isr14, CHANGE);
    47a0:	bl	16804 <attachInterrupt>
    47a4:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    47a8:	ldr	r3, [pc, #304]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(13, isr13, CHANGE);
    47aa:	movs	r2, #4
    47ac:	ldr	r1, [pc, #368]	; (4920 <HardwareControls::init()+0x12fc>)
    47ae:	movs	r0, #13
				attachInterrupt(12, isr12, CHANGE);
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
    47b0:	str	r5, [r3, #52]	; 0x34
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    47b2:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT13_PIN
			case CORE_INT13_PIN:
				interruptArgs[13] = state;
				attachInterrupt(13, isr13, CHANGE);
    47b4:	bl	16804 <attachInterrupt>
    47b8:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    47bc:	ldr	r3, [pc, #284]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(12, isr12, CHANGE);
    47be:	movs	r2, #4
    47c0:	ldr	r1, [pc, #352]	; (4924 <HardwareControls::init()+0x1300>)
    47c2:	movs	r0, #12
				attachInterrupt(11, isr11, CHANGE);
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
    47c4:	str	r5, [r3, #48]	; 0x30
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    47c6:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT12_PIN
			case CORE_INT12_PIN:
				interruptArgs[12] = state;
				attachInterrupt(12, isr12, CHANGE);
    47c8:	bl	16804 <attachInterrupt>
    47cc:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    47d0:	ldr	r3, [pc, #264]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(11, isr11, CHANGE);
    47d2:	movs	r2, #4
    47d4:	ldr	r1, [pc, #336]	; (4928 <HardwareControls::init()+0x1304>)
    47d6:	movs	r0, #11
				attachInterrupt(10, isr10, CHANGE);
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
    47d8:	str	r5, [r3, #44]	; 0x2c
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    47da:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT11_PIN
			case CORE_INT11_PIN:
				interruptArgs[11] = state;
				attachInterrupt(11, isr11, CHANGE);
    47dc:	bl	16804 <attachInterrupt>
    47e0:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    47e4:	ldr	r3, [pc, #244]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(10, isr10, CHANGE);
    47e6:	movs	r2, #4
    47e8:	ldr	r1, [pc, #320]	; (492c <HardwareControls::init()+0x1308>)
    47ea:	movs	r0, #10
				attachInterrupt(9, isr9, CHANGE);
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
    47ec:	str	r5, [r3, #40]	; 0x28
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    47ee:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT10_PIN
			case CORE_INT10_PIN:
				interruptArgs[10] = state;
				attachInterrupt(10, isr10, CHANGE);
    47f0:	bl	16804 <attachInterrupt>
    47f4:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    47f8:	ldr	r3, [pc, #224]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(9, isr9, CHANGE);
    47fa:	movs	r2, #4
    47fc:	ldr	r1, [pc, #304]	; (4930 <HardwareControls::init()+0x130c>)
    47fe:	movs	r0, #9
				attachInterrupt(8, isr8, CHANGE);
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
    4800:	str	r5, [r3, #36]	; 0x24
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4802:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT9_PIN
			case CORE_INT9_PIN:
				interruptArgs[9] = state;
				attachInterrupt(9, isr9, CHANGE);
    4804:	bl	16804 <attachInterrupt>
    4808:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    480c:	ldr	r3, [pc, #204]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(8, isr8, CHANGE);
    480e:	movs	r2, #4
    4810:	ldr	r1, [pc, #288]	; (4934 <HardwareControls::init()+0x1310>)
    4812:	movs	r0, #8
				attachInterrupt(7, isr7, CHANGE);
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
    4814:	str	r5, [r3, #32]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4816:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT8_PIN
			case CORE_INT8_PIN:
				interruptArgs[8] = state;
				attachInterrupt(8, isr8, CHANGE);
    4818:	bl	16804 <attachInterrupt>
    481c:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    4820:	ldr	r3, [pc, #184]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(7, isr7, CHANGE);
    4822:	movs	r2, #4
    4824:	ldr	r1, [pc, #272]	; (4938 <HardwareControls::init()+0x1314>)
    4826:	movs	r0, #7
				attachInterrupt(6, isr6, CHANGE);
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
    4828:	str	r5, [r3, #28]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    482a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT7_PIN
			case CORE_INT7_PIN:
				interruptArgs[7] = state;
				attachInterrupt(7, isr7, CHANGE);
    482c:	bl	16804 <attachInterrupt>
    4830:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    4834:	ldr	r3, [pc, #164]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(6, isr6, CHANGE);
    4836:	movs	r2, #4
    4838:	ldr	r1, [pc, #256]	; (493c <HardwareControls::init()+0x1318>)
    483a:	movs	r0, #6
				attachInterrupt(5, isr5, CHANGE);
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
    483c:	str	r5, [r3, #24]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    483e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT6_PIN
			case CORE_INT6_PIN:
				interruptArgs[6] = state;
				attachInterrupt(6, isr6, CHANGE);
    4840:	bl	16804 <attachInterrupt>
    4844:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    4848:	ldr	r3, [pc, #144]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(5, isr5, CHANGE);
    484a:	movs	r2, #4
    484c:	ldr	r1, [pc, #240]	; (4940 <HardwareControls::init()+0x131c>)
    484e:	movs	r0, #5
				attachInterrupt(4, isr4, CHANGE);
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
    4850:	str	r5, [r3, #20]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4852:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT5_PIN
			case CORE_INT5_PIN:
				interruptArgs[5] = state;
				attachInterrupt(5, isr5, CHANGE);
    4854:	bl	16804 <attachInterrupt>
    4858:	b.w	372a <HardwareControls::init()+0x106>
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    485c:	movs	r2, #4
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    485e:	ldr	r3, [pc, #124]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(4, isr4, CHANGE);
    4860:	ldr	r1, [pc, #224]	; (4944 <HardwareControls::init()+0x1320>)
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    4862:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
				attachInterrupt(4, isr4, CHANGE);
    4864:	mov	r0, r2
				attachInterrupt(3, isr3, CHANGE);
				break;
		#endif
		#ifdef CORE_INT4_PIN
			case CORE_INT4_PIN:
				interruptArgs[4] = state;
    4866:	str	r5, [r3, #16]
				attachInterrupt(4, isr4, CHANGE);
    4868:	bl	16804 <attachInterrupt>
    486c:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    4870:	ldr	r3, [pc, #104]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(3, isr3, CHANGE);
    4872:	movs	r2, #4
    4874:	ldr	r1, [pc, #208]	; (4948 <HardwareControls::init()+0x1324>)
    4876:	movs	r0, #3
				attachInterrupt(2, isr2, CHANGE);
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
    4878:	str	r5, [r3, #12]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    487a:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT3_PIN
			case CORE_INT3_PIN:
				interruptArgs[3] = state;
				attachInterrupt(3, isr3, CHANGE);
    487c:	bl	16804 <attachInterrupt>
    4880:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    4884:	ldr	r3, [pc, #84]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(2, isr2, CHANGE);
    4886:	movs	r2, #4
    4888:	ldr	r1, [pc, #192]	; (494c <HardwareControls::init()+0x1328>)
    488a:	movs	r0, #2
				attachInterrupt(1, isr1, CHANGE);
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
    488c:	str	r5, [r3, #8]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    488e:	movs	r6, #1
				break;
		#endif
		#ifdef CORE_INT2_PIN
			case CORE_INT2_PIN:
				interruptArgs[2] = state;
				attachInterrupt(2, isr2, CHANGE);
    4890:	bl	16804 <attachInterrupt>
    4894:	b.w	372a <HardwareControls::init()+0x106>
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    4898:	ldr	r3, [pc, #64]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(1, isr1, CHANGE);
    489a:	movs	r2, #4
    489c:	ldr	r1, [pc, #176]	; (4950 <HardwareControls::init()+0x132c>)
    489e:	movs	r0, #1
				attachInterrupt(0, isr0, CHANGE);
				break;
		#endif
		#ifdef CORE_INT1_PIN
			case CORE_INT1_PIN:
				interruptArgs[1] = state;
    48a0:	str	r5, [r3, #4]
				attachInterrupt(1, isr1, CHANGE);
    48a2:	bl	16804 <attachInterrupt>
    48a6:	b.w	372a <HardwareControls::init()+0x106>
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    48aa:	ldr	r3, [pc, #48]	; (48dc <HardwareControls::init()+0x12b8>)
				attachInterrupt(0, isr0, CHANGE);
    48ac:	movs	r2, #4
    48ae:	ldr	r1, [pc, #164]	; (4954 <HardwareControls::init()+0x1330>)
    48b0:	movs	r0, #0
	// or other context to the attached function.
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
    48b2:	str	r5, [r3, #0]
				break;
		#endif
			default:
				return 0;
		}
		return 1;
    48b4:	movs	r6, #1
	static uint8_t attach_interrupt(uint8_t pin, Encoder_internal_state_t *state) {
		switch (pin) {
		#ifdef CORE_INT0_PIN
			case CORE_INT0_PIN:
				interruptArgs[0] = state;
				attachInterrupt(0, isr0, CHANGE);
    48b6:	bl	16804 <attachInterrupt>
    48ba:	b.w	372a <HardwareControls::init()+0x106>
				interruptArgs[59] = state;
				attachInterrupt(59, isr59, CHANGE);
				break;
		#endif
			default:
				return 0;
    48be:	movs	r6, #0
    48c0:	b.w	392c <HardwareControls::init()+0x308>
    48c4:	mov.w	r9, #0
    48c8:	b.w	38b8 <HardwareControls::init()+0x294>
    48cc:	mov.w	r9, #0
    48d0:	b.w	379e <HardwareControls::init()+0x17a>
    48d4:	movs	r6, #0
    48d6:	b.w	372a <HardwareControls::init()+0x106>
    48da:	nop
    48dc:	.word	0x20057ee8
    48e0:	.word	0x000028c1
    48e4:	.word	0x00002839
    48e8:	.word	0x000027b1
    48ec:	.word	0x00002729
    48f0:	.word	0x000026a1
    48f4:	.word	0x00002619
    48f8:	.word	0x00002591
    48fc:	.word	0x00002509
    4900:	.word	0x00002481
    4904:	.word	0x000023f9
    4908:	.word	0x00002371
    490c:	.word	0x000022e9
    4910:	.word	0x00002261
    4914:	.word	0x000021d9
    4918:	.word	0x00002151
    491c:	.word	0x000020c9
    4920:	.word	0x00002041
    4924:	.word	0x00001fb9
    4928:	.word	0x00001f31
    492c:	.word	0x00001ea9
    4930:	.word	0x00001e21
    4934:	.word	0x00001d99
    4938:	.word	0x00001c01
    493c:	.word	0x00001b79
    4940:	.word	0x00001af1
    4944:	.word	0x00001a69
    4948:	.word	0x00001d11
    494c:	.word	0x00001c89
    4950:	.word	0x000019e1
    4954:	.word	0x00001959

00004958 <AudioEffectEnsemble_F32::update()>:
    return;
    
}

void AudioEffectEnsemble_F32::update(void)
{
    4958:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    495c:	sub	sp, #84	; 0x54
    495e:	mov	r8, r0
	const audio_block_f32_t *block;
    audio_block_f32_t *outblock;
    audio_block_f32_t *outblockB;
	uint16_t i;

    outblock = allocate_f32();
    4960:	bl	15198 <AudioStream_F32::allocate_f32()>
    4964:	mov	r4, r0
    4966:	str	r0, [sp, #68]	; 0x44
    outblockB = allocate_f32();
    4968:	bl	15198 <AudioStream_F32::allocate_f32()>
    496c:	str	r0, [sp, #72]	; 0x48
    if ((!outblock) || (!outblockB)) {
    496e:	cmp	r4, #0
    4970:	beq.w	4c52 <AudioEffectEnsemble_F32::update()+0x2fa>
    4974:	clz	r6, r0
    4978:	lsrs	r6, r6, #5
    497a:	cmp	r6, #0
    497c:	bne.w	4c52 <AudioEffectEnsemble_F32::update()+0x2fa>
        audio_block_f32_t *tmp = receiveReadOnly_f32(0);
        if (tmp) release(tmp);
        return;
    }
	block = receiveReadOnly_f32(0);
    4980:	mov	r1, r6
    4982:	mov	r0, r8
    4984:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
    if (!block)
    4988:	str	r0, [sp, #76]	; 0x4c
    498a:	cmp	r0, #0
    498c:	beq.w	4c66 <AudioEffectEnsemble_F32::update()+0x30e>
    4990:	movw	r3, #10020	; 0x2724
    4994:	adds	r1, r0, #4
    4996:	add.w	r5, r0, #516	; 0x204
    499a:	mov	r4, r3
    499c:	ldrsh.w	r3, [r8, r3]
    49a0:	add	r4, r8
    49a2:	b.n	49b4 <AudioEffectEnsemble_F32::update()+0x5c>
        // wrap the input index
        inIndex++;
        if (inIndex > (ENSEMBLE_BUFFER_SIZE - 1))
            inIndex = 0;

        delayBuffer[inIndex] = block->data[i];
    49a4:	ldr.w	r0, [r1], #4
    49a8:	add.w	r2, r8, r2, lsl #2
    // buffer the incoming block
    for (i=0; i < AUDIO_BLOCK_SAMPLES; i++)
    {

        // wrap the input index
        inIndex++;
    49ac:	strh	r3, [r4, #0]
	block = receiveReadOnly_f32(0);
    if (!block)
        return;

    // buffer the incoming block
    for (i=0; i < AUDIO_BLOCK_SAMPLES; i++)
    49ae:	cmp	r1, r5
        // wrap the input index
        inIndex++;
        if (inIndex > (ENSEMBLE_BUFFER_SIZE - 1))
            inIndex = 0;

        delayBuffer[inIndex] = block->data[i];
    49b0:	str	r0, [r2, #44]	; 0x2c
	block = receiveReadOnly_f32(0);
    if (!block)
        return;

    // buffer the incoming block
    for (i=0; i < AUDIO_BLOCK_SAMPLES; i++)
    49b2:	beq.n	49d4 <AudioEffectEnsemble_F32::update()+0x7c>
    {

        // wrap the input index
        inIndex++;
    49b4:	adds	r3, #1
    49b6:	sxth	r3, r3
        if (inIndex > (ENSEMBLE_BUFFER_SIZE - 1))
    49b8:	cmp.w	r3, #1024	; 0x400
    49bc:	mov	r2, r3
    49be:	blt.n	49a4 <AudioEffectEnsemble_F32::update()+0x4c>
    49c0:	movs	r3, #0
            inIndex = 0;

        delayBuffer[inIndex] = block->data[i];
    49c2:	ldr.w	r0, [r1], #4
    {

        // wrap the input index
        inIndex++;
        if (inIndex > (ENSEMBLE_BUFFER_SIZE - 1))
            inIndex = 0;
    49c6:	strh	r6, [r4, #0]
    49c8:	mov	r2, r3
	block = receiveReadOnly_f32(0);
    if (!block)
        return;

    // buffer the incoming block
    for (i=0; i < AUDIO_BLOCK_SAMPLES; i++)
    49ca:	cmp	r1, r5
        // wrap the input index
        inIndex++;
        if (inIndex > (ENSEMBLE_BUFFER_SIZE - 1))
            inIndex = 0;

        delayBuffer[inIndex] = block->data[i];
    49cc:	add.w	r2, r8, r2, lsl #2
    49d0:	str	r0, [r2, #44]	; 0x2c
	block = receiveReadOnly_f32(0);
    if (!block)
        return;

    // buffer the incoming block
    for (i=0; i < AUDIO_BLOCK_SAMPLES; i++)
    49d2:	bne.n	49b4 <AudioEffectEnsemble_F32::update()+0x5c>
    49d4:	movw	r6, #10028	; 0x272c
    49d8:	movw	lr, #10030	; 0x272e
    49dc:	movw	r1, #10024	; 0x2728
    49e0:	movw	r9, #10022	; 0x2726
        if (lfoCount > COUNTS_PER_LFO)
        {
            // wrap the lfo index
            lfoIndex1++;
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
    49e4:	mov	r2, r6
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
    49e6:	add.w	r3, r8, lr
    49ea:	movw	sl, #10026	; 0x272a
    49ee:	ldrsh.w	r6, [r8, r6]
    49f2:	str	r3, [sp, #56]	; 0x38
        if (lfoCount > COUNTS_PER_LFO)
        {
            // wrap the lfo index
            lfoIndex1++;
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
    49f4:	add.w	r3, r8, r2
    49f8:	add.w	r5, r8, r1
    49fc:	movw	ip, #10032	; 0x2730
    4a00:	str	r3, [sp, #60]	; 0x3c
    4a02:	add.w	r4, r8, sl
    4a06:	ldr	r3, [sp, #68]	; 0x44
    4a08:	movw	fp, #10034	; 0x2732
    4a0c:	str	r6, [sp, #16]
    4a0e:	add.w	r6, r8, r9
    4a12:	adds	r2, r3, #4
    4a14:	str	r5, [sp, #48]	; 0x30
    4a16:	str	r6, [sp, #44]	; 0x2c
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
            if (lfoIndex3 > (LFO_SIZE - 1))
                lfoIndex3 = 0;
    4a18:	add.w	r0, r8, ip
    4a1c:	str	r2, [sp, #12]
    4a1e:	add.w	r3, r3, #516	; 0x204
    4a22:	ldr	r2, [sp, #72]	; 0x48
        if (offsetIndex3B < 0)
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;

        // combine delayed samples into output
        // add the delayed and scaled samples
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
    4a24:	vmov.f32	s12, #8	; 0x40400000  3.0
    4a28:	ldrsh.w	r6, [r8, lr]
    4a2c:	ldrsh.w	r5, [r8, ip]
    4a30:	adds	r2, #4
    4a32:	str	r4, [sp, #52]	; 0x34
    4a34:	ldrsh.w	r4, [r8, r1]
    4a38:	ldrsh.w	r1, [r8, sl]
    4a3c:	str	r6, [sp, #20]
    4a3e:	str	r5, [sp, #36]	; 0x24
    4a40:	ldrsh.w	r7, [r8, r9]
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
            if (lfoIndex3 > (LFO_SIZE - 1))
                lfoIndex3 = 0;
    4a44:	str	r0, [sp, #64]	; 0x40
    4a46:	ldrsh.w	fp, [r8, fp]
    4a4a:	str	r2, [sp, #8]
    4a4c:	str	r3, [sp, #40]	; 0x28

            // reset the counter
            lfoCount = 0;
    4a4e:	str	r1, [sp, #4]
    4a50:	b.n	4bf2 <AudioEffectEnsemble_F32::update()+0x29a>
    4a52:	ldr	r6, [sp, #36]	; 0x24
        }

        // wrap the output index
        outIndex1++;
    4a54:	add.w	lr, r7, #1
    4a58:	uxth.w	lr, lr
    4a5c:	sxth.w	r7, lr
        if (outIndex1 > (ENSEMBLE_BUFFER_SIZE - 1))
    4a60:	cmp.w	r7, #1024	; 0x400
    4a64:	bge.w	4c7c <AudioEffectEnsemble_F32::update()+0x324>
            // reset the counter
            lfoCount = 0;
        }

        // wrap the output index
        outIndex1++;
    4a68:	ldr	r3, [sp, #44]	; 0x2c
    4a6a:	strh	r7, [r3, #0]
        if (outIndex1 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex1 = 0;

        outIndex2++;
    4a6c:	adds	r5, r4, #1
    4a6e:	uxth	r5, r5
    4a70:	sxth	r4, r5
        if (outIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
    4a72:	cmp.w	r4, #1024	; 0x400
    4a76:	bge.w	4c8a <AudioEffectEnsemble_F32::update()+0x332>
        // wrap the output index
        outIndex1++;
        if (outIndex1 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex1 = 0;

        outIndex2++;
    4a7a:	ldr	r3, [sp, #48]	; 0x30
    4a7c:	strh	r4, [r3, #0]
        if (outIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex2 = 0;

        outIndex3++;
    4a7e:	ldr	r0, [sp, #4]
    4a80:	adds	r0, #1
    4a82:	uxth	r0, r0
    4a84:	sxth	r3, r0
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
    4a86:	cmp.w	r3, #1024	; 0x400

        outIndex2++;
        if (outIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex2 = 0;

        outIndex3++;
    4a8a:	mov	r2, r3
    4a8c:	str	r3, [sp, #4]
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
    4a8e:	bge.w	4c6c <AudioEffectEnsemble_F32::update()+0x314>

        outIndex2++;
        if (outIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex2 = 0;

        outIndex3++;
    4a92:	ldr	r3, [sp, #52]	; 0x34
    4a94:	strh	r2, [r3, #0]
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4a96:	ldr	r3, [sp, #16]
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];
    4a98:	addw	r6, r6, #1034	; 0x40a
        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4a9c:	addw	r2, r3, #1034	; 0x40a
        offset2 = lfoTable[lfoIndex2];
    4aa0:	ldr	r3, [sp, #20]
        offset3 = lfoTable[lfoIndex3];
    4aa2:	add.w	r6, r8, r6, lsl #2
        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4aa6:	add.w	r2, r8, r2, lsl #2
        offset2 = lfoTable[lfoIndex2];
    4aaa:	addw	r3, r3, #1034	; 0x40a
        offset3 = lfoTable[lfoIndex3];
    4aae:	vldr	s13, [r6, #4]
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
    4ab2:	add.w	r3, r8, r3, lsl #2
        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4ab6:	vldr	s14, [r2, #4]
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];
    4aba:	vcvt.s32.f32	s13, s13
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
    4abe:	vldr	s15, [r3, #4]
        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4ac2:	vcvt.s32.f32	s14, s14
        offset2 = lfoTable[lfoIndex2];
    4ac6:	vcvt.s32.f32	s15, s15
        offset3 = lfoTable[lfoIndex3];
    4aca:	vstr	s13, [sp, #32]
        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4ace:	vstr	s14, [sp, #24]
    4ad2:	ldrsh.w	r2, [sp, #24]
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];
    4ad6:	ldrsh.w	r3, [sp, #32]
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
    4ada:	vstr	s15, [sp, #28]
        offset3 = lfoTable[lfoIndex3];

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
    4ade:	add	lr, r2
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
    4ae0:	ldrsh.w	r6, [sp, #28]
        offset3 = lfoTable[lfoIndex3];

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
        offsetIndex3 = outIndex3 + offset3;
    4ae4:	add	r0, r3
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
    4ae6:	uxth.w	lr, lr
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];
    4aea:	str	r3, [sp, #32]

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
    4aec:	add	r5, r6
        offsetIndex3 = outIndex3 + offset3;
    4aee:	uxth	r0, r0
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
    4af0:	sxth.w	sl, lr
        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
    4af4:	str	r2, [sp, #24]
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
    4af6:	uxth	r5, r5
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;

        // get the delay from the wavetable
        offset1 = lfoTable[lfoIndex1];
        offset2 = lfoTable[lfoIndex2];
    4af8:	str	r6, [sp, #28]
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
        offsetIndex3 = outIndex3 + offset3;
        offsetIndex1B = outIndex1 + offset1 + PHASE_90;
        offsetIndex2B = outIndex2 + offset2 + PHASE_90;
        offsetIndex3B = outIndex3 + offset3 + PHASE_90;
    4afa:	addw	r2, r0, #367	; 0x16f

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
        offsetIndex3 = outIndex3 + offset3;
        offsetIndex1B = outIndex1 + offset1 + PHASE_90;
    4afe:	addw	r6, lr, #367	; 0x16f
        offsetIndex2B = outIndex2 + offset2 + PHASE_90;
    4b02:	addw	r3, r5, #367	; 0x16f
        offsetIndex3B = outIndex3 + offset3 + PHASE_90;


        // wrap the index if it goes past the end of the buffer
        if (offsetIndex1 > (ENSEMBLE_BUFFER_SIZE - 1))
    4b06:	cmp.w	sl, #1024	; 0x400
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
        offsetIndex3 = outIndex3 + offset3;
        offsetIndex1B = outIndex1 + offset1 + PHASE_90;
        offsetIndex2B = outIndex2 + offset2 + PHASE_90;
        offsetIndex3B = outIndex3 + offset3 + PHASE_90;
    4b0a:	sxth	r2, r2

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
        offsetIndex3 = outIndex3 + offset3;
        offsetIndex1B = outIndex1 + offset1 + PHASE_90;
    4b0c:	sxth	r6, r6
        offsetIndex2B = outIndex2 + offset2 + PHASE_90;
    4b0e:	sxth	r3, r3
        offset2 = lfoTable[lfoIndex2];
        offset3 = lfoTable[lfoIndex3];

        // add the delay to the buffer index to get the delay index
        offsetIndex1 = outIndex1 + offset1;
        offsetIndex2 = outIndex2 + offset2;
    4b10:	sxth.w	r9, r5
        offsetIndex3 = outIndex3 + offset3;
    4b14:	sxth.w	ip, r0
        offsetIndex2B = outIndex2 + offset2 + PHASE_90;
        offsetIndex3B = outIndex3 + offset3 + PHASE_90;


        // wrap the index if it goes past the end of the buffer
        if (offsetIndex1 > (ENSEMBLE_BUFFER_SIZE - 1))
    4b18:	blt.n	4b22 <AudioEffectEnsemble_F32::update()+0x1ca>
            offsetIndex1 = offsetIndex1 - ENSEMBLE_BUFFER_SIZE;
    4b1a:	sub.w	sl, lr, #1024	; 0x400
    4b1e:	sxth.w	sl, sl
        if (offsetIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
    4b22:	cmp.w	r9, #1024	; 0x400
    4b26:	blt.n	4b30 <AudioEffectEnsemble_F32::update()+0x1d8>
            offsetIndex2 = offsetIndex2 - ENSEMBLE_BUFFER_SIZE;
    4b28:	sub.w	r9, r5, #1024	; 0x400
    4b2c:	sxth.w	r9, r9
        if (offsetIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
    4b30:	cmp.w	ip, #1024	; 0x400
    4b34:	blt.n	4b3e <AudioEffectEnsemble_F32::update()+0x1e6>
            offsetIndex3 = offsetIndex3 - ENSEMBLE_BUFFER_SIZE;
    4b36:	sub.w	ip, r0, #1024	; 0x400
    4b3a:	sxth.w	ip, ip

        // wrap the index if it goes past the buffer the other way
        if (offsetIndex1 < 0)
    4b3e:	cmp.w	sl, #0
    4b42:	blt.w	4cc4 <AudioEffectEnsemble_F32::update()+0x36c>
            offsetIndex1 = ENSEMBLE_BUFFER_SIZE + offsetIndex1;
        if (offsetIndex2 < 0)
    4b46:	cmp.w	r9, #0
    4b4a:	blt.w	4cba <AudioEffectEnsemble_F32::update()+0x362>
            offsetIndex2 = ENSEMBLE_BUFFER_SIZE + offsetIndex2;
        if (offsetIndex3 < 0)
    4b4e:	cmp.w	ip, #0
    4b52:	blt.w	4cb0 <AudioEffectEnsemble_F32::update()+0x358>
            offsetIndex3 = ENSEMBLE_BUFFER_SIZE + offsetIndex3;
        
        // wrap the index if it goes past the end of the buffer
        if (offsetIndex1B > (ENSEMBLE_BUFFER_SIZE - 1))
    4b56:	cmp.w	r6, #1024	; 0x400
    4b5a:	blt.n	4b66 <AudioEffectEnsemble_F32::update()+0x20e>
            offsetIndex1B = offsetIndex1B - ENSEMBLE_BUFFER_SIZE;
    4b5c:	mvn.w	r6, #656	; 0x290
    4b60:	add	lr, r6
    4b62:	sxth.w	r6, lr
        if (offsetIndex2B > (ENSEMBLE_BUFFER_SIZE - 1))
    4b66:	cmp.w	r3, #1024	; 0x400
    4b6a:	blt.n	4b74 <AudioEffectEnsemble_F32::update()+0x21c>
            offsetIndex2B = offsetIndex2B - ENSEMBLE_BUFFER_SIZE;
    4b6c:	mvn.w	r1, #656	; 0x290
    4b70:	add	r5, r1
    4b72:	sxth	r3, r5
        if (offsetIndex3B > (ENSEMBLE_BUFFER_SIZE - 1))
    4b74:	cmp.w	r2, #1024	; 0x400
    4b78:	blt.n	4b82 <AudioEffectEnsemble_F32::update()+0x22a>
            offsetIndex3B = offsetIndex3B - ENSEMBLE_BUFFER_SIZE;
    4b7a:	mvn.w	r2, #656	; 0x290
    4b7e:	add	r0, r2
    4b80:	sxth	r2, r0
        
        // wrap the index if it goes past the buffer the other way
        if (offsetIndex1B < 0)
    4b82:	cmp	r6, #0
    4b84:	blt.w	4ca8 <AudioEffectEnsemble_F32::update()+0x350>
            offsetIndex1B = ENSEMBLE_BUFFER_SIZE + offsetIndex1B;
        if (offsetIndex2B < 0)
    4b88:	cmp	r3, #0
    4b8a:	blt.w	4ca0 <AudioEffectEnsemble_F32::update()+0x348>
            offsetIndex2B = ENSEMBLE_BUFFER_SIZE + offsetIndex2B;
        if (offsetIndex3B < 0)
    4b8e:	cmp	r2, #0
    4b90:	blt.w	4c98 <AudioEffectEnsemble_F32::update()+0x340>
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;

        // combine delayed samples into output
        // add the delayed and scaled samples
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
    4b94:	add.w	r0, r8, sl, lsl #2
    4b98:	ldr	r1, [sp, #12]
    4b9a:	add.w	r5, r8, r9, lsl #2
    4b9e:	vldr	s13, [r0, #44]	; 0x2c
    4ba2:	add.w	r0, r8, ip, lsl #2
    4ba6:	vldr	s15, [r5, #44]	; 0x2c
        outblockB->data[i] = (delayBuffer[offsetIndex1B] + delayBuffer[offsetIndex2B] + delayBuffer[offsetIndex3B]) / 3.0;
    4baa:	add.w	lr, r8, r6, lsl #2
        if (offsetIndex3B < 0)
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;

        // combine delayed samples into output
        // add the delayed and scaled samples
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
    4bae:	vldr	s14, [r0, #44]	; 0x2c
        outblockB->data[i] = (delayBuffer[offsetIndex1B] + delayBuffer[offsetIndex2B] + delayBuffer[offsetIndex3B]) / 3.0;
    4bb2:	add.w	r5, r8, r3, lsl #2
        if (offsetIndex3B < 0)
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;

        // combine delayed samples into output
        // add the delayed and scaled samples
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
    4bb6:	vadd.f32	s15, s13, s15
        outblockB->data[i] = (delayBuffer[offsetIndex1B] + delayBuffer[offsetIndex2B] + delayBuffer[offsetIndex3B]) / 3.0;
    4bba:	add.w	r0, r8, r2, lsl #2
        if (offsetIndex3B < 0)
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;

        // combine delayed samples into output
        // add the delayed and scaled samples
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
    4bbe:	vadd.f32	s15, s15, s14
    4bc2:	vdiv.f32	s14, s15, s12
    4bc6:	vstmia	r1!, {s14}
        outblockB->data[i] = (delayBuffer[offsetIndex1B] + delayBuffer[offsetIndex2B] + delayBuffer[offsetIndex3B]) / 3.0;
    4bca:	vldr	s13, [lr, #44]	; 0x2c
    4bce:	vldr	s15, [r5, #44]	; 0x2c
    4bd2:	vldr	s14, [r0, #44]	; 0x2c
    4bd6:	vadd.f32	s15, s13, s15
    4bda:	ldr	r0, [sp, #8]
        if (offsetIndex3B < 0)
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;

        // combine delayed samples into output
        // add the delayed and scaled samples
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
    4bdc:	str	r1, [sp, #12]
        outblockB->data[i] = (delayBuffer[offsetIndex1B] + delayBuffer[offsetIndex2B] + delayBuffer[offsetIndex3B]) / 3.0;
    4bde:	vadd.f32	s15, s15, s14
    4be2:	vdiv.f32	s14, s15, s12
    4be6:	vstmia	r0!, {s14}
    4bea:	str	r0, [sp, #8]

        delayBuffer[inIndex] = block->data[i];

    }
    // re-load the block with the delayed data
    for (i=0; i < AUDIO_BLOCK_SAMPLES; i++)
    4bec:	ldr	r0, [sp, #40]	; 0x28
    4bee:	cmp	r1, r0
    4bf0:	beq.n	4cf2 <AudioEffectEnsemble_F32::update()+0x39a>
    {
        // advance the wavetable indexes every COUNTS_PER_LFO
        // so the LFO modulates at the correct rate
        lfoCount++;
    4bf2:	add.w	fp, fp, #1
    4bf6:	sxth.w	fp, fp
        if (lfoCount > COUNTS_PER_LFO)
    4bfa:	cmp.w	fp, #200	; 0xc8
    4bfe:	ble.w	4a52 <AudioEffectEnsemble_F32::update()+0xfa>
        {
            // wrap the lfo index
            lfoIndex1++;
    4c02:	ldr	r3, [sp, #16]
            if (lfoIndex1 > (LFO_SIZE - 1))
    4c04:	movw	r2, #1469	; 0x5bd
        // so the LFO modulates at the correct rate
        lfoCount++;
        if (lfoCount > COUNTS_PER_LFO)
        {
            // wrap the lfo index
            lfoIndex1++;
    4c08:	adds	r3, #1
    4c0a:	sxth	r3, r3
            if (lfoIndex1 > (LFO_SIZE - 1))
    4c0c:	cmp	r3, r2
    4c0e:	bgt.n	4ce8 <AudioEffectEnsemble_F32::update()+0x390>
        // so the LFO modulates at the correct rate
        lfoCount++;
        if (lfoCount > COUNTS_PER_LFO)
        {
            // wrap the lfo index
            lfoIndex1++;
    4c10:	ldr	r2, [sp, #60]	; 0x3c
    4c12:	strh	r3, [r2, #0]
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
    4c14:	ldr	r3, [sp, #20]
            if (lfoIndex2 > (LFO_SIZE - 1))
    4c16:	movw	r2, #1469	; 0x5bd
        {
            // wrap the lfo index
            lfoIndex1++;
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
    4c1a:	adds	r3, #1
    4c1c:	sxth	r3, r3
            if (lfoIndex2 > (LFO_SIZE - 1))
    4c1e:	cmp	r3, r2
    4c20:	bgt.n	4cde <AudioEffectEnsemble_F32::update()+0x386>
        {
            // wrap the lfo index
            lfoIndex1++;
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
    4c22:	ldr	r2, [sp, #56]	; 0x38
    4c24:	strh	r3, [r2, #0]
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
    4c26:	ldr	r3, [sp, #36]	; 0x24
            if (lfoIndex3 > (LFO_SIZE - 1))
    4c28:	movw	r1, #1469	; 0x5bd
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
    4c2c:	adds	r3, #1
    4c2e:	sxth	r3, r3
            if (lfoIndex3 > (LFO_SIZE - 1))
    4c30:	cmp	r3, r1
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
    4c32:	str	r3, [sp, #36]	; 0x24
            if (lfoIndex3 > (LFO_SIZE - 1))
    4c34:	bgt.n	4cce <AudioEffectEnsemble_F32::update()+0x376>
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
    4c36:	ldr	r2, [sp, #64]	; 0x40
    4c38:	mov	r6, r3
    4c3a:	strh	r3, [r2, #0]
    4c3c:	ldr	r3, [sp, #60]	; 0x3c
            if (lfoIndex3 > (LFO_SIZE - 1))
                lfoIndex3 = 0;

            // reset the counter
            lfoCount = 0;
    4c3e:	mov.w	fp, #0
    4c42:	ldrsh.w	r3, [r3]
    4c46:	str	r3, [sp, #16]
    4c48:	ldr	r3, [sp, #56]	; 0x38
    4c4a:	ldrsh.w	r3, [r3]
    4c4e:	str	r3, [sp, #20]
    4c50:	b.n	4a54 <AudioEffectEnsemble_F32::update()+0xfc>
	uint16_t i;

    outblock = allocate_f32();
    outblockB = allocate_f32();
    if ((!outblock) || (!outblockB)) {
        audio_block_f32_t *tmp = receiveReadOnly_f32(0);
    4c52:	mov	r0, r8
    4c54:	movs	r1, #0
    4c56:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
        if (tmp) release(tmp);
    4c5a:	cbz	r0, 4c66 <AudioEffectEnsemble_F32::update()+0x30e>
    release((audio_block_f32_t *)block);

    
    return;

}
    4c5c:	add	sp, #84	; 0x54
    4c5e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    transmit(outblock, 0);
    transmit(outblockB, 1);
    release(outblock);
    release(outblockB);
    release((audio_block_f32_t *)block);
    4c62:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>

    
    return;

}
    4c66:	add	sp, #84	; 0x54
    4c68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4c6c:	movs	r3, #0
        if (outIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex2 = 0;

        outIndex3++;
        if (outIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex3 = 0;
    4c6e:	mov.w	r2, #0
    4c72:	mov	r0, r3
    4c74:	str	r3, [sp, #4]
    4c76:	ldr	r3, [sp, #52]	; 0x34
    4c78:	strh	r2, [r3, #0]
    4c7a:	b.n	4a96 <AudioEffectEnsemble_F32::update()+0x13e>
    4c7c:	movs	r7, #0
        }

        // wrap the output index
        outIndex1++;
        if (outIndex1 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex1 = 0;
    4c7e:	ldr	r3, [sp, #44]	; 0x2c
    4c80:	mov.w	r2, #0
    4c84:	mov	lr, r7
    4c86:	strh	r2, [r3, #0]
    4c88:	b.n	4a6c <AudioEffectEnsemble_F32::update()+0x114>
    4c8a:	movs	r4, #0

        outIndex2++;
        if (outIndex2 > (ENSEMBLE_BUFFER_SIZE - 1))
            outIndex2 = 0;
    4c8c:	ldr	r3, [sp, #48]	; 0x30
    4c8e:	mov.w	r2, #0
    4c92:	mov	r5, r4
    4c94:	strh	r2, [r3, #0]
    4c96:	b.n	4a7e <AudioEffectEnsemble_F32::update()+0x126>
        if (offsetIndex1B < 0)
            offsetIndex1B = ENSEMBLE_BUFFER_SIZE + offsetIndex1B;
        if (offsetIndex2B < 0)
            offsetIndex2B = ENSEMBLE_BUFFER_SIZE + offsetIndex2B;
        if (offsetIndex3B < 0)
            offsetIndex3B = ENSEMBLE_BUFFER_SIZE + offsetIndex3B;
    4c98:	add.w	r2, r2, #1024	; 0x400
    4c9c:	sxth	r2, r2
    4c9e:	b.n	4b94 <AudioEffectEnsemble_F32::update()+0x23c>
        
        // wrap the index if it goes past the buffer the other way
        if (offsetIndex1B < 0)
            offsetIndex1B = ENSEMBLE_BUFFER_SIZE + offsetIndex1B;
        if (offsetIndex2B < 0)
            offsetIndex2B = ENSEMBLE_BUFFER_SIZE + offsetIndex2B;
    4ca0:	add.w	r3, r3, #1024	; 0x400
    4ca4:	sxth	r3, r3
    4ca6:	b.n	4b8e <AudioEffectEnsemble_F32::update()+0x236>
        if (offsetIndex3B > (ENSEMBLE_BUFFER_SIZE - 1))
            offsetIndex3B = offsetIndex3B - ENSEMBLE_BUFFER_SIZE;
        
        // wrap the index if it goes past the buffer the other way
        if (offsetIndex1B < 0)
            offsetIndex1B = ENSEMBLE_BUFFER_SIZE + offsetIndex1B;
    4ca8:	add.w	r6, r6, #1024	; 0x400
    4cac:	sxth	r6, r6
    4cae:	b.n	4b88 <AudioEffectEnsemble_F32::update()+0x230>
        if (offsetIndex1 < 0)
            offsetIndex1 = ENSEMBLE_BUFFER_SIZE + offsetIndex1;
        if (offsetIndex2 < 0)
            offsetIndex2 = ENSEMBLE_BUFFER_SIZE + offsetIndex2;
        if (offsetIndex3 < 0)
            offsetIndex3 = ENSEMBLE_BUFFER_SIZE + offsetIndex3;
    4cb0:	add.w	ip, ip, #1024	; 0x400
    4cb4:	sxth.w	ip, ip
    4cb8:	b.n	4b56 <AudioEffectEnsemble_F32::update()+0x1fe>

        // wrap the index if it goes past the buffer the other way
        if (offsetIndex1 < 0)
            offsetIndex1 = ENSEMBLE_BUFFER_SIZE + offsetIndex1;
        if (offsetIndex2 < 0)
            offsetIndex2 = ENSEMBLE_BUFFER_SIZE + offsetIndex2;
    4cba:	add.w	r9, r9, #1024	; 0x400
    4cbe:	sxth.w	r9, r9
    4cc2:	b.n	4b4e <AudioEffectEnsemble_F32::update()+0x1f6>
        if (offsetIndex3 > (ENSEMBLE_BUFFER_SIZE - 1))
            offsetIndex3 = offsetIndex3 - ENSEMBLE_BUFFER_SIZE;

        // wrap the index if it goes past the buffer the other way
        if (offsetIndex1 < 0)
            offsetIndex1 = ENSEMBLE_BUFFER_SIZE + offsetIndex1;
    4cc4:	add.w	sl, sl, #1024	; 0x400
    4cc8:	sxth.w	sl, sl
    4ccc:	b.n	4b46 <AudioEffectEnsemble_F32::update()+0x1ee>
    4cce:	movs	r3, #0
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
            lfoIndex3++;
            if (lfoIndex3 > (LFO_SIZE - 1))
                lfoIndex3 = 0;
    4cd0:	ldr	r2, [sp, #64]	; 0x40
    4cd2:	mov.w	r1, #0
    4cd6:	str	r3, [sp, #36]	; 0x24
    4cd8:	mov	r6, r3
    4cda:	strh	r1, [r2, #0]
    4cdc:	b.n	4c3c <AudioEffectEnsemble_F32::update()+0x2e4>
            lfoIndex1++;
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
            lfoIndex2++;
            if (lfoIndex2 > (LFO_SIZE - 1))
                lfoIndex2 = 0;
    4cde:	ldr	r3, [sp, #56]	; 0x38
    4ce0:	mov.w	r2, #0
    4ce4:	strh	r2, [r3, #0]
    4ce6:	b.n	4c26 <AudioEffectEnsemble_F32::update()+0x2ce>
        if (lfoCount > COUNTS_PER_LFO)
        {
            // wrap the lfo index
            lfoIndex1++;
            if (lfoIndex1 > (LFO_SIZE - 1))
                lfoIndex1 = 0;
    4ce8:	ldr	r3, [sp, #60]	; 0x3c
    4cea:	mov.w	r2, #0
    4cee:	strh	r2, [r3, #0]
    4cf0:	b.n	4c14 <AudioEffectEnsemble_F32::update()+0x2bc>
    4cf2:	movw	r4, #10052	; 0x2744
    4cf6:	movw	r0, #10034	; 0x2732
    4cfa:	ldrh.w	lr, [sp, #32]
    4cfe:	movw	r1, #10036	; 0x2734
    4d02:	strh.w	r2, [r8, r4]
    4d06:	movw	r7, #10040	; 0x2738
    4d0a:	strh.w	fp, [r8, r0]
    4d0e:	movw	r4, #10038	; 0x2736
    4d12:	ldrh.w	r0, [sp, #24]
    4d16:	movw	r2, #10042	; 0x273a
    4d1a:	ldrh.w	r5, [sp, #28]
    4d1e:	strh.w	r0, [r8, r1]
    4d22:	movw	r1, #10044	; 0x273c
    4d26:	strh.w	r5, [r8, r4]
    4d2a:	movw	r0, #10046	; 0x273e
    4d2e:	strh.w	lr, [r8, r7]
    4d32:	add.w	r5, r8, #10048	; 0x2740
        outblock->data[i] = (delayBuffer[offsetIndex1] + delayBuffer[offsetIndex2] + delayBuffer[offsetIndex3]) / 3.0;
        outblockB->data[i] = (delayBuffer[offsetIndex1B] + delayBuffer[offsetIndex2B] + delayBuffer[offsetIndex3B]) / 3.0;

    }

    transmit(outblock, 0);
    4d36:	ldr	r7, [sp, #68]	; 0x44
    4d38:	movw	r4, #10050	; 0x2742
    4d3c:	strh.w	sl, [r8, r2]
    4d40:	movs	r2, #0
    4d42:	strh.w	r9, [r8, r1]
    4d46:	mov	r1, r7
    4d48:	strh.w	ip, [r8, r0]
    4d4c:	mov	r0, r8
    4d4e:	strh	r6, [r5, #0]
    4d50:	strh.w	r3, [r8, r4]
    4d54:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
    transmit(outblockB, 1);
    4d58:	ldr	r4, [sp, #72]	; 0x48
    4d5a:	movs	r2, #1
    4d5c:	mov	r0, r8
    4d5e:	mov	r1, r4
    4d60:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
    release(outblock);
    4d64:	mov	r0, r7
    4d66:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    release(outblockB);
    4d6a:	mov	r0, r4
    4d6c:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    release((audio_block_f32_t *)block);
    4d70:	ldr	r0, [sp, #76]	; 0x4c

    
    return;

}
    4d72:	add	sp, #84	; 0x54
    4d74:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    transmit(outblock, 0);
    transmit(outblockB, 1);
    release(outblock);
    release(outblockB);
    release((audio_block_f32_t *)block);
    4d78:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    4d7c:	movs	r0, r0
	...

00004d80 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()>:
#include <Arduino.h>
#include "effect_ensemble_f32.h"
#include "utility/dspinst.h"
#include "arm_math.h"

AudioEffectEnsemble_F32::AudioEffectEnsemble_F32() : AudioStream_F32(1, inputQueueArray_f32)
    4d80:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4d84:	mov	r4, r0

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    4d86:	ldr	r2, [pc, #392]	; (4f10 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x190>)
			active = false;
    4d88:	movs	r0, #0

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    4d8a:	movs	r6, #1


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
    4d8c:	add.w	r5, r4, #36	; 0x24
    4d90:	add.w	lr, r4, #40	; 0x28
			active = false;
			destination_list = NULL;
    4d94:	mov	r3, r0
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    4d96:	mov	r1, r0
    4d98:	vpush	{d8-d14}

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    4d9c:	str	r2, [r4, #0]
			active = false;
			destination_list = NULL;
    4d9e:	mov	r2, r5

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    4da0:	strb	r6, [r4, #9]
    4da2:	str	r5, [r4, #16]
			active = false;
    4da4:	strb	r0, [r4, #8]
			destination_list = NULL;
    4da6:	str	r0, [r4, #12]
    4da8:	b.n	4dac <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x2c>
    4daa:	ldr	r2, [r4, #16]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    4dac:	str.w	r1, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    4db0:	adds	r3, #1
    4db2:	ldrb	r2, [r4, #9]
    4db4:	cmp	r2, r3
    4db6:	bgt.n	4daa <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x2a>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    4db8:	ldr	r3, [pc, #344]	; (4f14 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x194>)
    4dba:	ldr	r2, [r3, #0]
    4dbc:	cbnz	r2, 4dc2 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x42>
    4dbe:	b.n	4ee8 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x168>
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    4dc0:	mov	r2, r3
    4dc2:	ldr	r3, [r2, #20]
    4dc4:	cmp	r3, #0
    4dc6:	bne.n	4dc0 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x40>
				p->next_update = this;
    4dc8:	str	r4, [r2, #20]
{
	memset(delayBuffer, 0, sizeof(delayBuffer));
    memset(lfoTable, 0, sizeof(lfoTable));
    4dca:	movw	r6, #4140	; 0x102c
			}
			next_update = NULL;
    4dce:	movs	r7, #0
#include <Arduino.h>
#include "effect_ensemble_f32.h"
#include "utility/dspinst.h"
#include "arm_math.h"

AudioEffectEnsemble_F32::AudioEffectEnsemble_F32() : AudioStream_F32(1, inputQueueArray_f32)
    4dd0:	ldr	r3, [pc, #324]	; (4f18 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x198>)
    4dd2:	mov	r0, r4
    4dd4:	movs	r5, #1
{
	memset(delayBuffer, 0, sizeof(delayBuffer));
    memset(lfoTable, 0, sizeof(lfoTable));
    4dd6:	add	r6, r4
    4dd8:	str.w	lr, [r4, #32]
#include "utility/dspinst.h"
#include "arm_math.h"

AudioEffectEnsemble_F32::AudioEffectEnsemble_F32() : AudioStream_F32(1, inputQueueArray_f32)
{
	memset(delayBuffer, 0, sizeof(delayBuffer));
    4ddc:	mov	r1, r7
    4dde:	str	r7, [r4, #20]
    4de0:	mov.w	r2, #4096	; 0x1000
			cpu_cycles = 0;
    4de4:	strh	r7, [r4, #4]
    offsetIndex3B = 0;
    
    // generate the LFO wavetable
    for (iC = 0; iC < LFO_SAMPLES; iC++)
    {
        lfoTable[iC] = ((sin(((2.0 * M_PI)/LFO_SAMPLES) * iC) * LFO_RANGE) / 2.0) + (((sin(((20.0 * M_PI)/LFO_SAMPLES) * iC)) * LFO_RANGE) / 3.0);
    4de6:	vmov.f64	d9, #8	; 0x40400000  3.0
			cpu_cycles_max = 0;
    4dea:	strh	r7, [r4, #6]
    4dec:	vmov.f64	d8, #96	; 0x3f000000  0.5
			numConnections = 0;
    4df0:	strb	r7, [r4, #10]
    offsetIndex1B = 0;
    offsetIndex2B = 0;
    offsetIndex3B = 0;
    
    // generate the LFO wavetable
    for (iC = 0; iC < LFO_SAMPLES; iC++)
    4df2:	movw	r8, #1471	; 0x5bf
      //active_f32 = false;
      destination_list_f32 = NULL;
    4df6:	str	r7, [r4, #28]
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
    4df8:	str	r7, [r4, #40]	; 0x28


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
    4dfa:	strb	r5, [r4, #24]
#include <Arduino.h>
#include "effect_ensemble_f32.h"
#include "utility/dspinst.h"
#include "arm_math.h"

AudioEffectEnsemble_F32::AudioEffectEnsemble_F32() : AudioStream_F32(1, inputQueueArray_f32)
    4dfc:	str.w	r3, [r0], #44
{
	memset(delayBuffer, 0, sizeof(delayBuffer));
    4e00:	bl	1b018 <memset>
    memset(lfoTable, 0, sizeof(lfoTable));
    4e04:	mov	r1, r7
    4e06:	movw	r2, #5880	; 0x16f8
    4e0a:	mov	r0, r6
    4e0c:	bl	1b018 <memset>
    
    // input index
    inIndex = 0;
    4e10:	movw	r2, #10020	; 0x2724
    outIndex1 = 512;
    outIndex2 = 512;
    outIndex3 = 512;
    // lfo index
    // seprated by thirds to approximate 120 degree phase relationship
    lfoIndex1 = 0;
    4e14:	movw	r1, #10028	; 0x272c
    lfoIndex2 = 245;
    lfoIndex3 = 490;

    // lfo rate counter
    lfoCount = 0;
    4e18:	movw	r3, #10034	; 0x2732
    // input index offset
    offset1 = 0;
    4e1c:	movw	r0, #10036	; 0x2734
{
	memset(delayBuffer, 0, sizeof(delayBuffer));
    memset(lfoTable, 0, sizeof(lfoTable));
    
    // input index
    inIndex = 0;
    4e20:	strh	r7, [r4, r2]
    outIndex1 = 512;
    outIndex2 = 512;
    outIndex3 = 512;
    // lfo index
    // seprated by thirds to approximate 120 degree phase relationship
    lfoIndex1 = 0;
    4e22:	strh	r7, [r4, r1]

    // lfo rate counter
    lfoCount = 0;
    // input index offset
    offset1 = 0;
    offset2 = 0;
    4e24:	movw	r2, #10038	; 0x2736
    lfoIndex1 = 0;
    lfoIndex2 = 245;
    lfoIndex3 = 490;

    // lfo rate counter
    lfoCount = 0;
    4e28:	strh	r7, [r4, r3]
    // input index offset
    offset1 = 0;
    offset2 = 0;
    offset3 = 0;
    4e2a:	movw	r1, #10040	; 0x2738
    lfoIndex3 = 490;

    // lfo rate counter
    lfoCount = 0;
    // input index offset
    offset1 = 0;
    4e2e:	strh	r7, [r4, r0]
    offset2 = 0;
    offset3 = 0;
    offsetIndex1 = 0;
    4e30:	movw	r3, #10042	; 0x273a
    offsetIndex2 = 0;
    4e34:	movw	r0, #10044	; 0x273c

    // lfo rate counter
    lfoCount = 0;
    // input index offset
    offset1 = 0;
    offset2 = 0;
    4e38:	strh	r7, [r4, r2]
    offset3 = 0;
    4e3a:	strh	r7, [r4, r1]
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    4e3c:	movw	r2, #10046	; 0x273e
    lfoCount = 0;
    // input index offset
    offset1 = 0;
    offset2 = 0;
    offset3 = 0;
    offsetIndex1 = 0;
    4e40:	strh	r7, [r4, r3]
    
    // input index
    inIndex = 0;
    // output indexes
    // default to center of buffer
    outIndex1 = 512;
    4e42:	movw	r1, #10022	; 0x2726
    // input index offset
    offset1 = 0;
    offset2 = 0;
    offset3 = 0;
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    4e46:	strh	r7, [r4, r0]
    
    // input index
    inIndex = 0;
    // output indexes
    // default to center of buffer
    outIndex1 = 512;
    4e48:	mov.w	r3, #512	; 0x200
    outIndex2 = 512;
    4e4c:	movw	r0, #10024	; 0x2728
    offset1 = 0;
    offset2 = 0;
    offset3 = 0;
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    4e50:	strh	r7, [r4, r2]
    
    // input index
    inIndex = 0;
    // output indexes
    // default to center of buffer
    outIndex1 = 512;
    4e52:	strh	r3, [r4, r1]
    outIndex2 = 512;
    outIndex3 = 512;
    4e54:	movw	r2, #10026	; 0x272a
    // input index
    inIndex = 0;
    // output indexes
    // default to center of buffer
    outIndex1 = 512;
    outIndex2 = 512;
    4e58:	strh	r3, [r4, r0]
    outIndex3 = 512;
    // lfo index
    // seprated by thirds to approximate 120 degree phase relationship
    lfoIndex1 = 0;
    lfoIndex2 = 245;
    4e5a:	movw	r1, #10030	; 0x272e
    4e5e:	movs	r0, #245	; 0xf5
    inIndex = 0;
    // output indexes
    // default to center of buffer
    outIndex1 = 512;
    outIndex2 = 512;
    outIndex3 = 512;
    4e60:	strh	r3, [r4, r2]
    // lfo index
    // seprated by thirds to approximate 120 degree phase relationship
    lfoIndex1 = 0;
    lfoIndex2 = 245;
    lfoIndex3 = 490;
    4e62:	movw	r2, #10032	; 0x2730
    offset2 = 0;
    offset3 = 0;
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    offsetIndex1B = 0;
    4e66:	add.w	r3, r4, #10048	; 0x2740
    outIndex2 = 512;
    outIndex3 = 512;
    // lfo index
    // seprated by thirds to approximate 120 degree phase relationship
    lfoIndex1 = 0;
    lfoIndex2 = 245;
    4e6a:	strh	r0, [r4, r1]
    lfoIndex3 = 490;
    4e6c:	mov.w	r0, #490	; 0x1ea
    offset3 = 0;
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    offsetIndex1B = 0;
    offsetIndex2B = 0;
    4e70:	movw	r1, #10050	; 0x2742
    outIndex3 = 512;
    // lfo index
    // seprated by thirds to approximate 120 degree phase relationship
    lfoIndex1 = 0;
    lfoIndex2 = 245;
    lfoIndex3 = 490;
    4e74:	strh	r0, [r4, r2]
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    offsetIndex1B = 0;
    offsetIndex2B = 0;
    offsetIndex3B = 0;
    4e76:	movw	r2, #10052	; 0x2744
    offset2 = 0;
    offset3 = 0;
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    offsetIndex1B = 0;
    4e7a:	strh	r7, [r3, #0]
    offsetIndex2B = 0;
    4e7c:	strh	r7, [r4, r1]
    offsetIndex3B = 0;
    4e7e:	strh	r7, [r4, r2]
    4e80:	vldr	d0, [pc, #108]	; 4ef0 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x170>
    
    // generate the LFO wavetable
    for (iC = 0; iC < LFO_SAMPLES; iC++)
    {
        lfoTable[iC] = ((sin(((2.0 * M_PI)/LFO_SAMPLES) * iC) * LFO_RANGE) / 2.0) + (((sin(((20.0 * M_PI)/LFO_SAMPLES) * iC)) * LFO_RANGE) / 3.0);
    4e84:	vldr	d14, [pc, #112]	; 4ef8 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x178>
    4e88:	vldr	d11, [pc, #116]	; 4f00 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x180>
    4e8c:	vldr	d10, [pc, #120]	; 4f08 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x188>
    offsetIndex1 = 0;
    offsetIndex2 = 0;
    offsetIndex3 = 0;
    offsetIndex1B = 0;
    offsetIndex2B = 0;
    offsetIndex3B = 0;
    4e90:	vmov.f64	d13, d0
    4e94:	b.n	4eb2 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x132>
    4e96:	vmov	s15, r2
    4e9a:	vcvt.f64.s32	d12, s15
    4e9e:	vmul.f64	d0, d12, d11
    4ea2:	bl	17ec0 <sin>
    4ea6:	vmov.f64	d13, d0
    4eaa:	vmul.f64	d0, d12, d10
    4eae:	bl	17ec0 <sin>
    4eb2:	adds	r3, r5, #1
    
    // generate the LFO wavetable
    for (iC = 0; iC < LFO_SAMPLES; iC++)
    4eb4:	sxth	r2, r5
    {
        lfoTable[iC] = ((sin(((2.0 * M_PI)/LFO_SAMPLES) * iC) * LFO_RANGE) / 2.0) + (((sin(((20.0 * M_PI)/LFO_SAMPLES) * iC)) * LFO_RANGE) / 3.0);
    4eb6:	vmul.f64	d0, d0, d14
    4eba:	uxth	r5, r3
    4ebc:	vmul.f64	d13, d13, d14
    offsetIndex1B = 0;
    offsetIndex2B = 0;
    offsetIndex3B = 0;
    
    // generate the LFO wavetable
    for (iC = 0; iC < LFO_SAMPLES; iC++)
    4ec0:	cmp	r5, r8
    {
        lfoTable[iC] = ((sin(((2.0 * M_PI)/LFO_SAMPLES) * iC) * LFO_RANGE) / 2.0) + (((sin(((20.0 * M_PI)/LFO_SAMPLES) * iC)) * LFO_RANGE) / 3.0);
    4ec2:	vdiv.f64	d7, d0, d9
    4ec6:	vfma.f64	d7, d13, d8
    4eca:	vcvt.f32.f64	s14, d7
    4ece:	vstmia	r6!, {s14}
    offsetIndex1B = 0;
    offsetIndex2B = 0;
    offsetIndex3B = 0;
    
    // generate the LFO wavetable
    for (iC = 0; iC < LFO_SAMPLES; iC++)
    4ed2:	bne.n	4e96 <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x116>
    4ed4:	movw	r3, #10054	; 0x2746
    4ed8:	movw	r2, #1470	; 0x5be
        lfoTable[iC] = ((sin(((2.0 * M_PI)/LFO_SAMPLES) * iC) * LFO_RANGE) / 2.0) + (((sin(((20.0 * M_PI)/LFO_SAMPLES) * iC)) * LFO_RANGE) / 3.0);
    }
    
    return;
    
}
    4edc:	mov	r0, r4
    4ede:	strh	r2, [r4, r3]
    4ee0:	vpop	{d8-d14}
    4ee4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
				first_update = this;
    4ee8:	str	r4, [r3, #0]
    4eea:	b.n	4dca <AudioEffectEnsemble_F32::AudioEffectEnsemble_F32()+0x4a>
    4eec:	nop.w
	...
    4efc:	.word	0x40590000
    4f00:	.word	0x26d8c3cf
    4f04:	.word	0x3f7181e7
    4f08:	.word	0xf08ef4c3
    4f0c:	.word	0x3fa5e260
    4f10:	.word	0x20000008
    4f14:	.word	0x2005876c
    4f18:	.word	0x2000052c

00004f1c <AudioSynthPlaits_F32::update()>:

using namespace plaits;
using namespace stmlib;

void AudioSynthPlaits_F32::update(void)
{
    4f1c:	push	{r4, r5, r6, r7, lr}
    4f1e:	subw	sp, sp, #1036	; 0x40c
    4f22:	mov	r5, r0
    audio_block_f32_t *blockOutMain;
    audio_block_f32_t *blockOutAux;

    blockOutMain = AudioStream_F32::allocate_f32();
    4f24:	bl	15198 <AudioStream_F32::allocate_f32()>
    4f28:	mov	r4, r0
    blockOutAux = AudioStream_F32::allocate_f32();
    4f2a:	bl	15198 <AudioStream_F32::allocate_f32()>
    if (blockOutMain == NULL || blockOutAux == NULL)
    4f2e:	cbz	r4, 4f88 <AudioSynthPlaits_F32::update()+0x6c>
    4f30:	mov	r6, r0
    4f32:	cbz	r0, 4f88 <AudioSynthPlaits_F32::update()+0x6c>
        return;

    Voice::Frame out[AUDIO_BLOCK_SAMPLES];
    voice.Render(patch, modulations, out, AUDIO_BLOCK_SAMPLES);
    4f34:	movs	r0, #128	; 0x80
    4f36:	add.w	r2, r5, #40	; 0x28
    4f3a:	add.w	r1, r5, #80	; 0x50
    4f3e:	add	r3, sp, #8
    4f40:	str	r0, [sp, #0]
    4f42:	add.w	r0, r5, #120	; 0x78
    4f46:	bl	619c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)>
    4f4a:	add.w	r7, sp, #1032	; 0x408
    4f4e:	add	r3, sp, #8
    4f50:	adds	r1, r4, #4
    4f52:	adds	r2, r6, #4
    for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    {
        blockOutMain->data[i] = out[i].out;
    4f54:	ldr	r0, [r3, #0]
    4f56:	adds	r3, #8
    4f58:	str.w	r0, [r1], #4
        blockOutAux->data[i] = out[i].aux;
    4f5c:	ldr.w	r0, [r3, #-4]
    if (blockOutMain == NULL || blockOutAux == NULL)
        return;

    Voice::Frame out[AUDIO_BLOCK_SAMPLES];
    voice.Render(patch, modulations, out, AUDIO_BLOCK_SAMPLES);
    for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    4f60:	cmp	r3, r7
    {
        blockOutMain->data[i] = out[i].out;
        blockOutAux->data[i] = out[i].aux;
    4f62:	str.w	r0, [r2], #4
    if (blockOutMain == NULL || blockOutAux == NULL)
        return;

    Voice::Frame out[AUDIO_BLOCK_SAMPLES];
    voice.Render(patch, modulations, out, AUDIO_BLOCK_SAMPLES);
    for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    4f66:	bne.n	4f54 <AudioSynthPlaits_F32::update()+0x38>
    {
        blockOutMain->data[i] = out[i].out;
        blockOutAux->data[i] = out[i].aux;
    }
    AudioStream_F32::transmit(blockOutMain, 0);
    4f68:	movs	r2, #0
    4f6a:	mov	r1, r4
    4f6c:	mov	r0, r5
    4f6e:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
    AudioStream_F32::transmit(blockOutAux, 1);
    4f72:	mov	r0, r5
    4f74:	movs	r2, #1
    4f76:	mov	r1, r6
    4f78:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
    AudioStream_F32::release(blockOutMain);
    4f7c:	mov	r0, r4
    4f7e:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    AudioStream_F32::release(blockOutAux);
    4f82:	mov	r0, r6
    4f84:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    return;
}
    4f88:	addw	sp, sp, #1036	; 0x40c
    4f8c:	pop	{r4, r5, r6, r7, pc}
    4f8e:	nop

00004f90 <AudioFilterMoog_F32::update_fixed(float const*, float*)>:
#include "filter_moog_f32.h"
#include "utility/dspinst.h"
#include "arm_math.h"

void AudioFilterMoog_F32::update_fixed(const float *in, float *lp)
{
    4f90:	push	{r3, r4, r5, r6, r7, lr}
    4f92:	mov	r5, r1
    4f94:	mov	r4, r0
    4f96:	mov	r6, r2
    4f98:	add.w	r7, r1, #512	; 0x200
    4f9c:	vpush	{d8-d11}
	for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
	{
		float cs = in[i];
		cs = tanhf(cs * driv);
		y_a = y_a + g * (tanhf(cs - q * ((y_d_1 + y_d) / 2) - tanhf(y_a)));
    4fa0:	vmov.f32	s20, #96	; 0x3f000000  0.5
		y_b = y_b + g * (tanhf(y_a) - tanhf(y_b));
		y_c = y_c + g * (tanhf(y_b) - tanhf(y_c));
		y_d_1 = y_d;
		y_d = y_d + g * (tanhf(y_c) - tanhf(y_d));
		cs = (y_d < -1 ? -1 : y_d > 1 ? 0.999 : y_d);
    4fa4:	vldr	s21, [pc, #248]	; 50a0 <AudioFilterMoog_F32::update_fixed(float const*, float*)+0x110>
    4fa8:	vmov.f32	s19, #240	; 0xbf800000 -1.0
    4fac:	vmov.f32	s22, #112	; 0x3f800000  1.0
    4fb0:	b.n	4fc8 <AudioFilterMoog_F32::update_fixed(float const*, float*)+0x38>
    4fb2:	vcmp.f32	s16, s22
    4fb6:	vmrs	APSR_nzcv, fpscr
    4fba:	it	gt
    4fbc:	vmovgt.f32	s0, s21
#include "utility/dspinst.h"
#include "arm_math.h"

void AudioFilterMoog_F32::update_fixed(const float *in, float *lp)
{
	for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    4fc0:	cmp	r7, r5
		y_b = y_b + g * (tanhf(y_a) - tanhf(y_b));
		y_c = y_c + g * (tanhf(y_b) - tanhf(y_c));
		y_d_1 = y_d;
		y_d = y_d + g * (tanhf(y_c) - tanhf(y_d));
		cs = (y_d < -1 ? -1 : y_d > 1 ? 0.999 : y_d);
		lp[i] = cs;
    4fc2:	vstmia	r6!, {s0}
#include "utility/dspinst.h"
#include "arm_math.h"

void AudioFilterMoog_F32::update_fixed(const float *in, float *lp)
{
	for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    4fc6:	beq.n	509a <AudioFilterMoog_F32::update_fixed(float const*, float*)+0x10a>
	{
		float cs = in[i];
    4fc8:	vldmia	r5!, {s0}
		cs = tanhf(cs * driv);
    4fcc:	vldr	s15, [r4, #48]	; 0x30
    4fd0:	vmul.f32	s0, s0, s15
    4fd4:	bl	17fbc <tanhf>
		y_a = y_a + g * (tanhf(cs - q * ((y_d_1 + y_d) / 2) - tanhf(y_a)));
    4fd8:	vldr	s17, [r4, #60]	; 0x3c
void AudioFilterMoog_F32::update_fixed(const float *in, float *lp)
{
	for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
	{
		float cs = in[i];
		cs = tanhf(cs * driv);
    4fdc:	vmov.f32	s23, s0
		y_a = y_a + g * (tanhf(cs - q * ((y_d_1 + y_d) / 2) - tanhf(y_a)));
    4fe0:	vldr	s16, [r4, #72]	; 0x48
    4fe4:	vmov.f32	s0, s17
    4fe8:	vldr	s18, [r4, #40]	; 0x28
    4fec:	bl	17fbc <tanhf>
    4ff0:	vldr	s15, [r4, #76]	; 0x4c
    4ff4:	vldr	s14, [r4, #44]	; 0x2c
    4ff8:	vadd.f32	s15, s16, s15
    4ffc:	vmul.f32	s15, s15, s20
    5000:	vfms.f32	s23, s14, s15
    5004:	vsub.f32	s0, s23, s0
    5008:	bl	17fbc <tanhf>
    500c:	vfma.f32	s17, s18, s0
    5010:	vmov.f32	s0, s17
    5014:	vstr	s17, [r4, #60]	; 0x3c
		y_b = y_b + g * (tanhf(y_a) - tanhf(y_b));
    5018:	bl	17fbc <tanhf>
    501c:	vldr	s17, [r4, #64]	; 0x40
    5020:	vmov.f32	s23, s0
    5024:	vmov.f32	s0, s17
    5028:	bl	17fbc <tanhf>
    502c:	vsub.f32	s0, s23, s0
    5030:	vfma.f32	s17, s18, s0
    5034:	vmov.f32	s0, s17
    5038:	vstr	s17, [r4, #64]	; 0x40
		y_c = y_c + g * (tanhf(y_b) - tanhf(y_c));
    503c:	bl	17fbc <tanhf>
    5040:	vldr	s17, [r4, #68]	; 0x44
    5044:	vmov.f32	s23, s0
    5048:	vmov.f32	s0, s17
    504c:	bl	17fbc <tanhf>
		y_d_1 = y_d;
    5050:	vstr	s16, [r4, #76]	; 0x4c
	{
		float cs = in[i];
		cs = tanhf(cs * driv);
		y_a = y_a + g * (tanhf(cs - q * ((y_d_1 + y_d) / 2) - tanhf(y_a)));
		y_b = y_b + g * (tanhf(y_a) - tanhf(y_b));
		y_c = y_c + g * (tanhf(y_b) - tanhf(y_c));
    5054:	vsub.f32	s0, s23, s0
    5058:	vfma.f32	s17, s18, s0
    505c:	vmov.f32	s0, s17
    5060:	vstr	s17, [r4, #68]	; 0x44
		y_d_1 = y_d;
		y_d = y_d + g * (tanhf(y_c) - tanhf(y_d));
    5064:	bl	17fbc <tanhf>
    5068:	vmov.f32	s17, s0
    506c:	vmov.f32	s0, s16
    5070:	bl	17fbc <tanhf>
    5074:	vsub.f32	s0, s17, s0
    5078:	vfma.f32	s16, s18, s0
		cs = (y_d < -1 ? -1 : y_d > 1 ? 0.999 : y_d);
    507c:	vcmpe.f32	s16, s19
		cs = tanhf(cs * driv);
		y_a = y_a + g * (tanhf(cs - q * ((y_d_1 + y_d) / 2) - tanhf(y_a)));
		y_b = y_b + g * (tanhf(y_a) - tanhf(y_b));
		y_c = y_c + g * (tanhf(y_b) - tanhf(y_c));
		y_d_1 = y_d;
		y_d = y_d + g * (tanhf(y_c) - tanhf(y_d));
    5080:	vstr	s16, [r4, #72]	; 0x48
    5084:	vmov.f32	s0, s16
		cs = (y_d < -1 ? -1 : y_d > 1 ? 0.999 : y_d);
    5088:	vmrs	APSR_nzcv, fpscr
    508c:	bpl.n	4fb2 <AudioFilterMoog_F32::update_fixed(float const*, float*)+0x22>
    508e:	vmov.f32	s0, #240	; 0xbf800000 -1.0
#include "utility/dspinst.h"
#include "arm_math.h"

void AudioFilterMoog_F32::update_fixed(const float *in, float *lp)
{
	for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    5092:	cmp	r7, r5
		y_b = y_b + g * (tanhf(y_a) - tanhf(y_b));
		y_c = y_c + g * (tanhf(y_b) - tanhf(y_c));
		y_d_1 = y_d;
		y_d = y_d + g * (tanhf(y_c) - tanhf(y_d));
		cs = (y_d < -1 ? -1 : y_d > 1 ? 0.999 : y_d);
		lp[i] = cs;
    5094:	vstmia	r6!, {s0}
#include "utility/dspinst.h"
#include "arm_math.h"

void AudioFilterMoog_F32::update_fixed(const float *in, float *lp)
{
	for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++)
    5098:	bne.n	4fc8 <AudioFilterMoog_F32::update_fixed(float const*, float*)+0x38>
		y_d_1 = y_d;
		y_d = y_d + g * (tanhf(y_c) - tanhf(y_d));
		cs = (y_d < -1 ? -1 : y_d > 1 ? 0.999 : y_d);
		lp[i] = cs;
	}
}
    509a:	vpop	{d8-d11}
    509e:	pop	{r3, r4, r5, r6, r7, pc}
    50a0:	.word	0x3f7fbe77
    50a4:	.word	0x00000000

000050a8 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)>:

void AudioFilterMoog_F32::update_variable(const float *in, const float *ctl, float *lp)
{
	float nf = basef * (exp2f(ctl[0] * oct));
    50a8:	vldr	s15, [r0, #52]	; 0x34
    50ac:	vldr	s0, [r2]
		lp[i] = cs;
	}
}

void AudioFilterMoog_F32::update_variable(const float *in, const float *ctl, float *lp)
{
    50b0:	push	{r4, r5, r6, lr}
    50b2:	vpush	{d8}
	float nf = basef * (exp2f(ctl[0] * oct));
    50b6:	vldr	s16, [r0, #56]	; 0x38
    50ba:	vmul.f32	s0, s0, s15
		lp[i] = cs;
	}
}

void AudioFilterMoog_F32::update_variable(const float *in, const float *ctl, float *lp)
{
    50be:	mov	r4, r0
    50c0:	mov	r5, r1
    50c2:	mov	r6, r3
	float nf = basef * (exp2f(ctl[0] * oct));
    50c4:	bl	1815c <exp2f>
			n = 6.9999;
		oct = n;
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
    50c8:	vmov.f32	s15, #52	; 0x41a00000  20.0
    50cc:	vmul.f32	s0, s16, s0
    50d0:	vcmpe.f32	s0, s15
    50d4:	vmrs	APSR_nzcv, fpscr
    50d8:	bmi.n	50ee <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0x46>
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
    50da:	vldr	s15, [pc, #116]	; 5150 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0xa8>
    50de:	vcmpe.f32	s0, s15
    50e2:	vmrs	APSR_nzcv, fpscr
    50e6:	ble.n	5114 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0x6c>
    50e8:	vldr	s0, [pc, #104]	; 5154 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0xac>
    50ec:	b.n	50f2 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0x4a>
			n = 6.9999;
		oct = n;
	}
	void frequency(float freq, bool setf = true)
	{
		if (freq < 20.0)
    50ee:	vldr	s0, [pc, #104]	; 5158 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0xb0>
			freq = 20.0;
		else if (freq > AUDIO_SAMPLE_RATE_EXACT / 2.5)
			freq = AUDIO_SAMPLE_RATE_EXACT / 2.5;
		g = 1 - expf(-2 * tanf(2 * M_PI * freq / (2 * AUDIO_SAMPLE_RATE_EXACT)));
    50f2:	bl	18068 <expf>
    50f6:	vmov.f32	s15, #112	; 0x3f800000  1.0
	//	Serial.println(nf);
	frequency(nf, false);
	update_fixed(in, lp);
    50fa:	mov	r2, r6
    50fc:	mov	r1, r5
    50fe:	mov	r0, r4
    5100:	vsub.f32	s0, s15, s0
}
    5104:	vpop	{d8}
    5108:	vstr	s0, [r4, #40]	; 0x28
    510c:	ldmia.w	sp!, {r4, r5, r6, lr}
void AudioFilterMoog_F32::update_variable(const float *in, const float *ctl, float *lp)
{
	float nf = basef * (exp2f(ctl[0] * oct));
	//	Serial.println(nf);
	frequency(nf, false);
	update_fixed(in, lp);
    5110:	b.w	4f90 <AudioFilterMoog_F32::update_fixed(float const*, float*)>
    5114:	vcvt.f64.f32	d0, s0
    5118:	vldr	d7, [pc, #36]	; 5140 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0x98>
    511c:	vldr	d6, [pc, #40]	; 5148 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0xa0>
    5120:	vmul.f64	d7, d0, d7
    5124:	vdiv.f64	d0, d7, d6
    5128:	vcvt.f32.f64	s0, d0
    512c:	bl	17f60 <tanf>
    5130:	vmov.f32	s15, #128	; 0xc0000000 -2.0
    5134:	vmul.f32	s0, s0, s15
    5138:	b.n	50f2 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)+0x4a>
    513a:	nop
    513c:	nop.w
    5140:	.word	0x54442d18
    5144:	.word	0x401921fb
    5148:	.word	0x00000000
    514c:	.word	0x40f77000
    5150:	.word	0x46960000
    5154:	.word	0xc0c4f8c6
    5158:	.word	0xbb2b92ac

0000515c <AudioFilterMoog_F32::update()>:
}

void AudioFilterMoog_F32::update(void)
{
    515c:	push	{r3, r4, r5, r6, r7, lr}
	audio_block_f32_t *input_block = NULL, *control_block = NULL;
	audio_block_f32_t *lowpass_block = NULL;

	input_block = receiveReadOnly_f32(0);
    515e:	movs	r1, #0
	frequency(nf, false);
	update_fixed(in, lp);
}

void AudioFilterMoog_F32::update(void)
{
    5160:	mov	r6, r0
	audio_block_f32_t *input_block = NULL, *control_block = NULL;
	audio_block_f32_t *lowpass_block = NULL;

	input_block = receiveReadOnly_f32(0);
    5162:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
    5166:	mov	r5, r0
	control_block = receiveReadOnly_f32(1);
    5168:	movs	r1, #1
    516a:	mov	r0, r6
    516c:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
    5170:	mov	r7, r0
	if (!input_block)
    5172:	cbz	r5, 51aa <AudioFilterMoog_F32::update()+0x4e>
	{
		if (control_block)
			release(control_block);
		return;
	}
	lowpass_block = allocate_f32();
    5174:	bl	15198 <AudioStream_F32::allocate_f32()>
	if (!lowpass_block)
    5178:	mov	r4, r0
    517a:	cbz	r0, 51bc <AudioFilterMoog_F32::update()+0x60>
		if (control_block)
			release(control_block);
		return;
	}

	if (control_block)
    517c:	cbz	r7, 51b0 <AudioFilterMoog_F32::update()+0x54>
	{
		update_variable(input_block->data, control_block->data, lowpass_block->data);
    517e:	adds	r3, r0, #4
    5180:	adds	r2, r7, #4
    5182:	mov	r0, r6
    5184:	adds	r1, r5, #4
    5186:	bl	50a8 <AudioFilterMoog_F32::update_variable(float const*, float const*, float*)>
		release(control_block);
    518a:	mov	r0, r7
    518c:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
	}
	else
	{
		update_fixed(input_block->data, lowpass_block->data);
	}
	release(input_block);
    5190:	mov	r0, r5
    5192:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
	transmit(lowpass_block, 0);
    5196:	mov	r0, r6
    5198:	movs	r2, #0
    519a:	mov	r1, r4
    519c:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
	release(lowpass_block);
    51a0:	mov	r0, r4
	return;
}
    51a2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	{
		update_fixed(input_block->data, lowpass_block->data);
	}
	release(input_block);
	transmit(lowpass_block, 0);
	release(lowpass_block);
    51a6:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>

	input_block = receiveReadOnly_f32(0);
	control_block = receiveReadOnly_f32(1);
	if (!input_block)
	{
		if (control_block)
    51aa:	cmp	r0, #0
    51ac:	bne.n	51a2 <AudioFilterMoog_F32::update()+0x46>
    51ae:	pop	{r3, r4, r5, r6, r7, pc}
		update_variable(input_block->data, control_block->data, lowpass_block->data);
		release(control_block);
	}
	else
	{
		update_fixed(input_block->data, lowpass_block->data);
    51b0:	adds	r2, r0, #4
    51b2:	adds	r1, r5, #4
    51b4:	mov	r0, r6
    51b6:	bl	4f90 <AudioFilterMoog_F32::update_fixed(float const*, float*)>
    51ba:	b.n	5190 <AudioFilterMoog_F32::update()+0x34>
		return;
	}
	lowpass_block = allocate_f32();
	if (!lowpass_block)
	{
		release(input_block);
    51bc:	mov	r0, r5
    51be:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
		if (control_block)
    51c2:	cmp	r7, #0
    51c4:	beq.n	51ae <AudioFilterMoog_F32::update()+0x52>
			release(control_block);
    51c6:	mov	r0, r7
	}
	release(input_block);
	transmit(lowpass_block, 0);
	release(lowpass_block);
	return;
}
    51c8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lowpass_block = allocate_f32();
	if (!lowpass_block)
	{
		release(input_block);
		if (control_block)
			release(control_block);
    51cc:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>

000051d0 <AudioEffectFreeverbStereo_F32::update()>:
	allpass3indexR = 0;
	allpass4indexR = 0;
}

void AudioEffectFreeverbStereo_F32::update()
{
    51d0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    51d4:	vpush	{d8-d14}
    51d8:	sub	sp, #172	; 0xac
	audio_block_f32_t *outblockR;
	int i;
	float input, bufout, outputL, outputR;
	float sum;

	block = receiveReadOnly_f32(0);
    51da:	movs	r1, #0
	allpass3indexR = 0;
	allpass4indexR = 0;
}

void AudioEffectFreeverbStereo_F32::update()
{
    51dc:	mov	r4, r0
	audio_block_f32_t *outblockR;
	int i;
	float input, bufout, outputL, outputR;
	float sum;

	block = receiveReadOnly_f32(0);
    51de:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
    51e2:	str	r0, [sp, #88]	; 0x58
	outblockL = allocate_f32();
    51e4:	bl	15198 <AudioStream_F32::allocate_f32()>
    51e8:	mov	r5, r0
    51ea:	str	r0, [sp, #92]	; 0x5c
	outblockR = allocate_f32();
    51ec:	bl	15198 <AudioStream_F32::allocate_f32()>
    51f0:	str	r0, [sp, #96]	; 0x60
	if (!outblockL || !outblockR) {
    51f2:	cmp	r5, #0
    51f4:	beq.w	59b2 <AudioEffectFreeverbStereo_F32::update()+0x7e2>
    51f8:	cmp	r0, #0
    51fa:	beq.w	59b2 <AudioEffectFreeverbStereo_F32::update()+0x7e2>
		if (outblockL) release(outblockL);
		if (outblockR) release(outblockR);
		if (block) release((audio_block_f32_t *)block);
		return;
	}
	if (!block) block = &zeroblock;
    51fe:	ldr	r3, [sp, #88]	; 0x58
    5200:	cmp	r3, #0
    5202:	beq.w	5afe <AudioEffectFreeverbStereo_F32::update()+0x92e>
    5206:	add.w	r3, r4, #44	; 0x2c
    520a:	str	r3, [sp, #164]	; 0xa4
    520c:	movw	r3, #44688	; 0xae90
    5210:	movw	r0, #44692	; 0xae94
    5214:	ldr	r7, [pc, #424]	; (53c0 <AudioEffectFreeverbStereo_F32::update()+0x1f0>)
    5216:	movw	r9, #44680	; 0xae88
    521a:	mov	r5, r0
    521c:	mov	r1, r3
    521e:	movw	r0, #44696	; 0xae98
    5222:	ldr	r3, [pc, #416]	; (53c4 <AudioEffectFreeverbStereo_F32::update()+0x1f4>)
    5224:	adds	r1, r4, r1
    5226:	ldr.w	sl, [pc, #488]	; 5410 <AudioEffectFreeverbStereo_F32::update()+0x240>
    522a:	mov	r6, r0
    522c:	movw	r0, #44700	; 0xae9c
    5230:	str	r1, [sp, #148]	; 0x94
    5232:	adds	r1, r4, r5
    5234:	adds	r5, r4, r6
    5236:	adds	r6, r4, r0
    5238:	mov	r0, r7
    523a:	movw	r7, #44704	; 0xaea0
    523e:	str	r5, [sp, #156]	; 0x9c
    5240:	movw	r5, #44712	; 0xaea8
    5244:	adds	r7, r4, r7
    5246:	str	r1, [sp, #152]	; 0x98
    5248:	str	r6, [sp, #160]	; 0xa0
    524a:	adds	r5, r4, r5
    524c:	str	r7, [sp, #100]	; 0x64
    524e:	movw	r6, #44716	; 0xaeac
    5252:	ldr	r1, [pc, #372]	; (53c8 <AudioEffectFreeverbStereo_F32::update()+0x1f8>)
    5254:	add	r3, r4
    5256:	ldr	r7, [pc, #372]	; (53cc <AudioEffectFreeverbStereo_F32::update()+0x1fc>)
    5258:	adds	r6, r4, r6
    525a:	mov	r2, r1
    525c:	str	r5, [sp, #108]	; 0x6c
    525e:	adds	r7, r4, r7
    5260:	movw	r1, #44708	; 0xaea4
    5264:	ldr	r5, [pc, #360]	; (53d0 <AudioEffectFreeverbStereo_F32::update()+0x200>)
    5266:	add	sl, r4
    5268:	adds	r1, r4, r1
    526a:	str	r6, [sp, #112]	; 0x70
    526c:	str	r7, [sp, #116]	; 0x74
    526e:	adds	r5, r4, r5
    5270:	ldr	r6, [pc, #352]	; (53d4 <AudioEffectFreeverbStereo_F32::update()+0x204>)
    5272:	movw	r8, #44682	; 0xae8a
    5276:	ldr	r7, [pc, #352]	; (53d8 <AudioEffectFreeverbStereo_F32::update()+0x208>)
    5278:	movw	ip, #44684	; 0xae8c
    527c:	str	r1, [sp, #104]	; 0x68
    527e:	adds	r6, r4, r6
    5280:	str	r5, [sp, #124]	; 0x7c
    5282:	adds	r7, r4, r7
    5284:	adds	r5, r4, r0
    5286:	ldr	r1, [pc, #340]	; (53dc <AudioEffectFreeverbStereo_F32::update()+0x20c>)
    5288:	movw	r0, #44672	; 0xae80
    528c:	str	r6, [sp, #128]	; 0x80
    528e:	adds	r1, r4, r1
    5290:	str	r7, [sp, #132]	; 0x84
    5292:	ldr	r6, [pc, #332]	; (53e0 <AudioEffectFreeverbStereo_F32::update()+0x210>)
    5294:	mov	r7, r0
    5296:	movw	r0, #44674	; 0xae82
    529a:	str	r1, [sp, #120]	; 0x78
    529c:	str	r5, [sp, #140]	; 0x8c
    529e:	adds	r1, r4, r6
    52a0:	mov	r5, r0
    52a2:	adds	r6, r4, r2
    52a4:	movw	r0, #44676	; 0xae84
    52a8:	movw	r2, #44678	; 0xae86
    52ac:	str	r6, [sp, #144]	; 0x90
    52ae:	adds	r5, r4, r5
    52b0:	adds	r6, r4, r0
    52b2:	ldr	r0, [pc, #304]	; (53e4 <AudioEffectFreeverbStereo_F32::update()+0x214>)
    52b4:	str	r5, [sp, #20]
    52b6:	adds	r2, r4, r2
    52b8:	adds	r5, r4, r0
    52ba:	adds	r0, #2
    52bc:	str	r2, [sp, #28]
    52be:	adds	r7, r4, r7
    52c0:	str	r5, [sp, #56]	; 0x38
    52c2:	adds	r5, r4, r0
    52c4:	adds	r0, #2
    52c6:	ldr	r2, [pc, #288]	; (53e8 <AudioEffectFreeverbStereo_F32::update()+0x218>)
    52c8:	str	r5, [sp, #60]	; 0x3c
    52ca:	movw	lr, #44686	; 0xae8e
    52ce:	adds	r5, r4, r0
    52d0:	adds	r0, #2
    52d2:	vldr	s13, [r3]
    52d6:	adds	r2, r4, r2
    52d8:	adds	r0, r4, r0
    52da:	ldr	r3, [sp, #148]	; 0x94
    52dc:	str	r1, [sp, #136]	; 0x88
    52de:	add.w	r1, r4, #89600	; 0x15e00
    52e2:	str	r0, [sp, #68]	; 0x44
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
    52e4:	vmov.f64	d4, #96	; 0x3f000000  0.5
    52e8:	ldr	r0, [pc, #256]	; (53ec <AudioEffectFreeverbStereo_F32::update()+0x21c>)
		outputL = (bufout - outputL)/2.0;
    52ea:	vmov.f32	s11, #96	; 0x3f000000  0.5
    52ee:	str	r7, [sp, #16]
    52f0:	add	r9, r4
    52f2:	adds	r0, r4, r0
    52f4:	str	r6, [sp, #24]
    52f6:	str	r5, [sp, #64]	; 0x40
    52f8:	add	r8, r4
    52fa:	str	r0, [sp, #72]	; 0x48
    52fc:	add	ip, r4
    52fe:	ldr	r0, [pc, #240]	; (53f0 <AudioEffectFreeverbStereo_F32::update()+0x220>)
    5300:	add	lr, r4
    5302:	str	r2, [sp, #32]
    5304:	adds	r0, r4, r0
    5306:	vldr	s12, [sl]
    530a:	vldr	s26, [r3]
    530e:	str	r0, [sp, #76]	; 0x4c
    5310:	ldr	r0, [pc, #224]	; (53f4 <AudioEffectFreeverbStereo_F32::update()+0x224>)
    5312:	ldr	r7, [pc, #228]	; (53f8 <AudioEffectFreeverbStereo_F32::update()+0x228>)
    5314:	adds	r0, r4, r0
    5316:	ldr	r6, [pc, #228]	; (53fc <AudioEffectFreeverbStereo_F32::update()+0x22c>)
    5318:	ldr	r5, [pc, #228]	; (5400 <AudioEffectFreeverbStereo_F32::update()+0x230>)
    531a:	add	r7, r4
    531c:	str	r0, [sp, #80]	; 0x50
    531e:	add	r6, r4
    5320:	ldr	r3, [sp, #152]	; 0x98
    5322:	add	r5, r4
    5324:	ldr	r0, [pc, #220]	; (5404 <AudioEffectFreeverbStereo_F32::update()+0x234>)
    5326:	vldr	s25, [r3]
    532a:	ldr	r3, [sp, #156]	; 0x9c
    532c:	adds	r2, r4, r0
    532e:	adds	r0, #2
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
		sum = 0;

		bufout = comb1bufL[comb1indexL];
		sum += bufout;
    5330:	vldr	s27, [pc, #212]	; 5408 <AudioEffectFreeverbStereo_F32::update()+0x238>
    5334:	vldr	s24, [r3]
    5338:	ldr	r3, [sp, #160]	; 0xa0
    533a:	str	r2, [sp, #40]	; 0x28
    533c:	adds	r2, r4, r0
    533e:	vldr	s23, [r3]
    5342:	adds	r0, #2
    5344:	ldr	r3, [sp, #100]	; 0x64
    5346:	str	r2, [sp, #44]	; 0x2c
    5348:	adds	r2, r4, r0
    534a:	vldr	s22, [r3]
    534e:	adds	r0, #2
    5350:	ldr	r3, [sp, #104]	; 0x68
    5352:	str	r2, [sp, #48]	; 0x30
    5354:	adds	r2, r4, r0
    5356:	vldr	s21, [r3]
    535a:	ldr	r3, [sp, #108]	; 0x6c
    535c:	ldr	r0, [pc, #172]	; (540c <AudioEffectFreeverbStereo_F32::update()+0x23c>)
    535e:	vldr	s20, [r3]
    5362:	ldr	r3, [sp, #112]	; 0x70
    5364:	adds	r0, r4, r0
    5366:	str	r2, [sp, #52]	; 0x34
    5368:	vldr	s19, [r3]
    536c:	ldr	r3, [sp, #116]	; 0x74
    536e:	ldr	r2, [sp, #88]	; 0x58
    5370:	vldr	s18, [r3]
    5374:	ldr	r3, [sp, #120]	; 0x78
    5376:	str	r0, [sp, #36]	; 0x24
    5378:	mov	r0, r2
    537a:	vldr	s0, [r3]
    537e:	add.w	r2, r2, #516	; 0x204
    5382:	ldr	r3, [sp, #124]	; 0x7c
    5384:	adds	r0, #4
    5386:	vldr	s1, [r3]
    538a:	ldr	r3, [sp, #96]	; 0x60
    538c:	adds	r3, #4
    538e:	str	r3, [sp, #8]
    5390:	ldr	r3, [sp, #128]	; 0x80
    5392:	vldr	s2, [r3]
    5396:	ldr	r3, [sp, #92]	; 0x5c
    5398:	adds	r3, #4
    539a:	str	r3, [sp, #12]
    539c:	ldr	r3, [sp, #132]	; 0x84
    539e:	str	r2, [sp, #84]	; 0x54
    53a0:	vldr	s3, [r3]
    53a4:	ldr	r3, [sp, #136]	; 0x88
    53a6:	ldr	r2, [sp, #144]	; 0x90
    53a8:	vldr	s4, [r3]
    53ac:	ldr	r3, [sp, #140]	; 0x8c
    53ae:	vldr	s10, [r2]
    53b2:	vldr	s5, [r3]
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    53b6:	movs	r3, #0
    53b8:	vldr	s14, [r1]

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;
    53bc:	str	r0, [sp, #4]
    53be:	b.n	5972 <AudioEffectFreeverbStereo_F32::update()+0x7a2>
    53c0:	.word	0x00015df8
    53c4:	.word	0x00015e08
    53c8:	.word	0x00015dfc
    53cc:	.word	0x00015de0
    53d0:	.word	0x00015de8
    53d4:	.word	0x00015dec
    53d8:	.word	0x00015df0
    53dc:	.word	0x00015de4
    53e0:	.word	0x00015df4
    53e4:	.word	0x00015dd0
    53e8:	.word	0x00015dde
    53ec:	.word	0x00015dd8
    53f0:	.word	0x00015dda
    53f4:	.word	0x00015ddc
    53f8:	.word	0x0001905c
    53fc:	.word	0x0001905e
    5400:	.word	0x00019060
    5404:	.word	0x00017678
    5408:	.word	0x00000000
    540c:	.word	0x00019062
    5410:	.word	0x00015e04

		bufout = comb1bufL[comb1indexL];
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    5414:	ldr	r1, [sp, #16]
    5416:	strh	r2, [r1, #0]

		bufout = comb2bufL[comb2indexL];
    5418:	ldr	r2, [sp, #20]
    541a:	movw	r1, #5040	; 0x13b0
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
    541e:	vmul.f32	s25, s25, s14
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;
    5422:	movw	r0, #1187	; 0x4a3
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;

		bufout = comb2bufL[comb2indexL];
    5426:	ldrh	r2, [r2, #0]
    5428:	add.w	sl, r4, r2, lsl #2
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;
    542c:	adds	r2, #1
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;

		bufout = comb2bufL[comb2indexL];
    542e:	add	r1, sl
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;
    5430:	uxth	r2, r2
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;

		bufout = comb2bufL[comb2indexL];
    5432:	vldr	s15, [r1]
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;
    5436:	cmp	r2, r0
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;

		bufout = comb2bufL[comb2indexL];
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
    5438:	vfma.f32	s25, s15, s12
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;

		bufout = comb2bufL[comb2indexL];
		sum += bufout;
    543c:	vadd.f32	s28, s28, s15
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
    5440:	vmov.f32	s15, s7
    5444:	vfma.f32	s15, s25, s13
    5448:	vstr	s15, [r1]
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;
    544c:	bhi.w	5af8 <AudioEffectFreeverbStereo_F32::update()+0x928>
    5450:	ldr	r1, [sp, #20]
    5452:	strh	r2, [r1, #0]

		bufout = comb3bufL[comb3indexL];
    5454:	ldr	r2, [sp, #24]
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
    5456:	vmul.f32	s24, s24, s14
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;
    545a:	movw	r0, #1276	; 0x4fc
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;

		bufout = comb3bufL[comb3indexL];
    545e:	ldrh	r2, [r2, #0]
    5460:	add.w	r1, r4, r2, lsl #2
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;
    5464:	adds	r2, #1
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;

		bufout = comb3bufL[comb3indexL];
    5466:	add.w	r1, r1, #9792	; 0x2640
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;
    546a:	uxth	r2, r2
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;

		bufout = comb3bufL[comb3indexL];
    546c:	vldr	s15, [r1]
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;
    5470:	cmp	r2, r0
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;

		bufout = comb3bufL[comb3indexL];
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
    5472:	vfma.f32	s24, s15, s12
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;

		bufout = comb3bufL[comb3indexL];
		sum += bufout;
    5476:	vadd.f32	s28, s28, s15
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
    547a:	vmov.f32	s15, s7
    547e:	vfma.f32	s15, s24, s13
    5482:	vstr	s15, [r1]
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;
    5486:	bhi.w	5af2 <AudioEffectFreeverbStereo_F32::update()+0x922>
    548a:	ldr	r1, [sp, #24]
    548c:	strh	r2, [r1, #0]

		bufout = comb4bufL[comb4indexL];
    548e:	ldr	r2, [sp, #28]
    5490:	movw	r1, #14900	; 0x3a34
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
    5494:	vmul.f32	s23, s23, s14
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;
    5498:	movw	r0, #1355	; 0x54b
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;

		bufout = comb4bufL[comb4indexL];
    549c:	ldrh	r2, [r2, #0]
    549e:	add.w	sl, r4, r2, lsl #2
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;
    54a2:	adds	r2, #1
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;

		bufout = comb4bufL[comb4indexL];
    54a4:	add	r1, sl
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;
    54a6:	uxth	r2, r2
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;

		bufout = comb4bufL[comb4indexL];
    54a8:	vldr	s15, [r1]
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;
    54ac:	cmp	r2, r0
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;

		bufout = comb4bufL[comb4indexL];
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
    54ae:	vfma.f32	s23, s15, s12
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;

		bufout = comb4bufL[comb4indexL];
		sum += bufout;
    54b2:	vadd.f32	s28, s28, s15
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
    54b6:	vmov.f32	s15, s7
    54ba:	vfma.f32	s15, s23, s13
    54be:	vstr	s15, [r1]
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;
    54c2:	bhi.w	5aec <AudioEffectFreeverbStereo_F32::update()+0x91c>
    54c6:	ldr	r1, [sp, #28]
    54c8:	strh	r2, [r1, #0]

		bufout = comb5bufL[comb5indexL];
    54ca:	ldrh.w	r2, [r9]
    54ce:	movw	r1, #20324	; 0x4f64
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
    54d2:	vmul.f32	s22, s22, s14
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;

		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
    54d6:	ldr	r0, [sp, #56]	; 0x38
    54d8:	add.w	sl, r4, r2, lsl #2

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;
    54dc:	adds	r2, #1

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
    54de:	vmul.f32	s21, s21, s14
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;

		bufout = comb5bufL[comb5indexL];
    54e2:	add	r1, sl
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;
    54e4:	uxth	r2, r2

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;
    54e6:	movw	sl, #1490	; 0x5d2

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
    54ea:	vmul.f32	s20, s20, s14
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;

		bufout = comb5bufL[comb5indexL];
    54ee:	vldr	s15, [r1]
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
    54f2:	vmov.f32	s6, s7
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;

		bufout = comb8bufL[comb8indexL];
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
    54f6:	vmul.f32	s19, s19, s14
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
    54fa:	vfma.f32	s22, s15, s12
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
    54fe:	vadd.f32	s28, s28, s15
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
    5502:	vmov.f32	s15, s7
		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
    5506:	vmul.f32	s18, s18, s14
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
    550a:	vfma.f32	s15, s22, s13
    550e:	vstr	s15, [r1]
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;
    5512:	movw	r1, #1421	; 0x58d
    5516:	cmp	r2, r1

		bufout = comb6bufL[comb6indexL];
    5518:	movw	r1, #26012	; 0x659c

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;
    551c:	it	ls
    551e:	strhls.w	r2, [r9]

		bufout = comb6bufL[comb6indexL];
    5522:	ldrh.w	r2, [r8]

		bufout = comb5bufL[comb5indexL];
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;
    5526:	it	hi
    5528:	strhhi.w	r3, [r9]
    552c:	add.w	fp, r4, r2, lsl #2

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;
    5530:	adds	r2, #1
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;

		bufout = comb6bufL[comb6indexL];
    5532:	add	r1, fp
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;
    5534:	uxth	r2, r2
		sum += bufout;
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;

		bufout = comb6bufL[comb6indexL];
    5536:	vldr	s15, [r1]
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;
    553a:	cmp	r2, sl

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;
    553c:	movw	sl, #1556	; 0x614
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
    5540:	vfma.f32	s21, s15, s12
		comb5filterL = bufout * combdamp2 + comb5filterL * combdamp1;
		comb5bufL[comb5indexL] = input + comb5filterL * combfeeback;
		if (++comb5indexL >= sizeof(comb5bufL)/sizeof(float)) comb5indexL = 0;

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
    5544:	vadd.f32	s28, s28, s15
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
    5548:	vmov.f32	s15, s7
    554c:	vfma.f32	s15, s21, s13
    5550:	vstr	s15, [r1]
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;

		bufout = comb7bufL[comb7indexL];
    5554:	movw	r1, #31976	; 0x7ce8

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;
    5558:	it	ls
    555a:	strhls.w	r2, [r8]

		bufout = comb7bufL[comb7indexL];
    555e:	ldrh.w	r2, [ip]

		bufout = comb6bufL[comb6indexL];
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;
    5562:	it	hi
    5564:	strhhi.w	r3, [r8]
    5568:	add.w	fp, r4, r2, lsl #2

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;
    556c:	adds	r2, #1
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;

		bufout = comb7bufL[comb7indexL];
    556e:	add	r1, fp
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;
    5570:	uxth	r2, r2
		sum += bufout;
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;

		bufout = comb7bufL[comb7indexL];
    5572:	vldr	s15, [r1]
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;
    5576:	cmp	r2, sl
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
    5578:	vfma.f32	s20, s15, s12
		comb6filterL = bufout * combdamp2 + comb6filterL * combdamp1;
		comb6bufL[comb6indexL] = input + comb6filterL * combfeeback;
		if (++comb6indexL >= sizeof(comb6bufL)/sizeof(float)) comb6indexL = 0;

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
    557c:	vadd.f32	s15, s28, s15
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
    5580:	vfma.f32	s6, s20, s13
    5584:	vstr	s6, [r1]
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;

		bufout = comb8bufL[comb8indexL];
    5588:	movw	r1, #38204	; 0x953c

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;
    558c:	it	ls
    558e:	strhls.w	r2, [ip]

		bufout = comb8bufL[comb8indexL];
    5592:	ldrh.w	r2, [lr]

		bufout = comb7bufL[comb7indexL];
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;
    5596:	it	hi
    5598:	strhhi.w	r3, [ip]
    559c:	add.w	sl, r4, r2, lsl #2

		bufout = comb8bufL[comb8indexL];
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
		comb8bufL[comb8indexL] = input + comb8filterL * combfeeback;
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;
    55a0:	adds	r2, #1
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;

		bufout = comb8bufL[comb8indexL];
    55a2:	add	r1, sl
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
		comb8bufL[comb8indexL] = input + comb8filterL * combfeeback;
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;
    55a4:	uxth	r2, r2

		bufout = comb1bufR[comb1indexR];
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;
    55a6:	movw	sl, #1138	; 0x472
		sum += bufout;
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;

		bufout = comb8bufL[comb8indexL];
    55aa:	vldr	s28, [r1]
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
		comb8bufL[comb8indexL] = input + comb8filterL * combfeeback;
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;
    55ae:	cmp.w	r2, #1616	; 0x650
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;

		bufout = comb8bufL[comb8indexL];
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
    55b2:	vfma.f32	s19, s28, s12
		comb7filterL = bufout * combdamp2 + comb7filterL * combdamp1;
		comb7bufL[comb7indexL] = input + comb7filterL * combfeeback;
		if (++comb7indexL >= sizeof(comb7bufL)/sizeof(float)) comb7indexL = 0;

		bufout = comb8bufL[comb8indexL];
		sum += bufout;
    55b6:	vadd.f32	s28, s15, s28
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
		comb8bufL[comb8indexL] = input + comb8filterL * combfeeback;
    55ba:	vmov.f32	s15, s7
    55be:	vfma.f32	s15, s19, s13
    55c2:	vstr	s15, [r1]
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;

		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
    55c6:	movw	r1, #44720	; 0xaeb0

		bufout = comb8bufL[comb8indexL];
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
		comb8bufL[comb8indexL] = input + comb8filterL * combfeeback;
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;
    55ca:	it	ls
    55cc:	strhls.w	r2, [lr]

		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
    55d0:	ldrh	r2, [r0, #0]

		bufout = comb8bufL[comb8indexL];
		sum += bufout;
		comb8filterL = bufout * combdamp2 + comb8filterL * combdamp1;
		comb8bufL[comb8indexL] = input + comb8filterL * combfeeback;
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;
    55d2:	it	hi
    55d4:	strhhi.w	r3, [lr]
    55d8:	add.w	fp, r4, r2, lsl #2

		bufout = comb1bufR[comb1indexR];
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;
    55dc:	adds	r2, #1
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;

		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
    55de:	add	r1, fp
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;
    55e0:	uxth	r2, r2
		if (++comb8indexL >= sizeof(comb8bufL)/sizeof(float)) comb8indexL = 0;

		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
    55e2:	vldr	s15, [r1]
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;
    55e6:	cmp	r2, sl
		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
    55e8:	vfma.f32	s18, s15, s12

		outputL = sum;
		sum = 0.0;

		bufout = comb1bufR[comb1indexR];
		sum += bufout;
    55ec:	vadd.f32	s6, s15, s27
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
    55f0:	vmov.f32	s15, s7
    55f4:	vfma.f32	s15, s18, s13
    55f8:	vstr	s15, [r1]
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;
    55fc:	bhi.w	5ae6 <AudioEffectFreeverbStereo_F32::update()+0x916>
    5600:	strh	r2, [r0, #0]

		bufout = comb2bufR[comb2indexR];
    5602:	ldr	r0, [sp, #60]	; 0x3c
    5604:	movw	r1, #49276	; 0xc07c
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
    5608:	vmul.f32	s0, s0, s14
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;
    560c:	movw	sl, #1210	; 0x4ba
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;

		bufout = comb2bufR[comb2indexR];
    5610:	ldrh	r2, [r0, #0]
    5612:	add.w	fp, r4, r2, lsl #2
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;
    5616:	adds	r2, #1
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;

		bufout = comb2bufR[comb2indexR];
    5618:	add	r1, fp
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;
    561a:	uxth	r2, r2
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;

		bufout = comb2bufR[comb2indexR];
    561c:	vldr	s15, [r1]
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;
    5620:	cmp	r2, sl
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;

		bufout = comb2bufR[comb2indexR];
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
    5622:	vfma.f32	s0, s15, s12
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;

		bufout = comb2bufR[comb2indexR];
		sum += bufout;
    5626:	vadd.f32	s6, s6, s15
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
    562a:	vmov.f32	s15, s7
    562e:	vfma.f32	s15, s0, s13
    5632:	vstr	s15, [r1]
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;
    5636:	bhi.w	5ae0 <AudioEffectFreeverbStereo_F32::update()+0x910>
    563a:	strh	r2, [r0, #0]

		bufout = comb3bufR[comb3indexR];
    563c:	ldr	r0, [sp, #64]	; 0x40
    563e:	movw	r1, #54120	; 0xd368
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
    5642:	vmul.f32	s1, s1, s14
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;
    5646:	movw	sl, #1299	; 0x513
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;

		bufout = comb3bufR[comb3indexR];
    564a:	ldrh	r2, [r0, #0]
    564c:	add.w	fp, r4, r2, lsl #2
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;
    5650:	adds	r2, #1
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;

		bufout = comb3bufR[comb3indexR];
    5652:	add	r1, fp
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;
    5654:	uxth	r2, r2
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;

		bufout = comb3bufR[comb3indexR];
    5656:	vldr	s15, [r1]
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;
    565a:	cmp	r2, sl
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;

		bufout = comb3bufR[comb3indexR];
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
    565c:	vfma.f32	s1, s15, s12
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;

		bufout = comb3bufR[comb3indexR];
		sum += bufout;
    5660:	vadd.f32	s6, s6, s15
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
    5664:	vmov.f32	s15, s7
    5668:	vfma.f32	s15, s1, s13
    566c:	vstr	s15, [r1]
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;
    5670:	bhi.w	5ada <AudioEffectFreeverbStereo_F32::update()+0x90a>
    5674:	strh	r2, [r0, #0]

		bufout = comb4bufR[comb4indexR];
    5676:	ldr	r0, [sp, #68]	; 0x44
    5678:	movw	r1, #59320	; 0xe7b8
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
    567c:	vmul.f32	s2, s2, s14
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;
    5680:	movw	sl, #1378	; 0x562
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;

		bufout = comb4bufR[comb4indexR];
    5684:	ldrh	r2, [r0, #0]
    5686:	add.w	fp, r4, r2, lsl #2
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;
    568a:	adds	r2, #1
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;

		bufout = comb4bufR[comb4indexR];
    568c:	add	r1, fp
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;
    568e:	uxth	r2, r2
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;

		bufout = comb4bufR[comb4indexR];
    5690:	vldr	s15, [r1]
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;
    5694:	cmp	r2, sl
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;

		bufout = comb4bufR[comb4indexR];
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
    5696:	vfma.f32	s2, s15, s12
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;

		bufout = comb4bufR[comb4indexR];
		sum += bufout;
    569a:	vadd.f32	s6, s6, s15
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
    569e:	vmov.f32	s15, s7
    56a2:	vfma.f32	s15, s2, s13
    56a6:	vstr	s15, [r1]
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;
    56aa:	bhi.w	5ad4 <AudioEffectFreeverbStereo_F32::update()+0x904>
    56ae:	strh	r2, [r0, #0]

		bufout = comb5bufR[comb5indexR];
    56b0:	ldr	r0, [sp, #72]	; 0x48
    56b2:	movw	r1, #64836	; 0xfd44
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
    56b6:	vmul.f32	s3, s3, s14
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;
    56ba:	movw	sl, #1444	; 0x5a4
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;

		bufout = comb5bufR[comb5indexR];
    56be:	ldrh	r2, [r0, #0]
    56c0:	add.w	fp, r4, r2, lsl #2
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;
    56c4:	adds	r2, #1
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;

		bufout = comb5bufR[comb5indexR];
    56c6:	add	r1, fp
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;
    56c8:	uxth	r2, r2
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;

		bufout = comb5bufR[comb5indexR];
    56ca:	vldr	s15, [r1]
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;
    56ce:	cmp	r2, sl
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;

		bufout = comb5bufR[comb5indexR];
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
    56d0:	vfma.f32	s3, s15, s12
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;

		bufout = comb5bufR[comb5indexR];
		sum += bufout;
    56d4:	vadd.f32	s6, s6, s15
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
    56d8:	vmov.f32	s15, s7
    56dc:	vfma.f32	s15, s3, s13
    56e0:	vstr	s15, [r1]
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;
    56e4:	bhi.w	5ace <AudioEffectFreeverbStereo_F32::update()+0x8fe>
    56e8:	strh	r2, [r0, #0]

		bufout = comb6bufR[comb6indexR];
    56ea:	ldr	r0, [sp, #76]	; 0x4c
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
    56ec:	vmul.f32	s4, s4, s14
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;

		bufout = comb6bufR[comb6indexR];
    56f0:	ldr	r1, [pc, #744]	; (59dc <AudioEffectFreeverbStereo_F32::update()+0x80c>)
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;
    56f2:	movw	sl, #1513	; 0x5e9
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;

		bufout = comb6bufR[comb6indexR];
    56f6:	ldrh	r2, [r0, #0]
    56f8:	add.w	fp, r4, r2, lsl #2
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;
    56fc:	adds	r2, #1
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;

		bufout = comb6bufR[comb6indexR];
    56fe:	add	r1, fp
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;
    5700:	uxth	r2, r2
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;

		bufout = comb6bufR[comb6indexR];
    5702:	vldr	s15, [r1]
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;
    5706:	cmp	r2, sl
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;

		bufout = comb6bufR[comb6indexR];
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
    5708:	vfma.f32	s4, s15, s12
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;

		bufout = comb6bufR[comb6indexR];
		sum += bufout;
    570c:	vadd.f32	s6, s6, s15
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
    5710:	vmov.f32	s15, s7
    5714:	vfma.f32	s15, s4, s13
    5718:	vstr	s15, [r1]
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;
    571c:	bhi.w	5ac8 <AudioEffectFreeverbStereo_F32::update()+0x8f8>
    5720:	strh	r2, [r0, #0]

		bufout = comb7bufR[comb7indexR];
    5722:	ldr	r0, [sp, #80]	; 0x50
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
    5724:	vmul.f32	s5, s5, s14
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;

		bufout = comb7bufR[comb7indexR];
    5728:	ldr	r1, [pc, #692]	; (59e0 <AudioEffectFreeverbStereo_F32::update()+0x810>)
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;
    572a:	movw	sl, #1579	; 0x62b
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;

		bufout = comb7bufR[comb7indexR];
    572e:	ldrh	r2, [r0, #0]
    5730:	add.w	fp, r4, r2, lsl #2
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;
    5734:	adds	r2, #1
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;

		bufout = comb7bufR[comb7indexR];
    5736:	add	r1, fp
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;
    5738:	uxth	r2, r2
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;

		bufout = comb7bufR[comb7indexR];
    573a:	vldr	s15, [r1]
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;
    573e:	cmp	r2, sl
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;

		bufout = comb7bufR[comb7indexR];
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
    5740:	vfma.f32	s5, s15, s12
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;

		bufout = comb7bufR[comb7indexR];
		sum += bufout;
    5744:	vadd.f32	s15, s6, s15
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
    5748:	vmov.f32	s6, s7
    574c:	vfma.f32	s6, s5, s13
    5750:	vstr	s6, [r1]
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;
    5754:	bhi.w	5ac2 <AudioEffectFreeverbStereo_F32::update()+0x8f2>
    5758:	strh	r2, [r0, #0]

		bufout = comb8bufR[comb8indexR];
    575a:	ldr	r0, [sp, #32]
		sum += bufout;
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
    575c:	vmul.f32	s10, s10, s14
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;

		bufout = comb8bufR[comb8indexR];
    5760:	ldr	r1, [pc, #640]	; (59e4 <AudioEffectFreeverbStereo_F32::update()+0x814>)
    5762:	ldrh	r2, [r0, #0]
    5764:	add.w	sl, r4, r2, lsl #2
		sum += bufout;
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;
    5768:	adds	r2, #1
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;

		bufout = comb8bufR[comb8indexR];
    576a:	add	r1, sl
		sum += bufout;
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;
    576c:	uxth	r2, r2
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;

		bufout = comb8bufR[comb8indexR];
    576e:	vldr	s6, [r1]
		sum += bufout;
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;
    5772:	cmp.w	r2, #1640	; 0x668
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;

		bufout = comb8bufR[comb8indexR];
		sum += bufout;
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
    5776:	vfma.f32	s10, s6, s12
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;

		bufout = comb8bufR[comb8indexR];
		sum += bufout;
    577a:	vadd.f32	s15, s15, s6
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
    577e:	vfma.f32	s7, s10, s13
    5782:	vstr	s7, [r1]
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;
    5786:	bcs.w	5abc <AudioEffectFreeverbStereo_F32::update()+0x8ec>
    578a:	strh	r2, [r0, #0]

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
    578c:	ldr	r0, [sp, #40]	; 0x28
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
    578e:	vcvt.f64.f32	d3, s28
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
    5792:	ldr	r1, [pc, #596]	; (59e8 <AudioEffectFreeverbStereo_F32::update()+0x818>)
    5794:	ldrh	r2, [r0, #0]
    5796:	add.w	sl, r4, r2, lsl #2
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;
    579a:	adds	r2, #1
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
    579c:	add	r1, sl
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;
    579e:	uxth	r2, r2
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
    57a0:	vldr	s29, [r1]
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;
    57a4:	cmp.w	r2, #556	; 0x22c
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
    57a8:	vcvt.f64.f32	d8, s29
		outputL = (bufout - outputL)/2.0;
    57ac:	vsub.f32	s28, s29, s28
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
    57b0:	vfma.f64	d3, d8, d4
		outputL = (bufout - outputL)/2.0;
    57b4:	vmul.f32	s28, s28, s11
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;

		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
    57b8:	vcvt.f32.f64	s6, d3
    57bc:	vstr	s6, [r1]
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;
    57c0:	bcs.w	5ab6 <AudioEffectFreeverbStereo_F32::update()+0x8e6>
    57c4:	strh	r2, [r0, #0]

		bufout = allpass2bufL[allpass2indexL];
    57c6:	ldr	r0, [sp, #44]	; 0x2c
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
    57c8:	vcvt.f64.f32	d8, s28
		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
    57cc:	ldr	r1, [pc, #540]	; (59ec <AudioEffectFreeverbStereo_F32::update()+0x81c>)
    57ce:	ldrh	r2, [r0, #0]
    57d0:	add.w	sl, r4, r2, lsl #2
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;
    57d4:	adds	r2, #1
		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
    57d6:	add	r1, sl
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;
    57d8:	uxth	r2, r2
		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
    57da:	vldr	s29, [r1]
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;
    57de:	cmp.w	r2, #440	; 0x1b8
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
    57e2:	vcvt.f64.f32	d3, s29
		outputL = (bufout - outputL)/2.0;
    57e6:	vsub.f32	s28, s29, s28
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
    57ea:	vfma.f64	d8, d3, d4
		outputL = (bufout - outputL)/2.0;
    57ee:	vmul.f32	s28, s28, s11
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
    57f2:	vcvt.f32.f64	s16, d8
    57f6:	vstr	s16, [r1]
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;
    57fa:	bhi.w	5ab0 <AudioEffectFreeverbStereo_F32::update()+0x8e0>
    57fe:	strh	r2, [r0, #0]

		bufout = allpass3bufL[allpass3indexL];
    5800:	ldr	r0, [sp, #48]	; 0x30
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
    5802:	vcvt.f64.f32	d8, s28
		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
    5806:	ldr	r1, [pc, #488]	; (59f0 <AudioEffectFreeverbStereo_F32::update()+0x820>)
    5808:	ldrh	r2, [r0, #0]
    580a:	add.w	sl, r4, r2, lsl #2
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;
    580e:	adds	r2, #1
		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
    5810:	add	r1, sl
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;
    5812:	uxth	r2, r2
		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
    5814:	vldr	s29, [r1]
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;
    5818:	cmp.w	r2, #340	; 0x154
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
    581c:	vcvt.f64.f32	d3, s29
		outputL = (bufout - outputL)/2.0;
    5820:	vsub.f32	s28, s29, s28
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
    5824:	vfma.f64	d8, d3, d4
		outputL = (bufout - outputL)/2.0;
    5828:	vmul.f32	s28, s28, s11
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
    582c:	vcvt.f32.f64	s16, d8
    5830:	vstr	s16, [r1]
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;
    5834:	bhi.w	5aaa <AudioEffectFreeverbStereo_F32::update()+0x8da>
    5838:	strh	r2, [r0, #0]

		bufout = allpass4bufL[allpass4indexL];
    583a:	ldr	r0, [sp, #52]	; 0x34
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
    583c:	vcvt.f64.f32	d8, s28
		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
    5840:	ldr	r1, [pc, #432]	; (59f4 <AudioEffectFreeverbStereo_F32::update()+0x824>)
    5842:	ldrh	r2, [r0, #0]
    5844:	add.w	sl, r4, r2, lsl #2
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;
    5848:	adds	r2, #1
		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
    584a:	add	r1, sl
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;
    584c:	uxth	r2, r2
		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
    584e:	vldr	s29, [r1]
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;
    5852:	cmp	r2, #224	; 0xe0
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
    5854:	vcvt.f64.f32	d3, s29
		outputL = (bufout - outputL)/2.0;
    5858:	vsub.f32	s28, s29, s28
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
    585c:	vfma.f64	d8, d3, d4
		outputL = (bufout - outputL)/2.0;
    5860:	vmul.f32	s28, s28, s11
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
    5864:	vcvt.f32.f64	s16, d8
    5868:	vstr	s16, [r1]
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;
    586c:	bhi.w	5aa4 <AudioEffectFreeverbStereo_F32::update()+0x8d4>
    5870:	strh	r2, [r0, #0]

		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
    5872:	ldrh	r2, [r7, #0]
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
    5874:	vcvt.f64.f32	d8, s15
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
    5878:	ldr	r1, [pc, #380]	; (59f8 <AudioEffectFreeverbStereo_F32::update()+0x828>)
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;
    587a:	movw	sl, #578	; 0x242
    587e:	add.w	fp, r4, r2, lsl #2
		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;
    5882:	ldr	r0, [sp, #12]

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;
    5884:	adds	r2, #1
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
    5886:	add	r1, fp
		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;
    5888:	vstmia	r0!, {s28}

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;
    588c:	uxth	r2, r2
		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;
    588e:	str	r0, [sp, #12]

		bufout = allpass1bufR[allpass1indexR];
    5890:	vldr	s28, [r1]
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;
    5894:	cmp	r2, sl
		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
    5896:	ldr	r0, [sp, #36]	; 0x24
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
    5898:	vcvt.f64.f32	d3, s28
		outputR = (bufout - outputR)/2.0;
    589c:	vsub.f32	s15, s28, s15
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
    58a0:	vfma.f64	d8, d3, d4
		outputR = (bufout - outputR)/2.0;
    58a4:	vmul.f32	s15, s15, s11
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;

		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
    58a8:	vcvt.f32.f64	s16, d8
    58ac:	vstr	s16, [r1]
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
    58b0:	vcvt.f64.f32	d8, s15
		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;
    58b4:	it	ls
    58b6:	strhls	r2, [r7, #0]

		bufout = allpass2bufR[allpass2indexR];
    58b8:	ldrh	r2, [r6, #0]
    58ba:	ldr	r1, [pc, #320]	; (59fc <AudioEffectFreeverbStereo_F32::update()+0x82c>)
    58bc:	add.w	sl, r4, r2, lsl #2
		outblockL->data[i] = outputL;

		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;
    58c0:	it	hi
    58c2:	strhhi	r3, [r7, #0]

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;
    58c4:	adds	r2, #1
		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
    58c6:	add	r1, sl
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;
    58c8:	uxth	r2, r2
		bufout = allpass1bufR[allpass1indexR];
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
    58ca:	vldr	s28, [r1]
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;
    58ce:	cmp.w	r2, #464	; 0x1d0
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
    58d2:	vcvt.f64.f32	d3, s28
		outputR = (bufout - outputR)/2.0;
    58d6:	vsub.f32	s15, s28, s15
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
    58da:	vfma.f64	d8, d3, d4
		outputR = (bufout - outputR)/2.0;
    58de:	vmul.f32	s15, s15, s11
		allpass1bufR[allpass1indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
    58e2:	vcvt.f32.f64	s16, d8
    58e6:	vstr	s16, [r1]
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
    58ea:	vcvt.f64.f32	d8, s15
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;
    58ee:	it	cc
    58f0:	strhcc	r2, [r6, #0]

		bufout = allpass3bufR[allpass3indexR];
    58f2:	ldrh	r2, [r5, #0]
    58f4:	ldr	r1, [pc, #264]	; (5a00 <AudioEffectFreeverbStereo_F32::update()+0x830>)
    58f6:	add.w	sl, r4, r2, lsl #2
		if (++allpass1indexR >= sizeof(allpass1bufR)/sizeof(float)) allpass1indexR = 0;

		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;
    58fa:	it	cs
    58fc:	strhcs	r3, [r6, #0]

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;
    58fe:	adds	r2, #1
		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
    5900:	add	r1, sl
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;
    5902:	uxth	r2, r2
		bufout = allpass2bufR[allpass2indexR];
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
    5904:	vldr	s28, [r1]
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;
    5908:	cmp.w	r2, #364	; 0x16c
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
    590c:	vcvt.f64.f32	d3, s28
		outputR = (bufout - outputR)/2.0;
    5910:	vsub.f32	s15, s28, s15
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
    5914:	vfma.f64	d8, d3, d4
		outputR = (bufout - outputR)/2.0;
    5918:	vmul.f32	s15, s15, s11
		allpass2bufR[allpass2indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
    591c:	vcvt.f32.f64	s16, d8
    5920:	vstr	s16, [r1]
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
    5924:	vcvt.f64.f32	d8, s15
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;
    5928:	it	cc
    592a:	strhcc	r2, [r5, #0]

		bufout = allpass4bufR[allpass4indexR];
    592c:	ldrh	r2, [r0, #0]
    592e:	ldr	r1, [pc, #212]	; (5a04 <AudioEffectFreeverbStereo_F32::update()+0x834>)
    5930:	add.w	sl, r4, r2, lsl #2
		if (++allpass2indexR >= sizeof(allpass2bufR)/sizeof(float)) allpass2indexR = 0;

		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;
    5934:	it	cs
    5936:	strhcs	r3, [r5, #0]

		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;
    5938:	adds	r2, #1
		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
    593a:	add	r1, sl
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;
    593c:	uxth	r2, r2
		bufout = allpass3bufR[allpass3indexR];
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
    593e:	vldr	s28, [r1]
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;
    5942:	cmp	r2, #247	; 0xf7
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
    5944:	vcvt.f64.f32	d3, s28
		outputR = (bufout - outputR)/2.0;
    5948:	vsub.f32	s15, s28, s15
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
    594c:	vfma.f64	d8, d3, d4
		outputR = (bufout - outputR)/2.0;
    5950:	vmul.f32	s15, s15, s11
		allpass3bufR[allpass3indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
    5954:	vcvt.f32.f64	s16, d8
    5958:	vstr	s16, [r1]
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;
    595c:	bhi.w	5a9e <AudioEffectFreeverbStereo_F32::update()+0x8ce>
    5960:	strh	r2, [r0, #0]

		outblockR->data[i] = outputR;
    5962:	ldr	r2, [sp, #8]
		if (block) release((audio_block_f32_t *)block);
		return;
	}
	if (!block) block = &zeroblock;

	for (i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
    5964:	ldr	r1, [sp, #4]
		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;

		outblockR->data[i] = outputR;
    5966:	vstmia	r2!, {s15}
    596a:	str	r2, [sp, #8]
		if (block) release((audio_block_f32_t *)block);
		return;
	}
	if (!block) block = &zeroblock;

	for (i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
    596c:	ldr	r2, [sp, #84]	; 0x54
    596e:	cmp	r1, r2
    5970:	beq.n	5a08 <AudioEffectFreeverbStereo_F32::update()+0x838>
		// TODO: scale numerical range depending on roomsize & damping
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
    5972:	ldr	r1, [sp, #4]
		sum = 0;

		bufout = comb1bufL[comb1indexL];
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
    5974:	vmul.f32	s26, s26, s14
		// TODO: scale numerical range depending on roomsize & damping
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
		sum = 0;

		bufout = comb1bufL[comb1indexL];
    5978:	ldr	r2, [sp, #16]
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    597a:	movw	r0, #1115	; 0x45b
	if (!block) block = &zeroblock;

	for (i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
		// TODO: scale numerical range depending on roomsize & damping
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
    597e:	vldmia	r1!, {s7}
		sum = 0;

		bufout = comb1bufL[comb1indexL];
    5982:	ldrh	r2, [r2, #0]
	if (!block) block = &zeroblock;

	for (i=0; i < AUDIO_BLOCK_SAMPLES; i++) {
		// TODO: scale numerical range depending on roomsize & damping
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
    5984:	str	r1, [sp, #4]
    5986:	add.w	r1, r4, r2, lsl #2

		bufout = comb1bufL[comb1indexL];
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    598a:	adds	r2, #1
		// TODO: scale numerical range depending on roomsize & damping
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
		sum = 0;

		bufout = comb1bufL[comb1indexL];
    598c:	vldr	s15, [r1, #576]	; 0x240
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    5990:	uxth	r2, r2
		input = block->data[i]; 
		sum = 0;

		bufout = comb1bufL[comb1indexL];
		sum += bufout;
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
    5992:	vfma.f32	s26, s15, s12
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    5996:	cmp	r2, r0
		//input = sat16(block->data[i] * 8738.0, 17); // for numerical headroom
		input = block->data[i]; 
		sum = 0;

		bufout = comb1bufL[comb1indexL];
		sum += bufout;
    5998:	vadd.f32	s28, s15, s27
		comb1filterL = bufout * combdamp2 + comb1filterL * combdamp1;
		comb1bufL[comb1indexL] = input + comb1filterL * combfeeback;
    599c:	vmov.f32	s15, s7
    59a0:	vfma.f32	s15, s26, s13
    59a4:	vstr	s15, [r1, #576]	; 0x240
		if (++comb1indexL >= sizeof(comb1bufL)/sizeof(float)) comb1indexL = 0;
    59a8:	bls.w	5414 <AudioEffectFreeverbStereo_F32::update()+0x244>
    59ac:	ldr	r2, [sp, #16]
    59ae:	strh	r3, [r2, #0]
    59b0:	b.n	5418 <AudioEffectFreeverbStereo_F32::update()+0x248>

	block = receiveReadOnly_f32(0);
	outblockL = allocate_f32();
	outblockR = allocate_f32();
	if (!outblockL || !outblockR) {
		if (outblockL) release(outblockL);
    59b2:	ldr	r3, [sp, #92]	; 0x5c
    59b4:	cbz	r3, 59bc <AudioEffectFreeverbStereo_F32::update()+0x7ec>
    59b6:	mov	r0, r3
    59b8:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
		if (outblockR) release(outblockR);
    59bc:	ldr	r3, [sp, #96]	; 0x60
    59be:	cbz	r3, 59c6 <AudioEffectFreeverbStereo_F32::update()+0x7f6>
    59c0:	mov	r0, r3
    59c2:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
		if (block) release((audio_block_f32_t *)block);
    59c6:	ldr	r3, [sp, #88]	; 0x58
    59c8:	cmp	r3, #0
    59ca:	beq.n	5a94 <AudioEffectFreeverbStereo_F32::update()+0x8c4>
    59cc:	mov	r0, r3
#elif defined(KINETISL)
	audio_block_f32_t *block;
	block = receiveReadOnly_f32(0);
	if (block) release(block);
#endif
}
    59ce:	add	sp, #172	; 0xac
    59d0:	vpop	{d8-d14}
    59d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	}
	transmit(outblockL, 0);
	transmit(outblockR, 1);
	release(outblockL);
	release(outblockR);
	if (block != &zeroblock) release((audio_block_f32_t *)block);
    59d8:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>
    59dc:	.word	0x000113d8
    59e0:	.word	0x00012b80
    59e4:	.word	0x00014430
    59e8:	.word	0x00015e0c
    59ec:	.word	0x000166bc
    59f0:	.word	0x00016da0
    59f4:	.word	0x000172f4
    59f8:	.word	0x00017680
    59fc:	.word	0x00017f8c
    5a00:	.word	0x000186cc
    5a04:	.word	0x00018c7c
    5a08:	ldr	r3, [sp, #148]	; 0x94
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;

		outblockR->data[i] = outputR;
	}
	transmit(outblockL, 0);
    5a0a:	mov	r0, r4
    5a0c:	ldr	r5, [sp, #92]	; 0x5c
    5a0e:	movs	r2, #0
    5a10:	vstr	s26, [r3]
    5a14:	ldr	r3, [sp, #152]	; 0x98
    5a16:	mov	r1, r5
    5a18:	vstr	s25, [r3]
    5a1c:	ldr	r3, [sp, #156]	; 0x9c
    5a1e:	vstr	s24, [r3]
    5a22:	ldr	r3, [sp, #160]	; 0xa0
    5a24:	vstr	s23, [r3]
    5a28:	ldr	r3, [sp, #100]	; 0x64
    5a2a:	vstr	s22, [r3]
    5a2e:	ldr	r3, [sp, #104]	; 0x68
    5a30:	vstr	s21, [r3]
    5a34:	ldr	r3, [sp, #108]	; 0x6c
    5a36:	vstr	s20, [r3]
    5a3a:	ldr	r3, [sp, #112]	; 0x70
    5a3c:	vstr	s19, [r3]
    5a40:	ldr	r3, [sp, #116]	; 0x74
    5a42:	vstr	s18, [r3]
    5a46:	ldr	r3, [sp, #120]	; 0x78
    5a48:	vstr	s0, [r3]
    5a4c:	ldr	r3, [sp, #124]	; 0x7c
    5a4e:	vstr	s1, [r3]
    5a52:	ldr	r3, [sp, #128]	; 0x80
    5a54:	vstr	s2, [r3]
    5a58:	ldr	r3, [sp, #132]	; 0x84
    5a5a:	vstr	s3, [r3]
    5a5e:	ldr	r3, [sp, #136]	; 0x88
    5a60:	vstr	s4, [r3]
    5a64:	ldr	r3, [sp, #140]	; 0x8c
    5a66:	vstr	s5, [r3]
    5a6a:	ldr	r3, [sp, #144]	; 0x90
    5a6c:	vstr	s10, [r3]
    5a70:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
	transmit(outblockR, 1);
    5a74:	mov	r0, r4
    5a76:	ldr	r4, [sp, #96]	; 0x60
    5a78:	movs	r2, #1
    5a7a:	mov	r1, r4
    5a7c:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
	release(outblockL);
    5a80:	mov	r0, r5
    5a82:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
	release(outblockR);
    5a86:	mov	r0, r4
    5a88:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
	if (block != &zeroblock) release((audio_block_f32_t *)block);
    5a8c:	ldr	r0, [sp, #88]	; 0x58
    5a8e:	ldr	r2, [sp, #164]	; 0xa4
    5a90:	cmp	r0, r2
    5a92:	bne.n	59ce <AudioEffectFreeverbStereo_F32::update()+0x7fe>
#elif defined(KINETISL)
	audio_block_f32_t *block;
	block = receiveReadOnly_f32(0);
	if (block) release(block);
#endif
}
    5a94:	add	sp, #172	; 0xac
    5a96:	vpop	{d8-d14}
    5a9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (++allpass3indexR >= sizeof(allpass3bufR)/sizeof(float)) allpass3indexR = 0;

		bufout = allpass4bufR[allpass4indexR];
		allpass4bufR[allpass4indexR] = outputR + (bufout / 2.0);
		outputR = (bufout - outputR)/2.0;
		if (++allpass4indexR >= sizeof(allpass4bufR)/sizeof(float)) allpass4indexR = 0;
    5a9e:	ldr	r2, [sp, #36]	; 0x24
    5aa0:	strh	r3, [r2, #0]
    5aa2:	b.n	5962 <AudioEffectFreeverbStereo_F32::update()+0x792>
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;

		bufout = allpass4bufL[allpass4indexL];
		allpass4bufL[allpass4indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass4indexL >= sizeof(allpass4bufL)/sizeof(float)) allpass4indexL = 0;
    5aa4:	ldr	r2, [sp, #52]	; 0x34
    5aa6:	strh	r3, [r2, #0]
    5aa8:	b.n	5872 <AudioEffectFreeverbStereo_F32::update()+0x6a2>
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;

		bufout = allpass3bufL[allpass3indexL];
		allpass3bufL[allpass3indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass3indexL >= sizeof(allpass3bufL)/sizeof(float)) allpass3indexL = 0;
    5aaa:	ldr	r2, [sp, #48]	; 0x30
    5aac:	strh	r3, [r2, #0]
    5aae:	b.n	583a <AudioEffectFreeverbStereo_F32::update()+0x66a>
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;

		bufout = allpass2bufL[allpass2indexL];
		allpass2bufL[allpass2indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass2indexL >= sizeof(allpass2bufL)/sizeof(float)) allpass2indexL = 0;
    5ab0:	ldr	r2, [sp, #44]	; 0x2c
    5ab2:	strh	r3, [r2, #0]
    5ab4:	b.n	5800 <AudioEffectFreeverbStereo_F32::update()+0x630>
		outputR = sum;

		bufout = allpass1bufL[allpass1indexL];
		allpass1bufL[allpass1indexL] = outputL + (bufout / 2.0);
		outputL = (bufout - outputL)/2.0;
		if (++allpass1indexL >= sizeof(allpass1bufL)/sizeof(float)) allpass1indexL = 0;
    5ab6:	ldr	r2, [sp, #40]	; 0x28
    5ab8:	strh	r3, [r2, #0]
    5aba:	b.n	57c6 <AudioEffectFreeverbStereo_F32::update()+0x5f6>

		bufout = comb8bufR[comb8indexR];
		sum += bufout;
		comb8filterR = bufout * combdamp2 + comb8filterR * combdamp1;
		comb8bufR[comb8indexR] = input + comb8filterR * combfeeback;
		if (++comb8indexR >= sizeof(comb8bufR)/sizeof(float)) comb8indexR = 0;
    5abc:	ldr	r2, [sp, #32]
    5abe:	strh	r3, [r2, #0]
    5ac0:	b.n	578c <AudioEffectFreeverbStereo_F32::update()+0x5bc>

		bufout = comb7bufR[comb7indexR];
		sum += bufout;
		comb7filterR = bufout * combdamp2 + comb7filterR * combdamp1;
		comb7bufR[comb7indexR] = input + comb7filterR * combfeeback;
		if (++comb7indexR >= sizeof(comb7bufR)/sizeof(float)) comb7indexR = 0;
    5ac2:	ldr	r2, [sp, #80]	; 0x50
    5ac4:	strh	r3, [r2, #0]
    5ac6:	b.n	575a <AudioEffectFreeverbStereo_F32::update()+0x58a>

		bufout = comb6bufR[comb6indexR];
		sum += bufout;
		comb6filterR = bufout * combdamp2 + comb6filterR * combdamp1;
		comb6bufR[comb6indexR] = input + comb6filterR * combfeeback;
		if (++comb6indexR >= sizeof(comb6bufR)/sizeof(float)) comb6indexR = 0;
    5ac8:	ldr	r2, [sp, #76]	; 0x4c
    5aca:	strh	r3, [r2, #0]
    5acc:	b.n	5722 <AudioEffectFreeverbStereo_F32::update()+0x552>

		bufout = comb5bufR[comb5indexR];
		sum += bufout;
		comb5filterR = bufout * combdamp2 + comb5filterR * combdamp1;
		comb5bufR[comb5indexR] = input + comb5filterR * combfeeback;
		if (++comb5indexR >= sizeof(comb5bufR)/sizeof(float)) comb5indexR = 0;
    5ace:	ldr	r2, [sp, #72]	; 0x48
    5ad0:	strh	r3, [r2, #0]
    5ad2:	b.n	56ea <AudioEffectFreeverbStereo_F32::update()+0x51a>

		bufout = comb4bufR[comb4indexR];
		sum += bufout;
		comb4filterR = bufout * combdamp2 + comb4filterR * combdamp1;
		comb4bufR[comb4indexR] = input + comb4filterR * combfeeback;
		if (++comb4indexR >= sizeof(comb4bufR)/sizeof(float)) comb4indexR = 0;
    5ad4:	ldr	r2, [sp, #68]	; 0x44
    5ad6:	strh	r3, [r2, #0]
    5ad8:	b.n	56b0 <AudioEffectFreeverbStereo_F32::update()+0x4e0>

		bufout = comb3bufR[comb3indexR];
		sum += bufout;
		comb3filterR = bufout * combdamp2 + comb3filterR * combdamp1;
		comb3bufR[comb3indexR] = input + comb3filterR * combfeeback;
		if (++comb3indexR >= sizeof(comb3bufR)/sizeof(float)) comb3indexR = 0;
    5ada:	ldr	r2, [sp, #64]	; 0x40
    5adc:	strh	r3, [r2, #0]
    5ade:	b.n	5676 <AudioEffectFreeverbStereo_F32::update()+0x4a6>

		bufout = comb2bufR[comb2indexR];
		sum += bufout;
		comb2filterR = bufout * combdamp2 + comb2filterR * combdamp1;
		comb2bufR[comb2indexR] = input + comb2filterR * combfeeback;
		if (++comb2indexR >= sizeof(comb2bufR)/sizeof(float)) comb2indexR = 0;
    5ae0:	ldr	r2, [sp, #60]	; 0x3c
    5ae2:	strh	r3, [r2, #0]
    5ae4:	b.n	563c <AudioEffectFreeverbStereo_F32::update()+0x46c>

		bufout = comb1bufR[comb1indexR];
		sum += bufout;
		comb1filterR = bufout * combdamp2 + comb1filterR * combdamp1;
		comb1bufR[comb1indexR] = input + comb1filterR * combfeeback;
		if (++comb1indexR >= sizeof(comb1bufR)/sizeof(float)) comb1indexR = 0;
    5ae6:	ldr	r2, [sp, #56]	; 0x38
    5ae8:	strh	r3, [r2, #0]
    5aea:	b.n	5602 <AudioEffectFreeverbStereo_F32::update()+0x432>

		bufout = comb4bufL[comb4indexL];
		sum += bufout;
		comb4filterL = bufout * combdamp2 + comb4filterL * combdamp1;
		comb4bufL[comb4indexL] = input +comb4filterL * combfeeback;
		if (++comb4indexL >= sizeof(comb4bufL)/sizeof(float)) comb4indexL = 0;
    5aec:	ldr	r2, [sp, #28]
    5aee:	strh	r3, [r2, #0]
    5af0:	b.n	54ca <AudioEffectFreeverbStereo_F32::update()+0x2fa>

		bufout = comb3bufL[comb3indexL];
		sum += bufout;
		comb3filterL = bufout * combdamp2 + comb3filterL * combdamp1;
		comb3bufL[comb3indexL] = input + comb3filterL * combfeeback;
		if (++comb3indexL >= sizeof(comb3bufL)/sizeof(float)) comb3indexL = 0;
    5af2:	ldr	r2, [sp, #24]
    5af4:	strh	r3, [r2, #0]
    5af6:	b.n	548e <AudioEffectFreeverbStereo_F32::update()+0x2be>

		bufout = comb2bufL[comb2indexL];
		sum += bufout;
		comb2filterL = bufout * combdamp2 + comb2filterL * combdamp1;
		comb2bufL[comb2indexL] = input + comb2filterL * combfeeback;
		if (++comb2indexL >= sizeof(comb2bufL)/sizeof(float)) comb2indexL = 0;
    5af8:	ldr	r2, [sp, #20]
    5afa:	strh	r3, [r2, #0]
    5afc:	b.n	5454 <AudioEffectFreeverbStereo_F32::update()+0x284>
		if (outblockL) release(outblockL);
		if (outblockR) release(outblockR);
		if (block) release((audio_block_f32_t *)block);
		return;
	}
	if (!block) block = &zeroblock;
    5afe:	add.w	r3, r4, #44	; 0x2c
    5b02:	str	r3, [sp, #88]	; 0x58
    5b04:	str	r3, [sp, #164]	; 0xa4
    5b06:	b.w	520c <AudioEffectFreeverbStereo_F32::update()+0x3c>
    5b0a:	nop

00005b0c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()>:
	if (block) release(block);
#endif
}


AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32() : AudioStream_F32(1, inputQueueArray)
    5b0c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    5b10:	mov	r1, r0
class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
    5b12:	movs	r4, #0
    5b14:	add.w	r5, r0, #36	; 0x24

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    5b18:	ldr	r2, [pc, #44]	; (5b48 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3c>)
    5b1a:	movs	r7, #1
    5b1c:	add.w	r6, r0, #40	; 0x28
    5b20:	str	r2, [r0, #0]
			active = false;
			destination_list = NULL;
    5b22:	mov	r3, r4
    5b24:	mov	r2, r5
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    5b26:	mov	r0, r4

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
    5b28:	strb	r7, [r1, #9]
    5b2a:	str	r5, [r1, #16]
			active = false;
    5b2c:	strb	r4, [r1, #8]
			destination_list = NULL;
    5b2e:	str	r4, [r1, #12]
    5b30:	b.n	5b34 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x28>
    5b32:	ldr	r2, [r1, #16]
			for (int i=0; i < num_inputs; i++) {
				inputQueue[i] = NULL;
    5b34:	str.w	r0, [r2, r3, lsl #2]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
    5b38:	adds	r3, #1
    5b3a:	ldrb	r2, [r1, #9]
    5b3c:	cmp	r2, r3
    5b3e:	bgt.n	5b32 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x26>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
    5b40:	ldr	r3, [pc, #8]	; (5b4c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x40>)
    5b42:	ldr	r2, [r3, #0]
    5b44:	cbnz	r2, 5b52 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x46>
    5b46:	b.n	5e56 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x34a>
    5b48:	.word	0x20000008
    5b4c:	.word	0x2005876c
				first_update = this;
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
    5b50:	mov	r2, r3
    5b52:	ldr	r3, [r2, #20]
    5b54:	cmp	r3, #0
    5b56:	bne.n	5b50 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x44>
				p->next_update = this;
    5b58:	str	r1, [r2, #20]
			}
			next_update = NULL;
    5b5a:	movs	r0, #0
    5b5c:	movw	r3, #5040	; 0x13b0
//modeled on the existing teensy audio block struct, which uses Int16
//https://github.com/PaulStoffregen/cores/blob/268848cdb0121f26b7ef6b82b4fb54abbe465427/teensy3/AudioStream.h
// Added id, per Tympan.  Should not disturb existing programs.  Bob Larkin June 2020
class audio_block_f32_t {
	public:
		audio_block_f32_t(void) {};
    5b60:	movs	r4, #128	; 0x80


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
    5b62:	mov.w	lr, #1
    5b66:	ldr	r7, [pc, #756]	; (5e5c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x350>)
    5b68:	add	r3, r1
//modeled on the existing teensy audio block struct, which uses Int16
//https://github.com/PaulStoffregen/cores/blob/268848cdb0121f26b7ef6b82b4fb54abbe465427/teensy3/AudioStream.h
// Added id, per Tympan.  Should not disturb existing programs.  Bob Larkin June 2020
class audio_block_f32_t {
	public:
		audio_block_f32_t(void) {};
    5b6a:	ldr	r5, [pc, #756]	; (5e60 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x354>)
    5b6c:	add.w	r2, r1, #576	; 0x240
    5b70:	str	r0, [r1, #20]
			cpu_cycles = 0;
    5b72:	strh	r0, [r1, #4]
			cpu_cycles_max = 0;
    5b74:	strh	r0, [r1, #6]
			numConnections = 0;
    5b76:	strb	r0, [r1, #10]
class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
      //active_f32 = false;
      destination_list_f32 = NULL;
    5b78:	str	r0, [r1, #28]
      for (int i=0; i < n_input_f32; i++) {
        inputQueue_f32[i] = NULL;
    5b7a:	str	r0, [r1, #40]	; 0x28
{
	for(uint16_t i = 0; i < sizeof(comb1bufL)/sizeof(float); i++) comb1bufL[i] = 0.0; 
    5b7c:	movs	r0, #0


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
    5b7e:	str	r6, [r1, #32]
    5b80:	strb.w	lr, [r1, #24]
	if (block) release(block);
#endif
}


AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32() : AudioStream_F32(1, inputQueueArray)
    5b84:	str	r7, [r1, #0]
//modeled on the existing teensy audio block struct, which uses Int16
//https://github.com/PaulStoffregen/cores/blob/268848cdb0121f26b7ef6b82b4fb54abbe465427/teensy3/AudioStream.h
// Added id, per Tympan.  Should not disturb existing programs.  Bob Larkin June 2020
class audio_block_f32_t {
	public:
		audio_block_f32_t(void) {};
    5b86:	str.w	r4, [r1, #560]	; 0x230
    5b8a:	str.w	r4, [r1, #564]	; 0x234
    5b8e:	str.w	r5, [r1, #568]	; 0x238
{
	for(uint16_t i = 0; i < sizeof(comb1bufL)/sizeof(float); i++) comb1bufL[i] = 0.0; 
    5b92:	str.w	r0, [r2], #4
    5b96:	cmp	r2, r3
    5b98:	bne.n	5b92 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x86>
    5b9a:	add.w	r2, r1, #9792	; 0x2640
	for(uint16_t i = 0; i < sizeof(comb2bufL)/sizeof(float); i++) comb2bufL[i] = 0.0; 
    5b9e:	movs	r0, #0
    5ba0:	str.w	r0, [r3], #4
    5ba4:	cmp	r3, r2
    5ba6:	bne.n	5ba0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x94>
    5ba8:	movw	r3, #14900	; 0x3a34
	for(uint16_t i = 0; i < sizeof(comb3bufL)/sizeof(float); i++) comb3bufL[i] = 0.0; 
    5bac:	movs	r0, #0
    5bae:	add	r3, r1
    5bb0:	str.w	r0, [r2], #4
    5bb4:	cmp	r3, r2
    5bb6:	bne.n	5bb0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0xa4>
    5bb8:	movw	r2, #20324	; 0x4f64
	for(uint16_t i = 0; i < sizeof(comb4bufL)/sizeof(float); i++) comb4bufL[i] = 0.0; 
    5bbc:	movs	r0, #0
    5bbe:	add	r2, r1
    5bc0:	str.w	r0, [r3], #4
    5bc4:	cmp	r2, r3
    5bc6:	bne.n	5bc0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0xb4>
    5bc8:	movw	r3, #26012	; 0x659c
	for(uint16_t i = 0; i < sizeof(comb5bufL)/sizeof(float); i++) comb5bufL[i] = 0.0; 
    5bcc:	movs	r0, #0
    5bce:	add	r3, r1
    5bd0:	str.w	r0, [r2], #4
    5bd4:	cmp	r3, r2
    5bd6:	bne.n	5bd0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0xc4>
    5bd8:	movw	r2, #31976	; 0x7ce8
	for(uint16_t i = 0; i < sizeof(comb6bufL)/sizeof(float); i++) comb6bufL[i] = 0.0; 
    5bdc:	movs	r0, #0
    5bde:	add	r2, r1
    5be0:	str.w	r0, [r3], #4
    5be4:	cmp	r2, r3
    5be6:	bne.n	5be0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0xd4>
    5be8:	movw	r3, #38204	; 0x953c
	for(uint16_t i = 0; i < sizeof(comb7bufL)/sizeof(float); i++) comb7bufL[i] = 0.0; 
    5bec:	movs	r0, #0
    5bee:	add	r3, r1
    5bf0:	str.w	r0, [r2], #4
    5bf4:	cmp	r3, r2
    5bf6:	bne.n	5bf0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0xe4>
    5bf8:	movw	r2, #44672	; 0xae80
	for(uint16_t i = 0; i < sizeof(comb8bufL)/sizeof(float); i++) comb8bufL[i] = 0.0; 
    5bfc:	movs	r4, #0
    5bfe:	add	r2, r1
    5c00:	str.w	r4, [r3], #4
    5c04:	cmp	r2, r3
    5c06:	mov.w	r0, #0
    5c0a:	bne.n	5c00 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0xf4>
	comb1indexL = 0;
    5c0c:	movs	r3, #0
    5c0e:	movw	r2, #44672	; 0xae80
	comb2indexL = 0;
	comb3indexL = 0;
	comb4indexL = 0;
    5c12:	movw	sl, #44678	; 0xae86
	comb5indexL = 0;
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
    5c16:	movw	r9, #44688	; 0xae90
	for(uint16_t i = 0; i < sizeof(comb4bufL)/sizeof(float); i++) comb4bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb5bufL)/sizeof(float); i++) comb5bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb6bufL)/sizeof(float); i++) comb6bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb7bufL)/sizeof(float); i++) comb7bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufL)/sizeof(float); i++) comb8bufL[i] = 0.0; 
	comb1indexL = 0;
    5c1a:	strh	r3, [r1, r2]
	comb2indexL = 0;
    5c1c:	movw	r2, #44674	; 0xae82
	comb5indexL = 0;
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
	comb2filterL = 0.0;
    5c20:	movw	r8, #44692	; 0xae94
	comb3filterL = 0.0;
    5c24:	movw	r4, #44696	; 0xae98
	for(uint16_t i = 0; i < sizeof(comb5bufL)/sizeof(float); i++) comb5bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb6bufL)/sizeof(float); i++) comb6bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb7bufL)/sizeof(float); i++) comb7bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufL)/sizeof(float); i++) comb8bufL[i] = 0.0; 
	comb1indexL = 0;
	comb2indexL = 0;
    5c28:	strh	r3, [r1, r2]
	comb3indexL = 0;
    5c2a:	movw	r2, #44676	; 0xae84
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
	comb2filterL = 0.0;
	comb3filterL = 0.0;
    5c2e:	add	r4, r1
	comb4filterL = 0.0;
    5c30:	movw	ip, #44700	; 0xae9c
	for(uint16_t i = 0; i < sizeof(comb6bufL)/sizeof(float); i++) comb6bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb7bufL)/sizeof(float); i++) comb7bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufL)/sizeof(float); i++) comb8bufL[i] = 0.0; 
	comb1indexL = 0;
	comb2indexL = 0;
	comb3indexL = 0;
    5c34:	strh	r3, [r1, r2]
	comb8indexL = 0;
	comb1filterL = 0.0;
	comb2filterL = 0.0;
	comb3filterL = 0.0;
	comb4filterL = 0.0;
	comb5filterL = 0.0;
    5c36:	movw	lr, #44704	; 0xaea0
	for(uint16_t i = 0; i < sizeof(comb7bufL)/sizeof(float); i++) comb7bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufL)/sizeof(float); i++) comb8bufL[i] = 0.0; 
	comb1indexL = 0;
	comb2indexL = 0;
	comb3indexL = 0;
	comb4indexL = 0;
    5c3a:	strh.w	r3, [r1, sl]
	comb5indexL = 0;
    5c3e:	movw	sl, #44680	; 0xae88
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
    5c42:	add	r9, r1
	comb2filterL = 0.0;
    5c44:	add	r8, r1
	for(uint16_t i = 0; i < sizeof(comb8bufL)/sizeof(float); i++) comb8bufL[i] = 0.0; 
	comb1indexL = 0;
	comb2indexL = 0;
	comb3indexL = 0;
	comb4indexL = 0;
	comb5indexL = 0;
    5c46:	strh.w	r3, [r1, sl]
	comb6indexL = 0;
    5c4a:	movw	sl, #44682	; 0xae8a
	comb1filterL = 0.0;
	comb2filterL = 0.0;
	comb3filterL = 0.0;
	comb4filterL = 0.0;
	comb5filterL = 0.0;
	comb6filterL = 0.0;
    5c4e:	movw	r7, #44708	; 0xaea4
	comb7filterL = 0.0;
    5c52:	movw	r6, #44712	; 0xaea8
	comb1indexL = 0;
	comb2indexL = 0;
	comb3indexL = 0;
	comb4indexL = 0;
	comb5indexL = 0;
	comb6indexL = 0;
    5c56:	strh.w	r3, [r1, sl]
	comb7indexL = 0;
    5c5a:	movw	sl, #44684	; 0xae8c
	comb3filterL = 0.0;
	comb4filterL = 0.0;
	comb5filterL = 0.0;
	comb6filterL = 0.0;
	comb7filterL = 0.0;
	comb8filterL = 0.0;
    5c5e:	movw	r5, #44716	; 0xaeac
    5c62:	movw	r2, #44720	; 0xaeb0
	comb2indexL = 0;
	comb3indexL = 0;
	comb4indexL = 0;
	comb5indexL = 0;
	comb6indexL = 0;
	comb7indexL = 0;
    5c66:	strh.w	r3, [r1, sl]
	comb8indexL = 0;
    5c6a:	movw	sl, #44686	; 0xae8e
	comb1filterL = 0.0;
	comb2filterL = 0.0;
	comb3filterL = 0.0;
	comb4filterL = 0.0;
    5c6e:	add	ip, r1
	comb5filterL = 0.0;
    5c70:	add	lr, r1
	comb3indexL = 0;
	comb4indexL = 0;
	comb5indexL = 0;
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
    5c72:	strh.w	r3, [r1, sl]
    5c76:	movw	r3, #49276	; 0xc07c
	comb1filterL = 0.0;
    5c7a:	str.w	r0, [r9]
	comb2filterL = 0.0;
	comb3filterL = 0.0;
	comb4filterL = 0.0;
	comb5filterL = 0.0;
	comb6filterL = 0.0;
    5c7e:	add	r7, r1
	comb5indexL = 0;
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
	comb2filterL = 0.0;
    5c80:	str.w	r0, [r8]
	comb3filterL = 0.0;
	comb4filterL = 0.0;
	comb5filterL = 0.0;
	comb6filterL = 0.0;
	comb7filterL = 0.0;
    5c84:	add	r6, r1
	comb6indexL = 0;
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
	comb2filterL = 0.0;
	comb3filterL = 0.0;
    5c86:	str	r0, [r4, #0]
	comb4filterL = 0.0;
	comb5filterL = 0.0;
	comb6filterL = 0.0;
	comb7filterL = 0.0;
	comb8filterL = 0.0;
    5c88:	add	r5, r1
    5c8a:	add	r2, r1
    5c8c:	add	r3, r1
	for(uint16_t i = 0; i < sizeof(comb1bufR)/sizeof(float); i++) comb1bufR[i] = 0.0; 
    5c8e:	mov	r4, r0
	comb7indexL = 0;
	comb8indexL = 0;
	comb1filterL = 0.0;
	comb2filterL = 0.0;
	comb3filterL = 0.0;
	comb4filterL = 0.0;
    5c90:	str.w	r0, [ip]
	comb5filterL = 0.0;
    5c94:	str.w	r0, [lr]
	comb6filterL = 0.0;
    5c98:	str	r0, [r7, #0]
	comb7filterL = 0.0;
    5c9a:	str	r0, [r6, #0]
	comb8filterL = 0.0;
    5c9c:	str	r0, [r5, #0]
	for(uint16_t i = 0; i < sizeof(comb1bufR)/sizeof(float); i++) comb1bufR[i] = 0.0; 
    5c9e:	str.w	r4, [r2], #4
    5ca2:	cmp	r3, r2
    5ca4:	bne.n	5c9e <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x192>
    5ca6:	movw	r2, #54120	; 0xd368
	for(uint16_t i = 0; i < sizeof(comb2bufR)/sizeof(float); i++) comb2bufR[i] = 0.0; 
    5caa:	movs	r0, #0
    5cac:	add	r2, r1
    5cae:	str.w	r0, [r3], #4
    5cb2:	cmp	r2, r3
    5cb4:	bne.n	5cae <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1a2>
    5cb6:	movw	r3, #59320	; 0xe7b8
	for(uint16_t i = 0; i < sizeof(comb3bufR)/sizeof(float); i++) comb3bufR[i] = 0.0; 
    5cba:	movs	r0, #0
    5cbc:	add	r3, r1
    5cbe:	str.w	r0, [r2], #4
    5cc2:	cmp	r3, r2
    5cc4:	bne.n	5cbe <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1b2>
    5cc6:	movw	r2, #64836	; 0xfd44
	for(uint16_t i = 0; i < sizeof(comb4bufR)/sizeof(float); i++) comb4bufR[i] = 0.0; 
    5cca:	movs	r0, #0
    5ccc:	add	r2, r1
    5cce:	str.w	r0, [r3], #4
    5cd2:	cmp	r2, r3
    5cd4:	bne.n	5cce <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1c2>
    5cd6:	ldr	r3, [pc, #396]	; (5e64 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x358>)
	for(uint16_t i = 0; i < sizeof(comb5bufR)/sizeof(float); i++) comb5bufR[i] = 0.0; 
    5cd8:	movs	r0, #0
    5cda:	add	r3, r1
    5cdc:	str.w	r0, [r2], #4
    5ce0:	cmp	r3, r2
    5ce2:	bne.n	5cdc <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1d0>
    5ce4:	ldr	r2, [pc, #384]	; (5e68 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x35c>)
	for(uint16_t i = 0; i < sizeof(comb6bufR)/sizeof(float); i++) comb6bufR[i] = 0.0; 
    5ce6:	movs	r0, #0
    5ce8:	add	r2, r1
    5cea:	str.w	r0, [r3], #4
    5cee:	cmp	r3, r2
    5cf0:	bne.n	5cea <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1de>
    5cf2:	ldr	r3, [pc, #376]	; (5e6c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x360>)
	for(uint16_t i = 0; i < sizeof(comb7bufR)/sizeof(float); i++) comb7bufR[i] = 0.0; 
    5cf4:	movs	r0, #0
    5cf6:	add	r3, r1
    5cf8:	str.w	r0, [r2], #4
    5cfc:	cmp	r2, r3
    5cfe:	bne.n	5cf8 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1ec>
    5d00:	ldr	r2, [pc, #364]	; (5e70 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x364>)
	for(uint16_t i = 0; i < sizeof(comb8bufR)/sizeof(float); i++) comb8bufR[i] = 0.0; 
    5d02:	movs	r4, #0
    5d04:	add	r2, r1
    5d06:	str.w	r4, [r3], #4
    5d0a:	cmp	r3, r2
    5d0c:	mov.w	r0, #0
    5d10:	bne.n	5d06 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x1fa>
	comb1indexR = 0;
    5d12:	movs	r3, #0
    5d14:	ldr.w	ip, [pc, #344]	; 5e70 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x364>
	comb2indexR = 0;
	comb3indexR = 0;
    5d18:	ldr.w	r9, [pc, #436]	; 5ed0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3c4>
	comb7filterR = 0.0;
	comb8filterR = 0.0;
	combdamp1 = 6553.0;
	combdamp2 = 26215.0;
	combfeeback = 27524.0;
	for(uint16_t i = 0; i < sizeof(allpass1bufL)/sizeof(float); i++) allpass1bufL[i] = 0.0; 
    5d1c:	mov	r4, r0
	for(uint16_t i = 0; i < sizeof(comb4bufR)/sizeof(float); i++) comb4bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb5bufR)/sizeof(float); i++) comb5bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb6bufR)/sizeof(float); i++) comb6bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb7bufR)/sizeof(float); i++) comb7bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufR)/sizeof(float); i++) comb8bufR[i] = 0.0; 
	comb1indexR = 0;
    5d1e:	strh.w	r3, [r1, ip]
	comb2indexR = 0;
    5d22:	add.w	ip, ip, #2
	comb4indexR = 0;
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
    5d26:	ldr	r7, [pc, #332]	; (5e74 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x368>)
	for(uint16_t i = 0; i < sizeof(comb5bufR)/sizeof(float); i++) comb5bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb6bufR)/sizeof(float); i++) comb6bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb7bufR)/sizeof(float); i++) comb7bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufR)/sizeof(float); i++) comb8bufR[i] = 0.0; 
	comb1indexR = 0;
	comb2indexR = 0;
    5d28:	strh.w	r3, [r1, ip]
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
    5d2c:	add.w	ip, ip, #38	; 0x26
	for(uint16_t i = 0; i < sizeof(comb6bufR)/sizeof(float); i++) comb6bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb7bufR)/sizeof(float); i++) comb7bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufR)/sizeof(float); i++) comb8bufR[i] = 0.0; 
	comb1indexR = 0;
	comb2indexR = 0;
	comb3indexR = 0;
    5d30:	strh.w	r3, [r1, r9]
	comb4indexR = 0;
    5d34:	add.w	r9, r9, #2
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
    5d38:	ldr.w	lr, [pc, #408]	; 5ed4 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3c8>
	comb4indexR = 0;
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
    5d3c:	add	r7, r1
	for(uint16_t i = 0; i < sizeof(comb7bufR)/sizeof(float); i++) comb7bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(comb8bufR)/sizeof(float); i++) comb8bufR[i] = 0.0; 
	comb1indexR = 0;
	comb2indexR = 0;
	comb3indexR = 0;
	comb4indexR = 0;
    5d3e:	strh.w	r3, [r1, r9]
	comb5indexR = 0;
    5d42:	add.w	r9, r9, #2
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
    5d46:	add	lr, r1
	comb3filterR = 0.0;
    5d48:	ldr	r6, [pc, #300]	; (5e78 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x36c>)
	for(uint16_t i = 0; i < sizeof(comb8bufR)/sizeof(float); i++) comb8bufR[i] = 0.0; 
	comb1indexR = 0;
	comb2indexR = 0;
	comb3indexR = 0;
	comb4indexR = 0;
	comb5indexR = 0;
    5d4a:	strh.w	r3, [r1, r9]
	comb6indexR = 0;
    5d4e:	add.w	r9, r9, #2
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
    5d52:	ldr	r5, [pc, #296]	; (5e7c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x370>)
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
    5d54:	add	r6, r1
	comb1indexR = 0;
	comb2indexR = 0;
	comb3indexR = 0;
	comb4indexR = 0;
	comb5indexR = 0;
	comb6indexR = 0;
    5d56:	strh.w	r3, [r1, r9]
	comb7indexR = 0;
    5d5a:	add.w	r9, r9, #2
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
    5d5e:	ldr	r2, [pc, #288]	; (5e80 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x374>)
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
    5d60:	add	r5, r1
	comb2indexR = 0;
	comb3indexR = 0;
	comb4indexR = 0;
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
    5d62:	strh.w	r3, [r1, r9]
	comb8indexR = 0;
    5d66:	add.w	r9, r9, #2
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
    5d6a:	add	r2, r1
	comb6filterR = 0.0;
    5d6c:	ldr.w	r8, [pc, #360]	; 5ed8 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3cc>
	comb3indexR = 0;
	comb4indexR = 0;
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
    5d70:	strh.w	r3, [r1, r9]
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
    5d74:	add	ip, r1
	comb4indexR = 0;
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
    5d76:	str	r0, [r7, #0]
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
    5d78:	add	r8, r1
	comb5indexR = 0;
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
    5d7a:	str.w	r0, [lr]
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
	combdamp1 = 6553.0;
    5d7e:	add.w	r7, r1, #89600	; 0x15e00
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
    5d82:	ldr.w	lr, [pc, #344]	; 5edc <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3d0>
	comb6indexR = 0;
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
    5d86:	str	r0, [r6, #0]
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
    5d88:	add	lr, r1
	comb7indexR = 0;
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
    5d8a:	str	r0, [r5, #0]
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
	combdamp1 = 6553.0;
	combdamp2 = 26215.0;
    5d8c:	ldr	r6, [pc, #244]	; (5e84 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x378>)
	comb8indexR = 0;
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
    5d8e:	str	r0, [r2, #0]
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
	combdamp1 = 6553.0;
	combdamp2 = 26215.0;
	combfeeback = 27524.0;
    5d90:	ldr	r5, [pc, #244]	; (5e88 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x37c>)
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
	combdamp1 = 6553.0;
	combdamp2 = 26215.0;
    5d92:	add	r6, r1
    5d94:	ldr	r2, [pc, #244]	; (5e8c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x380>)
    5d96:	ldr	r3, [pc, #248]	; (5e90 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x384>)
	combfeeback = 27524.0;
    5d98:	add	r5, r1
	comb1filterR = 0.0;
	comb2filterR = 0.0;
	comb3filterR = 0.0;
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
    5d9a:	str.w	r0, [r8]
    5d9e:	add	r2, r1
	comb7filterR = 0.0;
    5da0:	str.w	r0, [ip]
    5da4:	add	r3, r1
	comb8filterR = 0.0;
    5da6:	str.w	r0, [lr]
	combdamp1 = 6553.0;
    5daa:	ldr.w	ip, [pc, #308]	; 5ee0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3d4>
	combdamp2 = 26215.0;
    5dae:	ldr.w	lr, [pc, #308]	; 5ee4 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3d8>
	combfeeback = 27524.0;
    5db2:	ldr	r0, [pc, #224]	; (5e94 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x388>)
	comb4filterR = 0.0;
	comb5filterR = 0.0;
	comb6filterR = 0.0;
	comb7filterR = 0.0;
	comb8filterR = 0.0;
	combdamp1 = 6553.0;
    5db4:	str.w	ip, [r7]
	combdamp2 = 26215.0;
    5db8:	str.w	lr, [r6]
	combfeeback = 27524.0;
    5dbc:	str	r0, [r5, #0]
	for(uint16_t i = 0; i < sizeof(allpass1bufL)/sizeof(float); i++) allpass1bufL[i] = 0.0; 
    5dbe:	str.w	r4, [r2], #4
    5dc2:	cmp	r2, r3
    5dc4:	bne.n	5dbe <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x2b2>
    5dc6:	ldr	r2, [pc, #208]	; (5e98 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x38c>)
	for(uint16_t i = 0; i < sizeof(allpass2bufL)/sizeof(float); i++) allpass2bufL[i] = 0.0; 
    5dc8:	movs	r0, #0
    5dca:	add	r2, r1
    5dcc:	str.w	r0, [r3], #4
    5dd0:	cmp	r2, r3
    5dd2:	bne.n	5dcc <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x2c0>
    5dd4:	ldr	r3, [pc, #196]	; (5e9c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x390>)
	for(uint16_t i = 0; i < sizeof(allpass3bufL)/sizeof(float); i++) allpass3bufL[i] = 0.0; 
    5dd6:	movs	r0, #0
    5dd8:	add	r3, r1
    5dda:	str.w	r0, [r2], #4
    5dde:	cmp	r3, r2
    5de0:	bne.n	5dda <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x2ce>
    5de2:	ldr	r2, [pc, #188]	; (5ea0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x394>)
	for(uint16_t i = 0; i < sizeof(allpass4bufL)/sizeof(float); i++) allpass4bufL[i] = 0.0; 
    5de4:	movs	r0, #0
    5de6:	add	r2, r1
    5de8:	str.w	r0, [r3], #4
    5dec:	cmp	r2, r3
    5dee:	bne.n	5de8 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x2dc>
	allpass1indexL = 0;
    5df0:	movs	r4, #0
    5df2:	ldr	r0, [pc, #172]	; (5ea0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x394>)
    5df4:	ldr	r2, [pc, #172]	; (5ea4 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x398>)
    5df6:	ldr	r3, [pc, #176]	; (5ea8 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x39c>)
    5df8:	strh	r4, [r1, r0]
    5dfa:	add	r2, r1
	allpass2indexL = 0;
    5dfc:	ldr	r7, [pc, #172]	; (5eac <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3a0>)
    5dfe:	add	r3, r1
	allpass3indexL = 0;
    5e00:	ldr	r6, [pc, #172]	; (5eb0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3a4>)
	allpass4indexL = 0;
	for(uint16_t i = 0; i < sizeof(allpass1bufR)/sizeof(float); i++) allpass1bufR[i] = 0.0; 
    5e02:	movs	r0, #0
	for(uint16_t i = 0; i < sizeof(allpass3bufL)/sizeof(float); i++) allpass3bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass4bufL)/sizeof(float); i++) allpass4bufL[i] = 0.0; 
	allpass1indexL = 0;
	allpass2indexL = 0;
	allpass3indexL = 0;
	allpass4indexL = 0;
    5e04:	ldr	r5, [pc, #172]	; (5eb4 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3a8>)
	for(uint16_t i = 0; i < sizeof(allpass1bufL)/sizeof(float); i++) allpass1bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass2bufL)/sizeof(float); i++) allpass2bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass3bufL)/sizeof(float); i++) allpass3bufL[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass4bufL)/sizeof(float); i++) allpass4bufL[i] = 0.0; 
	allpass1indexL = 0;
	allpass2indexL = 0;
    5e06:	strh	r4, [r1, r7]
	allpass3indexL = 0;
    5e08:	strh	r4, [r1, r6]
	allpass4indexL = 0;
    5e0a:	strh	r4, [r1, r5]
	for(uint16_t i = 0; i < sizeof(allpass1bufR)/sizeof(float); i++) allpass1bufR[i] = 0.0; 
    5e0c:	str.w	r0, [r2], #4
    5e10:	cmp	r3, r2
    5e12:	bne.n	5e0c <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x300>
    5e14:	ldr	r2, [pc, #160]	; (5eb8 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3ac>)
	for(uint16_t i = 0; i < sizeof(allpass2bufR)/sizeof(float); i++) allpass2bufR[i] = 0.0; 
    5e16:	movs	r0, #0
    5e18:	add	r2, r1
    5e1a:	str.w	r0, [r3], #4
    5e1e:	cmp	r2, r3
    5e20:	bne.n	5e1a <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x30e>
    5e22:	ldr	r3, [pc, #152]	; (5ebc <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3b0>)
	for(uint16_t i = 0; i < sizeof(allpass3bufR)/sizeof(float); i++) allpass3bufR[i] = 0.0; 
    5e24:	movs	r0, #0
    5e26:	add	r3, r1
    5e28:	str.w	r0, [r2], #4
    5e2c:	cmp	r3, r2
    5e2e:	bne.n	5e28 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x31c>
    5e30:	ldr	r2, [pc, #140]	; (5ec0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3b4>)
	for(uint16_t i = 0; i < sizeof(allpass4bufR)/sizeof(float); i++) allpass4bufR[i] = 0.0; 
    5e32:	movs	r0, #0
    5e34:	add	r2, r1
    5e36:	str.w	r0, [r3], #4
    5e3a:	cmp	r3, r2
    5e3c:	bne.n	5e36 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x32a>
	allpass1indexR = 0;
    5e3e:	movs	r3, #0
    5e40:	ldr	r6, [pc, #124]	; (5ec0 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3b4>)
	allpass2indexR = 0;
    5e42:	ldr	r5, [pc, #128]	; (5ec4 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3b8>)
	allpass3indexR = 0;
	allpass4indexR = 0;
}
    5e44:	mov	r0, r1
	for(uint16_t i = 0; i < sizeof(allpass2bufR)/sizeof(float); i++) allpass2bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass3bufR)/sizeof(float); i++) allpass3bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass4bufR)/sizeof(float); i++) allpass4bufR[i] = 0.0; 
	allpass1indexR = 0;
	allpass2indexR = 0;
	allpass3indexR = 0;
    5e46:	ldr	r4, [pc, #128]	; (5ec8 <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3bc>)
	allpass4indexR = 0;
    5e48:	ldr	r2, [pc, #128]	; (5ecc <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x3c0>)
	allpass4indexL = 0;
	for(uint16_t i = 0; i < sizeof(allpass1bufR)/sizeof(float); i++) allpass1bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass2bufR)/sizeof(float); i++) allpass2bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass3bufR)/sizeof(float); i++) allpass3bufR[i] = 0.0; 
	for(uint16_t i = 0; i < sizeof(allpass4bufR)/sizeof(float); i++) allpass4bufR[i] = 0.0; 
	allpass1indexR = 0;
    5e4a:	strh	r3, [r1, r6]
	allpass2indexR = 0;
    5e4c:	strh	r3, [r1, r5]
	allpass3indexR = 0;
    5e4e:	strh	r3, [r1, r4]
	allpass4indexR = 0;
    5e50:	strh	r3, [r1, r2]
}
    5e52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
				first_update = this;
    5e56:	str	r1, [r3, #0]
    5e58:	b.n	5b5a <AudioEffectFreeverbStereo_F32::AudioEffectFreeverbStereo_F32()+0x4e>
    5e5a:	nop
    5e5c:	.word	0x20000550
    5e60:	.word	0x473b8000
    5e64:	.word	0x000113d8
    5e68:	.word	0x00012b80
    5e6c:	.word	0x00014430
    5e70:	.word	0x00015dd0
    5e74:	.word	0x00015de0
    5e78:	.word	0x00015de8
    5e7c:	.word	0x00015dec
    5e80:	.word	0x00015df0
    5e84:	.word	0x00015e04
    5e88:	.word	0x00015e08
    5e8c:	.word	0x00015e0c
    5e90:	.word	0x000166bc
    5e94:	.word	0x46d70800
    5e98:	.word	0x00016da0
    5e9c:	.word	0x000172f4
    5ea0:	.word	0x00017678
    5ea4:	.word	0x00017680
    5ea8:	.word	0x00017f8c
    5eac:	.word	0x0001767a
    5eb0:	.word	0x0001767c
    5eb4:	.word	0x0001767e
    5eb8:	.word	0x000186cc
    5ebc:	.word	0x00018c7c
    5ec0:	.word	0x0001905c
    5ec4:	.word	0x0001905e
    5ec8:	.word	0x00019060
    5ecc:	.word	0x00019062
    5ed0:	.word	0x00015dd4
    5ed4:	.word	0x00015de4
    5ed8:	.word	0x00015df4
    5edc:	.word	0x00015dfc
    5ee0:	.word	0x45ccc800
    5ee4:	.word	0x46ccce00

00005ee8 <plaits::Voice::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace std;
using namespace stmlib;

void Voice::Init(BufferAllocator* allocator) {
    5ee8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5eec:	mov	r5, r0
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5eee:	movw	r7, #4176	; 0x1050
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5ef2:	movs	r0, #0
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5ef4:	movw	r2, #4176	; 0x1050
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5ef8:	addw	r6, r5, #3724	; 0xe8c
    5efc:	mov	r4, r1
  engines_.Init();
  engines_.RegisterInstance(&virtual_analog_engine_, false, 0.8f, 0.8f);
    5efe:	addw	r3, r5, #3720	; 0xe88
    5f02:	ldr	r1, [pc, #632]	; (617c <plaits::Voice::Init(stmlib::BufferAllocator*)+0x294>)
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f04:	add	r2, r5
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5f06:	add.w	r9, r5, #3888	; 0xf30
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f0a:	str	r3, [r5, r7]
  engines_.RegisterInstance(&waveshaping_engine_, false, 0.7f, 0.6f);
    5f0c:	addw	sl, r5, #3884	; 0xf2c
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f10:	strb.w	r0, [r5, #3732]	; 0xe94
    s->out_gain = out_gain;
    5f14:	vmov.f32	s15, #136	; 0xc0400000 -3.0
    s->aux_gain = aux_gain;
    5f18:	str	r1, [r6, #4]
    5f1a:	mov.w	ip, #1065353216	; 0x3f800000
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5f1e:	str	r1, [r6, #0]
    5f20:	mov.w	fp, #3221225472	; 0xc0000000
    s->aux_gain = aux_gain;
    5f24:	ldr	r6, [pc, #600]	; (6180 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x298>)
    5f26:	movw	r8, #4240	; 0x1090
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5f2a:	ldr.w	lr, [pc, #604]	; 6188 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x2a0>
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f2e:	str.w	sl, [r2, #4]
  engines_.RegisterInstance(&fm_engine_, false, 0.6f, 0.6f);
  engines_.RegisterInstance(&grain_engine_, false, 0.7f, 0.6f);
  engines_.RegisterInstance(&additive_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&wavetable_engine_, false, 0.6f, 0.6f);
    5f32:	add.w	sl, r5, #3968	; 0xf80
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f36:	strb.w	r0, [r5, #3896]	; 0xf38
    5f3a:	add	r8, r5
    s->out_gain = out_gain;
    5f3c:	str.w	lr, [r9]
    s->aux_gain = aux_gain;
    5f40:	str.w	r6, [r9, #4]

void Voice::Init(BufferAllocator* allocator) {
  engines_.Init();
  engines_.RegisterInstance(&virtual_analog_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&waveshaping_engine_, false, 0.7f, 0.6f);
  engines_.RegisterInstance(&fm_engine_, false, 0.6f, 0.6f);
    5f44:	add.w	r9, r5, #848	; 0x350
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5f48:	ldr	r7, [pc, #568]	; (6184 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x29c>)
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f4a:	str.w	r9, [r2, #8]
  engines_.RegisterInstance(&grain_engine_, false, 0.7f, 0.6f);
    5f4e:	add.w	r9, r5, #904	; 0x388
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f52:	strb.w	r0, [r5, #860]	; 0x35c
    s->out_gain = out_gain;
    5f56:	str.w	r6, [r5, #852]	; 0x354
    s->aux_gain = aux_gain;
    5f5a:	str.w	r6, [r5, #856]	; 0x358
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f5e:	str.w	r9, [r2, #12]
  engines_.RegisterInstance(&additive_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&wavetable_engine_, false, 0.6f, 0.6f);
  engines_.RegisterInstance(&chord_engine_, false, 0.8f, 0.8f);
    5f62:	add.w	r9, r5, #512	; 0x200
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5f66:	str.w	lr, [r5, #908]	; 0x38c
    5f6a:	addw	lr, r5, #3972	; 0xf84
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f6e:	strb.w	r0, [r5, #916]	; 0x394
    s->out_gain = out_gain;
    s->aux_gain = aux_gain;
    5f72:	str.w	r6, [r5, #912]	; 0x390
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f76:	str	r5, [r2, #16]
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f78:	strb	r0, [r5, #12]
    s->out_gain = out_gain;
    5f7a:	str	r1, [r5, #4]
    s->aux_gain = aux_gain;
    5f7c:	str	r1, [r5, #8]
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f7e:	str.w	sl, [r2, #20]
  engines_.RegisterInstance(&speech_engine_, false, -0.7f, 0.8f);

  engines_.RegisterInstance(&swarm_engine_, false, -3.0f, 1.0f);
  engines_.RegisterInstance(&noise_engine_, false, -1.0f, -1.0f);
    5f82:	add.w	sl, r5, #1688	; 0x698
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f86:	strb.w	r0, [r5, #3980]	; 0xf8c
    s->out_gain = out_gain;
    5f8a:	str.w	r6, [lr]
    s->aux_gain = aux_gain;
    5f8e:	str.w	r6, [lr, #4]
  engines_.RegisterInstance(&fm_engine_, false, 0.6f, 0.6f);
  engines_.RegisterInstance(&grain_engine_, false, 0.7f, 0.6f);
  engines_.RegisterInstance(&additive_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&wavetable_engine_, false, 0.6f, 0.6f);
  engines_.RegisterInstance(&chord_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&speech_engine_, false, -0.7f, 0.8f);
    5f92:	addw	lr, r5, #2332	; 0x91c
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5f96:	str.w	r9, [r2, #24]
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5f9a:	add.w	r6, r5, #2336	; 0x920
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5f9e:	strb.w	r0, [r5, #524]	; 0x20c

  engines_.RegisterInstance(&swarm_engine_, false, -3.0f, 1.0f);
  engines_.RegisterInstance(&noise_engine_, false, -1.0f, -1.0f);
  engines_.RegisterInstance(&particle_engine_, false, -2.0f, 1.0f);
    5fa2:	add.w	r9, r5, #1816	; 0x718
    s->out_gain = out_gain;
    5fa6:	str.w	r1, [r5, #516]	; 0x204
    s->aux_gain = aux_gain;
    5faa:	str.w	r1, [r5, #520]	; 0x208
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5fae:	str.w	lr, [r2, #28]
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5fb2:	ldr.w	lr, [pc, #472]	; 618c <plaits::Voice::Init(stmlib::BufferAllocator*)+0x2a4>
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5fb6:	strb.w	r0, [r5, #2344]	; 0x928
    s->out_gain = out_gain;
    s->aux_gain = aux_gain;
    5fba:	str	r1, [r6, #4]
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5fbc:	str.w	lr, [r6]
  engines_.RegisterInstance(&additive_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&wavetable_engine_, false, 0.6f, 0.6f);
  engines_.RegisterInstance(&chord_engine_, false, 0.8f, 0.8f);
  engines_.RegisterInstance(&speech_engine_, false, -0.7f, 0.8f);

  engines_.RegisterInstance(&swarm_engine_, false, -3.0f, 1.0f);
    5fc0:	addw	lr, r5, #3192	; 0xc78
    5fc4:	addw	r6, r5, #3196	; 0xc7c
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5fc8:	str.w	lr, [r2, #32]
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5fcc:	addw	lr, r5, #1692	; 0x69c
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5fd0:	strb.w	r0, [r5, #3204]	; 0xc84
    s->out_gain = out_gain;
    s->aux_gain = aux_gain;
    5fd4:	str.w	ip, [r6, #4]
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5fd8:	vstr	s15, [r6]
    s->aux_gain = aux_gain;
    ++num_engines_;
    5fdc:	mov	r6, r0
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5fde:	str.w	sl, [r2, #36]	; 0x24
  engines_.RegisterInstance(&noise_engine_, false, -1.0f, -1.0f);
  engines_.RegisterInstance(&particle_engine_, false, -2.0f, 1.0f);
  engines_.RegisterInstance(&string_engine_, true, -1.0f, 0.8f);
    5fe2:	addw	sl, r5, #2860	; 0xb2c
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5fe6:	strb.w	r0, [r5, #1700]	; 0x6a4
    s->out_gain = out_gain;
    5fea:	str.w	r7, [lr]
    s->aux_gain = aux_gain;
    5fee:	str.w	r7, [lr, #4]
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    5ff2:	addw	lr, r5, #1820	; 0x71c
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    5ff6:	str.w	r9, [r2, #40]	; 0x28
  engines_.RegisterInstance(&modal_engine_, true, -1.0f, 0.8f);
    5ffa:	addw	r9, r5, #1364	; 0x554
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    5ffe:	strb.w	r0, [r5, #1828]	; 0x724
    6002:	movs	r0, #1
    s->out_gain = out_gain;
    s->aux_gain = aux_gain;
    6004:	str.w	ip, [lr, #4]
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    6008:	add.w	ip, r5, #2864	; 0xb30
    600c:	str.w	fp, [lr]
    6010:	add.w	lr, r5, #1368	; 0x558
  engines_.RegisterInstance(&bass_drum_engine_, true, 0.8f, 0.8f);
    6014:	add.w	fp, r5, #328	; 0x148
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    6018:	str.w	sl, [r2, #44]	; 0x2c
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    601c:	strb.w	r0, [r5, #2872]	; 0xb38
  engines_.RegisterInstance(&snare_drum_engine_, true, 0.8f, 0.8f);
    6020:	add.w	sl, r5, #2040	; 0x7f8
    s->out_gain = out_gain;
    6024:	str.w	r7, [ip]
    s->aux_gain = aux_gain;
    6028:	str.w	r1, [ip, #4]
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    602c:	addw	ip, r5, #2044	; 0x7fc
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    6030:	str.w	r9, [r2, #48]	; 0x30
  engines_.RegisterInstance(&hi_hat_engine_, true, 0.8f, 0.8f);
    6034:	addw	r9, r5, #1036	; 0x40c
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    6038:	strb.w	r0, [r5, #1376]	; 0x560
    s->out_gain = out_gain;
    603c:	str.w	r7, [lr]
    6040:	mov	r7, r2
    s->aux_gain = aux_gain;
    6042:	str.w	r1, [lr, #4]
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    6046:	add.w	lr, r5, #1040	; 0x410
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    604a:	str.w	fp, [r2, #52]	; 0x34
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    s->out_gain = out_gain;
    s->aux_gain = aux_gain;
    ++num_engines_;
    604e:	mov.w	fp, #16
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    6052:	strb.w	r0, [r5, #340]	; 0x154
    s->out_gain = out_gain;
    6056:	str.w	r1, [r5, #332]	; 0x14c
    s->aux_gain = aux_gain;
    605a:	str.w	r1, [r5, #336]	; 0x150
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    605e:	str.w	sl, [r2, #56]	; 0x38
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    6062:	strb.w	r0, [r5, #2052]	; 0x804
    s->out_gain = out_gain;
    6066:	str.w	r1, [ip]
    s->aux_gain = aux_gain;
    606a:	str.w	r1, [ip, #4]
      float out_gain,
      float aux_gain) {
    if (num_engines_ >= max_size) {
      return;
    }
    engine_[num_engines_] = instance;
    606e:	str.w	r9, [r2, #60]	; 0x3c
    PostProcessingSettings* s = &instance->post_processing_settings;
    s->already_enveloped = already_enveloped;
    6072:	strb.w	r0, [r5, #1048]	; 0x418
    s->out_gain = out_gain;
    6076:	str.w	r1, [lr]
    s->aux_gain = aux_gain;
    607a:	str.w	r1, [lr, #4]
    ++num_engines_;
    607e:	str.w	fp, [r2, #64]	; 0x40
    6082:	b.n	6088 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x1a0>
    6084:	ldr.w	r3, [r7, #4]!
      return NULL;
    }
  }
  
  inline void Free() {
    next_ = buffer_;
    6088:	ldr	r2, [r4, #4]
  for (int i = 0; i < engines_.size(); ++i) {
    // All engines will share the same RAM space.
    allocator->Free();
    engines_.get(i)->Init(allocator);
    608a:	mov	r0, r3
    608c:	ldr	r3, [r3, #0]
    608e:	mov	r1, r4
    6090:	str	r2, [r4, #0]
  engines_.RegisterInstance(&string_engine_, true, -1.0f, 0.8f);
  engines_.RegisterInstance(&modal_engine_, true, -1.0f, 0.8f);
  engines_.RegisterInstance(&bass_drum_engine_, true, 0.8f, 0.8f);
  engines_.RegisterInstance(&snare_drum_engine_, true, 0.8f, 0.8f);
  engines_.RegisterInstance(&hi_hat_engine_, true, 0.8f, 0.8f);
  for (int i = 0; i < engines_.size(); ++i) {
    6092:	adds	r6, #1
    free_ = size_;
    6094:	ldr	r2, [r4, #12]
    // All engines will share the same RAM space.
    allocator->Free();
    engines_.get(i)->Init(allocator);
    6096:	ldr	r3, [r3, #0]
    6098:	str	r2, [r4, #8]
    609a:	blx	r3
  engines_.RegisterInstance(&string_engine_, true, -1.0f, 0.8f);
  engines_.RegisterInstance(&modal_engine_, true, -1.0f, 0.8f);
  engines_.RegisterInstance(&bass_drum_engine_, true, 0.8f, 0.8f);
  engines_.RegisterInstance(&snare_drum_engine_, true, 0.8f, 0.8f);
  engines_.RegisterInstance(&hi_hat_engine_, true, 0.8f, 0.8f);
  for (int i = 0; i < engines_.size(); ++i) {
    609c:	ldr.w	r3, [r8]
    60a0:	cmp	r6, r3
    60a2:	blt.n	6084 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x19c>
    allocator->Free();
    engines_.get(i)->Init(allocator);
  }
  
  engine_quantizer_.Init();
  previous_engine_index_ = -1;
    60a4:	mov.w	r9, #4294967295
 public:
  LowPassGate() { }
  ~LowPassGate() { }
  
  void Init() {
    previous_gain_ = 0.0f;
    60a8:	movw	r4, #4124	; 0x101c
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    60ac:	movw	ip, #4144	; 0x1030
    60b0:	movw	r6, #4140	; 0x102c
    60b4:	str.w	r9, [r5, #4040]	; 0xfc8
  engine_cv_ = 0.0f;
    60b8:	movs	r2, #0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    60ba:	add.w	r1, r5, #4128	; 0x1020
 public:
  HysteresisQuantizer() { }
  ~HysteresisQuantizer() { }

  void Init() {
    quantized_value_ = 0;
    60be:	mov.w	lr, #0
    60c2:	add	r4, r5
    60c4:	addw	r0, r5, #4044	; 0xfcc
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    60c8:	add	ip, r5
    60ca:	add	r6, r5

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    60cc:	ldr.w	fp, [pc, #192]	; 6190 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x2a8>
 public:
  Limiter() { }
  ~Limiter() { }

  void Init() {
    peak_ = 0.5f;
    60d0:	movw	r8, #4120	; 0x1018
    r_ = 1.0f / resonance;
    60d4:	ldr.w	sl, [pc, #188]	; 6194 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x2ac>
    60d8:	movw	r7, #4152	; 0x1038
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    60dc:	ldr.w	r9, [pc, #184]	; 6198 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x2b0>

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    60e0:	movw	r3, #4156	; 0x103c
    60e4:	str.w	lr, [r5, #4036]	; 0xfc4
    60e8:	add	r8, r5
    60ea:	str	r2, [r0, #0]
    60ec:	add	r3, r5
    60ee:	str	r2, [r4, #0]
    60f0:	add	r7, r5
    r_ = 1.0f / resonance;
    60f2:	str.w	sl, [r1, #4]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    60f6:	movw	r0, #4172	; 0x104c

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    60fa:	str.w	fp, [r1]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    60fe:	movw	r4, #4168	; 0x1048
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6102:	str.w	r9, [r1, #8]
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
    6106:	movw	r1, #4112	; 0x1010
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    610a:	str.w	r2, [ip]
    610e:	add	r0, r5
    6110:	str	r2, [r6, #0]
    6112:	mov.w	r6, #1056964608	; 0x3f000000
    6116:	add	r4, r5
    6118:	add	r1, r5
    611a:	str.w	r6, [r8]
    611e:	movw	ip, #4148	; 0x1034
    6122:	str	r2, [r7, #0]
  LPGEnvelope() { }
  ~LPGEnvelope() { }
  
  inline void Init() {
    vactrol_state_ = 0.0f;
    gain_ = 1.0f;
    6124:	mov.w	r8, #1065353216	; 0x3f800000

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6128:	str.w	fp, [r3]
    612c:	add	ip, r5
    r_ = 1.0f / resonance;
    612e:	str.w	sl, [r3, #4]
 public:
  DecayEnvelope() { }
  ~DecayEnvelope() { }
  
  inline void Init() {
    value_ = 0.0f;
    6132:	addw	r7, r5, #4056	; 0xfd8
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6136:	str.w	r9, [r3, #8]
  lpg_envelope_.Init();
  
  trigger_state_ = false;
  previous_note_ = 0.0f;
  
  trigger_delay_.Init(trigger_delay_line_);
    613a:	add.w	r3, r5, #4080	; 0xff0
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    613e:	str	r2, [r0, #0]
 public:
  LPGEnvelope() { }
  ~LPGEnvelope() { }
  
  inline void Init() {
    vactrol_state_ = 0.0f;
    6140:	addw	r0, r5, #4060	; 0xfdc
    6144:	str	r2, [r4, #0]
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    6146:	cmp	r1, r3

  decay_envelope_.Init();
  lpg_envelope_.Init();
  
  trigger_state_ = false;
  previous_note_ = 0.0f;
    6148:	add.w	r4, r5, #4048	; 0xfd0
    614c:	str.w	r6, [ip]
 public:
  DecayEnvelope() { }
  ~DecayEnvelope() { }
  
  inline void Init() {
    value_ = 0.0f;
    6150:	str	r2, [r7, #0]
  ~LPGEnvelope() { }
  
  inline void Init() {
    vactrol_state_ = 0.0f;
    gain_ = 1.0f;
    frequency_ = 0.5f;
    6152:	str	r6, [r0, #8]
 public:
  LPGEnvelope() { }
  ~LPGEnvelope() { }
  
  inline void Init() {
    vactrol_state_ = 0.0f;
    6154:	str	r2, [r0, #0]
    gain_ = 1.0f;
    frequency_ = 0.5f;
    hf_bleed_ = 0.0f;
    6156:	str	r2, [r0, #12]
  LPGEnvelope() { }
  ~LPGEnvelope() { }
  
  inline void Init() {
    vactrol_state_ = 0.0f;
    gain_ = 1.0f;
    6158:	str.w	r8, [r0, #4]
  aux_post_processor_.Init();

  decay_envelope_.Init();
  lpg_envelope_.Init();
  
  trigger_state_ = false;
    615c:	strb.w	lr, [r5, #4052]	; 0xfd4
  previous_note_ = 0.0f;
    6160:	str	r2, [r4, #0]
    6162:	str	r3, [r1, #4]
    6164:	beq.n	616e <plaits::Voice::Init(stmlib::BufferAllocator*)+0x286>
	*__first = __tmp;
    6166:	str.w	r2, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    616a:	cmp	r1, r3
    616c:	bne.n	6166 <plaits::Voice::Init(stmlib::BufferAllocator*)+0x27e>
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
    616e:	movw	r3, #4112	; 0x1010
    6172:	movs	r2, #0
    6174:	str	r2, [r5, r3]
  
  trigger_delay_.Init(trigger_delay_line_);
}
    6176:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    617a:	nop
    617c:	.word	0x3f4ccccd
    6180:	.word	0x3f19999a
    6184:	.word	0xbf800000
    6188:	.word	0x3f333333
    618c:	.word	0xbf333333
    6190:	.word	0x3d00ba22
    6194:	.word	0x3c23d70a
    6198:	.word	0x3f7faaca

0000619c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)>:

void Voice::Render(
    const Patch& patch,
    const Modulations& modulations,
    Frame* frames,
    size_t size) {
    619c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    61a0:	movw	r4, #4112	; 0x1010
    61a4:	mov	r6, r0
    61a6:	mov	r8, r1
  // Trigger, LPG, internal envelope.
      
  // Delay trigger by 1ms to deal with sequencers or MIDI interfaces whose
  // CV out lags behind the GATE out.
  trigger_delay_.Write(modulations.trigger);
    61a8:	ldr.w	lr, [r2, #24]
    61ac:	ldr	r0, [r0, r4]
    61ae:	mov	r5, r4

void Voice::Render(
    const Patch& patch,
    const Modulations& modulations,
    Frame* frames,
    size_t size) {
    61b0:	mov	r7, r2
  // Delay trigger by 1ms to deal with sequencers or MIDI interfaces whose
  // CV out lags behind the GATE out.
  trigger_delay_.Write(modulations.trigger);
  float trigger_value = trigger_delay_.Read(kTriggerDelay);
  
  bool previous_trigger_state = trigger_state_;
    61b2:	ldrb.w	r9, [r6, #4052]	; 0xfd4
    61b6:	add	r5, r6
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
    61b8:	adds	r1, r0, #7
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
    61ba:	vldr	s13, [pc, #304]	; 62ec <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x150>
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    61be:	ldr	r2, [r5, #4]
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
    61c0:	and.w	r1, r1, #7

void Voice::Render(
    const Patch& patch,
    const Modulations& modulations,
    Frame* frames,
    size_t size) {
    61c4:	vpush	{d8-d9}
    61c8:	sub	sp, #52	; 0x34
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    61ca:	add.w	r0, r2, r0, lsl #2
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    61ce:	adds	r5, r1, #6
    61d0:	str	r3, [sp, #8]
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    61d2:	adds	r3, r1, #5
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    61d4:	str.w	lr, [r0]
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    61d8:	and.w	r0, r5, #7
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    61dc:	and.w	r3, r3, #7
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
    61e0:	str	r1, [r6, r4]
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    61e2:	add.w	r3, r2, r3, lsl #2
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    61e6:	add.w	r2, r2, r0, lsl #2
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    61ea:	vldr	s15, [r3]
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
    61ee:	vldr	s14, [r2]
    61f2:	vsub.f32	s14, s14, s15
    61f6:	vfma.f32	s15, s14, s13
  // CV out lags behind the GATE out.
  trigger_delay_.Write(modulations.trigger);
  float trigger_value = trigger_delay_.Read(kTriggerDelay);
  
  bool previous_trigger_state = trigger_state_;
  if (!previous_trigger_state) {
    61fa:	cmp.w	r9, #0
    61fe:	bne.w	67a8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x60c>
    if (trigger_value > 0.3f) {
    6202:	vldr	s14, [pc, #248]	; 62fc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x160>
    6206:	vcmpe.f32	s15, s14
    620a:	vmrs	APSR_nzcv, fpscr
    620e:	bgt.w	67ce <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x632>
    6212:	addw	r5, r6, #4056	; 0xfd8
    6216:	addw	r3, r6, #4044	; 0xfcc
  } else {
    if (trigger_value < 0.1f) {
      trigger_state_ = false;
    }
  }
  if (!modulations.trigger_patched) {
    621a:	ldrb.w	r1, [r7, #35]	; 0x23
    621e:	cmp	r1, #0
    6220:	beq.w	679e <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x602>
    6224:	vldr	s12, [r3]
    6228:	movw	r3, #4240	; 0x1090
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    622c:	vldr	s15, [r8, #28]
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    6230:	vmov.f32	s14, #208	; 0xbe800000 -0.250
    6234:	ldr	r2, [r6, r3]
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    6236:	vcvt.f32.s32	s15, s15
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    623a:	ldr.w	r3, [r6, #4036]	; 0xfc4
    623e:	vmov.f32	s10, #80	; 0x3e800000  0.250
  inline int Process(float value, int num_steps, float hysteresis) {
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    6242:	subs	r4, r2, #1
    value += static_cast<float>(base);
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    6244:	vmov.f32	s11, #96	; 0x3f000000  0.5
  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    6248:	vmov	s13, r3
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    624c:	vmov	s9, r4
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    6250:	vcvt.f32.s32	s13, s13
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    6254:	vcvt.f32.s32	s9, s9
    6258:	vfma.f32	s15, s9, s12
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    625c:	vcmpe.f32	s15, s13
    6260:	vmrs	APSR_nzcv, fpscr
    6264:	it	le
    6266:	vmovle.f32	s14, s10
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    626a:	vadd.f32	s15, s15, s14
    626e:	vadd.f32	s15, s15, s11
    6272:	vcvt.s32.f32	s15, s15
    6276:	vmov	r3, s15
    CONSTRAIN(q, 0, num_steps - 1);
    627a:	cmp	r3, #0
    627c:	blt.w	683c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x6a0>
    6280:	cmp	r2, r3
    6282:	it	gt
    6284:	movgt	r4, r3
  void Init() {
    num_engines_ = 0;
  }

  inline Engine* get(int index) {
    return engine_[index];
    6286:	movw	r2, #4176	; 0x1050
      engines_.size(),
      0.25f);
  
  Engine* e = engines_.get(engine_index);
  
  if (engine_index != previous_engine_index_) {
    628a:	ldr.w	r3, [r6, #4040]	; 0xfc8
    quantized_value_ = q;
    628e:	str.w	r4, [r6, #4036]	; 0xfc4
    6292:	add	r2, r6
    6294:	cmp	r3, r4
    6296:	ldr.w	fp, [r2, r4, lsl #2]
    629a:	beq.n	62ba <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x11e>
    e->Reset();
    629c:	ldr.w	r3, [fp]
    62a0:	mov	r0, fp
    62a2:	ldr	r3, [r3, #4]
    62a4:	blx	r3
    62a6:	movw	r2, #4120	; 0x1018
    62aa:	mov.w	r3, #1056964608	; 0x3f000000
    62ae:	ldrb.w	r1, [r7, #35]	; 0x23
    62b2:	add	r2, r6
    62b4:	str	r3, [r2, #0]
    out_post_processor_.Reset();
    previous_engine_index_ = engine_index;
    62b6:	str.w	r4, [r6, #4040]	; 0xfc8
  }
  EngineParameters p;

  bool rising_edge = trigger_state_ && !previous_trigger_state;
    62ba:	ldrb.w	r3, [r6, #4052]	; 0xfd4
    62be:	cmp	r3, r9
    62c0:	bls.n	6300 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x164>
  float note = (modulations.note + previous_note_) * 0.5f;
    62c2:	add.w	r3, r6, #4048	; 0xfd0
    62c6:	vldr	s13, [r7, #4]
    62ca:	vmov.f32	s15, #96	; 0x3f000000  0.5
    62ce:	vldr	s9, [r3]
  previous_note_ = modulations.note;
    62d2:	vstr	s13, [r3]
    previous_engine_index_ = engine_index;
  }
  EngineParameters p;

  bool rising_edge = trigger_state_ && !previous_trigger_state;
  float note = (modulations.note + previous_note_) * 0.5f;
    62d6:	vadd.f32	s13, s13, s9
    62da:	vmul.f32	s9, s13, s15
  previous_note_ = modulations.note;
  const PostProcessingSettings& pp_s = e->post_processing_settings;

  if (modulations.trigger_patched) {
    62de:	cbz	r1, 6322 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x186>
    p.trigger = rising_edge ? TRIGGER_RISING_EDGE : TRIGGER_LOW;
    62e0:	movs	r3, #1
    62e2:	strb.w	r3, [sp, #24]
    62e6:	movs	r2, #1
    62e8:	b.n	632a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x18e>
    62ea:	nop
    62ec:	.word	0x00000000
    62f0:	.word	0xc2c00000
    62f4:	.word	0x43000000
    62f8:	.word	0x3fa66666
    62fc:	.word	0x3e99999a
    previous_engine_index_ = engine_index;
  }
  EngineParameters p;

  bool rising_edge = trigger_state_ && !previous_trigger_state;
  float note = (modulations.note + previous_note_) * 0.5f;
    6300:	add.w	r3, r6, #4048	; 0xfd0
    6304:	vldr	s14, [r7, #4]
    6308:	vmov.f32	s15, #96	; 0x3f000000  0.5
    630c:	vldr	s9, [r3]
  previous_note_ = modulations.note;
    6310:	vstr	s14, [r3]
    previous_engine_index_ = engine_index;
  }
  EngineParameters p;

  bool rising_edge = trigger_state_ && !previous_trigger_state;
  float note = (modulations.note + previous_note_) * 0.5f;
    6314:	vadd.f32	s14, s14, s9
    6318:	vmul.f32	s9, s14, s15
  previous_note_ = modulations.note;
  const PostProcessingSettings& pp_s = e->post_processing_settings;

  if (modulations.trigger_patched) {
    631c:	cmp	r1, #0
    631e:	bne.w	6ac2 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x926>
    p.trigger = rising_edge ? TRIGGER_RISING_EDGE : TRIGGER_LOW;
  } else {
    p.trigger = TRIGGER_UNPATCHED;
    6322:	movs	r3, #2
    6324:	movs	r2, #0
    6326:	strb.w	r3, [sp, #24]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    632a:	vldr	s10, [r8, #32]
  inline void Trigger() {
    value_ = 1.0f;
  }
  
  inline void Process(float decay) {
    value_ *= (1.0f - decay);
    632e:	vmov.f32	s11, #112	; 0x3f800000  1.0
      SemitonesToRatio(-96.0f * patch.decay);

  decay_envelope_.Process(short_decay * 2.0f);

  const float compressed_level = max(
      1.3f * modulations.level / (0.3f + fabsf(modulations.level)),
    6332:	vldr	s14, [r7, #28]
    6336:	vmov.f32	s13, #0	; 0x40000000  2.0
    633a:	vldr	s12, [pc, #-76]	; 62f0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x154>
    633e:	vldr	s15, [pc, #-76]	; 62f4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x158>
    6342:	vldr	s8, [pc, #-76]	; 62f8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x15c>
    6346:	vfma.f32	s15, s10, s12
    634a:	vldr	s10, [pc, #-80]	; 62fc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x160>
    634e:	vabs.f32	s12, s14
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    6352:	ldr.w	sl, [pc, #812]	; 6680 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4e4>
    6356:	vmul.f32	s14, s14, s8
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    635a:	ldr.w	r9, [pc, #808]	; 6684 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4e8>
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
	return __b;
    635e:	vldr	s8, [pc, #844]	; 66ac <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x510>
    6362:	vadd.f32	s10, s12, s10
  } else {
    p.trigger = TRIGGER_UNPATCHED;
  }
  
  const float short_decay = (200.0f * kBlockSize) / kSampleRate *
      SemitonesToRatio(-96.0f * patch.decay);
    6366:	vldr	s6, [pc, #772]	; 666c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4d0>
  decay_envelope_.Process(short_decay * 2.0f);

  const float compressed_level = max(
      1.3f * modulations.level / (0.3f + fabsf(modulations.level)),
      0.0f);
  p.accent = modulations.level_patched ? compressed_level : 0.8f;
    636a:	ldrb.w	r1, [r7, #36]	; 0x24
extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    636e:	vcvt.s32.f32	s12, s15

  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
    6372:	vldr	s5, [r7, #12]
      SemitonesToRatio(-96.0f * patch.decay);

  decay_envelope_.Process(short_decay * 2.0f);

  const float compressed_level = max(
      1.3f * modulations.level / (0.3f + fabsf(modulations.level)),
    6376:	vdiv.f32	s17, s14, s10
      0.0f);
  p.accent = modulations.level_patched ? compressed_level : 0.8f;
    637a:	vldr	s10, [pc, #828]	; 66b8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x51c>

  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
    637e:	vldr	s14, [r8, #4]

  return lut_pitch_ratio_high[pitch_integral] * \
    6382:	vmov	r3, s12
    6386:	vldr	s7, [r5]
    638a:	add.w	r3, sl, r3, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    638e:	vcvt.f32.s32	s12, s12
  } else {
    p.trigger = TRIGGER_UNPATCHED;
  }
  
  const float short_decay = (200.0f * kBlockSize) / kSampleRate *
      SemitonesToRatio(-96.0f * patch.decay);
    6392:	vldr	s16, [r3]

  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
    6396:	vadd.f32	s14, s14, s5
    639a:	vsub.f32	s15, s15, s12
    639e:	vstr	s14, [sp, #40]	; 0x28
    63a2:	vcvt.s32.f32	s15, s15, #8
    63a6:	vmov	r3, s15
    63aa:	add.w	r3, r9, r3, lsl #2
    63ae:	vcmp.f32	s17, s8
  } else {
    p.trigger = TRIGGER_UNPATCHED;
  }
  
  const float short_decay = (200.0f * kBlockSize) / kSampleRate *
      SemitonesToRatio(-96.0f * patch.decay);
    63b2:	vldr	s12, [r3]
    63b6:	vmrs	APSR_nzcv, fpscr
    63ba:	vmul.f32	s12, s12, s16
  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);
    63be:	vcmpe.f32	s14, s8
    63c2:	it	mi
    63c4:	vmovmi.f32	s17, s8
  decay_envelope_.Process(short_decay * 2.0f);

  const float compressed_level = max(
      1.3f * modulations.level / (0.3f + fabsf(modulations.level)),
      0.0f);
  p.accent = modulations.level_patched ? compressed_level : 0.8f;
    63c8:	cmp	r1, #0
  } else {
    p.trigger = TRIGGER_UNPATCHED;
  }
  
  const float short_decay = (200.0f * kBlockSize) / kSampleRate *
      SemitonesToRatio(-96.0f * patch.decay);
    63ca:	vmul.f32	s16, s12, s6
  decay_envelope_.Process(short_decay * 2.0f);

  const float compressed_level = max(
      1.3f * modulations.level / (0.3f + fabsf(modulations.level)),
      0.0f);
  p.accent = modulations.level_patched ? compressed_level : 0.8f;
    63ce:	ite	eq
    63d0:	vmoveq.f32	s12, s10
    63d4:	vmovne.f32	s12, s17
    63d8:	vneg.f32	s18, s16
    63dc:	vmov.f32	s10, s11
  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);
    63e0:	vmrs	APSR_nzcv, fpscr
  decay_envelope_.Process(short_decay * 2.0f);

  const float compressed_level = max(
      1.3f * modulations.level / (0.3f + fabsf(modulations.level)),
      0.0f);
  p.accent = modulations.level_patched ? compressed_level : 0.8f;
    63e4:	vstr	s12, [sp, #44]	; 0x2c
    63e8:	vfma.f32	s10, s18, s13
    63ec:	vmul.f32	s10, s10, s7
    63f0:	vstr	s10, [r5]
  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);
    63f4:	bmi.w	67fe <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x662>
    63f8:	vcmpe.f32	s14, s11
    63fc:	vmrs	APSR_nzcv, fpscr
    6400:	ble.w	6cf4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xb58>

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    6404:	cmp	r4, #7
  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);
    6406:	vstr	s11, [sp, #40]	; 0x28

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    640a:	beq.w	6cd8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xb3c>
  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);

  float internal_envelope_amplitude = 1.0f;
    640e:	vmov.f32	s13, s11
    6412:	ldrb.w	r3, [r7, #32]
    6416:	ldrb.w	r1, [r7, #34]	; 0x22
            0.0f : patch.morph_modulation_amount);
  }

  p.note = ApplyModulations(
      patch.note + note,
      patch.frequency_modulation_amount,
    641a:	vldr	s14, [r8, #16]
      modulations.frequency_patched,
      modulations.frequency,
      use_internal_envelope,
      internal_envelope_amplitude * \
    641e:	vmul.f32	s13, s13, s10
      float envelope,
      float default_internal_modulation,
      float minimum_value,
      float maximum_value) {
    float value = base_value;
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    6422:	vldr	s12, [pc, #652]	; 66b0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x514>
    6426:	vabs.f32	s11, s14
    modulation_amount *= 1.05f;
    642a:	vldr	s7, [pc, #580]	; 6670 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4d4>
    speech_engine_.set_speed( 
        !modulations.trigger_patched || modulations.morph_patched ?
            0.0f : patch.morph_modulation_amount);
  }

  p.note = ApplyModulations(
    642e:	vldr	s15, [r8]
      patch.note + note,
      patch.frequency_modulation_amount,
      modulations.frequency_patched,
      modulations.frequency,
    6432:	vldr	s8, [r7, #8]
      float envelope,
      float default_internal_modulation,
      float minimum_value,
      float maximum_value) {
    float value = base_value;
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    6436:	vsub.f32	s11, s11, s12
    speech_engine_.set_speed( 
        !modulations.trigger_patched || modulations.morph_patched ?
            0.0f : patch.morph_modulation_amount);
  }

  p.note = ApplyModulations(
    643a:	vadd.f32	s15, s9, s15
      return __a;
    643e:	vcmpe.f32	s11, s12
    6442:	vmrs	APSR_nzcv, fpscr
    6446:	it	pl
    6448:	vmovpl.f32	s12, s11
    644c:	vmul.f32	s14, s14, s12
    modulation_amount *= 1.05f;
    6450:	vmul.f32	s14, s14, s7
    
    float modulation = use_external_modulation
        ? external_modulation
        : (use_internal_envelope ? envelope : default_internal_modulation);
    6454:	cbnz	r3, 6468 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x2cc>
    6456:	cmp	r2, #0
    6458:	beq.w	67c8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x62c>
    645c:	vmul.f32	s12, s13, s10
    6460:	vldr	s8, [pc, #528]	; 6674 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4d8>
    6464:	vmul.f32	s8, s12, s8
    value += modulation_amount * modulation;
    6468:	vfma.f32	s15, s14, s8
    CONSTRAIN(value, minimum_value, maximum_value);
    646c:	vldr	s14, [pc, #520]	; 6678 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4dc>
    6470:	vcmpe.f32	s15, s14
    6474:	vmrs	APSR_nzcv, fpscr
    6478:	bmi.w	6798 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x5fc>
    647c:	vldr	s14, [pc, #508]	; 667c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4e0>
    6480:	vcmp.f32	s15, s14
    6484:	vmrs	APSR_nzcv, fpscr
    6488:	it	gt
    648a:	vmovgt.f32	s15, s14
      -119.0f,
      120.0f);

  p.timbre = ApplyModulations(
      patch.timbre,
      patch.timbre_modulation_amount,
    648e:	vldr	s14, [r8, #20]
      float envelope,
      float default_internal_modulation,
      float minimum_value,
      float maximum_value) {
    float value = base_value;
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    6492:	vldr	s12, [pc, #540]	; 66b0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x514>
    6496:	vabs.f32	s11, s14
    modulation_amount *= 1.05f;
    649a:	vldr	s8, [pc, #468]	; 6670 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4d4>
      modulations.timbre_patched,
    649e:	ldrb.w	r3, [r7, #33]	; 0x21
      use_internal_envelope,
      internal_envelope_amplitude * \
          decay_envelope_.value() * decay_envelope_.value() * 48.0f,
      1.0f,
      -119.0f,
      120.0f);
    64a2:	vstr	s15, [sp, #28]
      float envelope,
      float default_internal_modulation,
      float minimum_value,
      float maximum_value) {
    float value = base_value;
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    64a6:	vsub.f32	s11, s11, s12

  p.timbre = ApplyModulations(
      patch.timbre,
    64aa:	vldr	s15, [r8, #8]
      patch.timbre_modulation_amount,
      modulations.timbre_patched,
      modulations.timbre,
    64ae:	vldr	s9, [r7, #16]
    64b2:	vcmpe.f32	s11, s12
    64b6:	vmrs	APSR_nzcv, fpscr
    64ba:	it	pl
    64bc:	vmovpl.f32	s12, s11
    64c0:	vmul.f32	s14, s14, s12
    modulation_amount *= 1.05f;
    64c4:	vmul.f32	s14, s14, s8
    
    float modulation = use_external_modulation
        ? external_modulation
        : (use_internal_envelope ? envelope : default_internal_modulation);
    64c8:	cbnz	r3, 64d6 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x33a>
    64ca:	cmp	r2, #0
    64cc:	vldr	s9, [pc, #476]	; 66ac <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x510>
    64d0:	it	ne
    64d2:	vmovne.f32	s9, s10
    value += modulation_amount * modulation;
    64d6:	vfma.f32	s15, s14, s9
    CONSTRAIN(value, minimum_value, maximum_value);
    64da:	vcmpe.f32	s15, #0.0
    64de:	vmrs	APSR_nzcv, fpscr
    64e2:	bmi.w	67f8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x65c>
    64e6:	vmov.f32	s14, #112	; 0x3f800000  1.0
    64ea:	vcmp.f32	s15, s14
    64ee:	vmrs	APSR_nzcv, fpscr
    64f2:	it	gt
    64f4:	vmovgt.f32	s15, s14
      0.0f,
      1.0f);

  p.morph = ApplyModulations(
      patch.morph,
      patch.morph_modulation_amount,
    64f8:	vldr	s14, [r8, #24]
      float envelope,
      float default_internal_modulation,
      float minimum_value,
      float maximum_value) {
    float value = base_value;
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    64fc:	vldr	s12, [pc, #432]	; 66b0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x514>
    6500:	vabs.f32	s11, s14
    modulation_amount *= 1.05f;
    6504:	vldr	s9, [pc, #360]	; 6670 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4d4>
      modulations.timbre,
      use_internal_envelope,
      decay_envelope_.value(),
      0.0f,
      0.0f,
      1.0f);
    6508:	vstr	s15, [sp, #32]

  p.morph = ApplyModulations(
      patch.morph,
      patch.morph_modulation_amount,
      modulations.morph_patched,
      modulations.morph,
    650c:	vldr	s10, [r7, #20]
      float envelope,
      float default_internal_modulation,
      float minimum_value,
      float maximum_value) {
    float value = base_value;
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    6510:	vsub.f32	s11, s11, s12
      0.0f,
      0.0f,
      1.0f);

  p.morph = ApplyModulations(
      patch.morph,
    6514:	vldr	s15, [r8, #12]
    6518:	vcmpe.f32	s11, s12
    651c:	vmrs	APSR_nzcv, fpscr
    6520:	it	pl
    6522:	vmovpl.f32	s12, s11
    6526:	vmul.f32	s14, s14, s12
    modulation_amount *= 1.05f;
    652a:	vmul.f32	s14, s14, s9
    
    float modulation = use_external_modulation
        ? external_modulation
        : (use_internal_envelope ? envelope : default_internal_modulation);
    652e:	cbnz	r1, 653c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x3a0>
    6530:	cmp	r2, #0
    6532:	vldr	s10, [pc, #376]	; 66ac <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x510>
    6536:	it	ne
    6538:	vmovne.f32	s10, s13
    value += modulation_amount * modulation;
    653c:	vfma.f32	s15, s14, s10
    CONSTRAIN(value, minimum_value, maximum_value);
    6540:	vcmpe.f32	s15, #0.0
    6544:	vmrs	APSR_nzcv, fpscr
    6548:	bmi.w	67f2 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x656>
    654c:	vmov.f32	s14, #112	; 0x3f800000  1.0
    6550:	vcmp.f32	s15, s14
    6554:	vmrs	APSR_nzcv, fpscr
    6558:	it	gt
    655a:	vmovgt.f32	s15, s14
      internal_envelope_amplitude * decay_envelope_.value(),
      0.0f,
      0.0f,
      1.0f);

  bool already_enveloped = pp_s.already_enveloped;
    655e:	ldrb.w	r0, [fp, #12]
  e->Render(p, out_buffer_, aux_buffer_, size, &already_enveloped);
    6562:	movw	r3, #4244	; 0x1094
    6566:	movw	r4, #4756	; 0x1294
    656a:	ldr.w	lr, [fp]
    656e:	add	r3, r6
    6570:	add.w	ip, sp, #23
      internal_envelope_amplitude * decay_envelope_.value(),
      0.0f,
      0.0f,
      1.0f);

  bool already_enveloped = pp_s.already_enveloped;
    6574:	strb.w	r0, [sp, #23]
  e->Render(p, out_buffer_, aux_buffer_, size, &already_enveloped);
    6578:	add	r4, r6
    657a:	ldr	r0, [sp, #104]	; 0x68
    657c:	mov	r2, r3
    657e:	str	r3, [sp, #12]
    6580:	add	r1, sp, #24
    6582:	str	r0, [sp, #0]
    6584:	mov	r3, r4
    6586:	str.w	ip, [sp, #4]
    658a:	mov	r0, fp
      modulations.morph,
      use_internal_envelope,
      internal_envelope_amplitude * decay_envelope_.value(),
      0.0f,
      0.0f,
      1.0f);
    658c:	vstr	s15, [sp, #36]	; 0x24

  bool already_enveloped = pp_s.already_enveloped;
  e->Render(p, out_buffer_, aux_buffer_, size, &already_enveloped);
    6590:	ldr.w	r5, [lr, #8]
    6594:	blx	r5
  
  bool lpg_bypass = already_enveloped || \
    6596:	ldrb.w	r3, [sp, #23]
    659a:	cbnz	r3, 65b0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x414>
      (!modulations.level_patched && !modulations.trigger_patched);
    659c:	ldrb.w	r2, [r7, #36]	; 0x24
      1.0f);

  bool already_enveloped = pp_s.already_enveloped;
  e->Render(p, out_buffer_, aux_buffer_, size, &already_enveloped);
  
  bool lpg_bypass = already_enveloped || \
    65a0:	cmp	r2, #0
    65a2:	bne.w	66c8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x52c>
      (!modulations.level_patched && !modulations.trigger_patched);
    65a6:	ldrb.w	r3, [r7, #35]	; 0x23
    65aa:	cmp	r3, #0
    65ac:	bne.w	66c8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x52c>
    65b0:	add.w	r8, r6, #4064	; 0xfe0
    65b4:	addw	ip, r6, #4068	; 0xfe4
    65b8:	addw	lr, r6, #4072	; 0xfe8
    float vactrol_state_4 = vactrol_state_2 * vactrol_state_2;
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    65bc:	movs	r7, #1
    65be:	vldr	s4, [r8]
    65c2:	vldr	s5, [ip]
    65c6:	vldr	s9, [lr]
      lpg_envelope_.ProcessPing(attack, short_decay, decay_tail, hf);
    }
  }
  
  out_post_processor_.Process(
      pp_s.out_gain,
    65ca:	vldr	s12, [fp, #4]
      float low_pass_gate_hf_bleed,
      float* in,
      float* out,
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
    65ce:	vcmpe.f32	s12, #0.0
    65d2:	vmrs	APSR_nzcv, fpscr
    65d6:	bmi.w	6840 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x6a4>
      limiter_.Process(-gain, in, size);
    }
    const float post_gain = (gain < 0.0f ? 1.0f : gain) * -0.6f;
    65da:	bmi.w	6d50 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbb4>
    65de:	vldr	s13, [pc, #220]	; 66bc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x520>
    65e2:	ldr	r3, [sp, #104]	; 0x68
    65e4:	vmul.f32	s13, s12, s13
    65e8:	subs	r3, #1
    if (!bypass_lpg) {
    65ea:	cmp	r7, #0
    65ec:	beq.w	68c8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x72c>
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    65f0:	ldr	r2, [sp, #104]	; 0x68
    65f2:	cmp	r2, #0
    65f4:	beq.w	6d1a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xb7e>
    65f8:	ldr	r2, [sp, #8]
    65fa:	ldr	r5, [sp, #12]
    65fc:	add.w	r1, r2, #8
    6600:	mov	r2, r3
        *out = *in++ * post_gain;
    6602:	vldmia	r5!, {s15}
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    6606:	subs	r2, #1
    6608:	adds	r1, #8
        *out = *in++ * post_gain;
    660a:	vmul.f32	s15, s15, s13
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    660e:	adds	r0, r2, #1
        *out = *in++ * post_gain;
    6610:	vstr	s15, [r1, #-16]
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    6614:	bne.n	6602 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x466>
      &frames->out,
      size,
      2);

  aux_post_processor_.Process(
      pp_s.aux_gain,
    6616:	vldr	s15, [fp, #8]
      out_buffer_,
      &frames->out,
      size,
      2);

  aux_post_processor_.Process(
    661a:	ldr	r2, [sp, #8]
      float low_pass_gate_hf_bleed,
      float* in,
      float* out,
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
    661c:	vcmpe.f32	s15, #0.0
    6620:	vldr	s4, [r8]
    6624:	adds	r2, #4
    6626:	vldr	s5, [ip]
    662a:	vldr	s9, [lr]
    662e:	vmrs	APSR_nzcv, fpscr
    6632:	bmi.w	6acc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x930>
      limiter_.Process(-gain, in, size);
    }
    const float post_gain = (gain < 0.0f ? 1.0f : gain) * -0.6f;
    6636:	bmi.w	6d5a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbbe>
    663a:	vldr	s13, [pc, #128]	; 66bc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x520>
    663e:	vmul.f32	s13, s15, s13
    if (!bypass_lpg) {
    6642:	cmp	r7, #0
    6644:	beq.w	69de <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x842>
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    6648:	ldr	r1, [sp, #104]	; 0x68
    664a:	cbz	r1, 6662 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4c6>
    664c:	adds	r2, #8
        *out = *in++ * post_gain;
    664e:	vldmia	r4!, {s15}
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    6652:	subs	r3, #1
    6654:	adds	r2, #8
        *out = *in++ * post_gain;
    6656:	vmul.f32	s15, s15, s13
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    665a:	adds	r1, r3, #1
        *out = *in++ * post_gain;
    665c:	vstr	s15, [r2, #-16]
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    6660:	bne.n	664e <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4b2>
      lpg_envelope_.hf_bleed(),
      aux_buffer_,
      &frames->aux,
      size,
      2);
}
    6662:	add	sp, #52	; 0x34
    6664:	vpop	{d8-d9}
    6668:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    666c:	.word	0x3f088889
    6670:	.word	0x3f866666
    6674:	.word	0x42400000
    6678:	.word	0xc2ee0000
    667c:	.word	0x42f00000
    6680:	.word	0x20000554
    6684:	.word	0x20000958
    6688:	.word	0xc2900000
    668c:	.word	0x43000000
    6690:	.word	0x43800000
    6694:	.word	0x3d5a740e
    6698:	.word	0xc3000000
    669c:	.word	0x42fe0000
    66a0:	.word	0x3e99999a
    66a4:	.word	0x3b449ba6
    66a8:	.word	0x3dcccccd
    66ac:	.word	0x00000000
    66b0:	.word	0x3d4ccccd
    66b4:	.word	0x37a7c5ac
    66b8:	.word	0x3f4ccccd
    66bc:	.word	0xbf19999a
    66c0:	.word	0x413957d7
    66c4:	.word	0x40490fdb

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    66c8:	vmov.f32	s15, #40	; 0x41400000  12.0
  bool lpg_bypass = already_enveloped || \
      (!modulations.level_patched && !modulations.trigger_patched);
  
  // Compute LPG parameters.
  if (!lpg_bypass) {
    const float hf = patch.lpg_colour;
    66cc:	vldr	s11, [r8, #36]	; 0x24
    66d0:	vldr	s9, [r8, #32]
    66d4:	vldr	s14, [pc, #-80]	; 6688 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4ec>
    66d8:	vmul.f32	s15, s11, s15
    66dc:	vldr	s12, [pc, #-84]	; 668c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4f0>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    66e0:	vldr	s13, [pc, #-84]	; 6690 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4f4>
    const float decay_tail = (20.0f * kBlockSize) / kSampleRate *
        SemitonesToRatio(-72.0f * patch.decay + 12.0f * hf) - short_decay;
    66e4:	vldr	s10, [pc, #-84]	; 6694 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4f8>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    66e8:	vfma.f32	s15, s9, s14
    66ec:	vadd.f32	s15, s15, s12
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    66f0:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    66f4:	vcvt.f32.s32	s8, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    66f8:	vmov	r3, s14
    66fc:	add.w	r3, sl, r3, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    6700:	vsub.f32	s15, s15, s8
    6704:	vldr	s9, [r3]
    6708:	vmul.f32	s15, s15, s13
    670c:	vcvt.s32.f32	s15, s15
    6710:	vmov	r3, s15
    6714:	add.w	r3, r9, r3, lsl #2
    6718:	vldr	s14, [r3]
    671c:	vmul.f32	s14, s14, s9
    6720:	vfma.f32	s18, s14, s10
    
    if (modulations.level_patched) {
    6724:	cmp	r2, #0
    6726:	bne.w	6c34 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xa98>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    672a:	vmov.f32	s10, #34	; 0x41100000  9.0
    672e:	vldr	s15, [sp, #28]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    6732:	vldr	s14, [pc, #-156]	; 6698 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4fc>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    6736:	vsub.f32	s15, s15, s10
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    673a:	vcmpe.f32	s15, s14
    673e:	vmrs	APSR_nzcv, fpscr
    6742:	bmi.w	6b44 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x9a8>
    6746:	vldr	s14, [pc, #-172]	; 669c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x500>
    674a:	vcmpe.f32	s15, s14
    674e:	vmrs	APSR_nzcv, fpscr
    6752:	ble.w	6cb6 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xb1a>
  inline void ProcessPing(
      float attack,
      float short_decay,
      float decay_tail,
      float hf) {
    if (ramp_up_) {
    6756:	ldrb.w	r1, [r6, #4076]	; 0xfec
    675a:	movs	r3, #255	; 0xff
    675c:	cmp	r1, #0
    675e:	bne.w	6b50 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x9b4>
    6762:	addw	r3, r6, #4060	; 0xfdc
    6766:	vmov.f32	s10, #112	; 0x3f800000  1.0
    676a:	vldr	s8, [pc, #-204]	; 66a0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x504>
    676e:	vldr	s14, [r3]
    6772:	vldr	s13, [pc, #-208]	; 66a4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x508>
    6776:	vsub.f32	s15, s10, s14
    677a:	vldr	s9, [pc, #-208]	; 66ac <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x510>
    677e:	vmul.f32	s12, s14, s14
    6782:	vsub.f32	s9, s9, s14
    6786:	vmul.f32	s15, s15, s15
    678a:	vmul.f32	s12, s12, s12
    678e:	vsub.f32	s10, s10, s15
    6792:	vfma.f32	s13, s12, s8
    6796:	b.n	6be2 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xa46>
    
    float modulation = use_external_modulation
        ? external_modulation
        : (use_internal_envelope ? envelope : default_internal_modulation);
    value += modulation_amount * modulation;
    CONSTRAIN(value, minimum_value, maximum_value);
    6798:	vmov.f32	s15, s14
    679c:	b.n	648e <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x2f2>
    if (trigger_value < 0.1f) {
      trigger_state_ = false;
    }
  }
  if (!modulations.trigger_patched) {
    engine_cv_ = modulations.engine;
    679e:	vldr	s12, [r7]
    67a2:	vstr	s12, [r3]
    67a6:	b.n	6228 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x8c>
      }
      decay_envelope_.Trigger();
      engine_cv_ = modulations.engine;
    }
  } else {
    if (trigger_value < 0.1f) {
    67a8:	vldr	s14, [pc, #-260]	; 66a8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x50c>
    67ac:	vcmpe.f32	s15, s14
    67b0:	vmrs	APSR_nzcv, fpscr
    67b4:	bpl.w	6212 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x76>
      trigger_state_ = false;
    67b8:	movs	r2, #0
    67ba:	addw	r5, r6, #4056	; 0xfd8
    67be:	addw	r3, r6, #4044	; 0xfcc
    67c2:	strb.w	r2, [r6, #4052]	; 0xfd4
    67c6:	b.n	621a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x7e>
    modulation_amount *= std::max(fabsf(modulation_amount) - 0.05f, 0.05f);
    modulation_amount *= 1.05f;
    
    float modulation = use_external_modulation
        ? external_modulation
        : (use_internal_envelope ? envelope : default_internal_modulation);
    67c8:	vmov.f32	s8, #112	; 0x3f800000  1.0
    67cc:	b.n	6468 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x2cc>
  float trigger_value = trigger_delay_.Read(kTriggerDelay);
  
  bool previous_trigger_state = trigger_state_;
  if (!previous_trigger_state) {
    if (trigger_value > 0.3f) {
      trigger_state_ = true;
    67ce:	movs	r3, #1
      if (!modulations.level_patched) {
    67d0:	ldrb.w	r2, [r7, #36]	; 0x24
  float trigger_value = trigger_delay_.Read(kTriggerDelay);
  
  bool previous_trigger_state = trigger_state_;
  if (!previous_trigger_state) {
    if (trigger_value > 0.3f) {
      trigger_state_ = true;
    67d4:	strb.w	r3, [r6, #4052]	; 0xfd4
      if (!modulations.level_patched) {
    67d8:	cbnz	r2, 67de <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x642>
    frequency_ = 0.5f;
    hf_bleed_ = 0.0f;
  }
  
  inline void Trigger() {
    ramp_up_ = true;
    67da:	strb.w	r3, [r6, #4076]	; 0xfec
        lpg_envelope_.Trigger();
      }
      decay_envelope_.Trigger();
      engine_cv_ = modulations.engine;
    67de:	ldr	r2, [r7, #0]
  inline void Init() {
    value_ = 0.0f;
  }
  
  inline void Trigger() {
    value_ = 1.0f;
    67e0:	mov.w	r1, #1065353216	; 0x3f800000
    67e4:	addw	r5, r6, #4056	; 0xfd8
    67e8:	addw	r3, r6, #4044	; 0xfcc
    67ec:	str	r1, [r5, #0]
    67ee:	str	r2, [r3, #0]
    67f0:	b.n	621a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x7e>
    value += modulation_amount * modulation;
    CONSTRAIN(value, minimum_value, maximum_value);
    67f2:	vldr	s15, [pc, #-328]	; 66ac <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x510>
    67f6:	b.n	655e <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x3c2>
    67f8:	vldr	s15, [pc, #-336]	; 66ac <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x510>
    67fc:	b.n	64f8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x35c>
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    67fe:	cmp	r4, #7
  bool use_internal_envelope = modulations.trigger_patched;

  // Actual synthesis parameters.
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);
    6800:	vstr	s8, [sp, #40]	; 0x28

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    6804:	bne.w	640e <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x272>
    internal_envelope_amplitude = 2.0f - p.harmonics * 6.0f;
    CONSTRAIN(internal_envelope_amplitude, 0.0f, 1.0f);
    6808:	vmov.f32	s13, #112	; 0x3f800000  1.0
    speech_engine_.set_prosody_amount(
    680c:	cmp	r2, #0
    680e:	beq.w	6ce2 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xb46>
        !modulations.trigger_patched || modulations.frequency_patched ?
    6812:	ldrb.w	r3, [r7, #32]
    6816:	cmp	r3, #0
    6818:	bne.w	6d3c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xba0>

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    internal_envelope_amplitude = 2.0f - p.harmonics * 6.0f;
    CONSTRAIN(internal_envelope_amplitude, 0.0f, 1.0f);
    speech_engine_.set_prosody_amount(
    681c:	ldr.w	r4, [r8, #16]
      float* aux,
      size_t size,
      bool* already_enveloped);
  
  inline void set_prosody_amount(float prosody_amount) {
    prosody_amount_ = prosody_amount;
    6820:	addw	r0, r6, #2852	; 0xb24
        !modulations.trigger_patched || modulations.frequency_patched ?
            0.0f : patch.frequency_modulation_amount);
    speech_engine_.set_speed( 
        !modulations.trigger_patched || modulations.morph_patched ?
    6824:	ldrb.w	r1, [r7, #34]	; 0x22
    6828:	str	r4, [r0, #0]
    682a:	cmp	r1, #0
    682c:	bne.w	6d40 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xba4>
    internal_envelope_amplitude = 2.0f - p.harmonics * 6.0f;
    CONSTRAIN(internal_envelope_amplitude, 0.0f, 1.0f);
    speech_engine_.set_prosody_amount(
        !modulations.trigger_patched || modulations.frequency_patched ?
            0.0f : patch.frequency_modulation_amount);
    speech_engine_.set_speed( 
    6830:	ldr.w	r0, [r8, #24]
  }
  
  inline void set_speed(float speed) {
    speed_ = speed;
    6834:	addw	r4, r6, #2856	; 0xb28
    6838:	str	r0, [r4, #0]
    683a:	b.n	641a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x27e>
    value += static_cast<float>(base);
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    CONSTRAIN(q, 0, num_steps - 1);
    683c:	movs	r4, #0
    683e:	b.n	6286 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xea>
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    6840:	ldr	r3, [sp, #104]	; 0x68
      float* in,
      float* out,
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
      limiter_.Process(-gain, in, size);
    6842:	vneg.f32	s12, s12
    6846:	ldr	r2, [sp, #104]	; 0x68
    6848:	subs	r3, #1
    684a:	cbz	r2, 68be <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x722>
    684c:	movw	r2, #4120	; 0x1018
    6850:	ldr	r5, [sp, #12]
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
    6852:	vmov.f32	s10, #112	; 0x3f800000  1.0
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    6856:	mov	r1, r3
    6858:	mov	r0, r5
    685a:	add	r2, r6
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    685c:	vldr	s6, [pc, #-432]	; 66b0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x514>
    6860:	vldr	s7, [pc, #-432]	; 66b4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x518>
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
      *in_out++ = s * gain * 0.8f;
    6864:	vldr	s8, [pc, #-432]	; 66b8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x51c>
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
    6868:	vldr	s15, [r0]
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    686c:	subs	r1, #1
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    686e:	vldr	s13, [r2]
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
    6872:	vmul.f32	s15, s12, s15
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    6876:	vabs.f32	s14, s15
    687a:	vsub.f32	s14, s14, s13
    687e:	vcmpe.f32	s14, #0.0
    6882:	vmrs	APSR_nzcv, fpscr
    6886:	ite	le
    6888:	vmovle.f32	s11, s7
    688c:	vmovgt.f32	s11, s6
    6890:	vfma.f32	s13, s14, s11
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
    6894:	vcmpe.f32	s13, s10
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    6898:	vstr	s13, [r2]
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
    689c:	vmrs	APSR_nzcv, fpscr
    68a0:	ite	hi
    68a2:	vdivhi.f32	s14, s10, s13
    68a6:	vmovls.f32	s14, #112	; 0x3f800000  1.0
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    68aa:	cmp.w	r1, #4294967295
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
      *in_out++ = s * gain * 0.8f;
    68ae:	vmul.f32	s15, s15, s14
    68b2:	vmul.f32	s15, s15, s8
    68b6:	vstmia	r0!, {s15}
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    68ba:	bne.n	6868 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x6cc>
    68bc:	str	r5, [sp, #12]
    }
    const float post_gain = (gain < 0.0f ? 1.0f : gain) * -0.6f;
    68be:	vldr	s13, [pc, #-516]	; 66bc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x520>
    if (!bypass_lpg) {
    68c2:	cmp	r7, #0
    68c4:	bne.w	65f0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x454>
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    68c8:	movw	r9, #4124	; 0x101c
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    68cc:	vldr	s15, [pc, #-528]	; 66c0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x524>
    increment_ = (new_value - *state) / static_cast<float>(size);
    68d0:	vldr	s11, [sp, #104]	; 0x68
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    68d4:	vmov.f32	s10, #112	; 0x3f800000  1.0
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    68d8:	add	r9, r6
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    68da:	vmul.f32	s15, s5, s15
    increment_ = (new_value - *state) / static_cast<float>(size);
    68de:	vcvt.f32.u32	s8, s11
    68e2:	vldr	s12, [pc, #-544]	; 66c4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x528>
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    68e6:	vldr	s11, [r9]
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    68ea:	vmov.f32	s14, #4	; 0x40200000  2.5
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    68ee:	vfma.f32	s12, s15, s5

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    68f2:	add.w	r2, r6, #4128	; 0x1020
    increment_ = (new_value - *state) / static_cast<float>(size);
    68f6:	vmov.f32	s15, s11
      float* out,
      size_t size,
      size_t stride) {
    stmlib::ParameterInterpolator gain_modulation(&previous_gain_, gain, size);
    filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(frequency, 0.4f);
    while (size--) {
    68fa:	ldr	r1, [sp, #104]	; 0x68
    r_ = 1.0f / resonance;
    68fc:	vstr	s14, [r2, #4]
    6900:	vfnms.f32	s15, s13, s4
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    6904:	vmul.f32	s12, s12, s5

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6908:	vstr	s12, [r2]
    690c:	vmov.f32	s13, s15
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6910:	vmov.f32	s15, s10
    6914:	vdiv.f32	s7, s13, s8
    6918:	vfma.f32	s15, s12, s14
    691c:	vfma.f32	s15, s12, s12
    6920:	vdiv.f32	s8, s10, s15
    6924:	vstr	s8, [r2, #8]
    6928:	cbz	r1, 69a6 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x80a>
    692a:	ldr	r1, [sp, #8]
    692c:	ldr	r5, [sp, #12]
    692e:	add.w	r0, r1, #8
    6932:	mov	r1, r3
    6934:	b.n	6942 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x7a6>
    6936:	vldr	s14, [r2, #4]
    693a:	vldr	s12, [r2]
    693e:	vldr	s8, [r2, #8]
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    6942:	vldr	s13, [r2, #12]
  }

  inline float Next() {
    value_ += increment_;
    6946:	vadd.f32	s11, s11, s7
      const float s = *in++ * gain_modulation.Next();
    694a:	vldmia	r5!, {s10}
      float* out,
      size_t size,
      size_t stride) {
    stmlib::ParameterInterpolator gain_modulation(&previous_gain_, gain, size);
    filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(frequency, 0.4f);
    while (size--) {
    694e:	subs	r1, #1
    6950:	vnmul.f32	s15, s14, s13
    6954:	vldr	s14, [r2, #16]
    6958:	cmp.w	r1, #4294967295
    695c:	add.w	r0, r0, #8
    6960:	vfma.f32	s15, s10, s11
    6964:	vfms.f32	s15, s13, s12
    6968:	vsub.f32	s15, s15, s14
    696c:	vmul.f32	s15, s15, s8
    bp = g_ * hp + state_1_;
    6970:	vfma.f32	s13, s15, s12
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    6974:	vfma.f32	s14, s13, s12
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    6978:	vmov.f32	s8, s13
    697c:	vfma.f32	s8, s15, s12
      const float s = *in++ * gain_modulation.Next();
      const float lp = filter_.Process<stmlib::FILTER_MODE_LOW_PASS>(s);
      *out = (lp + (s - lp) * hf_bleed);
    6980:	vmov.f32	s15, s14
    6984:	vfnms.f32	s15, s10, s11
    6988:	vstr	s8, [r2, #12]
    698c:	vmov.f32	s10, s15
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    6990:	vmov.f32	s15, s14
    6994:	vfma.f32	s14, s10, s9
    6998:	vfma.f32	s15, s13, s12
    699c:	vstr	s15, [r2, #16]
    69a0:	vstr	s14, [r0, #-16]
      float* out,
      size_t size,
      size_t stride) {
    stmlib::ParameterInterpolator gain_modulation(&previous_gain_, gain, size);
    filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(frequency, 0.4f);
    while (size--) {
    69a4:	bne.n	6936 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x79a>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    69a6:	vstr	s11, [r9]
      &frames->out,
      size,
      2);

  aux_post_processor_.Process(
      pp_s.aux_gain,
    69aa:	vldr	s15, [fp, #8]
      out_buffer_,
      &frames->out,
      size,
      2);

  aux_post_processor_.Process(
    69ae:	ldr	r2, [sp, #8]
      float low_pass_gate_hf_bleed,
      float* in,
      float* out,
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
    69b0:	vcmpe.f32	s15, #0.0
    69b4:	vldr	s4, [r8]
    69b8:	adds	r2, #4
    69ba:	vldr	s5, [ip]
    69be:	vldr	s9, [lr]
    69c2:	vmrs	APSR_nzcv, fpscr
    69c6:	bmi.n	6ac6 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x92a>
      limiter_.Process(-gain, in, size);
    }
    const float post_gain = (gain < 0.0f ? 1.0f : gain) * -0.6f;
    69c8:	vcmpe.f32	s15, #0.0
    69cc:	vmrs	APSR_nzcv, fpscr
    69d0:	bpl.w	663a <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x49e>
    69d4:	vldr	s13, [pc, #-796]	; 66bc <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x520>
    if (!bypass_lpg) {
    69d8:	cmp	r7, #0
    69da:	bne.w	6648 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4ac>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    69de:	movw	r0, #4152	; 0x1038
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    69e2:	vldr	s15, [pc, #-804]	; 66c0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x524>
    increment_ = (new_value - *state) / static_cast<float>(size);
    69e6:	vldr	s11, [sp, #104]	; 0x68
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    69ea:	vmov.f32	s10, #112	; 0x3f800000  1.0
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    69ee:	add	r0, r6
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    69f0:	vmul.f32	s15, s5, s15
    increment_ = (new_value - *state) / static_cast<float>(size);
    69f4:	vcvt.f32.u32	s8, s11
    69f8:	vldr	s12, [pc, #-824]	; 66c4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x528>
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    69fc:	vldr	s11, [r0]
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    6a00:	vmov.f32	s14, #4	; 0x40200000  2.5
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    6a04:	vfma.f32	s12, s15, s5

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6a08:	movw	r1, #4156	; 0x103c
    increment_ = (new_value - *state) / static_cast<float>(size);
    6a0c:	vmov.f32	s15, s11
    6a10:	ldr	r5, [sp, #104]	; 0x68
    6a12:	add	r1, r6
    6a14:	vfnms.f32	s15, s13, s4
    r_ = 1.0f / resonance;
    6a18:	vstr	s14, [r1, #4]
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    6a1c:	vmul.f32	s12, s12, s5

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6a20:	vstr	s12, [r1]
    6a24:	vmov.f32	s13, s15
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6a28:	vmov.f32	s15, s10
    6a2c:	vdiv.f32	s7, s13, s8
    6a30:	vfma.f32	s15, s12, s14
    6a34:	vfma.f32	s15, s12, s12
    6a38:	vdiv.f32	s8, s10, s15
    6a3c:	vstr	s8, [r1, #8]
    6a40:	cbz	r5, 6ab4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x918>
    6a42:	adds	r2, #8
    6a44:	b.n	6a52 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x8b6>
    6a46:	vldr	s14, [r1, #4]
    6a4a:	vldr	s12, [r1]
    6a4e:	vldr	s8, [r1, #8]
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    6a52:	vldr	s13, [r1, #12]
  }

  inline float Next() {
    value_ += increment_;
    6a56:	vadd.f32	s11, s11, s7
      const float s = *in++ * gain_modulation.Next();
    6a5a:	vldmia	r4!, {s10}
      float* out,
      size_t size,
      size_t stride) {
    stmlib::ParameterInterpolator gain_modulation(&previous_gain_, gain, size);
    filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(frequency, 0.4f);
    while (size--) {
    6a5e:	subs	r3, #1
    6a60:	vnmul.f32	s15, s14, s13
    6a64:	vldr	s14, [r1, #16]
    6a68:	adds	r5, r3, #1
    6a6a:	add.w	r2, r2, #8
    6a6e:	vfma.f32	s15, s10, s11
    6a72:	vfms.f32	s15, s13, s12
    6a76:	vsub.f32	s15, s15, s14
    6a7a:	vmul.f32	s15, s15, s8
    bp = g_ * hp + state_1_;
    6a7e:	vfma.f32	s13, s15, s12
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    6a82:	vfma.f32	s14, s13, s12
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    6a86:	vmov.f32	s8, s13
    6a8a:	vfma.f32	s8, s15, s12
      const float s = *in++ * gain_modulation.Next();
      const float lp = filter_.Process<stmlib::FILTER_MODE_LOW_PASS>(s);
      *out = (lp + (s - lp) * hf_bleed);
    6a8e:	vmov.f32	s15, s14
    6a92:	vfnms.f32	s15, s10, s11
    6a96:	vstr	s8, [r1, #12]
    6a9a:	vmov.f32	s10, s15
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    6a9e:	vmov.f32	s15, s14
    6aa2:	vfma.f32	s14, s10, s9
    6aa6:	vfma.f32	s15, s13, s12
    6aaa:	vstr	s15, [r1, #16]
    6aae:	vstr	s14, [r2, #-16]
      float* out,
      size_t size,
      size_t stride) {
    stmlib::ParameterInterpolator gain_modulation(&previous_gain_, gain, size);
    filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(frequency, 0.4f);
    while (size--) {
    6ab2:	bne.n	6a46 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x8aa>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    6ab4:	vstr	s11, [r0]
      lpg_envelope_.hf_bleed(),
      aux_buffer_,
      &frames->aux,
      size,
      2);
}
    6ab8:	add	sp, #52	; 0x34
    6aba:	vpop	{d8-d9}
    6abe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  float note = (modulations.note + previous_note_) * 0.5f;
  previous_note_ = modulations.note;
  const PostProcessingSettings& pp_s = e->post_processing_settings;

  if (modulations.trigger_patched) {
    p.trigger = rising_edge ? TRIGGER_RISING_EDGE : TRIGGER_LOW;
    6ac2:	movs	r3, #0
    6ac4:	b.n	62e2 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x146>
    6ac6:	ldr	r1, [sp, #104]	; 0x68
    6ac8:	cmp	r1, #0
    6aca:	beq.n	69d4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x838>
    6acc:	movw	r5, #4148	; 0x1034
      float* in,
      float* out,
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
      limiter_.Process(-gain, in, size);
    6ad0:	vneg.f32	s12, s15
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
    6ad4:	vmov.f32	s10, #112	; 0x3f800000  1.0
          in,
          out,
          size,
          stride);
    } else {
      while (size--) {
    6ad8:	mov	r0, r4
    6ada:	mov	r1, r3
    6adc:	add	r5, r6
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    6ade:	vldr	s6, [pc, #640]	; 6d60 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbc4>
    6ae2:	vldr	s7, [pc, #640]	; 6d64 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbc8>
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
      *in_out++ = s * gain * 0.8f;
    6ae6:	vldr	s8, [pc, #640]	; 6d68 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbcc>
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
    6aea:	vldr	s15, [r0]
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    6aee:	subs	r1, #1
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    6af0:	vldr	s13, [r5]
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
    6af4:	vmul.f32	s15, s12, s15
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    6af8:	vabs.f32	s14, s15
    6afc:	vsub.f32	s14, s14, s13
    6b00:	vcmpe.f32	s14, #0.0
    6b04:	vmrs	APSR_nzcv, fpscr
    6b08:	ite	le
    6b0a:	vmovle.f32	s11, s7
    6b0e:	vmovgt.f32	s11, s6
    6b12:	vfma.f32	s13, s14, s11
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
    6b16:	vcmpe.f32	s13, s10
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
    6b1a:	vstr	s13, [r5]
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
    6b1e:	vmrs	APSR_nzcv, fpscr
    6b22:	ite	hi
    6b24:	vdivhi.f32	s14, s10, s13
    6b28:	vmovls.f32	s14, #112	; 0x3f800000  1.0
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    6b2c:	cmp.w	r1, #4294967295
      float s = *in_out * pre_gain;
      SLOPE(peak_, fabs(s), 0.05f, 0.00002f);
      float gain = (peak_ <= 1.0f ? 1.0f : 1.0f / peak_);
      *in_out++ = s * gain * 0.8f;
    6b30:	vmul.f32	s15, s15, s14
    6b34:	vmul.f32	s15, s15, s8
    6b38:	vstmia	r0!, {s15}
  void Init() {
    peak_ = 0.5f;
  }

  void Process(float pre_gain, float* in_out, size_t size) {
    while (size--) {
    6b3c:	bne.n	6aea <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x94e>
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
      limiter_.Process(-gain, in, size);
    }
    const float post_gain = (gain < 0.0f ? 1.0f : gain) * -0.6f;
    6b3e:	vldr	s13, [pc, #556]	; 6d6c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbd0>
    6b42:	b.n	69d8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x83c>
    6b44:	mov	r3, r2
  inline void ProcessPing(
      float attack,
      float short_decay,
      float decay_tail,
      float hf) {
    if (ramp_up_) {
    6b46:	ldrb.w	r1, [r6, #4076]	; 0xfec
    6b4a:	cmp	r1, #0
    6b4c:	beq.w	6762 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x5c6>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    6b50:	add.w	sl, sl, r3, lsl #2
      vactrol_state_ += attack;
    6b54:	vldr	s15, [pc, #536]	; 6d70 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbd4>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    6b58:	add.w	r2, r9, r2, lsl #2
    6b5c:	vldr	s9, [pc, #532]	; 6d74 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbd8>
    6b60:	vldr	s13, [sl]
    6b64:	addw	r3, r6, #4060	; 0xfdc
    6b68:	vldr	s8, [r2]
    6b6c:	vmov.f32	s12, #0	; 0x40000000  2.0
    6b70:	vldr	s14, [r3]
      if (vactrol_state_ >= 1.0f) {
    6b74:	vmov.f32	s10, #112	; 0x3f800000  1.0
      float attack,
      float short_decay,
      float decay_tail,
      float hf) {
    if (ramp_up_) {
      vactrol_state_ += attack;
    6b78:	vmul.f32	s13, s13, s8
    6b7c:	vmul.f32	s15, s13, s15
    6b80:	vmul.f32	s15, s15, s9
    6b84:	vfma.f32	s14, s15, s12
      if (vactrol_state_ >= 1.0f) {
    6b88:	vcmpe.f32	s14, s10
      float attack,
      float short_decay,
      float decay_tail,
      float hf) {
    if (ramp_up_) {
      vactrol_state_ += attack;
    6b8c:	vstr	s14, [r3]
      if (vactrol_state_ >= 1.0f) {
    6b90:	vmrs	APSR_nzcv, fpscr
    6b94:	blt.n	6bbe <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xa22>
        vactrol_state_ = 1.0f;
        ramp_up_ = false;
    6b96:	vmov.f32	s9, #240	; 0xbf800000 -1.0
    6b9a:	movs	r2, #0
    6b9c:	vmov.f32	s12, s10
    6ba0:	vldr	s13, [pc, #468]	; 6d78 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbdc>
    6ba4:	vmov.f32	s14, s10
    6ba8:	vldr	s15, [pc, #464]	; 6d7c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbe0>
    6bac:	strb.w	r2, [r6, #4076]	; 0xfec
    float vactrol_state_4 = vactrol_state_2 * vactrol_state_2;
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    6bb0:	vmov.f32	s8, #112	; 0x3f800000  1.0
    6bb4:	vsub.f32	s12, s8, s12
    6bb8:	vfma.f32	s16, s18, s12
    6bbc:	b.n	6bf0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xa54>
    6bbe:	vmul.f32	s12, s14, s14
    6bc2:	vldr	s8, [pc, #444]	; 6d80 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbe4>
    6bc6:	vsub.f32	s15, s10, s14
    6bca:	vldr	s13, [pc, #440]	; 6d84 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbe8>
    6bce:	vsub.f32	s9, s14, s14
    6bd2:	vmul.f32	s12, s12, s12
    6bd6:	vmul.f32	s15, s15, s15
    6bda:	vfma.f32	s13, s12, s8
    6bde:	vsub.f32	s10, s10, s15
    6be2:	vcmpe.f32	s9, #0.0
    6be6:	vmrs	APSR_nzcv, fpscr
    6bea:	ble.n	6bb0 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xa14>
    6bec:	vldr	s16, [pc, #408]	; 6d88 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbec>
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6bf0:	vfma.f32	s15, s11, s10
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6bf4:	vldr	s12, [pc, #404]	; 6d8c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbf0>
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    6bf8:	vfma.f32	s14, s16, s9
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6bfc:	movs	r7, #0
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6bfe:	vfma.f32	s13, s11, s12
    6c02:	add.w	r8, r6, #4064	; 0xfe0
    6c06:	addw	ip, r6, #4068	; 0xfe4
    6c0a:	addw	lr, r6, #4072	; 0xfe8
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c0e:	vmul.f32	s15, s15, s11
    6c12:	vmov.f32	s4, s14
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    6c16:	vstr	s14, [r3]
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c1a:	vmov.f32	s5, s13
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    6c1e:	vstr	s14, [r3, #4]
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c22:	vmul.f32	s15, s15, s11
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6c26:	vstr	s13, [r3, #8]
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c2a:	vmov.f32	s9, s15
    6c2e:	vstr	s15, [r3, #12]
    6c32:	b.n	65ca <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x42e>
      float level,
      float short_decay,
      float decay_tail,
      float hf) {
    float vactrol_input = level;
    float vactrol_error = (vactrol_input - vactrol_state_);
    6c34:	addw	r3, r6, #4060	; 0xfdc
    float vactrol_state_2 = vactrol_state_ * vactrol_state_;
    float vactrol_state_4 = vactrol_state_2 * vactrol_state_2;
    float tail = 1.0f - vactrol_state_;
    6c38:	vmov.f32	s12, #112	; 0x3f800000  1.0
      float level,
      float short_decay,
      float decay_tail,
      float hf) {
    float vactrol_input = level;
    float vactrol_error = (vactrol_input - vactrol_state_);
    6c3c:	vldr	s14, [r3]
    6c40:	vsub.f32	s17, s17, s14
    float vactrol_state_2 = vactrol_state_ * vactrol_state_;
    6c44:	vmul.f32	s13, s14, s14
    float vactrol_state_4 = vactrol_state_2 * vactrol_state_2;
    float tail = 1.0f - vactrol_state_;
    6c48:	vsub.f32	s15, s12, s14
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    6c4c:	vcmpe.f32	s17, #0.0
      float decay_tail,
      float hf) {
    float vactrol_input = level;
    float vactrol_error = (vactrol_input - vactrol_state_);
    float vactrol_state_2 = vactrol_state_ * vactrol_state_;
    float vactrol_state_4 = vactrol_state_2 * vactrol_state_2;
    6c50:	vmul.f32	s13, s13, s13
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    6c54:	vmul.f32	s15, s15, s15
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    6c58:	vmrs	APSR_nzcv, fpscr
    6c5c:	ble.n	6d46 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbaa>
    6c5e:	vldr	s16, [pc, #296]	; 6d88 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbec>
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c62:	vmov.f32	s10, #112	; 0x3f800000  1.0
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6c66:	vldr	s8, [pc, #280]	; 6d80 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbe4>
    6c6a:	vldr	s12, [pc, #280]	; 6d84 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbe8>
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    6c6e:	vfma.f32	s14, s17, s16
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6c72:	vldr	s9, [pc, #280]	; 6d8c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbf0>
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c76:	movs	r7, #0
    6c78:	vsub.f32	s10, s10, s15
    6c7c:	add.w	r8, r6, #4064	; 0xfe0
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6c80:	vfma.f32	s12, s13, s8
    6c84:	addw	ip, r6, #4068	; 0xfe4
    6c88:	addw	lr, r6, #4072	; 0xfe8
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c8c:	vfma.f32	s15, s11, s10
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    6c90:	vstr	s14, [r3]
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6c94:	vmov.f32	s4, s14
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    6c98:	vstr	s14, [r3, #4]
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6c9c:	vfma.f32	s12, s11, s9
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6ca0:	vmul.f32	s9, s15, s11
    6ca4:	vmul.f32	s9, s9, s11
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    vactrol_state_ += vactrol_coefficient * vactrol_error;
    
    gain_ = vactrol_state_;
    frequency_ = 0.003f + 0.3f * vactrol_state_4 + hf * 0.04f;
    6ca8:	vstr	s12, [r3, #8]
    hf_bleed_ = (tail_2 + (1.0f - tail_2) * hf) * hf * hf;
    6cac:	vmov.f32	s5, s12
    6cb0:	vstr	s9, [r3, #12]
    6cb4:	b.n	65ca <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x42e>
    6cb6:	vadd.f32	s15, s15, s12
    6cba:	vcvt.s32.f32	s14, s15
    6cbe:	vmov	r3, s14
    6cc2:	vcvt.f32.s32	s14, s14
    6cc6:	vsub.f32	s15, s15, s14
    6cca:	vmul.f32	s15, s15, s13
    6cce:	vcvt.s32.f32	s15, s15
    6cd2:	vmov	r2, s15
    6cd6:	b.n	6b46 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x9aa>
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    internal_envelope_amplitude = 2.0f - p.harmonics * 6.0f;
    CONSTRAIN(internal_envelope_amplitude, 0.0f, 1.0f);
    6cd8:	vldr	s13, [pc, #160]	; 6d7c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbe0>
    speech_engine_.set_prosody_amount(
    6cdc:	cmp	r2, #0
    6cde:	bne.w	6812 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x676>
      float* aux,
      size_t size,
      bool* already_enveloped);
  
  inline void set_prosody_amount(float prosody_amount) {
    prosody_amount_ = prosody_amount;
    6ce2:	addw	r1, r6, #2852	; 0xb24
    6ce6:	movs	r0, #0
    6ce8:	ldrb.w	r3, [r7, #32]
    6cec:	str	r0, [r1, #0]
    6cee:	ldrb.w	r1, [r7, #34]	; 0x22
    6cf2:	b.n	6834 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x698>
  
  p.harmonics = patch.harmonics + modulations.harmonics;
  CONSTRAIN(p.harmonics, 0.0f, 1.0f);

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    6cf4:	cmp	r4, #7
    6cf6:	bne.w	640e <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x272>
    internal_envelope_amplitude = 2.0f - p.harmonics * 6.0f;
    6cfa:	vmov.f32	s15, #24	; 0x40c00000  6.0
    6cfe:	vfms.f32	s13, s14, s15
    CONSTRAIN(internal_envelope_amplitude, 0.0f, 1.0f);
    6d02:	vcmpe.f32	s13, #0.0
    6d06:	vmrs	APSR_nzcv, fpscr
    6d0a:	bmi.n	6cd8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xb3c>
    6d0c:	vcmpe.f32	s13, s11
    6d10:	vmrs	APSR_nzcv, fpscr
    6d14:	bgt.w	6808 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x66c>
    6d18:	b.n	680c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x670>
      &frames->out,
      size,
      2);

  aux_post_processor_.Process(
      pp_s.aux_gain,
    6d1a:	vldr	s15, [fp, #8]
      out_buffer_,
      &frames->out,
      size,
      2);

  aux_post_processor_.Process(
    6d1e:	ldr	r2, [sp, #8]
      float low_pass_gate_hf_bleed,
      float* in,
      float* out,
      size_t size,
      size_t stride) {
    if (gain < 0.0f) {
    6d20:	vcmpe.f32	s15, #0.0
    6d24:	vldr	s4, [r8]
    6d28:	adds	r2, #4
    6d2a:	vldr	s5, [ip]
    6d2e:	vldr	s9, [lr]
    6d32:	vmrs	APSR_nzcv, fpscr
    6d36:	bpl.w	69c8 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x82c>
    6d3a:	b.n	69d4 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x838>

  float internal_envelope_amplitude = 1.0f;
  if (engine_index == 7) {
    internal_envelope_amplitude = 2.0f - p.harmonics * 6.0f;
    CONSTRAIN(internal_envelope_amplitude, 0.0f, 1.0f);
    speech_engine_.set_prosody_amount(
    6d3c:	movs	r4, #0
    6d3e:	b.n	6820 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x684>
    6d40:	movs	r1, #1
        !modulations.trigger_patched || modulations.frequency_patched ?
            0.0f : patch.frequency_modulation_amount);
    speech_engine_.set_speed( 
    6d42:	movs	r0, #0
    6d44:	b.n	6834 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x698>
    float vactrol_state_4 = vactrol_state_2 * vactrol_state_2;
    float tail = 1.0f - vactrol_state_;
    float tail_2 = tail * tail;
    float vactrol_coefficient = (vactrol_error > 0.0f)
        ? 0.6f
        : short_decay + (1.0f - vactrol_state_4) * decay_tail;
    6d46:	vsub.f32	s12, s12, s13
    6d4a:	vfma.f32	s16, s18, s12
    6d4e:	b.n	6c62 <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xac6>
    6d50:	ldr	r3, [sp, #104]	; 0x68
      limiter_.Process(-gain, in, size);
    }
    const float post_gain = (gain < 0.0f ? 1.0f : gain) * -0.6f;
    6d52:	vldr	s13, [pc, #24]	; 6d6c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbd0>
    6d56:	subs	r3, #1
    6d58:	b.n	65ea <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x44e>
    6d5a:	vldr	s13, [pc, #16]	; 6d6c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0xbd0>
    6d5e:	b.n	664c <plaits::Voice::Render(plaits::Patch const&, plaits::Modulations const&, plaits::Voice::Frame*, unsigned int)+0x4b0>
    6d60:	.word	0x3d4ccccd
    6d64:	.word	0x37a7c5ac
    6d68:	.word	0x3f4ccccd
    6d6c:	.word	0xbf19999a
    6d70:	.word	0x39962fc9
    6d74:	.word	0x43000000
    6d78:	.word	0x3e9b22d1
    6d7c:	.word	0x00000000
    6d80:	.word	0x3e99999a
    6d84:	.word	0x3b449ba6
    6d88:	.word	0x3f19999a
    6d8c:	.word	0x3d23d70a

00006d90 <plaits::NaiveSpeechSynth::Init()>:
    { { { 63, 255 }, { 77, 64 }, { 99, 8 }, { 104, 2 }, { 110, 0 } } },
    { { { 63, 255 }, { 77, 40 }, { 100, 4 }, { 106, 2 }, { 110, 0 } } }
  },
};

void NaiveSpeechSynth::Init() {
    6d90:	push	{r4, r5, r6, r7, lr}
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    6d92:	movs	r1, #0
    lp_state_ = 1.0f;
    6d94:	mov.w	r6, #1065353216	; 0x3f800000
    hp_state_ = 0.0f;
    high_ = true;
    6d98:	movs	r2, #1

    frequency_ = 0.001f;
    6d9a:	ldr	r5, [pc, #92]	; (6df8 <plaits::NaiveSpeechSynth::Init()+0x68>)
  pulse_.Init();
  frequency_ = 0.0f;
  click_duration_ = 0;
    6d9c:	movs	r4, #0
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    6d9e:	mov.w	lr, #1056964608	; 0x3f000000
    next_sample_ = 0.0f;
    lp_state_ = 1.0f;
    6da2:	str	r6, [r0, #8]
    6da4:	mov	r3, r0
    hp_state_ = 0.0f;
    high_ = true;
    6da6:	strb	r2, [r0, #16]
    6da8:	add.w	r7, r0, #100	; 0x64

    frequency_ = 0.001f;
    6dac:	str	r5, [r0, #20]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    6dae:	mov	r2, r1
    6db0:	str	r4, [r0, #32]

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6db2:	ldr	r6, [pc, #72]	; (6dfc <plaits::NaiveSpeechSynth::Init()+0x6c>)
    r_ = 1.0f / resonance;
    6db4:	ldr	r5, [pc, #72]	; (6e00 <plaits::NaiveSpeechSynth::Init()+0x70>)
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6db6:	ldr	r4, [pc, #76]	; (6e04 <plaits::NaiveSpeechSynth::Init()+0x74>)
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    6db8:	str.w	lr, [r0]
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    high_ = true;

    frequency_ = 0.001f;
    pw_ = 0.5f;
    6dbc:	str.w	lr, [r0, #24]
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    6dc0:	str	r1, [r0, #4]
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    6dc2:	str	r1, [r0, #12]
  },
};

void NaiveSpeechSynth::Init() {
  pulse_.Init();
  frequency_ = 0.0f;
    6dc4:	str	r1, [r0, #28]

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6dc6:	str	r6, [r3, #36]	; 0x24
    6dc8:	adds	r3, #20
    r_ = 1.0f / resonance;
    6dca:	str	r5, [r3, #20]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    6dcc:	movs	r1, #0
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6dce:	str	r4, [r3, #24]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    6dd0:	str	r2, [r3, #32]
    6dd2:	str	r2, [r3, #28]
  click_duration_ = 0;
  
  for (int i = 0; i < kNaiveSpeechNumFormants; ++i) {
    6dd4:	cmp	r3, r7
    6dd6:	bne.n	6dc6 <plaits::NaiveSpeechSynth::Init()+0x36>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    6dd8:	mov.w	r4, #1073741824	; 0x40000000

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6ddc:	ldr	r2, [pc, #40]	; (6e08 <plaits::NaiveSpeechSynth::Init()+0x78>)
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6dde:	ldr	r3, [pc, #44]	; (6e0c <plaits::NaiveSpeechSynth::Init()+0x7c>)
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    6de0:	str.w	r1, [r0, #152]	; 0x98
    6de4:	str.w	r1, [r0, #148]	; 0x94
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    6de8:	str.w	r4, [r0, #140]	; 0x8c

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    6dec:	str.w	r2, [r0, #136]	; 0x88
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    6df0:	str.w	r3, [r0, #144]	; 0x90
    6df4:	pop	{r4, r5, r6, r7, pc}
    6df6:	nop
    6df8:	.word	0x3a83126f
    6dfc:	.word	0x3d00ba22
    6e00:	.word	0x3c23d70a
    6e04:	.word	0x3f7faaca
    6e08:	.word	0x3d56af8c
    6e0c:	.word	0x3f6722c1

00006e10 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)>:
    float phoneme,
    float vocal_register,
    float* temp,
    float* excitation,
    float* output,
    size_t size) {
    6e10:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6e14:	vpush	{d8-d9}
    6e18:	sub	sp, #12
    6e1a:	mov	r8, r3
    6e1c:	ldr.w	r9, [sp, #64]	; 0x40
    6e20:	ldr	r3, [sp, #68]	; 0x44
  if (click) {
    6e22:	cmp	r1, #0
    6e24:	bne.w	7238 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x428>
    6e28:	ldr	r4, [r0, #32]
    click_duration_ = kSampleRate * 0.05f;
  }
  click_duration_ -= min(click_duration_, size);
    6e2a:	cmp	r3, r4
    6e2c:	ite	ls
    6e2e:	subls	r4, r4, r3
    6e30:	subhi	r4, r4, r4
    6e32:	str	r4, [r0, #32]
  
  if (click_duration_) {
    6e34:	cbz	r4, 6e3e <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x2e>
    frequency *= 0.5f;
    6e36:	vmov.f32	s15, #96	; 0x3f000000  0.5
    6e3a:	vmul.f32	s0, s0, s15
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    6e3e:	vldr	s15, [pc, #828]	; 717c <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x36c>
    6e42:	vcmpe.f32	s0, s15
    6e46:	vmrs	APSR_nzcv, fpscr
    6e4a:	bmi.n	6e5c <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x4c>
    6e4c:	vmov.f32	s15, #80	; 0x3e800000  0.250
    6e50:	vcmpe.f32	s0, s15
    6e54:	vmrs	APSR_nzcv, fpscr
    6e58:	ble.w	723e <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x42e>
    6e5c:	vmov.f32	s0, s15
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    6e60:	vmov.f32	s15, #96	; 0x3f000000  0.5
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    6e64:	vldr	s12, [r0, #20]
    increment_ = (new_value - *state) / static_cast<float>(size);
    6e68:	vmov	s14, r3
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    6e6c:	vldr	s6, [r0, #24]
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    6e70:	add.w	sl, r3, #4294967295
    increment_ = (new_value - *state) / static_cast<float>(size);
    6e74:	vcvt.f32.u32	s14, s14
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    6e78:	vldr	s13, [r0, #4]
    6e7c:	vsub.f32	s0, s0, s12
    6e80:	vsub.f32	s15, s15, s6
    6e84:	vdiv.f32	s7, s0, s14
    6e88:	vdiv.f32	s4, s15, s14
  
    while (size--) {
    6e8c:	cmp	r3, #0
    6e8e:	beq.w	726e <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x45e>
    6e92:	vldr	s5, [r0, #12]
    6e96:	mov	r1, r8
    6e98:	mov	r2, sl
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
    6e9a:	vldr	s18, [pc, #740]	; 7180 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x370>
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    6e9e:	vmov.f32	s9, #112	; 0x3f800000  1.0
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    6ea2:	vmov.f32	s17, #96	; 0x3f000000  0.5
          next_sample -= stmlib::NextBlepSample(t);
    6ea6:	vmov.f32	s16, #224	; 0xbf000000 -0.5
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
        } else {
          lp_state_ += 0.25f * ((hp_state_ - this_sample) - lp_state_);
    6eaa:	vmov.f32	s0, #80	; 0x3e800000  0.250
          *out++ = 4.0f * lp_state_;
    6eae:	vmov.f32	s3, #16	; 0x40800000  4.0
    6eb2:	b.n	6f0e <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0xfe>
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    6eb4:	vsub.f32	s15, s15, s9
          float t = phase_ / frequency;
    6eb8:	vdiv.f32	s14, s15, s12
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    6ebc:	vstr	s15, [r0]
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    6ec0:	vmul.f32	s10, s14, s17
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    6ec4:	vsub.f32	s11, s9, s14
    6ec8:	vfms.f32	s13, s14, s10
          next_sample -= stmlib::NextBlepSample(t);
    6ecc:	vmul.f32	s8, s11, s16
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    6ed0:	vmov.f32	s10, s13
          next_sample -= stmlib::NextBlepSample(t);
    6ed4:	vmov.f32	s13, s18
    6ed8:	vfms.f32	s13, s11, s8
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
        } else {
          lp_state_ += 0.25f * ((hp_state_ - this_sample) - lp_state_);
    6edc:	vsub.f32	s11, s5, s10
    6ee0:	vldr	s14, [r0, #8]
          float t = phase_ / frequency;
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;
    6ee4:	vadd.f32	s13, s13, s15
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    6ee8:	subs	r2, #1
    6eea:	vmov.f32	s5, s10
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
        } else {
          lp_state_ += 0.25f * ((hp_state_ - this_sample) - lp_state_);
    6eee:	vsub.f32	s15, s11, s14
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    6ef2:	adds	r6, r2, #1
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
        } else {
          lp_state_ += 0.25f * ((hp_state_ - this_sample) - lp_state_);
    6ef4:	vfma.f32	s14, s15, s0
    6ef8:	vmov.f32	s15, s14
          *out++ = 4.0f * lp_state_;
    6efc:	vmul.f32	s14, s14, s3
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
        } else {
          lp_state_ += 0.25f * ((hp_state_ - this_sample) - lp_state_);
    6f00:	vstr	s15, [r0, #8]
          *out++ = 4.0f * lp_state_;
    6f04:	vstmia	r1!, {s14}
          hp_state_ = this_sample;
    6f08:	vstr	s10, [r0, #12]
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    6f0c:	beq.n	6f36 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x126>
  }

  inline float Next() {
    value_ += increment_;
    6f0e:	vadd.f32	s12, s12, s7
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    6f12:	vldr	s15, [r0]
    6f16:	vadd.f32	s6, s6, s4
    6f1a:	vadd.f32	s15, s12, s15
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    6f1e:	vcmpe.f32	s15, s9
    6f22:	vmrs	APSR_nzcv, fpscr
    6f26:	bge.n	6eb4 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0xa4>
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    6f28:	vmov.f32	s10, s13
    6f2c:	vstr	s15, [r0]
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    6f30:	vldr	s13, [pc, #588]	; 7180 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x370>
    6f34:	b.n	6edc <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0xcc>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    6f36:	vstr	s12, [r0, #20]
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    6f3a:	mov	r1, r8
    6f3c:	mov	r2, sl
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    6f3e:	vldr	s11, [r0, #148]	; 0x94
    float state_2 = state_2_;
    6f42:	vldr	s12, [r0, #152]	; 0x98
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    6f46:	vstr	s13, [r0, #4]
    6f4a:	vstr	s6, [r0, #24]
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    6f4e:	vldr	s14, [r0, #140]	; 0x8c
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    6f52:	subs	r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    6f54:	vldr	s15, [r1]
    6f58:	vldr	s13, [r0, #136]	; 0x88
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    6f5c:	adds	r5, r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    6f5e:	vfms.f32	s15, s14, s11
    6f62:	vldr	s14, [r0, #144]	; 0x90
    6f66:	vfms.f32	s15, s13, s11
    6f6a:	vsub.f32	s15, s15, s12
    6f6e:	vmul.f32	s15, s15, s14
      bp = g_ * hp + state_1;
    6f72:	vmov.f32	s14, s11
    6f76:	vfma.f32	s14, s13, s15
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    6f7a:	vfma.f32	s12, s13, s14
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
    6f7e:	vstmia	r1!, {s14}
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    6f82:	vmov.f32	s11, s14
    6f86:	vfma.f32	s11, s13, s15
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    6f8a:	vfma.f32	s12, s13, s14
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    6f8e:	bne.n	6f4e <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x13e>
  pulse_.Render<OSCILLATOR_SHAPE_IMPULSE_TRAIN>(
      frequency, 0.5f, excitation, size);
  pulse_coloration_.Process<FILTER_MODE_BAND_PASS>(
      excitation, excitation, size);
  for (size_t i = 0; i < size; ++i) {
    excitation[i] *= 4.0f;
    6f90:	vmov.f32	s14, #16	; 0x40800000  4.0
    6f94:	mov	r1, r8
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    state_2_ = state_2;
    6f96:	movs	r2, #0
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    6f98:	vstr	s11, [r0, #148]	; 0x94
    state_2_ = state_2;
    6f9c:	vstr	s12, [r0, #152]	; 0x98
    6fa0:	vldr	s15, [r1]
  // Generate excitation signal (glottal pulse).
  pulse_.Render<OSCILLATOR_SHAPE_IMPULSE_TRAIN>(
      frequency, 0.5f, excitation, size);
  pulse_coloration_.Process<FILTER_MODE_BAND_PASS>(
      excitation, excitation, size);
  for (size_t i = 0; i < size; ++i) {
    6fa4:	adds	r2, #1
    excitation[i] *= 4.0f;
    6fa6:	vmul.f32	s15, s15, s14
  // Generate excitation signal (glottal pulse).
  pulse_.Render<OSCILLATOR_SHAPE_IMPULSE_TRAIN>(
      frequency, 0.5f, excitation, size);
  pulse_coloration_.Process<FILTER_MODE_BAND_PASS>(
      excitation, excitation, size);
  for (size_t i = 0; i < size; ++i) {
    6faa:	cmp	r2, r3
    excitation[i] *= 4.0f;
    6fac:	vstmia	r1!, {s15}
  // Generate excitation signal (glottal pulse).
  pulse_.Render<OSCILLATOR_SHAPE_IMPULSE_TRAIN>(
      frequency, 0.5f, excitation, size);
  pulse_coloration_.Process<FILTER_MODE_BAND_PASS>(
      excitation, excitation, size);
  for (size_t i = 0; i < size; ++i) {
    6fb0:	bcc.n	6fa0 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x190>
    excitation[i] *= 4.0f;
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
    6fb2:	vldr	s8, [pc, #512]	; 71b4 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x3a4>
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
  
  MAKE_INTEGRAL_FRACTIONAL(p);
  MAKE_INTEGRAL_FRACTIONAL(r);
  
  fill(&output[0], &output[size], 0.0f);
    6fb6:	add.w	r1, r9, r3, lsl #2
      excitation, excitation, size);
  for (size_t i = 0; i < size; ++i) {
    excitation[i] *= 4.0f;
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
    6fba:	vmul.f32	s1, s1, s8
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    6fbe:	cmp	r9, r1
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
    6fc0:	vmul.f32	s2, s2, s8
  
  MAKE_INTEGRAL_FRACTIONAL(p);
    6fc4:	vcvt.s32.f32	s14, s1
  MAKE_INTEGRAL_FRACTIONAL(r);
    6fc8:	vcvt.s32.f32	s15, s2
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
  
  MAKE_INTEGRAL_FRACTIONAL(p);
    6fcc:	vcvt.f32.s32	s7, s14
  MAKE_INTEGRAL_FRACTIONAL(r);
    6fd0:	vcvt.f32.s32	s8, s15
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
  
  MAKE_INTEGRAL_FRACTIONAL(p);
    6fd4:	vsub.f32	s7, s1, s7
  MAKE_INTEGRAL_FRACTIONAL(r);
    6fd8:	vsub.f32	s8, s2, s8
    6fdc:	beq.n	6fea <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x1da>
    6fde:	mov	r2, r9
	*__first = __tmp;
    6fe0:	movs	r5, #0
    6fe2:	str.w	r5, [r2], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    6fe6:	cmp	r1, r2
    6fe8:	bne.n	6fe2 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x1d2>
    6fea:	vmov	r2, s15
    6fee:	adds	r4, #0
    6ff0:	mov.w	r5, #50	; 0x32
    6ff4:	ldr	r1, [pc, #396]	; (7184 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x374>)
    6ff6:	add.w	r2, r2, #1
    6ffa:	it	ne
    6ffc:	movne	r4, #1
    6ffe:	mov.w	ip, #0
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    7002:	str	r3, [sp, #68]	; 0x44
    7004:	add.w	r2, r2, r2, lsl #2
    7008:	str	r4, [sp, #4]
    700a:	vmov	r4, s14
    700e:	mov	r3, ip
    7010:	lsls	r2, r2, #1

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    7012:	vldr	s1, [pc, #372]	; 7188 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x378>
    7016:	mul.w	r4, r5, r4
    
    if (f >= 160.0f) {
    701a:	vldr	s2, [pc, #368]	; 718c <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x37c>
    701e:	sub.w	r7, r2, #10
    7022:	vldr	s17, [pc, #364]	; 7190 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x380>
    7026:	adds	r5, r4, r5
    7028:	add.w	lr, r4, r2
    702c:	adds	r6, r7, r4
    702e:	vldr	s16, [pc, #356]	; 7194 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x384>
    7032:	add	r7, r5
    7034:	add	r5, r2
    7036:	adds	r6, #1
    7038:	add	lr, r1
    703a:	add	r7, r1
    703c:	add	r5, r1
    703e:	add	r6, r1
    7040:	vldr	s0, [pc, #340]	; 7198 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x388>
      f = 160.0f;
    }
    f = a0 * stmlib::SemitonesToRatio(f - 33.0f);
    7044:	vldr	s3, [pc, #340]	; 719c <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x38c>
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    7048:	vldr	s4, [pc, #340]	; 71a0 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x390>
    704c:	vldr	s5, [pc, #340]	; 71a4 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x394>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    7050:	vldr	s6, [pc, #340]	; 71a8 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x398>
    7054:	ldr.w	ip, [sp, #68]	; 0x44
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;

    float p0r_a = p0r0.amplitude + \
    7058:	ldrb	r2, [r6, #0]
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    705a:	ldrb.w	r1, [lr, #1]
    float p1r_a = p1r0.amplitude + \
    705e:	ldrb	r4, [r7, #1]
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    7060:	vmov	s15, r2
    7064:	subs	r1, r1, r2
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    7066:	ldrb	r2, [r5, #1]
    const Formant& p0r0 = phonemes_[p_integral][r_integral].formant[i];
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
    7068:	ldrb.w	fp, [r6, #-1]
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    706c:	vcvt.f32.s32	s9, s15
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    7070:	subs	r2, r2, r4
    7072:	vmov	s15, r4
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    float p1r_f = p1r0.frequency + \
    7076:	ldrb	r4, [r7, #0]

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    7078:	vmov	s13, r2
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    707c:	ldrb.w	r2, [lr]

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    7080:	vcvt.f32.s32	s11, s15
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    7084:	vmov	s15, r1
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    7088:	rsb	r2, fp, r2

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    708c:	vcvt.f32.s32	s13, s13
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    7090:	vcvt.f32.s32	s12, s15
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    7094:	vmov	s15, fp
    7098:	vmov	s18, r2
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    709c:	ldrb	r2, [r5, #0]
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    709e:	vcvt.f32.s32	s15, s15
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    70a2:	subs	r2, r2, r4
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    70a4:	vcvt.f32.s32	s18, s18
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    70a8:	vfma.f32	s9, s12, s8

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    70ac:	vmov	s14, r2

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    70b0:	vfma.f32	s11, s13, s8
    const Formant& p0r1 = phonemes_[p_integral][r_integral + 1].formant[i];
    const Formant& p1r0 = phonemes_[p_integral + 1][r_integral].formant[i];
    const Formant& p1r1 = phonemes_[p_integral + 1][r_integral + 1].formant[i];

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    70b4:	vfma.f32	s15, s18, s8
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    70b8:	vcvt.f32.s32	s10, s14
    70bc:	vmov	s14, r4
    70c0:	vcvt.f32.s32	s14, s14

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    70c4:	vsub.f32	s13, s11, s9

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    70c8:	vfma.f32	s14, s10, s8

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    70cc:	vfma.f32	s9, s13, s7

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    70d0:	vsub.f32	s14, s14, s15

    float p0r_a = p0r0.amplitude + \
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    70d4:	vmul.f32	s9, s9, s1

    float p0r_f = p0r0.frequency + \
        (p0r1.frequency - p0r0.frequency) * r_fractional;
    float p1r_f = p1r0.frequency + \
        (p1r1.frequency - p1r0.frequency) * r_fractional;
    float f = p0r_f + (p1r_f - p0r_f) * p_fractional;
    70d8:	vfma.f32	s15, s14, s7
        (p0r1.amplitude - p0r0.amplitude) * r_fractional;
    float p1r_a = p1r0.amplitude + \
        (p1r1.amplitude - p1r0.amplitude) * r_fractional;
    float a = (p0r_a + (p1r_a - p0r_a) * p_fractional) / 256.0f;
    
    if (f >= 160.0f) {
    70dc:	vcmpe.f32	s15, s2
    70e0:	vmrs	APSR_nzcv, fpscr
    70e4:	bge.w	7232 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x422>
    70e8:	vsub.f32	s15, s15, s17
    70ec:	vadd.f32	s15, s15, s16
    70f0:	vcvt.s32.f32	s14, s15
    70f4:	vmov	r1, s14
    70f8:	vcvt.f32.s32	s14, s14
    70fc:	vsub.f32	s15, s15, s14
    7100:	vmul.f32	s15, s15, s0
    7104:	vcvt.s32.f32	s15, s15
    7108:	vmov	r2, s15

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    710c:	ldr	r4, [pc, #156]	; (71ac <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x39c>)
    710e:	add.w	r1, r4, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    7112:	ldr	r4, [pc, #156]	; (71b0 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x3a0>)
    7114:	add.w	r2, r4, r2, lsl #2
      f = 160.0f;
    }
    f = a0 * stmlib::SemitonesToRatio(f - 33.0f);
    7118:	vldr	s14, [r1]
    711c:	vldr	s15, [r2]
    7120:	vmul.f32	s15, s14, s15
    7124:	vmul.f32	s15, s15, s3
    if (click_duration_ && i == 0) {
    7128:	cbnz	r3, 7132 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x322>
    712a:	ldr	r2, [sp, #4]
    712c:	cmp	r2, #0
    712e:	bne.w	7294 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x484>
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    7132:	vmul.f32	s14, s15, s4
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    7136:	vstr	s6, [r0, #40]	; 0x28
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    713a:	vmov.f32	s10, s5
  }
  
  template<FilterMode mode>
  inline void ProcessAdd(const float* in, float* out, size_t size, float gain) {
    float hp, bp, lp;
    float state_1 = state_1_;
    713e:	vldr	s11, [r0, #48]	; 0x30
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    7142:	vmov.f32	s13, #112	; 0x3f800000  1.0
  
  template<FilterMode mode>
  inline void ProcessAdd(const float* in, float* out, size_t size, float gain) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    7146:	vldr	s12, [r0, #52]	; 0x34
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    714a:	vfma.f32	s10, s15, s14
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    714e:	vmov.f32	s14, s13
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    7152:	vmul.f32	s15, s10, s15
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    7156:	vfma.f32	s14, s15, s6

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    715a:	vstr	s15, [r0, #36]	; 0x24
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    715e:	vfma.f32	s14, s15, s15
    7162:	vmov.f32	s15, s14
    7166:	vdiv.f32	s14, s13, s15
    716a:	vstr	s14, [r0, #44]	; 0x2c
  inline void ProcessAdd(const float* in, float* out, size_t size, float gain) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    716e:	cmp.w	ip, #0
    7172:	beq.n	7204 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x3f4>
    7174:	mov	r4, r8
    7176:	mov	r1, r9
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    7178:	mov	r2, sl
    717a:	b.n	71bc <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x3ac>
    717c:	.word	0x358637bd
    7180:	.word	0x00000000
    7184:	.word	0x2002048c
    7188:	.word	0x3b800000
    718c:	.word	0x43200000
    7190:	.word	0x42040000
    7194:	.word	0x43000000
    7198:	.word	0x43800000
    719c:	.word	0x3a962fc9
    71a0:	.word	0x413957d7
    71a4:	.word	0x40490fdb
    71a8:	.word	0x3d4ccccd
    71ac:	.word	0x20000554
    71b0:	.word	0x20000958
    71b4:	.word	0x407fef9e
    71b8:	vldr	s14, [r0, #44]	; 0x2c
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    71bc:	vldr	s10, [r0, #40]	; 0x28
  inline void ProcessAdd(const float* in, float* out, size_t size, float gain) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    71c0:	subs	r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    71c2:	vldmia	r4!, {s15}
    71c6:	vldr	s13, [r0, #36]	; 0x24
  inline void ProcessAdd(const float* in, float* out, size_t size, float gain) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    71ca:	cmp.w	r2, #4294967295
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    71ce:	vfms.f32	s15, s10, s11
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out += gain * value;
    71d2:	vldr	s10, [r1]
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    71d6:	vfms.f32	s15, s13, s11
    71da:	vsub.f32	s15, s15, s12
    71de:	vmul.f32	s15, s15, s14
      bp = g_ * hp + state_1;
    71e2:	vmov.f32	s14, s11
    71e6:	vfma.f32	s14, s13, s15
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    71ea:	vfma.f32	s12, s13, s14
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out += gain * value;
    71ee:	vfma.f32	s10, s9, s14
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    71f2:	vmov.f32	s11, s14
    71f6:	vfma.f32	s11, s13, s15
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    71fa:	vfma.f32	s12, s13, s14
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out += gain * value;
    71fe:	vstmia	r1!, {s10}
  inline void ProcessAdd(const float* in, float* out, size_t size, float gain) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    7202:	bne.n	71b8 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x3a8>
  
  MAKE_INTEGRAL_FRACTIONAL(p);
  MAKE_INTEGRAL_FRACTIONAL(r);
  
  fill(&output[0], &output[size], 0.0f);
  for (int i = 0; i < kNaiveSpeechNumFormants; ++i) {
    7204:	adds	r3, #1
      
      *out += gain * value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    7206:	vstr	s11, [r0, #48]	; 0x30
    state_2_ = state_2;
    720a:	vstr	s12, [r0, #52]	; 0x34
    720e:	add.w	lr, lr, #2
    7212:	cmp	r3, #5
    7214:	add.w	r7, r7, #2
    7218:	add.w	r5, r5, #2
    721c:	add.w	r6, r6, #2
    7220:	add.w	r0, r0, #20
    7224:	bne.w	7058 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x248>
      f *= 0.5f;
    }
    filter_[i].set_f_q<FREQUENCY_DIRTY>(f, 20.0f);
    filter_[i].ProcessAdd<FILTER_MODE_BAND_PASS>(excitation, output, size, a);
  }
}
    7228:	add	sp, #12
    722a:	vpop	{d8-d9}
    722e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7232:	movs	r2, #0
    7234:	movs	r1, #255	; 0xff
    7236:	b.n	710c <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x2fc>
    7238:	mov.w	r4, #2400	; 0x960
    723c:	b.n	6e2a <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x1a>
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    723e:	vabs.f32	s15, s0
    7242:	vmov.f32	s14, #96	; 0x3f000000  0.5
    7246:	vadd.f32	s15, s15, s15
    724a:	vcmpe.f32	s15, s14
    724e:	vmrs	APSR_nzcv, fpscr
    7252:	bgt.w	6e64 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x54>
    7256:	vmov.f32	s13, #112	; 0x3f800000  1.0
    725a:	vsub.f32	s15, s13, s15
    725e:	vcmpe.f32	s15, s14
    7262:	vmrs	APSR_nzcv, fpscr
    7266:	it	pl
    7268:	vmovpl.f32	s15, s14
    726c:	b.n	6e64 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x54>
      excitation, excitation, size);
  for (size_t i = 0; i < size; ++i) {
    excitation[i] *= 4.0f;
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
    726e:	vldr	s8, [pc, #-188]	; 71b4 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x3a4>
    7272:	vmul.f32	s1, s1, s8
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
    7276:	vmul.f32	s2, s2, s8
  
  MAKE_INTEGRAL_FRACTIONAL(p);
    727a:	vcvt.s32.f32	s14, s1
  MAKE_INTEGRAL_FRACTIONAL(r);
    727e:	vcvt.s32.f32	s15, s2
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
  
  MAKE_INTEGRAL_FRACTIONAL(p);
    7282:	vcvt.f32.s32	s7, s14
  MAKE_INTEGRAL_FRACTIONAL(r);
    7286:	vcvt.f32.s32	s8, s15
  }
  
  float p = phoneme * (kNaiveSpeechNumPhonemes - 1.001f);
  float r = vocal_register * (kNaiveSpeechNumRegisters - 1.001f);
  
  MAKE_INTEGRAL_FRACTIONAL(p);
    728a:	vsub.f32	s7, s1, s7
  MAKE_INTEGRAL_FRACTIONAL(r);
    728e:	vsub.f32	s8, s2, s8
    7292:	b.n	6fea <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x1da>
    if (f >= 160.0f) {
      f = 160.0f;
    }
    f = a0 * stmlib::SemitonesToRatio(f - 33.0f);
    if (click_duration_ && i == 0) {
      f *= 0.5f;
    7294:	vmov.f32	s14, #96	; 0x3f000000  0.5
    7298:	vmul.f32	s15, s15, s14
    729c:	b.n	7132 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)+0x322>
    729e:	nop

000072a0 <plaits::SAMSpeechSynth::Init()>:

using namespace std;
using namespace stmlib;

void SAMSpeechSynth::Init() {
  phase_ = 0.0f;
    72a0:	movs	r2, #0
  frequency_ = 0.0f;
  pulse_next_sample_ = 0.0f;
  pulse_lp_ = 0.0f;
  
  fill(&formant_phase_[0], &formant_phase_[3], 0);
    72a2:	add.w	r3, r0, #16
    72a6:	add.w	r1, r0, #28

using namespace std;
using namespace stmlib;

void SAMSpeechSynth::Init() {
  phase_ = 0.0f;
    72aa:	str	r2, [r0, #0]
  frequency_ = 0.0f;
    72ac:	str	r2, [r0, #4]
  pulse_next_sample_ = 0.0f;
    72ae:	str	r2, [r0, #8]
  pulse_lp_ = 0.0f;
    72b0:	str	r2, [r0, #12]
namespace plaits {

using namespace std;
using namespace stmlib;

void SAMSpeechSynth::Init() {
    72b2:	push	{r4}
	*__first = __tmp;
    72b4:	movs	r4, #0
    72b6:	str.w	r4, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    72ba:	cmp	r1, r3
	*__first = __tmp;
    72bc:	mov.w	r2, #0
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    72c0:	bne.n	72b6 <plaits::SAMSpeechSynth::Init()+0x16>
  pulse_next_sample_ = 0.0f;
  pulse_lp_ = 0.0f;
  
  fill(&formant_phase_[0], &formant_phase_[3], 0);
  consonant_samples_ = 0;
  consonant_index_ = 0.0f;
    72c2:	movs	r3, #0
  frequency_ = 0.0f;
  pulse_next_sample_ = 0.0f;
  pulse_lp_ = 0.0f;
  
  fill(&formant_phase_[0], &formant_phase_[3], 0);
  consonant_samples_ = 0;
    72c4:	str	r2, [r0, #28]
  consonant_index_ = 0.0f;
}
    72c6:	ldr.w	r4, [sp], #4
  pulse_next_sample_ = 0.0f;
  pulse_lp_ = 0.0f;
  
  fill(&formant_phase_[0], &formant_phase_[3], 0);
  consonant_samples_ = 0;
  consonant_index_ = 0.0f;
    72ca:	str	r3, [r0, #32]
}
    72cc:	bx	lr
    72ce:	nop

000072d0 <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)>:

void SAMSpeechSynth::InterpolatePhonemeData(
  float phoneme,
  float formant_shift,
  uint32_t* formant_frequency,
  float* formant_amplitude) {
    72d0:	vmov.f32	s14, #4	; 0x40200000  2.5
    72d4:	vldr	s13, [pc, #164]	; 737c <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)+0xac>
    72d8:	vmov.f32	s15, #112	; 0x3f800000  1.0
    72dc:	vldr	s12, [pc, #160]	; 7380 <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)+0xb0>
    72e0:	vmov.f32	s11, #32	; 0x41000000  8.0
    72e4:	subs	r1, #4
    72e6:	vfma.f32	s15, s1, s14
  MAKE_INTEGRAL_FRACTIONAL(phoneme);
    72ea:	vcvt.s32.f32	s14, s0

void SAMSpeechSynth::InterpolatePhonemeData(
  float phoneme,
  float formant_shift,
  uint32_t* formant_frequency,
  float* formant_amplitude) {
    72ee:	push	{r4, r5, r6, r7}
  MAKE_INTEGRAL_FRACTIONAL(phoneme);
    72f0:	vmov	r4, s14
    72f4:	vcvt.f32.s32	s14, s14
    72f8:	vmul.f32	s15, s15, s11
    72fc:	ldr	r5, [pc, #132]	; (7384 <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)+0xb4>)
    72fe:	add.w	r3, r4, r4, lsl #1
    7302:	add.w	r7, r2, #12
    7306:	vsub.f32	s0, s0, s14
    730a:	ldr	r6, [pc, #124]	; (7388 <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)+0xb8>)
    730c:	vmul.f32	s15, s15, s13
    7310:	lsls	r3, r3, #1
    7312:	adds	r0, r3, #6
    7314:	add	r3, r5
    7316:	vdiv.f32	s13, s15, s12
    731a:	add	r0, r5
  const Phoneme& p_1 = phonemes_[phoneme_integral];
  const Phoneme& p_2 = phonemes_[phoneme_integral + 1];

  formant_shift = 1.0f + formant_shift * 2.5f;
  for (int i = 0; i < kSAMNumFormants; ++i) {
    float f_1 = p_1.formant[i].frequency;
    731c:	ldrb	r4, [r3, #0]
    731e:	adds	r0, #2
    7320:	adds	r3, #2
    7322:	vmov	s15, r4
    float f_2 = p_2.formant[i].frequency;
    float f = f_1 + (f_2 - f_1) * phoneme_fractional;
    7326:	ldrb.w	r4, [r0, #-2]
    732a:	vmov	s14, r4
  const Phoneme& p_1 = phonemes_[phoneme_integral];
  const Phoneme& p_2 = phonemes_[phoneme_integral + 1];

  formant_shift = 1.0f + formant_shift * 2.5f;
  for (int i = 0; i < kSAMNumFormants; ++i) {
    float f_1 = p_1.formant[i].frequency;
    732e:	vcvt.f32.u32	s15, s15
    float f_2 = p_2.formant[i].frequency;
    float f = f_1 + (f_2 - f_1) * phoneme_fractional;
    7332:	vcvt.f32.u32	s14, s14
    7336:	vsub.f32	s14, s14, s15
    733a:	vfma.f32	s15, s0, s14
    f *= 8.0f * formant_shift * 4294967296.0f / kSampleRate;
    formant_frequency[i] = static_cast<uint32_t>(f);
    733e:	vmul.f32	s15, s15, s13
    7342:	vcvt.u32.f32	s15, s15
    7346:	vmov	r4, s15
    734a:	str.w	r4, [r1, #4]!
  
    float a_1 = formant_amplitude_lut[p_1.formant[i].amplitude];
    734e:	ldrb.w	r5, [r3, #-1]
    float a_2 = formant_amplitude_lut[p_2.formant[i].amplitude];
    7352:	ldrb.w	r4, [r0, #-1]
    float f_2 = p_2.formant[i].frequency;
    float f = f_1 + (f_2 - f_1) * phoneme_fractional;
    f *= 8.0f * formant_shift * 4294967296.0f / kSampleRate;
    formant_frequency[i] = static_cast<uint32_t>(f);
  
    float a_1 = formant_amplitude_lut[p_1.formant[i].amplitude];
    7356:	add.w	r5, r6, r5, lsl #2
    float a_2 = formant_amplitude_lut[p_2.formant[i].amplitude];
    735a:	add.w	r4, r6, r4, lsl #2
    float f_2 = p_2.formant[i].frequency;
    float f = f_1 + (f_2 - f_1) * phoneme_fractional;
    f *= 8.0f * formant_shift * 4294967296.0f / kSampleRate;
    formant_frequency[i] = static_cast<uint32_t>(f);
  
    float a_1 = formant_amplitude_lut[p_1.formant[i].amplitude];
    735e:	vldr	s15, [r5]
    float a_2 = formant_amplitude_lut[p_2.formant[i].amplitude];
    formant_amplitude[i] = a_1 + (a_2 - a_1) * phoneme_fractional;
    7362:	vldr	s14, [r4]
    7366:	vsub.f32	s14, s14, s15
    736a:	vfma.f32	s15, s0, s14
    736e:	vstmia	r2!, {s15}

  const Phoneme& p_1 = phonemes_[phoneme_integral];
  const Phoneme& p_2 = phonemes_[phoneme_integral + 1];

  formant_shift = 1.0f + formant_shift * 2.5f;
  for (int i = 0; i < kSAMNumFormants; ++i) {
    7372:	cmp	r2, r7
    7374:	bne.n	731c <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)+0x4c>
  
    float a_1 = formant_amplitude_lut[p_1.formant[i].amplitude];
    float a_2 = formant_amplitude_lut[p_2.formant[i].amplitude];
    formant_amplitude[i] = a_1 + (a_2 - a_1) * phoneme_fractional;
  }
}
    7376:	pop	{r4, r5, r6, r7}
    7378:	bx	lr
    737a:	nop
    737c:	.word	0x4f800000
    7380:	.word	0x473b8000
    7384:	.word	0x20020588
    7388:	.word	0x200205f0

0000738c <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)>:
    float vowel,
    float formant_shift,
    float* excitation,
    float* output,
    size_t size) {
  if (frequency >= 0.0625f) {
    738c:	vldr	s14, [pc, #552]	; 75b8 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x22c>
    float frequency,
    float vowel,
    float formant_shift,
    float* excitation,
    float* output,
    size_t size) {
    7390:	vmov.f32	s9, s0
  if (frequency >= 0.0625f) {
    frequency = 0.0625f;
    7394:	vcmp.f32	s0, s14
    float frequency,
    float vowel,
    float formant_shift,
    float* excitation,
    float* output,
    size_t size) {
    7398:	push	{r4, r5, r6, r7, lr}
  if (frequency >= 0.0625f) {
    frequency = 0.0625f;
    739a:	vmrs	APSR_nzcv, fpscr
    float frequency,
    float vowel,
    float formant_shift,
    float* excitation,
    float* output,
    size_t size) {
    739e:	mov	r4, r0
    73a0:	mov	r5, r2
    73a2:	mov	r6, r3
    73a4:	vpush	{d8-d10}
    73a8:	sub	sp, #28
  if (frequency >= 0.0625f) {
    frequency = 0.0625f;
    73aa:	it	ge
    73ac:	vmovge.f32	s9, s14
    float frequency,
    float vowel,
    float formant_shift,
    float* excitation,
    float* output,
    size_t size) {
    73b0:	ldr	r7, [sp, #72]	; 0x48
  if (frequency >= 0.0625f) {
    frequency = 0.0625f;
  }
  
  if (consonant) {
    73b2:	cmp	r1, #0
    73b4:	bne.w	7562 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x1d6>
    73b8:	ldr	r3, [r0, #28]
    consonant_samples_ = kSampleRate * 0.05f;
    int r = (vowel + 3.0f * frequency + 7.0f * formant_shift) * 8.0f;
    consonant_index_ = (r % kSAMNumConsonants);
  }
  consonant_samples_ -= min(consonant_samples_, size);
    73ba:	cmp	r3, r7
    73bc:	ite	ls
    73be:	subls	r3, r3, r3
    73c0:	subhi	r3, r3, r7
    73c2:	str	r3, [r4, #28]
  
  float phoneme = consonant_samples_
      ? (consonant_index_ + kSAMNumVowels)
      : vowel * (kSAMNumVowels - 1.0001f);
    73c4:	cmp	r3, #0
    73c6:	beq.w	7558 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x1cc>
    73ca:	vmov.f32	s0, #34	; 0x41100000  9.0
    73ce:	vldr	s15, [r4, #32]
    73d2:	vadd.f32	s0, s15, s0
  
  InterpolatePhonemeData(
      phoneme,
      formant_shift,
      formant_frequency,
      formant_amplitude);
    73d6:	mov	r0, r4
    73d8:	vmov.f32	s1, s2
    73dc:	add	r2, sp, #12
    73de:	mov	r1, sp
    73e0:	bl	72d0 <plaits::SAMSpeechSynth::InterpolatePhonemeData(float, float, unsigned long*, float*)>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    73e4:	vldr	s10, [r4, #4]
    increment_ = (new_value - *state) / static_cast<float>(size);
    73e8:	vmov	s15, r7

  ParameterInterpolator fm(&frequency_, frequency, size);
  float pulse_next_sample = pulse_next_sample_;
    73ec:	vldr	s18, [r4, #8]
    73f0:	vsub.f32	s9, s9, s10
  
  while (size--) {
    73f4:	subs	r0, r7, #1
    73f6:	vcvt.f32.u32	s15, s15
    73fa:	vdiv.f32	s7, s9, s15
    73fe:	cmp	r7, #0
    7400:	beq.w	7548 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x1bc>
  
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
    7404:	vldr	s0, [sp]
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
    7408:	vldr	s1, [sp, #4]
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
    740c:	vldr	s2, [sp, #8]
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    7410:	vldr	s3, [sp, #12]
    float pulse_this_sample = pulse_next_sample;
    pulse_next_sample = 0.0f;
    const float frequency = fm.Next();
    phase_ += frequency;
  
    if (phase_ >= 1.0f) {
    7414:	vmov.f32	s11, #112	; 0x3f800000  1.0
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    7418:	vldr	s4, [sp, #16]
          t * static_cast<float>(formant_frequency[0]));
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
    741c:	vmov.f32	s8, #96	; 0x3f000000  0.5
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    s += lut_sine[formant_phase_[2] >> 22] * formant_amplitude[2];
    7420:	vldr	s5, [sp, #20]
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    7424:	vmov.f32	s16, #224	; 0xbf000000 -0.5
    7428:	ldr	r7, [pc, #400]	; (75bc <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x230>)
      formant_phase_[2] += formant_frequency[2];
    }
    pulse_next_sample += phase_;
    
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    742a:	vmov.f32	s6, #48	; 0x41800000  16.0
  ParameterInterpolator fm(&frequency_, frequency, size);
  float pulse_next_sample = pulse_next_sample_;
  
  while (size--) {
    float pulse_this_sample = pulse_next_sample;
    pulse_next_sample = 0.0f;
    742e:	vldr	s9, [pc, #400]	; 75c0 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x234>
    7432:	b.n	7506 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x17a>
    const float frequency = fm.Next();
    phase_ += frequency;
  
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    7434:	vsub.f32	s12, s12, s11
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
    7438:	vcvt.f32.u32	s14, s1
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
    743c:	vcvt.f32.u32	s15, s2
    const float frequency = fm.Next();
    phase_ += frequency;
  
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
      float t = phase_ / frequency;
    7440:	vdiv.f32	s17, s12, s10
    pulse_next_sample = 0.0f;
    const float frequency = fm.Next();
    phase_ += frequency;
  
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    7444:	vstr	s12, [r4]
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
    7448:	vcvt.f32.u32	s13, s0
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
    744c:	vmul.f32	s14, s14, s17
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
    7450:	vmul.f32	s15, s15, s17
    7454:	vsub.f32	s19, s11, s17
      phase_ -= 1.0f;
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
    7458:	vcvt.u32.f32	s14, s14
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
    745c:	vcvt.u32.f32	s15, s15
      pulse_this_sample -= ThisBlepSample(t);
    7460:	vmul.f32	s20, s17, s8
      phase_ -= 1.0f;
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
    7464:	vmov	r1, s14
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    7468:	vmul.f32	s14, s19, s16
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
    746c:	vmov	r2, s15
      pulse_this_sample -= ThisBlepSample(t);
    7470:	vmov.f32	s15, s18
      pulse_next_sample -= NextBlepSample(t);
    7474:	vmov.f32	s18, s9
      phase_ -= 1.0f;
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
    7478:	str	r1, [r4, #20]
  
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
    747a:	vmul.f32	s13, s13, s17
      formant_phase_[1] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[1]));
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
    747e:	str	r2, [r4, #24]
      pulse_this_sample -= ThisBlepSample(t);
    7480:	vfms.f32	s15, s17, s20
      pulse_next_sample -= NextBlepSample(t);
    7484:	vfms.f32	s18, s19, s14
  
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
      float t = phase_ / frequency;
      formant_phase_[0] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[0]));
    7488:	vcvt.u32.f32	s13, s13
    748c:	vmov	r3, s13
    7490:	vstr	s13, [r4, #16]
      formant_phase_[2] += formant_frequency[2];
    }
    pulse_next_sample += phase_;
    
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    7494:	vmul.f32	s13, s10, s6
      formant_phase_[1] += formant_frequency[1];
      formant_phase_[2] += formant_frequency[2];
    }
    pulse_next_sample += phase_;
    
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    7498:	vldr	s14, [r4, #12]
    749c:	vsub.f32	s15, s15, s8
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    74a0:	lsrs	r3, r3, #22
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    74a2:	lsrs	r1, r1, #22
    } else {
      formant_phase_[0] += formant_frequency[0];
      formant_phase_[1] += formant_frequency[1];
      formant_phase_[2] += formant_frequency[2];
    }
    pulse_next_sample += phase_;
    74a4:	vadd.f32	s18, s18, s12
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
      return __a;
    74a8:	vcmpe.f32	s13, s11
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    74ac:	add.w	r3, r7, r3, lsl #2
      formant_phase_[1] += formant_frequency[1];
      formant_phase_[2] += formant_frequency[2];
    }
    pulse_next_sample += phase_;
    
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    74b0:	vsub.f32	s15, s15, s14
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    74b4:	add.w	r1, r7, r1, lsl #2
    s += lut_sine[formant_phase_[2] >> 22] * formant_amplitude[2];
    74b8:	lsrs	r2, r2, #22
      formant_amplitude);

  ParameterInterpolator fm(&frequency_, frequency, size);
  float pulse_next_sample = pulse_next_sample_;
  
  while (size--) {
    74ba:	subs	r0, #1
    74bc:	vmrs	APSR_nzcv, fpscr
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    s += lut_sine[formant_phase_[2] >> 22] * formant_amplitude[2];
    74c0:	add.w	r2, r7, r2, lsl #2
    74c4:	it	gt
    74c6:	vmovgt.f32	s13, s11
      formant_phase_[2] += formant_frequency[2];
    }
    pulse_next_sample += phase_;
    
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    74ca:	vfma.f32	s14, s15, s13
    74ce:	vstr	s14, [r4, #12]
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    74d2:	vmov.f32	s14, s9
    }
    pulse_next_sample += phase_;
    
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
    74d6:	vstmia	r5!, {s15}
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    74da:	vldr	s15, [r3]
      formant_amplitude);

  ParameterInterpolator fm(&frequency_, frequency, size);
  float pulse_next_sample = pulse_next_sample_;
  
  while (size--) {
    74de:	adds	r3, r0, #1
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    74e0:	vldr	s12, [r1]
    float d = pulse_this_sample - 0.5f - pulse_lp_;
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    74e4:	vfma.f32	s14, s15, s3
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    s += lut_sine[formant_phase_[2] >> 22] * formant_amplitude[2];
    74e8:	vldr	s15, [r2]
    s *= (1.0f - phase_);
    *output++ = s;
    74ec:	vldr	s13, [r4]
    74f0:	vsub.f32	s13, s11, s13
    pulse_lp_ += min(16.0f * frequency, 1.0f) * d;
    *excitation++ = d;
  
    float s = 0;
    s += lut_sine[formant_phase_[0] >> 22] * formant_amplitude[0];
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    74f4:	vfma.f32	s14, s12, s4
    s += lut_sine[formant_phase_[2] >> 22] * formant_amplitude[2];
    74f8:	vfma.f32	s14, s15, s5
    s *= (1.0f - phase_);
    *output++ = s;
    74fc:	vmul.f32	s14, s13, s14
    7500:	vstmia	r6!, {s14}
      formant_amplitude);

  ParameterInterpolator fm(&frequency_, frequency, size);
  float pulse_next_sample = pulse_next_sample_;
  
  while (size--) {
    7504:	beq.n	7548 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x1bc>
  }

  inline float Next() {
    value_ += increment_;
    7506:	vadd.f32	s10, s10, s7
    float pulse_this_sample = pulse_next_sample;
    pulse_next_sample = 0.0f;
    const float frequency = fm.Next();
    phase_ += frequency;
    750a:	vldr	s12, [r4]
    750e:	vadd.f32	s12, s10, s12
  
    if (phase_ >= 1.0f) {
    7512:	vcmpe.f32	s12, s11
  
  while (size--) {
    float pulse_this_sample = pulse_next_sample;
    pulse_next_sample = 0.0f;
    const float frequency = fm.Next();
    phase_ += frequency;
    7516:	vstr	s12, [r4]
  
    if (phase_ >= 1.0f) {
    751a:	vmrs	APSR_nzcv, fpscr
    751e:	bge.n	7434 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0xa8>
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    } else {
      formant_phase_[0] += formant_frequency[0];
    7520:	ldr	r3, [r4, #16]
    7522:	vmov	lr, s0
      formant_phase_[1] += formant_frequency[1];
    7526:	ldr	r1, [r4, #20]
      formant_phase_[2] += formant_frequency[2];
    7528:	vmov.f32	s15, s18
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    } else {
      formant_phase_[0] += formant_frequency[0];
    752c:	add	r3, lr
      formant_phase_[1] += formant_frequency[1];
    752e:	vmov	lr, s1
      formant_phase_[2] += formant_frequency[2];
    7532:	ldr	r2, [r4, #24]
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    } else {
      formant_phase_[0] += formant_frequency[0];
      formant_phase_[1] += formant_frequency[1];
    7534:	add	r1, lr
      formant_phase_[2] += formant_frequency[2];
    7536:	vmov	lr, s2
  ParameterInterpolator fm(&frequency_, frequency, size);
  float pulse_next_sample = pulse_next_sample_;
  
  while (size--) {
    float pulse_this_sample = pulse_next_sample;
    pulse_next_sample = 0.0f;
    753a:	vldr	s18, [pc, #132]	; 75c0 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x234>
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    } else {
      formant_phase_[0] += formant_frequency[0];
      formant_phase_[1] += formant_frequency[1];
      formant_phase_[2] += formant_frequency[2];
    753e:	add	r2, lr
      formant_phase_[2] = static_cast<uint32_t>(
          t * static_cast<float>(formant_frequency[2]));
      pulse_this_sample -= ThisBlepSample(t);
      pulse_next_sample -= NextBlepSample(t);
    } else {
      formant_phase_[0] += formant_frequency[0];
    7540:	str	r3, [r4, #16]
      formant_phase_[1] += formant_frequency[1];
    7542:	str	r1, [r4, #20]
      formant_phase_[2] += formant_frequency[2];
    7544:	str	r2, [r4, #24]
    7546:	b.n	7494 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x108>
    s += lut_sine[formant_phase_[1] >> 22] * formant_amplitude[1];
    s += lut_sine[formant_phase_[2] >> 22] * formant_amplitude[2];
    s *= (1.0f - phase_);
    *output++ = s;
  }
  pulse_next_sample_ = pulse_next_sample;
    7548:	vstr	s18, [r4, #8]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    754c:	vstr	s10, [r4, #4]
}
    7550:	add	sp, #28
    7552:	vpop	{d8-d10}
    7556:	pop	{r4, r5, r6, r7, pc}
  }
  consonant_samples_ -= min(consonant_samples_, size);
  
  float phoneme = consonant_samples_
      ? (consonant_index_ + kSAMNumVowels)
      : vowel * (kSAMNumVowels - 1.0001f);
    7558:	vldr	s0, [pc, #104]	; 75c4 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x238>
    755c:	vmul.f32	s0, s1, s0
    7560:	b.n	73d6 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x4a>
  }
  
  if (consonant) {
    consonant_samples_ = kSampleRate * 0.05f;
    int r = (vowel + 3.0f * frequency + 7.0f * formant_shift) * 8.0f;
    consonant_index_ = (r % kSAMNumConsonants);
    7562:	vmov.f32	s14, #8	; 0x40400000  3.0
    7566:	ldr	r3, [pc, #96]	; (75c8 <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x23c>)
    7568:	vmov.f32	s15, s1
    756c:	vmov.f32	s13, #28	; 0x40e00000  7.0
    7570:	vfma.f32	s15, s9, s14
    7574:	vmov.f32	s14, s15
    7578:	vfma.f32	s14, s2, s13
    757c:	vcvt.s32.f32	s14, s14, #3
    7580:	vmov	r2, s14
    7584:	ands	r2, r3
    7586:	cmp	r2, #0
    7588:	mov	r3, r2
    758a:	blt.n	759e <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x212>
    758c:	vmov	s15, r3
    7590:	mov.w	r3, #2400	; 0x960
    7594:	vcvt.f32.s32	s14, s15
    7598:	vstr	s14, [r4, #32]
    759c:	b.n	73ba <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x2e>
    759e:	subs	r3, r2, #1
    75a0:	orn	r3, r3, #7
    75a4:	adds	r3, #1
    75a6:	vmov	s15, r3
    75aa:	mov.w	r3, #2400	; 0x960
    75ae:	vcvt.f32.s32	s14, s15
    75b2:	vstr	s14, [r4, #32]
    75b6:	b.n	73ba <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)+0x2e>
    75b8:	.word	0x3d800000
    75bc:	.word	0x20002b10
    75c0:	.word	0x00000000
    75c4:	.word	0x40ffff2e
    75c8:	.word	0x80000007

000075cc <plaits::LPCSpeechSynth::Init()>:
namespace plaits {

using namespace std;
using namespace stmlib;

void LPCSpeechSynth::Init() {
    75cc:	push	{r4, r5, r6}
  phase_ = 0.0f;
    75ce:	movs	r4, #0
  frequency_ = 0.0125f;
    75d0:	ldr	r6, [pc, #48]	; (7604 <plaits::LPCSpeechSynth::Init()+0x38>)
  noise_energy_ = 0.0f;
  pulse_energy_ = 0.0f;

  next_sample_ = 0.0f;
  excitation_pulse_sample_index_ = 0;
    75d2:	movs	r5, #0

  fill(&k_[0], &k_[kLPCOrder], 0);
    75d4:	add.w	r2, r0, #24
    75d8:	add.w	r3, r0, #64	; 0x40
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    75dc:	mov	r1, r4
using namespace std;
using namespace stmlib;

void LPCSpeechSynth::Init() {
  phase_ = 0.0f;
  frequency_ = 0.0125f;
    75de:	str	r6, [r0, #4]
  noise_energy_ = 0.0f;
  pulse_energy_ = 0.0f;

  next_sample_ = 0.0f;
  excitation_pulse_sample_index_ = 0;
    75e0:	str	r5, [r0, #20]

using namespace std;
using namespace stmlib;

void LPCSpeechSynth::Init() {
  phase_ = 0.0f;
    75e2:	str	r4, [r0, #0]
  frequency_ = 0.0125f;
  noise_energy_ = 0.0f;
    75e4:	str	r4, [r0, #8]
  pulse_energy_ = 0.0f;
    75e6:	str	r4, [r0, #12]

  next_sample_ = 0.0f;
    75e8:	str	r4, [r0, #16]
    75ea:	str.w	r1, [r2], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    75ee:	cmp	r3, r2
    75f0:	bne.n	75ea <plaits::LPCSpeechSynth::Init()+0x1e>
  excitation_pulse_sample_index_ = 0;

  fill(&k_[0], &k_[kLPCOrder], 0);
  fill(&s_[0], &s_[kLPCOrder + 1], 0);
    75f2:	adds	r0, #108	; 0x6c
	*__first = __tmp;
    75f4:	movs	r2, #0
    75f6:	str.w	r2, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    75fa:	cmp	r0, r3
    75fc:	bne.n	75f6 <plaits::LPCSpeechSynth::Init()+0x2a>
}
    75fe:	pop	{r4, r5, r6}
    7600:	bx	lr
    7602:	nop
    7604:	.word	0x3c4ccccd

00007608 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)>:
    float* excitation,
    float* output,
    size_t size) {
  const float base_f0 = kLPCSpeechSynthDefaultF0 / 8000.0f;
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
    7608:	vldr	s15, [pc, #624]	; 787c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x274>
    760c:	vldr	s14, [r0, #4]
    7610:	vsub.f32	s14, s14, s15
void LPCSpeechSynth::Render(
    float prosody_amount,
    float pitch_shift,
    float* excitation,
    float* output,
    size_t size) {
    7614:	push	{r4, r5, r6, r7, lr}
  const float base_f0 = kLPCSpeechSynthDefaultF0 / 8000.0f;
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
    7616:	vfma.f32	s15, s14, s0
void LPCSpeechSynth::Render(
    float prosody_amount,
    float pitch_shift,
    float* excitation,
    float* output,
    size_t size) {
    761a:	vpush	{d8-d15}
  const float base_f0 = kLPCSpeechSynthDefaultF0 / 8000.0f;
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
    761e:	vmul.f32	s1, s15, s1
  CONSTRAIN(f, 0.0f, 0.5f);
    7622:	vcmpe.f32	s1, #0.0
    7626:	vmrs	APSR_nzcv, fpscr
    762a:	bmi.w	7876 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x26e>
    762e:	vmov.f32	s15, #96	; 0x3f000000  0.5
    7632:	vcmp.f32	s1, s15
    7636:	vmrs	APSR_nzcv, fpscr
    763a:	it	gt
    763c:	vmovgt.f32	s1, s15
  
  float next_sample = next_sample_;
    7640:	vldr	s3, [r0, #16]
  while (size--) {
    7644:	subs	r6, r3, #1
    7646:	cmp	r3, #0
    7648:	beq.w	786c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x264>
    764c:	ldr.w	ip, [pc, #584]	; 7898 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x290>
    phase_ += f;
    
    float this_sample = next_sample;
    next_sample = 0.0f;
    
    if (phase_ >= 1.0f) {
    7650:	vmov.f32	s30, #112	; 0x3f800000  1.0
      int reset_sample = static_cast<int>(32.0f * reset_time);
      
      float discontinuity = 0.0f;
      if (excitation_pulse_sample_index_ < LUT_LPC_EXCITATION_PULSE_SIZE) {
        excitation_pulse_sample_index_ -= reset_sample;
        int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
    7654:	ldr.w	lr, [pc, #580]	; 789c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x294>
    7658:	ldr.w	r3, [ip]
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
    765c:	ldr	r7, [pc, #544]	; (7880 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x278>)
    765e:	b.n	76ce <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0xc6>
    e[3] = e[4] - k_[3] * s_[3];
    e[2] = e[3] - k_[2] * s_[2];
    e[1] = e[2] - k_[1] * s_[1];
    e[0] = e[1] - k_[0] * s_[0];
  
    CONSTRAIN(e[0], -2.0f, 2.0f);
    7660:	vmov.f32	s31, #0	; 0x40000000  2.0
    7664:	vcmp.f32	s15, s31
    7668:	vmrs	APSR_nzcv, fpscr
    766c:	it	gt
    766e:	vmovgt.f32	s15, s31

    s_[9] = s_[8] + k_[8] * e[8];
    7672:	vfma.f32	s5, s29, s4
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
  CONSTRAIN(f, 0.0f, 0.5f);
  
  float next_sample = next_sample_;
  while (size--) {
    7676:	subs	r6, #1
    e[0] = e[1] - k_[0] * s_[0];
  
    CONSTRAIN(e[0], -2.0f, 2.0f);

    s_[9] = s_[8] + k_[8] * e[8];
    s_[8] = s_[7] + k_[7] * e[7];
    7678:	vfma.f32	s6, s28, s27
    s_[5] = s_[4] + k_[4] * e[4];
    s_[4] = s_[3] + k_[3] * e[3];
    s_[3] = s_[2] + k_[2] * e[2];
    s_[2] = s_[1] + k_[1] * e[1];
    s_[1] = s_[0] + k_[0] * e[0];
    s_[0] = e[0];
    767c:	vstr	s15, [r0, #64]	; 0x40
  
    CONSTRAIN(e[0], -2.0f, 2.0f);

    s_[9] = s_[8] + k_[8] * e[8];
    s_[8] = s_[7] + k_[7] * e[7];
    s_[7] = s_[6] + k_[6] * e[6];
    7680:	vfma.f32	s7, s26, s25
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
  CONSTRAIN(f, 0.0f, 0.5f);
  
  float next_sample = next_sample_;
  while (size--) {
    7684:	adds	r4, r6, #1
    CONSTRAIN(e[0], -2.0f, 2.0f);

    s_[9] = s_[8] + k_[8] * e[8];
    s_[8] = s_[7] + k_[7] * e[7];
    s_[7] = s_[6] + k_[6] * e[6];
    s_[6] = s_[5] + k_[5] * e[5];
    7686:	vfma.f32	s8, s24, s23
    s_[5] = s_[4] + k_[4] * e[4];
    768a:	vfma.f32	s9, s22, s21
    s_[4] = s_[3] + k_[3] * e[3];
    768e:	vfma.f32	s10, s20, s19
    s_[3] = s_[2] + k_[2] * e[2];
    7692:	vfma.f32	s11, s18, s17
    e[1] = e[2] - k_[1] * s_[1];
    e[0] = e[1] - k_[0] * s_[0];
  
    CONSTRAIN(e[0], -2.0f, 2.0f);

    s_[9] = s_[8] + k_[8] * e[8];
    7696:	vstr	s5, [r0, #100]	; 0x64
    s_[7] = s_[6] + k_[6] * e[6];
    s_[6] = s_[5] + k_[5] * e[5];
    s_[5] = s_[4] + k_[4] * e[4];
    s_[4] = s_[3] + k_[3] * e[3];
    s_[3] = s_[2] + k_[2] * e[2];
    s_[2] = s_[1] + k_[1] * e[1];
    769a:	vfma.f32	s12, s16, s0
    e[0] = e[1] - k_[0] * s_[0];
  
    CONSTRAIN(e[0], -2.0f, 2.0f);

    s_[9] = s_[8] + k_[8] * e[8];
    s_[8] = s_[7] + k_[7] * e[7];
    769e:	vstr	s6, [r0, #96]	; 0x60
    s_[6] = s_[5] + k_[5] * e[5];
    s_[5] = s_[4] + k_[4] * e[4];
    s_[4] = s_[3] + k_[3] * e[3];
    s_[3] = s_[2] + k_[2] * e[2];
    s_[2] = s_[1] + k_[1] * e[1];
    s_[1] = s_[0] + k_[0] * e[0];
    76a2:	vfma.f32	s13, s2, s15
  
    CONSTRAIN(e[0], -2.0f, 2.0f);

    s_[9] = s_[8] + k_[8] * e[8];
    s_[8] = s_[7] + k_[7] * e[7];
    s_[7] = s_[6] + k_[6] * e[6];
    76a6:	vstr	s7, [r0, #92]	; 0x5c
    s_[6] = s_[5] + k_[5] * e[5];
    76aa:	vstr	s8, [r0, #88]	; 0x58
    s_[5] = s_[4] + k_[4] * e[4];
    76ae:	vstr	s9, [r0, #84]	; 0x54
    s_[4] = s_[3] + k_[3] * e[3];
    76b2:	vstr	s10, [r0, #80]	; 0x50
    s_[3] = s_[2] + k_[2] * e[2];
    76b6:	vstr	s11, [r0, #76]	; 0x4c
    s_[2] = s_[1] + k_[1] * e[1];
    76ba:	vstr	s12, [r0, #72]	; 0x48
    s_[1] = s_[0] + k_[0] * e[0];
    76be:	vstr	s13, [r0, #68]	; 0x44
    s_[0] = e[0];
    
    *excitation++ = e[10];
    76c2:	vstmia	r1!, {s14}
    *output++ = e[0];
    76c6:	vstmia	r2!, {s15}
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
  CONSTRAIN(f, 0.0f, 0.5f);
  
  float next_sample = next_sample_;
  while (size--) {
    76ca:	beq.w	7868 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x260>
    phase_ += f;
    76ce:	vldr	s15, [r0]
    76d2:	vadd.f32	s15, s1, s15
    
    float this_sample = next_sample;
    next_sample = 0.0f;
    
    if (phase_ >= 1.0f) {
    76d6:	vcmpe.f32	s15, s30
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
  CONSTRAIN(f, 0.0f, 0.5f);
  
  float next_sample = next_sample_;
  while (size--) {
    phase_ += f;
    76da:	vstr	s15, [r0]
    
    float this_sample = next_sample;
    next_sample = 0.0f;
    
    if (phase_ >= 1.0f) {
    76de:	vmrs	APSR_nzcv, fpscr
    76e2:	blt.w	785c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x254>
      phase_ -= 1.0f;
    76e6:	vsub.f32	s15, s15, s30
      float reset_time = phase_ / f;
      int reset_sample = static_cast<int>(32.0f * reset_time);
      
      float discontinuity = 0.0f;
      if (excitation_pulse_sample_index_ < LUT_LPC_EXCITATION_PULSE_SIZE) {
    76ea:	ldr	r5, [r0, #20]
    76ec:	cmp.w	r5, #640	; 0x280
    float this_sample = next_sample;
    next_sample = 0.0f;
    
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
      float reset_time = phase_ / f;
    76f0:	vdiv.f32	s14, s15, s1
    
    float this_sample = next_sample;
    next_sample = 0.0f;
    
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    76f4:	vstr	s15, [r0]
      float reset_time = phase_ / f;
      int reset_sample = static_cast<int>(32.0f * reset_time);
    76f8:	vldr	s15, [pc, #392]	; 7884 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x27c>
    76fc:	vmul.f32	s15, s14, s15
    7700:	vcvt.s32.f32	s15, s15
    7704:	vmov	r4, s15
      
      float discontinuity = 0.0f;
      if (excitation_pulse_sample_index_ < LUT_LPC_EXCITATION_PULSE_SIZE) {
    7708:	bge.w	7856 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x24e>
        excitation_pulse_sample_index_ -= reset_sample;
    770c:	subs	r5, r5, r4
    770e:	vldr	s12, [pc, #376]	; 7888 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x280>
    7712:	vldr	s15, [r0, #12]
    7716:	str	r5, [r0, #20]
    7718:	ldrsb.w	r5, [lr, r5]
    771c:	vmov	s13, r5
    7720:	vcvt.f32.s32	s13, s13
    7724:	vmul.f32	s13, s13, s12
    7728:	vnmul.f32	s13, s15, s13
        int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
        discontinuity = static_cast<float>(s) / 128.0f * pulse_energy_;
      }
      
      this_sample += -discontinuity * ThisBlepSample(reset_time);
    772c:	vmov.f32	s15, #96	; 0x3f000000  0.5
    7730:	mov	r5, r4
    7732:	vsub.f32	s11, s30, s14
      next_sample += -discontinuity * NextBlepSample(reset_time);
      
      excitation_pulse_sample_index_ = reset_sample;
    7736:	str	r4, [r0, #20]
        excitation_pulse_sample_index_ -= reset_sample;
        int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
        discontinuity = static_cast<float>(s) / 128.0f * pulse_energy_;
      }
      
      this_sample += -discontinuity * ThisBlepSample(reset_time);
    7738:	vmul.f32	s12, s14, s15
      next_sample += -discontinuity * NextBlepSample(reset_time);
    773c:	vmov.f32	s15, #224	; 0xbf000000 -0.5
        excitation_pulse_sample_index_ -= reset_sample;
        int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
        discontinuity = static_cast<float>(s) / 128.0f * pulse_energy_;
      }
      
      this_sample += -discontinuity * ThisBlepSample(reset_time);
    7740:	vmul.f32	s14, s12, s14
      next_sample += -discontinuity * NextBlepSample(reset_time);
    7744:	vmul.f32	s15, s11, s15
        excitation_pulse_sample_index_ -= reset_sample;
        int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
        discontinuity = static_cast<float>(s) / 128.0f * pulse_energy_;
      }
      
      this_sample += -discontinuity * ThisBlepSample(reset_time);
    7748:	vmov.f32	s12, s3
      next_sample += -discontinuity * NextBlepSample(reset_time);
    774c:	vldr	s3, [pc, #316]	; 788c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x284>
    7750:	vmul.f32	s15, s15, s11
        excitation_pulse_sample_index_ -= reset_sample;
        int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
        discontinuity = static_cast<float>(s) / 128.0f * pulse_energy_;
      }
      
      this_sample += -discontinuity * ThisBlepSample(reset_time);
    7754:	vfma.f32	s12, s14, s13
      next_sample += -discontinuity * NextBlepSample(reset_time);
    7758:	vfma.f32	s3, s15, s13
    775c:	mul.w	r4, r7, r3
    7760:	ldr	r3, [pc, #300]	; (7890 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x288>)
      
      excitation_pulse_sample_index_ = reset_sample;
    }
    
    float e[11];
    e[10] = Random::GetSample() > 0 ? noise_energy_ : -noise_energy_;
    7762:	vldr	s14, [r0, #8]
    7766:	add	r3, r4
    7768:	cmp.w	r3, #65536	; 0x10000
    776c:	it	lt
    776e:	vneglt.f32	s14, s14
    if (excitation_pulse_sample_index_ < LUT_LPC_EXCITATION_PULSE_SIZE) {
    7772:	cmp.w	r5, #640	; 0x280
    7776:	bge.n	7798 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x190>
      int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
      next_sample += static_cast<float>(s) / 128.0f * pulse_energy_;
    7778:	ldrsb.w	r4, [lr, r5]
      excitation_pulse_sample_index_ += 32;
    777c:	adds	r5, #32
    
    float e[11];
    e[10] = Random::GetSample() > 0 ? noise_energy_ : -noise_energy_;
    if (excitation_pulse_sample_index_ < LUT_LPC_EXCITATION_PULSE_SIZE) {
      int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
      next_sample += static_cast<float>(s) / 128.0f * pulse_energy_;
    777e:	vldr	s11, [pc, #264]	; 7888 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x280>
    7782:	vmov	s13, r4
    7786:	vldr	s15, [r0, #12]
      excitation_pulse_sample_index_ += 32;
    778a:	str	r5, [r0, #20]
    
    float e[11];
    e[10] = Random::GetSample() > 0 ? noise_energy_ : -noise_energy_;
    if (excitation_pulse_sample_index_ < LUT_LPC_EXCITATION_PULSE_SIZE) {
      int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
      next_sample += static_cast<float>(s) / 128.0f * pulse_energy_;
    778c:	vcvt.f32.s32	s13, s13
    7790:	vmul.f32	s13, s13, s11
    7794:	vfma.f32	s3, s13, s15
      excitation_pulse_sample_index_ += 32;
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
    7798:	vadd.f32	s15, s12, s14
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    779c:	vldr	s13, [r0, #100]	; 0x64
      int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
      next_sample += static_cast<float>(s) / 128.0f * pulse_energy_;
      excitation_pulse_sample_index_ += 32;
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
    77a0:	vmov.f32	s14, #120	; 0x3fc00000  1.5
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    77a4:	vldr	s12, [r0, #60]	; 0x3c
    77a8:	vldr	s29, [r0, #56]	; 0x38
    e[3] = e[4] - k_[3] * s_[3];
    e[2] = e[3] - k_[2] * s_[2];
    e[1] = e[2] - k_[1] * s_[1];
    e[0] = e[1] - k_[0] * s_[0];
  
    CONSTRAIN(e[0], -2.0f, 2.0f);
    77ac:	vmov.f32	s31, #128	; 0xc0000000 -2.0
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    77b0:	vldr	s5, [r0, #96]	; 0x60
      int8_t s = lut_lpc_excitation_pulse[excitation_pulse_sample_index_];
      next_sample += static_cast<float>(s) / 128.0f * pulse_energy_;
      excitation_pulse_sample_index_ += 32;
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
    77b4:	vmul.f32	s14, s15, s14
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    e[7] = e[8] - k_[7] * s_[7];
    77b8:	vldr	s28, [r0, #52]	; 0x34
    77bc:	vldr	s6, [r0, #92]	; 0x5c
    e[6] = e[7] - k_[6] * s_[6];
    77c0:	vldr	s26, [r0, #48]	; 0x30
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    77c4:	vmov.f32	s4, s14
    e[7] = e[8] - k_[7] * s_[7];
    e[6] = e[7] - k_[6] * s_[6];
    77c8:	vldr	s7, [r0, #88]	; 0x58
    e[5] = e[6] - k_[5] * s_[5];
    77cc:	vldr	s24, [r0, #44]	; 0x2c
    77d0:	vldr	s8, [r0, #84]	; 0x54
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    77d4:	vfms.f32	s4, s12, s13
    e[7] = e[8] - k_[7] * s_[7];
    e[6] = e[7] - k_[6] * s_[6];
    e[5] = e[6] - k_[5] * s_[5];
    e[4] = e[5] - k_[4] * s_[4];
    77d8:	vldr	s22, [r0, #40]	; 0x28
    77dc:	vldr	s9, [r0, #80]	; 0x50
    e[3] = e[4] - k_[3] * s_[3];
    77e0:	vldr	s20, [r0, #36]	; 0x24
    77e4:	vldr	s10, [r0, #76]	; 0x4c
    e[2] = e[3] - k_[2] * s_[2];
    77e8:	vldr	s18, [r0, #32]
    77ec:	vldr	s11, [r0, #72]	; 0x48
    }
    e[10] += this_sample;
    e[10] *= 1.5f;
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    77f0:	vfms.f32	s4, s29, s5
    e[6] = e[7] - k_[6] * s_[6];
    e[5] = e[6] - k_[5] * s_[5];
    e[4] = e[5] - k_[4] * s_[4];
    e[3] = e[4] - k_[3] * s_[3];
    e[2] = e[3] - k_[2] * s_[2];
    e[1] = e[2] - k_[1] * s_[1];
    77f4:	vldr	s16, [r0, #28]
    77f8:	vldr	s12, [r0, #68]	; 0x44
    e[0] = e[1] - k_[0] * s_[0];
    77fc:	vldr	s2, [r0, #24]
    7800:	vldr	s13, [r0, #64]	; 0x40
    e[10] += this_sample;
    e[10] *= 1.5f;
  
    e[9] = e[10] - k_[9] * s_[9];
    e[8] = e[9] - k_[8] * s_[8];
    e[7] = e[8] - k_[7] * s_[7];
    7804:	vmov.f32	s27, s4
    7808:	vfms.f32	s27, s28, s6
    e[6] = e[7] - k_[6] * s_[6];
    780c:	vmov.f32	s25, s27
    7810:	vfms.f32	s25, s26, s7
    e[5] = e[6] - k_[5] * s_[5];
    7814:	vmov.f32	s23, s25
    7818:	vfms.f32	s23, s24, s8
    e[4] = e[5] - k_[4] * s_[4];
    781c:	vmov.f32	s21, s23
    7820:	vfms.f32	s21, s22, s9
    e[3] = e[4] - k_[3] * s_[3];
    7824:	vmov.f32	s19, s21
    7828:	vfms.f32	s19, s20, s10
    e[2] = e[3] - k_[2] * s_[2];
    782c:	vmov.f32	s17, s19
    7830:	vfms.f32	s17, s18, s11
    e[1] = e[2] - k_[1] * s_[1];
    7834:	vmov.f32	s0, s17
    7838:	vfms.f32	s0, s16, s12
    e[0] = e[1] - k_[0] * s_[0];
    783c:	vmov.f32	s15, s0
    7840:	vfms.f32	s15, s2, s13
  
    CONSTRAIN(e[0], -2.0f, 2.0f);
    7844:	vcmpe.f32	s15, s31
    7848:	vmrs	APSR_nzcv, fpscr
    784c:	bpl.w	7660 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x58>
    7850:	vmov.f32	s15, s31
    7854:	b.n	7672 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x6a>
    7856:	vldr	s13, [pc, #60]	; 7894 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x28c>
    785a:	b.n	772c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x124>
    phase_ += f;
    
    float this_sample = next_sample;
    next_sample = 0.0f;
    
    if (phase_ >= 1.0f) {
    785c:	vmov.f32	s12, s3
    7860:	ldr	r5, [r0, #20]
  float next_sample = next_sample_;
  while (size--) {
    phase_ += f;
    
    float this_sample = next_sample;
    next_sample = 0.0f;
    7862:	vldr	s3, [pc, #40]	; 788c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x284>
    7866:	b.n	775c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x154>
    7868:	str.w	r3, [ip]
    s_[0] = e[0];
    
    *excitation++ = e[10];
    *output++ = e[0];
  }
  next_sample_ = next_sample;
    786c:	vstr	s3, [r0, #16]
}
    7870:	vpop	{d8-d15}
    7874:	pop	{r4, r5, r6, r7, pc}
    float* output,
    size_t size) {
  const float base_f0 = kLPCSpeechSynthDefaultF0 / 8000.0f;
  float d = frequency_ - base_f0;
  float f = (base_f0 + d * prosody_amount) * pitch_shift;
  CONSTRAIN(f, 0.0f, 0.5f);
    7876:	vldr	s1, [pc, #20]	; 788c <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x284>
    787a:	b.n	7640 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)+0x38>
    787c:	.word	0x3c4ccccd
    7880:	.word	0x0019660d
    7884:	.word	0x42000000
    7888:	.word	0x3c000000
    788c:	.word	0x00000000
    7890:	.word	0x3c6ef35f
    7894:	.word	0x80000000
    7898:	.word	0x20020470
    789c:	.word	0x20002890

000078a0 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)>:
  }
  next_sample_ = next_sample;
}

void LPCSpeechSynth::PlayFrame(const Frame& f1, const Frame& f2, float blend) {
  float frequency_1 = f1.period == 0
    78a0:	ldrb	r3, [r1, #1]
    *output++ = e[0];
  }
  next_sample_ = next_sample;
}

void LPCSpeechSynth::PlayFrame(const Frame& f1, const Frame& f2, float blend) {
    78a2:	push	{r4}
  float frequency_1 = f1.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
    78a4:	cmp	r3, #0
    78a6:	bne.w	7afc <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x25c>
  float frequency_2 = f2.period == 0
    78aa:	ldrb	r3, [r2, #1]
}

void LPCSpeechSynth::PlayFrame(const Frame& f1, const Frame& f2, float blend) {
  float frequency_1 = f1.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
    78ac:	vldr	s15, [r0, #4]
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
    78b0:	cmp	r3, #0
    78b2:	bne.w	7b14 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x274>
    78b6:	vldr	s14, [r0, #4]
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
    78ba:	vsub.f32	s14, s14, s15

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    78be:	ldrsh.w	r3, [r2, #2]
    78c2:	vldr	s10, [pc, #612]	; 7b28 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x288>
    78c6:	vmov	s12, r3
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    78ca:	ldrsh.w	r3, [r2, #4]
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
    78ce:	vfma.f32	s15, s14, s0
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
    78d2:	vldr	s8, [pc, #600]	; 7b2c <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x28c>
  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    78d6:	vmov	s13, r3
 private:
  void PlayFrame(const Frame& f1, const Frame& f2, float blend);
  
  template <int scale, typename X>
  float BlendCoefficient(X a, X b, float blend) {
    float a_f = static_cast<float>(a) / float(scale);
    78da:	ldrsh.w	r3, [r1, #2]

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    78de:	vcvt.f32.s32	s12, s12
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
    78e2:	vldr	s9, [pc, #588]	; 7b30 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x290>
    78e6:	vmov	s6, r3
    78ea:	ldrsh.w	r3, [r1, #4]
  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    78ee:	vcvt.f32.s32	s13, s13
    78f2:	vcvt.f32.s32	s6, s6
    78f6:	vmov	s7, r3
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
    78fa:	vmov.f32	s14, s15
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
  k_[2] = BlendCoefficient<128>(f1.k2, f2.k2, blend);
    78fe:	vldr	s15, [pc, #564]	; 7b34 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x294>

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    7902:	vmul.f32	s12, s12, s10
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    7906:	vmul.f32	s13, s13, s10
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
    790a:	vstr	s14, [r0, #4]
    790e:	vcvt.f32.s32	s7, s7
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
    7912:	ldrb	r3, [r1, #0]

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    7914:	vfms.f32	s12, s6, s10
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
    7918:	ldrb	r4, [r1, #1]
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
    791a:	vmov	s14, r3
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
    791e:	ldrb	r3, [r2, #0]
  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    7920:	vfms.f32	s13, s7, s10
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
    7924:	cmp	r4, #0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
    7926:	vmov	s11, r3
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
    792a:	vcvt.f32.u32	s14, s14
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
  float noise_energy_2 = f2.period == 0 ? energy_2 : 0.0f;
    792e:	ldrb	r3, [r2, #1]
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
    7930:	vcvt.f32.u32	s11, s11
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
    7934:	vmul.f32	s14, s14, s8

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    7938:	vmul.f32	s12, s12, s0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
    793c:	vmul.f32	s11, s11, s8
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
    7940:	ite	ne
    7942:	vmovne.f32	s8, s9
    7946:	vmoveq.f32	s8, s14
  float noise_energy_2 = f2.period == 0 ? energy_2 : 0.0f;
    794a:	cmp	r3, #0

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    794c:	vfma.f32	s12, s6, s10
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    7950:	vmul.f32	s13, s13, s0
  frequency_ = frequency_1 + (frequency_2 - frequency_1) * blend;
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
  float noise_energy_2 = f2.period == 0 ? energy_2 : 0.0f;
    7954:	ite	ne
    7956:	vmovne.f32	s6, s9
    795a:	vmoveq.f32	s6, s11
  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    795e:	vfma.f32	s13, s7, s10
  
  float energy_1 = static_cast<float>(f1.energy) / 256.0f;
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
  float noise_energy_2 = f2.period == 0 ? energy_2 : 0.0f;
  noise_energy_ = noise_energy_1 + (noise_energy_2 - noise_energy_1) * blend;
    7962:	vsub.f32	s10, s6, s8
    7966:	vfma.f32	s8, s0, s10
    796a:	vstr	s8, [r0, #8]

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
    796e:	ldrb	r4, [r1, #1]
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
    7970:	ldrb	r3, [r2, #1]
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
  float noise_energy_2 = f2.period == 0 ? energy_2 : 0.0f;
  noise_energy_ = noise_energy_1 + (noise_energy_2 - noise_energy_1) * blend;

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
    7972:	cmp	r4, #0
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
    7974:	vstr	s13, [r0, #28]

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
    7978:	vstr	s12, [r0, #24]
  float energy_2 = static_cast<float>(f2.energy) / 256.0f;
  float noise_energy_1 = f1.period == 0 ? energy_1 : 0.0f;
  float noise_energy_2 = f2.period == 0 ? energy_2 : 0.0f;
  noise_energy_ = noise_energy_1 + (noise_energy_2 - noise_energy_1) * blend;

  float pulse_energy_1 = f1.period != 0 ? energy_1 : 0;
    797c:	it	eq
    797e:	vmoveq.f32	s14, s9
  float pulse_energy_2 = f2.period != 0 ? energy_2 : 0;
    7982:	cmp	r3, #0
    7984:	it	eq
    7986:	vmoveq.f32	s11, s9
  pulse_energy_ = pulse_energy_1 + (pulse_energy_2 - pulse_energy_1) * blend;
    798a:	vsub.f32	s11, s11, s14
    798e:	vfma.f32	s14, s0, s11
    7992:	vstr	s14, [r0, #12]
  
  k_[0] = BlendCoefficient<32768>(f1.k0, f2.k0, blend);
  k_[1] = BlendCoefficient<32768>(f1.k1, f2.k1, blend);
  k_[2] = BlendCoefficient<128>(f1.k2, f2.k2, blend);
    7996:	ldrsb.w	r3, [r2, #6]
    799a:	vmov	s14, r3
    799e:	ldrsb.w	r3, [r1, #6]
    79a2:	vcvt.f32.s32	s14, s14
    79a6:	vmov	s13, r3
    79aa:	vcvt.f32.s32	s13, s13
    79ae:	vmul.f32	s14, s14, s15
    79b2:	vfms.f32	s14, s13, s15
    79b6:	vmul.f32	s14, s14, s0
    79ba:	vfma.f32	s14, s13, s15
    79be:	vstr	s14, [r0, #32]
  k_[3] = BlendCoefficient<128>(f1.k3, f2.k3, blend);
    79c2:	ldrsb.w	r3, [r2, #7]
    79c6:	vmov	s14, r3
    79ca:	ldrsb.w	r3, [r1, #7]
    79ce:	vcvt.f32.s32	s14, s14
    79d2:	vmov	s13, r3
    79d6:	vcvt.f32.s32	s13, s13
    79da:	vmul.f32	s14, s14, s15
    79de:	vfms.f32	s14, s13, s15
    79e2:	vmul.f32	s14, s14, s0
    79e6:	vfma.f32	s14, s13, s15
    79ea:	vstr	s14, [r0, #36]	; 0x24
  k_[4] = BlendCoefficient<128>(f1.k4, f2.k4, blend);
    79ee:	ldrsb.w	r3, [r2, #8]
    79f2:	vmov	s14, r3
    79f6:	ldrsb.w	r3, [r1, #8]
    79fa:	vcvt.f32.s32	s14, s14
    79fe:	vmov	s13, r3
    7a02:	vcvt.f32.s32	s13, s13
    7a06:	vmul.f32	s14, s14, s15
    7a0a:	vfms.f32	s14, s13, s15
    7a0e:	vmul.f32	s14, s14, s0
    7a12:	vfma.f32	s14, s13, s15
    7a16:	vstr	s14, [r0, #40]	; 0x28
  k_[5] = BlendCoefficient<128>(f1.k5, f2.k5, blend);
    7a1a:	ldrsb.w	r3, [r2, #9]
    7a1e:	vmov	s14, r3
    7a22:	ldrsb.w	r3, [r1, #9]
    7a26:	vcvt.f32.s32	s14, s14
    7a2a:	vmov	s13, r3
    7a2e:	vcvt.f32.s32	s13, s13
    7a32:	vmul.f32	s14, s14, s15
    7a36:	vfms.f32	s14, s13, s15
    7a3a:	vmul.f32	s14, s14, s0
    7a3e:	vfma.f32	s14, s13, s15
    7a42:	vstr	s14, [r0, #44]	; 0x2c
  k_[6] = BlendCoefficient<128>(f1.k6, f2.k6, blend);
    7a46:	ldrsb.w	r3, [r2, #10]
    7a4a:	vmov	s14, r3
    7a4e:	ldrsb.w	r3, [r1, #10]
    7a52:	vcvt.f32.s32	s14, s14
    7a56:	vmov	s13, r3
    7a5a:	vcvt.f32.s32	s13, s13
    7a5e:	vmul.f32	s14, s14, s15
    7a62:	vfms.f32	s14, s13, s15
    7a66:	vmul.f32	s14, s14, s0
    7a6a:	vfma.f32	s14, s13, s15
    7a6e:	vstr	s14, [r0, #48]	; 0x30
  k_[7] = BlendCoefficient<128>(f1.k7, f2.k7, blend);
    7a72:	ldrsb.w	r3, [r2, #11]
    7a76:	vmov	s14, r3
    7a7a:	ldrsb.w	r3, [r1, #11]
    7a7e:	vcvt.f32.s32	s14, s14
    7a82:	vmov	s13, r3
    7a86:	vcvt.f32.s32	s13, s13
    7a8a:	vmul.f32	s14, s14, s15
    7a8e:	vfms.f32	s14, s13, s15
    7a92:	vmul.f32	s14, s14, s0
    7a96:	vfma.f32	s14, s13, s15
    7a9a:	vstr	s14, [r0, #52]	; 0x34
  k_[8] = BlendCoefficient<128>(f1.k8, f2.k8, blend);
    7a9e:	ldrsb.w	r3, [r2, #12]
  k_[9] = BlendCoefficient<128>(f1.k9, f2.k9, blend);
}
    7aa2:	ldr.w	r4, [sp], #4
  k_[3] = BlendCoefficient<128>(f1.k3, f2.k3, blend);
  k_[4] = BlendCoefficient<128>(f1.k4, f2.k4, blend);
  k_[5] = BlendCoefficient<128>(f1.k5, f2.k5, blend);
  k_[6] = BlendCoefficient<128>(f1.k6, f2.k6, blend);
  k_[7] = BlendCoefficient<128>(f1.k7, f2.k7, blend);
  k_[8] = BlendCoefficient<128>(f1.k8, f2.k8, blend);
    7aa6:	vmov	s14, r3
    7aaa:	ldrsb.w	r3, [r1, #12]
    7aae:	vcvt.f32.s32	s14, s14
    7ab2:	vmov	s13, r3
    7ab6:	vcvt.f32.s32	s13, s13
    7aba:	vmul.f32	s14, s14, s15
    7abe:	vfms.f32	s14, s13, s15
    7ac2:	vmul.f32	s14, s14, s0
    7ac6:	vfma.f32	s14, s13, s15
    7aca:	vstr	s14, [r0, #56]	; 0x38
  k_[9] = BlendCoefficient<128>(f1.k9, f2.k9, blend);
    7ace:	ldrsb.w	r3, [r2, #13]
    7ad2:	vmov	s14, r3
    7ad6:	ldrsb.w	r3, [r1, #13]
    7ada:	vcvt.f32.s32	s14, s14
    7ade:	vmov	s13, r3
    7ae2:	vcvt.f32.s32	s13, s13
    7ae6:	vmul.f32	s14, s14, s15
    7aea:	vfms.f32	s14, s13, s15
    7aee:	vmul.f32	s0, s14, s0
    7af2:	vfma.f32	s0, s13, s15
    7af6:	vstr	s0, [r0, #60]	; 0x3c
}
    7afa:	bx	lr
}

void LPCSpeechSynth::PlayFrame(const Frame& f1, const Frame& f2, float blend) {
  float frequency_1 = f1.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
    7afc:	vmov	s15, r3
    7b00:	vmov.f32	s13, #112	; 0x3f800000  1.0
  float frequency_2 = f2.period == 0
    7b04:	ldrb	r3, [r2, #1]
}

void LPCSpeechSynth::PlayFrame(const Frame& f1, const Frame& f2, float blend) {
  float frequency_1 = f1.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f1.period);
    7b06:	vcvt.f32.u32	s14, s15
    7b0a:	vdiv.f32	s15, s13, s14
  float frequency_2 = f2.period == 0
      ? frequency_
      : 1.0f / static_cast<float>(f2.period);
    7b0e:	cmp	r3, #0
    7b10:	beq.w	78b6 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x16>
    7b14:	vmov	s14, r3
    7b18:	vmov.f32	s12, #112	; 0x3f800000  1.0
    7b1c:	vcvt.f32.u32	s13, s14
    7b20:	vdiv.f32	s14, s12, s13
    7b24:	b.n	78ba <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)+0x1a>
    7b26:	nop
    7b28:	.word	0x38000000
    7b2c:	.word	0x3b800000
    7b30:	.word	0x00000000
    7b34:	.word	0x3c000000

00007b38 <plaits::LPCSpeechSynthWordBank::Init(plaits::LPCSpeechSynthWordBankData const*, int, stmlib::BufferAllocator*)>:
void LPCSpeechSynthWordBank::Init(
    const LPCSpeechSynthWordBankData* word_banks,
    int num_banks,
    BufferAllocator* allocator) {
  word_banks_ = word_banks;
  num_banks_ = num_banks;
    7b38:	str	r2, [r0, #4]
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    7b3a:	ldr	r2, [r3, #8]

void LPCSpeechSynthWordBank::Init(
    const LPCSpeechSynthWordBankData* word_banks,
    int num_banks,
    BufferAllocator* allocator) {
  word_banks_ = word_banks;
    7b3c:	str	r1, [r0, #0]
    7b3e:	cmp.w	r2, #14336	; 0x3800
};

void LPCSpeechSynthWordBank::Init(
    const LPCSpeechSynthWordBankData* word_banks,
    int num_banks,
    BufferAllocator* allocator) {
    7b42:	push	{r4, r5, r6}
    7b44:	bcc.n	7b7a <plaits::LPCSpeechSynthWordBank::Init(plaits::LPCSpeechSynthWordBankData const*, int, stmlib::BufferAllocator*)+0x42>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    7b46:	ldr	r5, [r3, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    7b48:	sub.w	r2, r2, #14336	; 0x3800
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    7b4c:	add.w	r1, r5, #14336	; 0x3800
      free_ -= size_bytes;
    7b50:	str	r2, [r3, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    7b52:	str	r1, [r3, #0]
  Reset();
}

void LPCSpeechSynthWordBank::Reset() {
  loaded_bank_ = -1;
  num_frames_ = 0;
    7b54:	movs	r4, #0
      kLPCSpeechSynthMaxFrames);
  Reset();
}

void LPCSpeechSynthWordBank::Reset() {
  loaded_bank_ = -1;
    7b56:	mov.w	r6, #4294967295
  num_frames_ = 0;
  num_words_ = 0;
  fill(
    7b5a:	add.w	r3, r0, #20
    7b5e:	add.w	r1, r0, #148	; 0x94
	*__first = __tmp;
    7b62:	mov	r2, r4
    int num_banks,
    BufferAllocator* allocator) {
  word_banks_ = word_banks;
  num_banks_ = num_banks;
  frames_ = allocator->Allocate<LPCSpeechSynth::Frame>(
      kLPCSpeechSynthMaxFrames);
    7b64:	str.w	r5, [r0, #148]	; 0x94
  Reset();
}

void LPCSpeechSynthWordBank::Reset() {
  loaded_bank_ = -1;
  num_frames_ = 0;
    7b68:	str	r4, [r0, #12]
  num_words_ = 0;
    7b6a:	str	r4, [r0, #16]
      kLPCSpeechSynthMaxFrames);
  Reset();
}

void LPCSpeechSynthWordBank::Reset() {
  loaded_bank_ = -1;
    7b6c:	str	r6, [r0, #8]
    7b6e:	str.w	r2, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    7b72:	cmp	r1, r3
    7b74:	bne.n	7b6e <plaits::LPCSpeechSynthWordBank::Init(plaits::LPCSpeechSynthWordBankData const*, int, stmlib::BufferAllocator*)+0x36>
  word_banks_ = word_banks;
  num_banks_ = num_banks;
  frames_ = allocator->Allocate<LPCSpeechSynth::Frame>(
      kLPCSpeechSynthMaxFrames);
  Reset();
}
    7b76:	pop	{r4, r5, r6}
    7b78:	bx	lr
      free_ -= size_bytes;
      return start;
    } else {
      return NULL;
    7b7a:	movs	r5, #0
    7b7c:	b.n	7b54 <plaits::LPCSpeechSynthWordBank::Init(plaits::LPCSpeechSynthWordBankData const*, int, stmlib::BufferAllocator*)+0x1c>
    7b7e:	nop

00007b80 <plaits::LPCSpeechSynthWordBank::Reset()>:

void LPCSpeechSynthWordBank::Reset() {
    7b80:	push	{r4, r5}
  loaded_bank_ = -1;
  num_frames_ = 0;
    7b82:	movs	r4, #0
      kLPCSpeechSynthMaxFrames);
  Reset();
}

void LPCSpeechSynthWordBank::Reset() {
  loaded_bank_ = -1;
    7b84:	mov.w	r5, #4294967295
  num_frames_ = 0;
  num_words_ = 0;
  fill(
    7b88:	add.w	r3, r0, #20
    7b8c:	add.w	r1, r0, #148	; 0x94
	*__first = __tmp;
    7b90:	mov	r2, r4
      kLPCSpeechSynthMaxFrames);
  Reset();
}

void LPCSpeechSynthWordBank::Reset() {
  loaded_bank_ = -1;
    7b92:	str	r5, [r0, #8]
  num_frames_ = 0;
    7b94:	str	r4, [r0, #12]
  num_words_ = 0;
    7b96:	str	r4, [r0, #16]
    7b98:	str.w	r2, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    7b9c:	cmp	r1, r3
    7b9e:	bne.n	7b98 <plaits::LPCSpeechSynthWordBank::Reset()+0x18>
  fill(
      &word_boundaries_[0],
      &word_boundaries_[kLPCSpeechSynthMaxWords], 0);
}
    7ba0:	pop	{r4, r5}
    7ba2:	bx	lr

00007ba4 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)>:

size_t LPCSpeechSynthWordBank::LoadNextWord(const uint8_t* data) {
    7ba4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ~BitStream() { }

  inline void Init(const uint8_t* p) {
    p_ = p;
    available_ = 0;
    bits_ = 0;
    7ba8:	movs	r3, #0
    7baa:	sub	sp, #36	; 0x24
 public:
  BitStream() { }
  ~BitStream() { }

  inline void Init(const uint8_t* p) {
    p_ = p;
    7bac:	mov	r6, r1
    7bae:	str	r1, [sp, #28]
    available_ = 0;
    7bb0:	mov	r5, r3
  frame.k4 = 0;
  frame.k5 = 0;
  frame.k6 = 0;
  frame.k7 = 0;
  frame.k8 = 0;
  frame.k9 = 0;
    7bb2:	mov	sl, r3
  frame.k3 = 0;
  frame.k4 = 0;
  frame.k5 = 0;
  frame.k6 = 0;
  frame.k7 = 0;
  frame.k8 = 0;
    7bb4:	mov	r9, r3
  frame.k2 = 0;
  frame.k3 = 0;
  frame.k4 = 0;
  frame.k5 = 0;
  frame.k6 = 0;
  frame.k7 = 0;
    7bb6:	str	r3, [sp, #8]
  frame.energy = 0;
  frame.period = 0;
  frame.k0 = 0;
  frame.k1 = 0;
  frame.k2 = 0;
  frame.k3 = 0;
    7bb8:	mov	r8, r3
  frame.k4 = 0;
  frame.k5 = 0;
  frame.k6 = 0;
    7bba:	str	r3, [sp, #12]
  LPCSpeechSynth::Frame frame;
  frame.energy = 0;
  frame.period = 0;
  frame.k0 = 0;
  frame.k1 = 0;
  frame.k2 = 0;
    7bbc:	mov	ip, r3
  frame.k3 = 0;
  frame.k4 = 0;
  frame.k5 = 0;
    7bbe:	str	r3, [sp, #16]
  BitStream bitstream;
  bitstream.Init(data);

  LPCSpeechSynth::Frame frame;
  frame.energy = 0;
  frame.period = 0;
    7bc0:	mov	r1, r3
  frame.k0 = 0;
  frame.k1 = 0;
  frame.k2 = 0;
  frame.k3 = 0;
  frame.k4 = 0;
    7bc2:	str	r3, [sp, #20]

  LPCSpeechSynth::Frame frame;
  frame.energy = 0;
  frame.period = 0;
  frame.k0 = 0;
  frame.k1 = 0;
    7bc4:	str	r3, [sp, #0]
  bitstream.Init(data);

  LPCSpeechSynth::Frame frame;
  frame.energy = 0;
  frame.period = 0;
  frame.k0 = 0;
    7bc6:	str	r3, [sp, #4]
    7bc8:	b.n	7d0e <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x16a>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7bca:	ldrb.w	fp, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7bce:	lsls	r3, r5
      shift -= available_;
    7bd0:	rsb	r7, r5, #4
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7bd4:	add.w	r4, r5, #8
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7bd8:	mov.w	r2, fp, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7bdc:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7bde:	uxth	r3, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7be0:	orr.w	r2, r2, fp, lsl #4
    7be4:	uxtb	r2, r2
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7be6:	asrs	r5, r2, #2
    7be8:	lsls	r2, r2, #2
    7bea:	and.w	r5, r5, #51	; 0x33
    7bee:	and.w	r2, r2, #204	; 0xcc
    7bf2:	orrs	r2, r5
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7bf4:	asrs	r5, r2, #1
    7bf6:	lsls	r2, r2, #1
    7bf8:	and.w	r5, r5, #85	; 0x55
    7bfc:	and.w	r2, r2, #170	; 0xaa
    7c00:	orrs	r2, r5
    7c02:	orrs	r3, r2
      available_ += 8;
    }
    bits_ <<= shift;
    7c04:	lsls	r3, r7
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7c06:	subs	r5, r4, #4
    7c08:	ubfx	r2, r3, #8, #8
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7c0c:	uxtb	r3, r3
  frame.k8 = 0;
  frame.k9 = 0;

  while (true) {
    int energy = bitstream.GetBits(4);
    if (energy == 0) {
    7c0e:	cmp	r2, #0
    7c10:	beq.n	7cc2 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x11e>
      frame.energy = 0;
    } else if (energy == 0xf) {
    7c12:	cmp	r2, #15
    7c14:	beq.w	80be <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x51a>
      bitstream.Flush();
      break;
    } else {
      frame.energy = energy_lut_[energy];
    7c18:	ldr	r1, [pc, #264]	; (7d24 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x180>)
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7c1a:	cmp	r5, #0
    7c1c:	ldrb	r2, [r1, r2]
    7c1e:	bgt.n	7d20 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x17c>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7c20:	ldrb.w	fp, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7c24:	lsls	r3, r5
      shift -= available_;
    7c26:	rsb	r1, r5, #1
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7c2a:	adds	r5, r4, #4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7c2c:	mov.w	r7, fp, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7c30:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7c32:	uxth	r3, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7c34:	orr.w	r7, r7, fp, lsl #4
    7c38:	uxtb	r7, r7
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7c3a:	mov.w	lr, r7, asr #2
    7c3e:	lsls	r7, r7, #2
    7c40:	and.w	lr, lr, #51	; 0x33
    7c44:	and.w	r7, r7, #204	; 0xcc
    7c48:	orr.w	r4, r7, lr
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7c4c:	asrs	r7, r4, #1
    7c4e:	lsls	r4, r4, #1
    7c50:	and.w	r7, r7, #85	; 0x55
    7c54:	and.w	r4, r4, #170	; 0xaa
    7c58:	orrs	r4, r7
    7c5a:	orrs	r3, r4
      available_ += 8;
    }
    bits_ <<= shift;
    7c5c:	lsls	r3, r1
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7c5e:	subs	r4, r5, #1
      shift -= available_;
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    7c60:	ubfx	r1, r3, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7c64:	cmp	r4, #5
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7c66:	uxtb	r3, r3
      shift -= available_;
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    7c68:	str	r1, [sp, #24]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7c6a:	bgt.n	7d1a <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x176>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7c6c:	ldrb.w	fp, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7c70:	lsls	r3, r4
      shift -= available_;
    7c72:	rsb	lr, r4, #6
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7c76:	adds	r4, r5, #7
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7c78:	mov.w	r1, fp, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7c7c:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7c7e:	uxth	r5, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7c80:	orr.w	r1, r1, fp, lsl #4
    7c84:	uxtb	r1, r1
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7c86:	mov.w	fp, r1, asr #2
    7c8a:	lsls	r1, r1, #2
    7c8c:	and.w	fp, fp, #51	; 0x33
    7c90:	and.w	r1, r1, #204	; 0xcc
    7c94:	orr.w	fp, r1, fp
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7c98:	mov.w	r1, fp, asr #1
    7c9c:	mov.w	fp, fp, lsl #1
    7ca0:	and.w	r1, r1, #85	; 0x55
    7ca4:	and.w	fp, fp, #170	; 0xaa
    7ca8:	orr.w	r3, fp, r1
    7cac:	orrs	r3, r5
      available_ += 8;
    }
    bits_ <<= shift;
    7cae:	lsl.w	r3, r3, lr
      bool repeat = bitstream.GetBits(1);
      frame.period = period_lut_[bitstream.GetBits(6)];
    7cb2:	ldr	r7, [pc, #116]	; (7d28 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x184>)
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7cb4:	subs	r5, r4, #6
    7cb6:	ubfx	r1, r3, #8, #8
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7cba:	uxtb	r3, r3
    7cbc:	ldrb	r1, [r7, r1]
      if (!repeat) {
    7cbe:	ldr	r7, [sp, #24]
    7cc0:	cbz	r7, 7d2c <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x188>
          frame.k8 = k8_lut_[bitstream.GetBits(3)];
          frame.k9 = k9_lut_[bitstream.GetBits(3)];
        }
      }
    }
    frames_[num_frames_++] = frame;
    7cc2:	ldr	r4, [r0, #12]
    7cc4:	ldr.w	r7, [r0, #148]	; 0x94
    7cc8:	rsb	lr, r4, r4, lsl #3
    7ccc:	adds	r4, #1
    7cce:	str	r4, [r0, #12]
    7cd0:	add.w	r4, r7, lr, lsl #1
    7cd4:	strb.w	r2, [r7, lr, lsl #1]
    7cd8:	ldrh.w	r2, [sp, #4]
    7cdc:	strb	r1, [r4, #1]
    7cde:	strh	r2, [r4, #2]
    7ce0:	ldrh.w	r2, [sp]
    7ce4:	strb.w	ip, [r4, #6]
    7ce8:	strh	r2, [r4, #4]
    7cea:	ldrb.w	r2, [sp, #20]
    7cee:	strb.w	r8, [r4, #7]
    7cf2:	strb	r2, [r4, #8]
    7cf4:	ldrb.w	r2, [sp, #16]
    7cf8:	strb.w	r9, [r4, #12]
    7cfc:	strb	r2, [r4, #9]
    7cfe:	ldrb.w	r2, [sp, #12]
    7d02:	strb.w	sl, [r4, #13]
    7d06:	strb	r2, [r4, #10]
    7d08:	ldrb.w	r2, [sp, #8]
    7d0c:	strb	r2, [r4, #11]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7d0e:	cmp	r5, #3
    7d10:	ble.w	7bca <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x26>
    7d14:	mov	r4, r5
      GetBits(1);
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    7d16:	movs	r7, #4
    7d18:	b.n	7c04 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x60>
    7d1a:	mov.w	lr, #6
    7d1e:	b.n	7cae <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x10a>
    7d20:	movs	r1, #1
    7d22:	b.n	7c5c <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0xb8>
    7d24:	.word	0x200206c0
    7d28:	.word	0x20020728
    if (num_bits > available_) {
    7d2c:	cmp	r5, #4
    7d2e:	bgt.w	80b8 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x514>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7d32:	ldrb.w	ip, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7d36:	lsls	r3, r5
      shift -= available_;
    7d38:	rsb	r8, r5, #5
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7d3c:	adds	r5, r4, #2
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7d3e:	mov.w	r7, ip, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7d42:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7d44:	uxth	r3, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7d46:	orr.w	r4, r7, ip, lsl #4
    7d4a:	uxtb	r4, r4
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7d4c:	mov.w	lr, r4, asr #2
    7d50:	lsls	r4, r4, #2
    7d52:	and.w	lr, lr, #51	; 0x33
    7d56:	and.w	r4, r4, #204	; 0xcc
    7d5a:	orr.w	r4, r4, lr
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7d5e:	asrs	r7, r4, #1
    7d60:	lsls	r4, r4, #1
    7d62:	and.w	r7, r7, #85	; 0x55
    7d66:	and.w	r4, r4, #170	; 0xaa
    7d6a:	orrs	r4, r7
    7d6c:	orrs	r3, r4
      available_ += 8;
    }
    bits_ <<= shift;
    7d6e:	lsl.w	r4, r3, r8
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7d72:	subs	r7, r5, #5
    } else {
      frame.energy = energy_lut_[energy];
      bool repeat = bitstream.GetBits(1);
      frame.period = period_lut_[bitstream.GetBits(6)];
      if (!repeat) {
        frame.k0 = k0_lut_[bitstream.GetBits(5)];
    7d74:	ldr	r3, [pc, #884]	; (80ec <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x548>)
    7d76:	ubfx	ip, r4, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7d7a:	cmp	r7, #4
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7d7c:	uxtb	r4, r4
    7d7e:	ldrsh.w	r3, [r3, ip, lsl #1]
    7d82:	str	r3, [sp, #4]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7d84:	bgt.w	80b2 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x50e>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7d88:	ldrb.w	fp, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7d8c:	lsls	r4, r7
      shift -= available_;
    7d8e:	rsb	r8, r7, #5
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7d92:	adds	r7, r5, #3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7d94:	mov.w	ip, fp, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7d98:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7d9a:	uxth	r4, r4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7d9c:	orr.w	r3, ip, fp, lsl #4
    7da0:	uxtb	r3, r3
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7da2:	asrs	r5, r3, #2
    7da4:	lsls	r3, r3, #2
    7da6:	and.w	r5, r5, #51	; 0x33
    7daa:	and.w	r3, r3, #204	; 0xcc
    7dae:	orrs	r5, r3
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7db0:	asrs	r3, r5, #1
    7db2:	lsls	r5, r5, #1
    7db4:	and.w	r3, r3, #85	; 0x55
    7db8:	and.w	r5, r5, #170	; 0xaa
    7dbc:	orrs	r5, r3
    7dbe:	orrs	r4, r5
      available_ += 8;
    }
    bits_ <<= shift;
    7dc0:	lsl.w	r3, r4, r8
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7dc4:	sub.w	r8, r7, #5
        frame.k1 = k1_lut_[bitstream.GetBits(5)];
    7dc8:	ldr	r4, [pc, #804]	; (80f0 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x54c>)
    7dca:	ubfx	r5, r3, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7dce:	cmp.w	r8, #3
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7dd2:	uxtb	r3, r3
    7dd4:	ldrsh.w	r4, [r4, r5, lsl #1]
    7dd8:	str	r4, [sp, #0]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7dda:	bgt.w	80ac <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x508>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7dde:	ldrb.w	ip, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7de2:	lsl.w	r3, r3, r8
      shift -= available_;
    7de6:	rsb	lr, r8, #4
      bits_ |= Reverse(*p_++);
    7dea:	adds	r6, #1
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7dec:	mov.w	r5, ip, lsr #4
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7df0:	add.w	r8, r7, #3
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7df4:	uxth	r3, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7df6:	orr.w	r4, r5, ip, lsl #4
    7dfa:	uxtb	r4, r4
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7dfc:	asrs	r5, r4, #2
    7dfe:	lsls	r4, r4, #2
    7e00:	and.w	r5, r5, #51	; 0x33
    7e04:	and.w	r4, r4, #204	; 0xcc
    7e08:	orrs	r5, r4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7e0a:	asrs	r4, r5, #1
    7e0c:	lsls	r5, r5, #1
    7e0e:	and.w	r4, r4, #85	; 0x55
    7e12:	and.w	r5, r5, #170	; 0xaa
    7e16:	orrs	r5, r4
    7e18:	orrs	r3, r5
      available_ += 8;
    }
    bits_ <<= shift;
    7e1a:	lsl.w	r4, r3, lr
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7e1e:	sub.w	r7, r8, #4
        frame.k2 = k2_lut_[bitstream.GetBits(4)];
    7e22:	ldr	r3, [pc, #720]	; (80f4 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x550>)
    7e24:	ubfx	r5, r4, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7e28:	cmp	r7, #3
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7e2a:	uxtb	r4, r4
    7e2c:	ldrsb.w	ip, [r3, r5]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7e30:	bgt.w	80a6 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x502>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7e34:	ldrb.w	fp, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7e38:	lsls	r4, r7
      shift -= available_;
    7e3a:	rsb	lr, r7, #4
      bits_ |= Reverse(*p_++);
    7e3e:	adds	r6, #1
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7e40:	mov.w	r5, fp, lsr #4
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7e44:	add.w	r7, r8, #4
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7e48:	uxth	r4, r4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7e4a:	orr.w	r3, r5, fp, lsl #4
    7e4e:	uxtb	r3, r3
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7e50:	asrs	r5, r3, #2
    7e52:	lsls	r3, r3, #2
    7e54:	and.w	r5, r5, #51	; 0x33
    7e58:	and.w	r3, r3, #204	; 0xcc
    7e5c:	orrs	r5, r3
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7e5e:	asrs	r3, r5, #1
    7e60:	lsls	r5, r5, #1
    7e62:	and.w	r3, r3, #85	; 0x55
    7e66:	and.w	r5, r5, #170	; 0xaa
    7e6a:	orrs	r5, r3
    7e6c:	orrs	r4, r5
      available_ += 8;
    }
    bits_ <<= shift;
    7e6e:	lsl.w	r4, r4, lr
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7e72:	subs	r5, r7, #4
        frame.k3 = k3_lut_[bitstream.GetBits(4)];
    7e74:	ubfx	r8, r4, #8, #8
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7e78:	uxtb	r3, r4
    7e7a:	ldr	r4, [pc, #636]	; (80f8 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x554>)
    7e7c:	ldrsb.w	r8, [r4, r8]
        if (frame.period) {
    7e80:	cmp	r1, #0
    7e82:	beq.w	7cc2 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x11e>
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7e86:	cmp	r5, #3
    7e88:	bgt.w	80d6 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x532>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7e8c:	ldrb.w	r9, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7e90:	lsls	r3, r5
      shift -= available_;
    7e92:	rsb	r4, r5, #4
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7e96:	adds	r5, r7, #4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7e98:	mov.w	sl, r9, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7e9c:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7e9e:	uxth.w	lr, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7ea2:	orr.w	r7, sl, r9, lsl #4
    7ea6:	uxtb	r7, r7
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7ea8:	asrs	r3, r7, #2
    7eaa:	lsls	r7, r7, #2
    7eac:	and.w	r3, r3, #51	; 0x33
    7eb0:	and.w	r7, r7, #204	; 0xcc
    7eb4:	orrs	r7, r3
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7eb6:	asrs	r3, r7, #1
    7eb8:	lsls	r7, r7, #1
    7eba:	and.w	r3, r3, #85	; 0x55
    7ebe:	and.w	r7, r7, #170	; 0xaa
    7ec2:	orrs	r3, r7
    7ec4:	orr.w	r3, lr, r3
      available_ += 8;
    }
    bits_ <<= shift;
    7ec8:	lsl.w	r4, r3, r4
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7ecc:	subs	r7, r5, #4
          frame.k4 = k4_lut_[bitstream.GetBits(4)];
    7ece:	ubfx	r3, r4, #8, #8
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7ed2:	uxtb.w	lr, r4
    7ed6:	ldr	r4, [pc, #548]	; (80fc <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x558>)
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7ed8:	cmp	r7, #3
    7eda:	ldrsb	r3, [r4, r3]
    7edc:	str	r3, [sp, #20]
    7ede:	bgt.w	8114 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x570>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7ee2:	ldrb.w	sl, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7ee6:	lsl.w	r4, lr, r7
      shift -= available_;
    7eea:	rsb	r9, r7, #4
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7eee:	adds	r7, r5, #4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7ef0:	mov.w	lr, sl, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7ef4:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7ef6:	uxth	r4, r4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7ef8:	orr.w	lr, lr, sl, lsl #4
    7efc:	uxtb.w	lr, lr
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7f00:	mov.w	r3, lr, asr #2
    7f04:	mov.w	lr, lr, lsl #2
    7f08:	and.w	r3, r3, #51	; 0x33
    7f0c:	and.w	lr, lr, #204	; 0xcc
    7f10:	orr.w	r3, lr, r3
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7f14:	asrs	r5, r3, #1
    7f16:	lsls	r3, r3, #1
    7f18:	and.w	r5, r5, #85	; 0x55
    7f1c:	and.w	r3, r3, #170	; 0xaa
    7f20:	orrs	r3, r5
    7f22:	orr.w	lr, r4, r3
      available_ += 8;
    }
    bits_ <<= shift;
    7f26:	lsl.w	r3, lr, r9
          frame.k5 = k5_lut_[bitstream.GetBits(4)];
    7f2a:	ldr	r5, [pc, #468]	; (8100 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x55c>)
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7f2c:	sub.w	lr, r7, #4
    7f30:	ubfx	r4, r3, #8, #8
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7f34:	uxtb	r3, r3
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7f36:	cmp.w	lr, #3
    7f3a:	ldrsb	r4, [r5, r4]
    7f3c:	str	r4, [sp, #16]
    7f3e:	bgt.w	80e6 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x542>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7f42:	ldrb.w	r9, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7f46:	lsl.w	r3, r3, lr
      shift -= available_;
    7f4a:	rsb	r4, lr, #4
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7f4e:	add.w	lr, r7, #4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7f52:	mov.w	r5, r9, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7f56:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7f58:	uxth	r3, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7f5a:	orr.w	r5, r5, r9, lsl #4
    7f5e:	uxtb	r5, r5
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7f60:	asrs	r7, r5, #2
    7f62:	lsls	r5, r5, #2
    7f64:	and.w	r7, r7, #51	; 0x33
    7f68:	and.w	r5, r5, #204	; 0xcc
    7f6c:	orrs	r7, r5
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7f6e:	asrs	r5, r7, #1
    7f70:	lsls	r7, r7, #1
    7f72:	and.w	r5, r5, #85	; 0x55
    7f76:	and.w	r7, r7, #170	; 0xaa
    7f7a:	orrs	r7, r5
    7f7c:	orrs	r3, r7
      available_ += 8;
    }
    bits_ <<= shift;
    7f7e:	lsl.w	r4, r3, r4
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7f82:	sub.w	r7, lr, #4
          frame.k6 = k6_lut_[bitstream.GetBits(4)];
    7f86:	ldr	r3, [pc, #380]	; (8104 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x560>)
    7f88:	ubfx	r5, r4, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7f8c:	cmp	r7, #2
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7f8e:	uxtb	r4, r4
    7f90:	ldrsb	r3, [r3, r5]
    7f92:	str	r3, [sp, #12]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7f94:	bgt.w	80e2 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x53e>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7f98:	ldrb.w	r9, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7f9c:	lsls	r4, r7
      shift -= available_;
    7f9e:	rsb	r3, r7, #3
      bits_ |= Reverse(*p_++);
      available_ += 8;
    7fa2:	add.w	r7, lr, #4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7fa6:	mov.w	r5, r9, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7faa:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7fac:	uxth	r4, r4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7fae:	orr.w	r5, r5, r9, lsl #4
    7fb2:	uxtb	r5, r5
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    7fb4:	mov.w	lr, r5, asr #2
    7fb8:	lsls	r5, r5, #2
    7fba:	and.w	lr, lr, #51	; 0x33
    7fbe:	and.w	r5, r5, #204	; 0xcc
    7fc2:	orr.w	lr, r5, lr
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    7fc6:	mov.w	r5, lr, asr #1
    7fca:	mov.w	lr, lr, lsl #1
    7fce:	and.w	r5, r5, #85	; 0x55
    7fd2:	and.w	lr, lr, #170	; 0xaa
    7fd6:	orr.w	lr, lr, r5
    7fda:	orr.w	r4, r4, lr
      available_ += 8;
    }
    bits_ <<= shift;
    7fde:	lsl.w	r3, r4, r3
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    7fe2:	sub.w	lr, r7, #3
          frame.k7 = k7_lut_[bitstream.GetBits(3)];
    7fe6:	ldr	r4, [pc, #288]	; (8108 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x564>)
    7fe8:	ubfx	r5, r3, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7fec:	cmp.w	lr, #2
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    7ff0:	uxtb	r3, r3
    7ff2:	ldrsb	r4, [r4, r5]
    7ff4:	str	r4, [sp, #8]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    7ff6:	bgt.n	80de <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x53a>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    7ff8:	ldrb.w	r9, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    7ffc:	lsl.w	r3, r3, lr
      shift -= available_;
    8000:	rsb	r4, lr, #3
      bits_ |= Reverse(*p_++);
      available_ += 8;
    8004:	add.w	lr, r7, #5
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    8008:	mov.w	r5, r9, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    800c:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    800e:	uxth	r3, r3
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    8010:	orr.w	r5, r5, r9, lsl #4
    8014:	uxtb	r5, r5
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    8016:	asrs	r7, r5, #2
    8018:	lsls	r5, r5, #2
    801a:	and.w	r7, r7, #51	; 0x33
    801e:	and.w	r5, r5, #204	; 0xcc
    8022:	orrs	r7, r5
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    8024:	asrs	r5, r7, #1
    8026:	lsls	r7, r7, #1
    8028:	and.w	r5, r5, #85	; 0x55
    802c:	and.w	r7, r7, #170	; 0xaa
    8030:	orrs	r7, r5
    8032:	orrs	r3, r7
      available_ += 8;
    }
    bits_ <<= shift;
    8034:	lsl.w	r4, r3, r4
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    8038:	sub.w	r5, lr, #3
          frame.k8 = k8_lut_[bitstream.GetBits(3)];
    803c:	ldr	r3, [pc, #204]	; (810c <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x568>)
    803e:	ubfx	r7, r4, #8, #8
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    8042:	cmp	r5, #2
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    8044:	uxtb	r4, r4
    8046:	ldrsb.w	r9, [r3, r7]
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    804a:	bgt.n	80da <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x536>
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    804c:	ldrb.w	sl, [r6]
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    8050:	lsls	r4, r5
      shift -= available_;
    8052:	rsb	r3, r5, #3
      bits_ |= Reverse(*p_++);
      available_ += 8;
    8056:	add.w	r5, lr, #5
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    805a:	mov.w	r7, sl, lsr #4
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    805e:	adds	r6, #1
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
    8060:	uxth	r4, r4
  inline const uint8_t* ptr() const { return p_; }

 private:
  inline uint8_t Reverse(uint8_t b) const {
    b = (b >> 4) | (b << 4);
  	b = ((b & 0xcc) >> 2) | ((b & 0x33) << 2);
    8062:	orr.w	r7, r7, sl, lsl #4
    8066:	uxtb	r7, r7
  	b = ((b & 0xaa) >> 1) | ((b & 0x55) << 1);
    8068:	mov.w	lr, r7, asr #2
    806c:	lsls	r7, r7, #2
    806e:	and.w	lr, lr, #51	; 0x33
    8072:	and.w	r7, r7, #204	; 0xcc
    8076:	orr.w	lr, r7, lr
  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    807a:	mov.w	r7, lr, asr #1
    807e:	mov.w	lr, lr, lsl #1
    8082:	and.w	r7, r7, #85	; 0x55
    8086:	and.w	lr, lr, #170	; 0xaa
    808a:	orr.w	lr, lr, r7
    808e:	orr.w	r4, r4, lr
      available_ += 8;
    }
    bits_ <<= shift;
    8092:	lsl.w	r3, r4, r3
          frame.k9 = k9_lut_[bitstream.GetBits(3)];
    8096:	ldr	r4, [pc, #120]	; (8110 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x56c>)
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    available_ -= num_bits;
    8098:	subs	r5, #3
    809a:	ubfx	r7, r3, #8, #8
      bits_ |= Reverse(*p_++);
      available_ += 8;
    }
    bits_ <<= shift;
    uint8_t result = bits_ >> 8;
    bits_ &= 0xff;
    809e:	uxtb	r3, r3
    80a0:	ldrsb.w	sl, [r4, r7]
    80a4:	b.n	7cc2 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x11e>
      GetBits(1);
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    80a6:	mov.w	lr, #4
    80aa:	b.n	7e6e <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x2ca>
    80ac:	mov.w	lr, #4
    80b0:	b.n	7e1a <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x276>
    80b2:	mov.w	r8, #5
    80b6:	b.n	7dc0 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x21c>
    80b8:	mov.w	r8, #5
    80bc:	b.n	7d6e <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x1ca>
    available_ = 0;
    bits_ = 0;
  }

  inline void Flush() {
    while (available_) {
    80be:	cbz	r5, 80cc <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x528>
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    if (num_bits > available_) {
    80c0:	cmp	r5, #0
    80c2:	bgt.n	80c8 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x524>
      bits_ <<= available_;
      shift -= available_;
      bits_ |= Reverse(*p_++);
    80c4:	adds	r6, #1
      available_ += 8;
    80c6:	adds	r5, #8
    available_ = 0;
    bits_ = 0;
  }

  inline void Flush() {
    while (available_) {
    80c8:	subs	r5, #1
    80ca:	bne.n	80c0 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x51c>
        }
      }
    }
    frames_[num_frames_++] = frame;
  }
  return bitstream.ptr() - data;
    80cc:	ldr	r3, [sp, #28]
    80ce:	subs	r0, r6, r3
}
    80d0:	add	sp, #36	; 0x24
    80d2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      GetBits(1);
    }
  }

  inline uint8_t GetBits(int num_bits) {
    int shift = num_bits;
    80d6:	movs	r4, #4
    80d8:	b.n	7ec8 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x324>
    80da:	movs	r3, #3
    80dc:	b.n	8092 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x4ee>
    80de:	movs	r4, #3
    80e0:	b.n	8034 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x490>
    80e2:	movs	r3, #3
    80e4:	b.n	7fde <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x43a>
    80e6:	movs	r4, #4
    80e8:	b.n	7f7e <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x3da>
    80ea:	nop
    80ec:	.word	0x20020658
    80f0:	.word	0x200206e8
    80f4:	.word	0x20020780
    80f8:	.word	0x200206b0
    80fc:	.word	0x200206d8
    8100:	.word	0x20020770
    8104:	.word	0x200206a0
    8108:	.word	0x200206d0
    810c:	.word	0x20020768
    8110:	.word	0x20020698
    8114:	mov.w	r9, #4
    8118:	b.n	7f26 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)+0x382>
    811a:	nop

0000811c <plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]>:

bool LPCSpeechSynthWordBank::Load(int bank) {
    811c:	push	{r3, r4, r5, r6, r7, lr}
  }

  num_frames_ = 0;
  num_words_ = 0;
  
  const uint8_t* data = word_banks_[bank].data;
    811e:	ldr	r3, [r0, #0]
    frames_[num_frames_++] = frame;
  }
  return bitstream.ptr() - data;
}

bool LPCSpeechSynthWordBank::Load(int bank) {
    8120:	mov	r6, r1
  if (bank == loaded_bank_ || bank >= num_banks_) {
    return false;
  }

  num_frames_ = 0;
    8122:	movs	r2, #0
    frames_[num_frames_++] = frame;
  }
  return bitstream.ptr() - data;
}

bool LPCSpeechSynthWordBank::Load(int bank) {
    8124:	mov	r4, r0
  }

  num_frames_ = 0;
  num_words_ = 0;
  
  const uint8_t* data = word_banks_[bank].data;
    8126:	add.w	r1, r3, r1, lsl #3
    812a:	ldr.w	r7, [r3, r6, lsl #3]
bool LPCSpeechSynthWordBank::Load(int bank) {
  if (bank == loaded_bank_ || bank >= num_banks_) {
    return false;
  }

  num_frames_ = 0;
    812e:	str	r2, [r0, #12]
  num_words_ = 0;
  
  const uint8_t* data = word_banks_[bank].data;
  size_t size = word_banks_[bank].size;
    8130:	ldr	r5, [r1, #4]
  if (bank == loaded_bank_ || bank >= num_banks_) {
    return false;
  }

  num_frames_ = 0;
  num_words_ = 0;
    8132:	str	r2, [r0, #16]
  
  const uint8_t* data = word_banks_[bank].data;
  size_t size = word_banks_[bank].size;
  
  while (size) {
    8134:	cbz	r5, 8166 <plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]+0x4a>
    8136:	mov	r3, r2
    8138:	b.n	813c <plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]+0x20>
    813a:	ldr	r2, [r4, #12]
    word_boundaries_[num_words_] = num_frames_;
    813c:	add.w	r3, r4, r3, lsl #2
    size_t consumed = LoadNextWord(data);
    8140:	mov	r1, r7
    8142:	mov	r0, r4
  
  const uint8_t* data = word_banks_[bank].data;
  size_t size = word_banks_[bank].size;
  
  while (size) {
    word_boundaries_[num_words_] = num_frames_;
    8144:	str	r2, [r3, #20]
    size_t consumed = LoadNextWord(data);
    8146:	bl	7ba4 <plaits::LPCSpeechSynthWordBank::LoadNextWord(unsigned char const*)>

    data += consumed;
    size -= consumed;
    ++num_words_;
    814a:	ldr	r3, [r4, #16]
  num_words_ = 0;
  
  const uint8_t* data = word_banks_[bank].data;
  size_t size = word_banks_[bank].size;
  
  while (size) {
    814c:	subs	r5, r5, r0
    word_boundaries_[num_words_] = num_frames_;
    size_t consumed = LoadNextWord(data);

    data += consumed;
    814e:	add	r7, r0
    size -= consumed;
    ++num_words_;
    8150:	add.w	r3, r3, #1
    8154:	str	r3, [r4, #16]
  num_words_ = 0;
  
  const uint8_t* data = word_banks_[bank].data;
  size_t size = word_banks_[bank].size;
  
  while (size) {
    8156:	bne.n	813a <plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]+0x1e>
    8158:	ldr	r5, [r4, #12]

    data += consumed;
    size -= consumed;
    ++num_words_;
  }
  word_boundaries_[num_words_] = num_frames_;
    815a:	add.w	r3, r4, r3, lsl #2
  loaded_bank_ = bank;
  return true;
}
    815e:	movs	r0, #1

    data += consumed;
    size -= consumed;
    ++num_words_;
  }
  word_boundaries_[num_words_] = num_frames_;
    8160:	str	r5, [r3, #20]
  loaded_bank_ = bank;
    8162:	str	r6, [r4, #8]
  return true;
}
    8164:	pop	{r3, r4, r5, r6, r7, pc}
  num_words_ = 0;
  
  const uint8_t* data = word_banks_[bank].data;
  size_t size = word_banks_[bank].size;
  
  while (size) {
    8166:	mov	r3, r5
    8168:	b.n	815a <plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]+0x3e>
    816a:	nop

0000816c <plaits::LPCSpeechSynthController::Init(plaits::LPCSpeechSynthWordBank*)>:
  word_boundaries_[num_words_] = num_frames_;
  loaded_bank_ = bank;
  return true;
}

void LPCSpeechSynthController::Init(LPCSpeechSynthWordBank* word_bank) {
    816c:	push	{r4, r5, r6, r7}
  word_bank_ = word_bank;
  
  clock_phase_ = 0.0f;
    816e:	movs	r6, #0
  playback_frame_ = -1;
    8170:	mov.w	r5, #4294967295
  last_playback_frame_ = -1;
  remaining_frame_samples_ = 0;
    8174:	movs	r7, #0

  fill(&sample_[0], &sample_[2], 0.0f);
    8176:	adds	r2, r0, #4
    8178:	add.w	r3, r0, #12
	*__first = __tmp;
    817c:	mov	r4, r6
  loaded_bank_ = bank;
  return true;
}

void LPCSpeechSynthController::Init(LPCSpeechSynthWordBank* word_bank) {
  word_bank_ = word_bank;
    817e:	str.w	r1, [r0, #144]	; 0x90
  
  clock_phase_ = 0.0f;
  playback_frame_ = -1;
  last_playback_frame_ = -1;
  remaining_frame_samples_ = 0;
    8182:	str.w	r7, [r0, #140]	; 0x8c
}

void LPCSpeechSynthController::Init(LPCSpeechSynthWordBank* word_bank) {
  word_bank_ = word_bank;
  
  clock_phase_ = 0.0f;
    8186:	str	r6, [r0, #0]
  playback_frame_ = -1;
    8188:	str.w	r5, [r0, #132]	; 0x84
  last_playback_frame_ = -1;
    818c:	str.w	r5, [r0, #136]	; 0x88
    8190:	str.w	r4, [r2], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    8194:	cmp	r3, r2
    8196:	bne.n	8190 <plaits::LPCSpeechSynthController::Init(plaits::LPCSpeechSynthWordBank*)+0x24>
  remaining_frame_samples_ = 0;

  fill(&sample_[0], &sample_[2], 0.0f);
  fill(&next_sample_[0], &next_sample_[2], 0.0f);
    8198:	add.w	r4, r0, #20
	*__first = __tmp;
    819c:	movs	r1, #0
    819e:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    81a2:	cmp	r4, r3
	*__first = __tmp;
    81a4:	mov.w	r2, #0
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    81a8:	bne.n	819e <plaits::LPCSpeechSynthController::Init(plaits::LPCSpeechSynthWordBank*)+0x32>

  gain_ = 0.0f;
    81aa:	str	r2, [r0, #20]
  
  synth_.Init();
    81ac:	adds	r0, #24
}
    81ae:	pop	{r4, r5, r6, r7}
  fill(&sample_[0], &sample_[2], 0.0f);
  fill(&next_sample_[0], &next_sample_[2], 0.0f);

  gain_ = 0.0f;
  
  synth_.Init();
    81b0:	b.w	75cc <plaits::LPCSpeechSynth::Init()>

000081b4 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)>:

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    81b4:	vmov.f32	s15, #96	; 0x3f000000  0.5
    81b8:	vldr	s11, [pc, #876]	; 8528 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x374>
    81bc:	vldr	s14, [pc, #876]	; 852c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x378>
  const float rate = rate_ratio / 6.0f;
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    81c0:	vmov.f32	s13, #56	; 0x41c00000  24.0
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    81c4:	ldr.w	ip, [pc, #904]	; 8550 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x39c>
    float gain,
    float* excitation,
    float* output,
    size_t size) {
  const float rate_ratio = SemitonesToRatio((formant_shift - 0.5f) * 36.0f);
  const float rate = rate_ratio / 6.0f;
    81c8:	vmov.f32	s10, #24	; 0x40c00000  6.0

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    81cc:	vsub.f32	s15, s4, s15
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
    81d0:	vldr	s12, [pc, #860]	; 8530 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x37c>
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    81d4:	vnmul.f32	s2, s2, s13
    81d8:	vfma.f32	s14, s15, s11
  const float rate_ratio = SemitonesToRatio((formant_shift - 0.5f) * 36.0f);
  const float rate = rate_ratio / 6.0f;
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
    81dc:	vldr	s11, [pc, #852]	; 8534 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x380>
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    81e0:	vldr	s15, [pc, #852]	; 8538 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x384>
    float address,
    float formant_shift,
    float gain,
    float* excitation,
    float* output,
    size_t size) {
    81e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    81e8:	mov	r5, r3
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    81ea:	ldr.w	lr, [pc, #872]	; 8554 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x3a0>
extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    81ee:	vcvt.s32.f32	s13, s14
    81f2:	mov	r9, r1
  const float rate = rate_ratio / 6.0f;
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    81f4:	vcmpe.f32	s4, s15
    float address,
    float formant_shift,
    float gain,
    float* excitation,
    float* output,
    size_t size) {
    81f8:	mov	r4, r0

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    81fa:	vcvt.f32.s32	s9, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    81fe:	vmov	r3, s13
  const float rate = rate_ratio / 6.0f;
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    8202:	vmrs	APSR_nzcv, fpscr
    8206:	add.w	r3, ip, r3, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    820a:	vsub.f32	s14, s14, s9
    820e:	vldr	s13, [r3]
    8212:	vcvt.s32.f32	s14, s14, #8
    float address,
    float formant_shift,
    float gain,
    float* excitation,
    float* output,
    size_t size) {
    8216:	vpush	{d8-d11}
    821a:	vmov	r3, s14
    821e:	sub	sp, #28
    8220:	vmov.f32	s21, s1
    8224:	add.w	r1, lr, r3, lsl #2
    8228:	vmov.f32	s16, s5
    822c:	ldr	r7, [sp, #96]	; 0x60
    822e:	vldr	s14, [r1]
    8232:	ldr.w	r8, [sp, #100]	; 0x64
    8236:	vmul.f32	s14, s14, s13
    823a:	ldr	r6, [sp, #104]	; 0x68
  const float rate_ratio = SemitonesToRatio((formant_shift - 0.5f) * 36.0f);
  const float rate = rate_ratio / 6.0f;
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
    823c:	vmul.f32	s12, s14, s12
    float gain,
    float* excitation,
    float* output,
    size_t size) {
  const float rate_ratio = SemitonesToRatio((formant_shift - 0.5f) * 36.0f);
  const float rate = rate_ratio / 6.0f;
    8240:	vdiv.f32	s18, s14, s10
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
    8244:	vdiv.f32	s14, s12, s11
    8248:	vdiv.f32	s20, s0, s14
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    824c:	bpl.w	83ce <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x21a>
    8250:	vsub.f32	s14, s4, s15
    8254:	vldr	s15, [pc, #740]	; 853c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x388>
    8258:	vmul.f32	s15, s14, s15

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    825c:	vadd.f32	s15, s15, s2
    8260:	vldr	s14, [pc, #712]	; 852c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x378>
        (formant_shift < 0.4f ? (formant_shift - 0.4f) * -45.0f
            : (formant_shift > 0.6f ? (formant_shift - 0.6f) * -45.0f : 0.0f)));
  
  if (bank != -1) {
    8264:	adds	r1, r5, #1
    8266:	vadd.f32	s15, s15, s14
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    826a:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    826e:	vcvt.f32.s32	s13, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    8272:	vmov	r3, s14
    8276:	add.w	ip, ip, r3, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    827a:	vsub.f32	s15, s15, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    827e:	vldr	s17, [ip]
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    8282:	vcvt.s32.f32	s15, s15, #8
    8286:	vmov	r3, s15
    828a:	add.w	lr, lr, r3, lsl #2
    828e:	vldr	s19, [lr]
    8292:	beq.n	8302 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x14e>
    bool reset_everything = word_bank_->Load(bank);
    8294:	ldr.w	r0, [r4, #144]	; 0x90
  }
  return bitstream.ptr() - data;
}

bool LPCSpeechSynthWordBank::Load(int bank) {
  if (bank == loaded_bank_ || bank >= num_banks_) {
    8298:	ldr	r3, [r0, #8]
    829a:	cmp	r5, r3
    829c:	beq.n	82a6 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0xf2>
    829e:	ldr	r3, [r0, #4]
    82a0:	cmp	r5, r3
    82a2:	blt.w	855c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x3a8>
    82a6:	ldr	r1, [r0, #12]
    82a8:	ldr.w	lr, [r0, #148]	; 0x94

  const LPCSpeechSynth::Frame* frames = bank == -1
      ? phonemes_
      : word_bank_->frames();
  
  if (trigger) {
    82ac:	cbz	r2, 830e <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x15a>
  
  inline int num_frames() const { return num_frames_; }
  inline const LPCSpeechSynth::Frame* frames() const { return frames_; }
  
  inline void GetWordBoundaries(float address, int* start, int* end) {
    if (num_words_ == 0) {
    82ae:	ldr	r3, [r0, #16]
    82b0:	cmp	r3, #0
    82b2:	bne.w	8488 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x2d4>
      *start = *end = -1;
    82b6:	mov.w	r2, #4294967295
      word_bank_->GetWordBoundaries(
          address,
          &playback_frame_,
          &last_playback_frame_);
    }
    remaining_frame_samples_ = 0;
    82ba:	str.w	r3, [r4, #140]	; 0x8c
    82be:	str.w	r2, [r4, #136]	; 0x88
    82c2:	str.w	r2, [r4, #132]	; 0x84
  }
  
  if (playback_frame_ == -1 && remaining_frame_samples_ == 0) {
    synth_.PlayFrame(
    82c6:	vmov	s15, r1
    82ca:	vldr	s14, [pc, #628]	; 8540 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x38c>
      frame_fractional = 0.0f;
    }
    PlayFrame(
        frames[frame_integral],
        frames[frame_integral + 1],
        frame_fractional);
    82ce:	add.w	r0, r4, #24
    82d2:	vcvt.f32.s32	s15, s15
    82d6:	vsub.f32	s15, s15, s14
    82da:	vmul.f32	s3, s15, s3
      float* excitation,
      float* output,
      size_t size);
  
  void PlayFrame(const Frame* frames, float frame, bool interpolate) {
    MAKE_INTEGRAL_FRACTIONAL(frame);
    82de:	vcvt.s32.f32	s0, s3
    
    if (!interpolate) {
      frame_fractional = 0.0f;
    }
    PlayFrame(
    82e2:	vmov	r3, s0
        frames[frame_integral],
        frames[frame_integral + 1],
        frame_fractional);
    82e6:	vcvt.f32.s32	s0, s0
    MAKE_INTEGRAL_FRACTIONAL(frame);
    
    if (!interpolate) {
      frame_fractional = 0.0f;
    }
    PlayFrame(
    82ea:	rsb	r1, r3, r3, lsl #3
        frames[frame_integral],
        frames[frame_integral + 1],
        frame_fractional);
    82ee:	vsub.f32	s0, s3, s0
    MAKE_INTEGRAL_FRACTIONAL(frame);
    
    if (!interpolate) {
      frame_fractional = 0.0f;
    }
    PlayFrame(
    82f2:	lsls	r1, r1, #1
        frames[frame_integral],
        frames[frame_integral + 1],
        frame_fractional);
    82f4:	add.w	r2, r1, #14
    82f8:	add	r1, lr
    82fa:	add	r2, lr
    82fc:	bl	78a0 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)>
    8300:	b.n	832c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x178>

  const LPCSpeechSynth::Frame* frames = bank == -1
      ? phonemes_
      : word_bank_->frames();
  
  if (trigger) {
    8302:	cmp	r2, #0
    8304:	bne.w	8586 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x3d2>
    8308:	movs	r1, #5
      ? kLPCSpeechSynthNumVowels
      : word_bank_->num_frames();

  const LPCSpeechSynth::Frame* frames = bank == -1
      ? phonemes_
      : word_bank_->frames();
    830a:	ldr.w	lr, [pc, #588]	; 8558 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x3a4>
          &last_playback_frame_);
    }
    remaining_frame_samples_ = 0;
  }
  
  if (playback_frame_ == -1 && remaining_frame_samples_ == 0) {
    830e:	ldr.w	r2, [r4, #132]	; 0x84
    8312:	ldr.w	r3, [r4, #140]	; 0x8c
    8316:	adds	r0, r2, #1
    8318:	beq.n	83fc <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x248>
    synth_.PlayFrame(
        frames,
        address * (static_cast<float>(num_frames) - 1.0001f),
        true);
  } else {
    if (remaining_frame_samples_ == 0) {
    831a:	cmp	r3, #0
    831c:	beq.w	84c2 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x30e>
      if (playback_frame_ >= last_playback_frame_) {
        bool back_to_scan_mode = bank == -1 || free_running;
        playback_frame_ = back_to_scan_mode ? -1 : last_playback_frame_;
      }
    }
    remaining_frame_samples_ -= min(size, remaining_frame_samples_);
    8320:	cmp	r6, r3
    8322:	ite	ls
    8324:	subls	r3, r3, r6
    8326:	subhi	r3, r3, r3
    8328:	str.w	r3, [r4, #140]	; 0x8c
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    832c:	vldr	s23, [r4, #20]
    increment_ = (new_value - *state) / static_cast<float>(size);
    8330:	vmov	s15, r6
  }
  
  ParameterInterpolator gain_modulation(&gain_, gain, size);
    8334:	add.w	r5, r4, #20
    8338:	vcvt.f32.u32	s15, s15
    833c:	vsub.f32	s16, s16, s23
    8340:	vdiv.f32	s19, s16, s15
  
  while (size--) {
    8344:	cbz	r6, 83c0 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x20c>
    8346:	add.w	r9, r4, #12
	*__first = __tmp;
    834a:	vldr	s16, [pc, #504]	; 8544 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x390>
    834e:	rsb	fp, r9, r5
    8352:	mov.w	sl, fp, asr #2
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
    8356:	cmp.w	sl, #0
    835a:	bne.n	83ea <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x236>
    835c:	mov	r3, r9
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    835e:	vstmia	r3!, {s16}
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    8362:	cmp	r5, r3
    8364:	bne.n	835e <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x1aa>
    float this_sample[2];
    copy(&next_sample_[0], &next_sample_[2], &this_sample[0]);
    fill(&next_sample_[0], &next_sample_[2], 0.0f);
    
    clock_phase_ += rate;
    8366:	vldr	s15, [r4]
    if (clock_phase_ >= 1.0f) {
    836a:	vmov.f32	s17, #112	; 0x3f800000  1.0
  while (size--) {
    float this_sample[2];
    copy(&next_sample_[0], &next_sample_[2], &this_sample[0]);
    fill(&next_sample_[0], &next_sample_[2], 0.0f);
    
    clock_phase_ += rate;
    836e:	vadd.f32	s15, s18, s15
    if (clock_phase_ >= 1.0f) {
    8372:	vcmpe.f32	s15, s17
  while (size--) {
    float this_sample[2];
    copy(&next_sample_[0], &next_sample_[2], &this_sample[0]);
    fill(&next_sample_[0], &next_sample_[2], 0.0f);
    
    clock_phase_ += rate;
    8376:	vstr	s15, [r4]
    if (clock_phase_ >= 1.0f) {
    837a:	vmrs	APSR_nzcv, fpscr
    837e:	bge.n	8402 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x24e>
    8380:	vldr	s13, [r4, #12]
    8384:	vldr	s15, [r4, #16]
    8388:	vldr	s10, [sp, #8]
    838c:	vldr	s11, [sp, #12]
  }

  inline float Next() {
    value_ += increment_;
    8390:	vadd.f32	s23, s23, s19
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
      copy(&new_sample[0], &new_sample[2], &sample_[0]);
    }
    next_sample_[0] += sample_[0];
    8394:	vldr	s12, [r4, #4]
    next_sample_[1] += sample_[1];
    8398:	vldr	s14, [r4, #8]
    remaining_frame_samples_ -= min(size, remaining_frame_samples_);
  }
  
  ParameterInterpolator gain_modulation(&gain_, gain, size);
  
  while (size--) {
    839c:	subs	r6, #1
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
      copy(&new_sample[0], &new_sample[2], &sample_[0]);
    }
    next_sample_[0] += sample_[0];
    839e:	vadd.f32	s13, s12, s13
    next_sample_[1] += sample_[1];
    const float gain = gain_modulation.Next();
    *excitation++ = this_sample[0] * gain;
    83a2:	vmul.f32	s10, s23, s10
    *output++ = this_sample[1] * gain;
    83a6:	vmul.f32	s12, s23, s11
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
      copy(&new_sample[0], &new_sample[2], &sample_[0]);
    }
    next_sample_[0] += sample_[0];
    next_sample_[1] += sample_[1];
    83aa:	vadd.f32	s15, s14, s15
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
      copy(&new_sample[0], &new_sample[2], &sample_[0]);
    }
    next_sample_[0] += sample_[0];
    83ae:	vstr	s13, [r4, #12]
    next_sample_[1] += sample_[1];
    83b2:	vstr	s15, [r4, #16]
    const float gain = gain_modulation.Next();
    *excitation++ = this_sample[0] * gain;
    83b6:	vstmia	r7!, {s10}
    *output++ = this_sample[1] * gain;
    83ba:	vstmia	r8!, {s12}
    remaining_frame_samples_ -= min(size, remaining_frame_samples_);
  }
  
  ParameterInterpolator gain_modulation(&gain_, gain, size);
  
  while (size--) {
    83be:	bne.n	8356 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x1a2>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    83c0:	vstr	s23, [r4, #20]
    next_sample_[1] += sample_[1];
    const float gain = gain_modulation.Next();
    *excitation++ = this_sample[0] * gain;
    *output++ = this_sample[1] * gain;
  }
}
    83c4:	add	sp, #28
    83c6:	vpop	{d8-d11}
    83ca:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const float rate = rate_ratio / 6.0f;
  
  // All utterances have been normalized for an average f0 of 100 Hz.
  const float pitch_shift = frequency / \
      (rate_ratio * kLPCSpeechSynthDefaultF0 / kCorrectedSampleRate);
  const float time_stretch = SemitonesToRatio(-speed * 24.0f +
    83ce:	vldr	s14, [pc, #376]	; 8548 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x394>
    83d2:	vcmpe.f32	s4, s14
    83d6:	vmrs	APSR_nzcv, fpscr
    83da:	ble.n	83f6 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x242>
    83dc:	vsub.f32	s14, s4, s14
    83e0:	vldr	s15, [pc, #344]	; 853c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x388>
    83e4:	vmul.f32	s15, s14, s15
    83e8:	b.n	825c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0xa8>
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
    83ea:	mov	r2, fp
    83ec:	mov	r1, r9
    83ee:	add	r0, sp, #8
    83f0:	bl	15578 <memcpy>
    83f4:	b.n	835c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x1a8>
    83f6:	vldr	s15, [pc, #332]	; 8544 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x390>
    83fa:	b.n	825c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0xa8>
          &last_playback_frame_);
    }
    remaining_frame_samples_ = 0;
  }
  
  if (playback_frame_ == -1 && remaining_frame_samples_ == 0) {
    83fc:	cmp	r3, #0
    83fe:	bne.n	8320 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x16c>
    8400:	b.n	82c6 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x112>
    copy(&next_sample_[0], &next_sample_[2], &this_sample[0]);
    fill(&next_sample_[0], &next_sample_[2], 0.0f);
    
    clock_phase_ += rate;
    if (clock_phase_ >= 1.0f) {
      clock_phase_ -= 1.0f;
    8402:	vsub.f32	s15, s15, s17
    8406:	mov	r0, r4
      
      synth_.Render(
          prosody_amount,
          pitch_shift,
          &new_sample[0],
          &new_sample[1], 1);
    8408:	movs	r3, #1
    840a:	add	r2, sp, #20
    840c:	vmov.f32	s1, s20
    fill(&next_sample_[0], &next_sample_[2], 0.0f);
    
    clock_phase_ += rate;
    if (clock_phase_ >= 1.0f) {
      clock_phase_ -= 1.0f;
      float reset_time = clock_phase_ / rate;
    8410:	vdiv.f32	s22, s15, s18
    copy(&next_sample_[0], &next_sample_[2], &this_sample[0]);
    fill(&next_sample_[0], &next_sample_[2], 0.0f);
    
    clock_phase_ += rate;
    if (clock_phase_ >= 1.0f) {
      clock_phase_ -= 1.0f;
    8414:	vmov	r1, s15
    8418:	str.w	r1, [r0], #24
      
      synth_.Render(
          prosody_amount,
          pitch_shift,
          &new_sample[0],
          &new_sample[1], 1);
    841c:	add	r1, sp, #16
    841e:	vmov.f32	s0, s21
    8422:	bl	7608 <plaits::LPCSpeechSynth::Render(float, float, float*, float*, unsigned int)>
  return -0.5f * t * t;
    8426:	vmov.f32	s15, #224	; 0xbf000000 -0.5
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    842a:	vmov.f32	s12, #96	; 0x3f000000  0.5
      
      float discontinuity[2] = {
        new_sample[0] - sample_[0],
        new_sample[1] - sample_[1]
    842e:	vldr	s14, [r4, #8]
    8432:	vldr	s9, [sp, #20]
    8436:	add	r3, sp, #16
          pitch_shift,
          &new_sample[0],
          &new_sample[1], 1);
      
      float discontinuity[2] = {
        new_sample[0] - sample_[0],
    8438:	vldr	s13, [r4, #4]
        new_sample[1] - sample_[1]
    843c:	vsub.f32	s9, s9, s14
          pitch_shift,
          &new_sample[0],
          &new_sample[1], 1);
      
      float discontinuity[2] = {
        new_sample[0] - sample_[0],
    8440:	vldr	s8, [sp, #16]
        new_sample[1] - sample_[1]
      };
      this_sample[0] += discontinuity[0] * ThisBlepSample(reset_time);
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
    8444:	vldr	s14, [r4, #16]
          pitch_shift,
          &new_sample[0],
          &new_sample[1], 1);
      
      float discontinuity[2] = {
        new_sample[0] - sample_[0],
    8448:	vsub.f32	s8, s8, s13
        new_sample[1] - sample_[1]
      };
      this_sample[0] += discontinuity[0] * ThisBlepSample(reset_time);
    844c:	vldr	s10, [sp, #8]
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
    8450:	vldr	s13, [r4, #12]
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
    8454:	vldr	s11, [sp, #12]
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    8458:	vsub.f32	s17, s17, s22
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    845c:	vmul.f32	s12, s22, s12
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
  return -0.5f * t * t;
    8460:	vmul.f32	s15, s17, s15
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    8464:	vmul.f32	s22, s12, s22
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
  return -0.5f * t * t;
    8468:	vmul.f32	s17, s15, s17
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
    846c:	vmov.f32	s15, s14
      
      float discontinuity[2] = {
        new_sample[0] - sample_[0],
        new_sample[1] - sample_[1]
      };
      this_sample[0] += discontinuity[0] * ThisBlepSample(reset_time);
    8470:	vfma.f32	s10, s8, s22
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
    8474:	vfma.f32	s11, s9, s22
      float discontinuity[2] = {
        new_sample[0] - sample_[0],
        new_sample[1] - sample_[1]
      };
      this_sample[0] += discontinuity[0] * ThisBlepSample(reset_time);
      next_sample_[0] += discontinuity[0] * NextBlepSample(reset_time);
    8478:	vfma.f32	s13, s8, s17
      this_sample[1] += discontinuity[1] * ThisBlepSample(reset_time);
      next_sample_[1] += discontinuity[1] * NextBlepSample(reset_time);
    847c:	vfma.f32	s15, s9, s17
    8480:	ldmia	r3!, {r0, r1}
    8482:	str	r0, [r4, #4]
    8484:	str	r1, [r4, #8]
    8486:	b.n	8390 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x1dc>
    } else {
      int word = static_cast<int>(address * static_cast<float>(num_words_));
    8488:	vmov	s15, r3
    848c:	vcvt.f32.s32	s15, s15
    8490:	vmul.f32	s15, s15, s3
    8494:	vcvt.s32.f32	s15, s15
    8498:	vmov	r2, s15
      if (word >= num_words_) {
    849c:	cmp	r3, r2
        word = num_words_ - 1;
    849e:	it	le
    84a0:	addle.w	r2, r3, #4294967295
    84a4:	add.w	r0, r0, r2, lsl #2
      }
      *start = word_boundaries_[word];
    84a8:	ldr	r2, [r0, #20]
    84aa:	str.w	r2, [r4, #132]	; 0x84
      *end = word_boundaries_[word + 1] - 1;
    84ae:	ldr	r3, [r0, #24]
    84b0:	subs	r3, #1
    84b2:	str.w	r3, [r4, #136]	; 0x88
      word_bank_->GetWordBoundaries(
          address,
          &playback_frame_,
          &last_playback_frame_);
    }
    remaining_frame_samples_ = 0;
    84b6:	movs	r3, #0
    84b8:	str.w	r3, [r4, #140]	; 0x8c
  }
  
  if (playback_frame_ == -1 && remaining_frame_samples_ == 0) {
    84bc:	adds	r3, r2, #1
    84be:	beq.w	82c6 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x112>
    MAKE_INTEGRAL_FRACTIONAL(frame);
    
    if (!interpolate) {
      frame_fractional = 0.0f;
    }
    PlayFrame(
    84c2:	vmov	s15, r2
        frames[frame_integral],
        frames[frame_integral + 1],
        frame_fractional);
    84c6:	vldr	s0, [pc, #124]	; 8544 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x390>
    84ca:	add.w	r0, r4, #24
    MAKE_INTEGRAL_FRACTIONAL(frame);
    
    if (!interpolate) {
      frame_fractional = 0.0f;
    }
    PlayFrame(
    84ce:	vcvt.f32.s32	s15, s15
    84d2:	vcvt.s32.f32	s15, s15
    84d6:	vmov	r1, s15
    84da:	rsb	r1, r1, r1, lsl #3
    84de:	lsls	r1, r1, #1
        frames[frame_integral],
        frames[frame_integral + 1],
        frame_fractional);
    84e0:	add.w	r2, r1, #14
    84e4:	add	r1, lr
    84e6:	add	r2, lr
    84e8:	bl	78a0 <plaits::LPCSpeechSynth::PlayFrame(plaits::LPCSpeechSynth::Frame const&, plaits::LPCSpeechSynth::Frame const&, float)>
        true);
  } else {
    if (remaining_frame_samples_ == 0) {
      synth_.PlayFrame(frames, float(playback_frame_), false);
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
    84ec:	vmul.f32	s17, s17, s19
    84f0:	vldr	s15, [pc, #88]	; 854c <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x398>
      ++playback_frame_;
    84f4:	ldr.w	r2, [r4, #132]	; 0x84
        true);
  } else {
    if (remaining_frame_samples_ == 0) {
      synth_.PlayFrame(frames, float(playback_frame_), false);
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
    84f8:	vmul.f32	s15, s17, s15
      ++playback_frame_;
      if (playback_frame_ >= last_playback_frame_) {
    84fc:	ldr.w	r1, [r4, #136]	; 0x88
  } else {
    if (remaining_frame_samples_ == 0) {
      synth_.PlayFrame(frames, float(playback_frame_), false);
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
      ++playback_frame_;
    8500:	adds	r2, #1
        true);
  } else {
    if (remaining_frame_samples_ == 0) {
      synth_.PlayFrame(frames, float(playback_frame_), false);
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
    8502:	vcvt.u32.f32	s15, s15
      ++playback_frame_;
      if (playback_frame_ >= last_playback_frame_) {
    8506:	cmp	r2, r1
  } else {
    if (remaining_frame_samples_ == 0) {
      synth_.PlayFrame(frames, float(playback_frame_), false);
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
      ++playback_frame_;
    8508:	str.w	r2, [r4, #132]	; 0x84
        true);
  } else {
    if (remaining_frame_samples_ == 0) {
      synth_.PlayFrame(frames, float(playback_frame_), false);
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
    850c:	vmov	r3, s15
    8510:	vstr	s15, [r4, #140]	; 0x8c
      ++playback_frame_;
      if (playback_frame_ >= last_playback_frame_) {
    8514:	blt.w	8320 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x16c>
        bool back_to_scan_mode = bank == -1 || free_running;
        playback_frame_ = back_to_scan_mode ? -1 : last_playback_frame_;
    8518:	adds	r5, #1
    851a:	beq.n	85d2 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x41e>
    851c:	cmp.w	r9, #0
    8520:	bne.n	85d2 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x41e>
    8522:	str.w	r1, [r4, #132]	; 0x84
    8526:	b.n	8320 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x16c>
    8528:	.word	0x42100000
    852c:	.word	0x43000000
    8530:	.word	0x42c80000
    8534:	.word	0x473b8000
    8538:	.word	0x3ecccccd
    853c:	.word	0xc2340000
    8540:	.word	0x3f800347
    8544:	.word	0x00000000
    8548:	.word	0x3f19999a
    854c:	.word	0x44960000
    8550:	.word	0x20000554
    8554:	.word	0x20000958
    8558:	.word	0x2001cb20
    855c:	mov	r1, r5
    855e:	str	r2, [sp, #4]
    8560:	bl	811c <plaits::LPCSpeechSynthWordBank::Load(int) [clone .part.5]>
        (formant_shift < 0.4f ? (formant_shift - 0.4f) * -45.0f
            : (formant_shift > 0.6f ? (formant_shift - 0.6f) * -45.0f : 0.0f)));
  
  if (bank != -1) {
    bool reset_everything = word_bank_->Load(bank);
    if (reset_everything) {
    8564:	ldr	r2, [sp, #4]
    8566:	cbz	r0, 8574 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x3c0>
      playback_frame_ = -1;
    8568:	mov.w	r3, #4294967295
    856c:	str.w	r3, [r4, #132]	; 0x84
      last_playback_frame_ = -1;
    8570:	str.w	r3, [r4, #136]	; 0x88
    8574:	ldr.w	r0, [r4, #144]	; 0x90
    8578:	ldr	r1, [r0, #12]
    857a:	ldr.w	lr, [r0, #148]	; 0x94

  const LPCSpeechSynth::Frame* frames = bank == -1
      ? phonemes_
      : word_bank_->frames();
  
  if (trigger) {
    857e:	cmp	r2, #0
    8580:	bne.w	82ae <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0xfa>
    8584:	b.n	830e <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x15a>
    if (bank == -1) {
      // Pick a pseudo-random consonant, and play it for the duration of a
      // frame.
      int r = (address + 3.0f * formant_shift + 7.0f * frequency) * 8.0f;
      playback_frame_ = (r % kLPCSpeechSynthNumConsonants);
    8586:	vmov.f32	s15, #8	; 0x40400000  3.0
    858a:	ldr	r3, [pc, #76]	; (85d8 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x424>)
    858c:	vmov.f32	s13, s3
    8590:	movs	r1, #5
    8592:	vmov.f32	s14, #28	; 0x40e00000  7.0
      ? kLPCSpeechSynthNumVowels
      : word_bank_->num_frames();

  const LPCSpeechSynth::Frame* frames = bank == -1
      ? phonemes_
      : word_bank_->frames();
    8596:	ldr.w	lr, [pc, #68]	; 85dc <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x428>
  if (trigger) {
    if (bank == -1) {
      // Pick a pseudo-random consonant, and play it for the duration of a
      // frame.
      int r = (address + 3.0f * formant_shift + 7.0f * frequency) * 8.0f;
      playback_frame_ = (r % kLPCSpeechSynthNumConsonants);
    859a:	vfma.f32	s13, s4, s15
    859e:	vmov.f32	s15, s13
    85a2:	vfma.f32	s15, s0, s14
    85a6:	vmov.f32	s14, s15
    85aa:	vcvt.s32.f32	s14, s14, #3
    85ae:	vmov	r2, s14
    85b2:	smull	r3, r0, r3, r2
    85b6:	asrs	r3, r2, #31
    85b8:	rsb	r3, r3, r0, asr #2
    85bc:	add.w	r3, r3, r3, lsl #2
    85c0:	sub.w	r3, r2, r3, lsl #1
      playback_frame_ += kLPCSpeechSynthNumVowels;
    85c4:	adds	r2, r3, r1
      last_playback_frame_ = playback_frame_ + 1;
    85c6:	adds	r3, #6
    if (bank == -1) {
      // Pick a pseudo-random consonant, and play it for the duration of a
      // frame.
      int r = (address + 3.0f * formant_shift + 7.0f * frequency) * 8.0f;
      playback_frame_ = (r % kLPCSpeechSynthNumConsonants);
      playback_frame_ += kLPCSpeechSynthNumVowels;
    85c8:	str.w	r2, [r4, #132]	; 0x84
      last_playback_frame_ = playback_frame_ + 1;
    85cc:	str.w	r3, [r4, #136]	; 0x88
    85d0:	b.n	84b6 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x302>
      remaining_frame_samples_ = kSampleRate / kLPCSpeechSynthFPS * \
          time_stretch;
      ++playback_frame_;
      if (playback_frame_ >= last_playback_frame_) {
        bool back_to_scan_mode = bank == -1 || free_running;
        playback_frame_ = back_to_scan_mode ? -1 : last_playback_frame_;
    85d2:	mov.w	r1, #4294967295
    85d6:	b.n	8522 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)+0x36e>
    85d8:	.word	0x66666667
    85dc:	.word	0x2001cb20

000085e0 <plaits::ModalEngine::Reset()>:
  harmonics_lp_ = 0.0f;
  Reset();
}

void ModalEngine::Reset() {
  voice_.Init();
    85e0:	adds	r0, #16
    85e2:	b.w	13988 <plaits::ModalVoice::Init()>
    85e6:	nop

000085e8 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
void ModalEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    85e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    85ec:	sub	sp, #20
    85ee:	mov	r5, r2
    85f0:	mov	lr, r1
    85f2:	mov	r6, r3
    85f4:	ldr	r7, [sp, #48]	; 0x30
  fill(&out[0], &out[size], 0.0f);
    85f6:	lsls	r2, r7, #2
    85f8:	adds	r1, r5, r2
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    85fa:	cmp	r5, r1
    85fc:	beq.n	860a <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22>
    85fe:	mov	r3, r5
	*__first = __tmp;
    8600:	movs	r4, #0
    8602:	str.w	r4, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    8606:	cmp	r1, r3
    8608:	bne.n	8602 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1a>
  fill(&aux[0], &aux[size], 0.0f);
    860a:	add	r2, r6
    860c:	cmp	r6, r2
    860e:	beq.n	861c <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x34>
    8610:	mov	r3, r6
	*__first = __tmp;
    8612:	movs	r1, #0
    8614:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    8618:	cmp	r2, r3
    861a:	bne.n	8614 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    861c:	vmov.f32	s13, #34	; 0x41100000  9.0
  
  ONE_POLE(harmonics_lp_, parameters.harmonics, 0.01f);
    8620:	vldr	s2, [r0, #320]	; 0x140
    8624:	vldr	s14, [lr, #16]
  
  voice_.Render(
    8628:	add.w	r9, r0, #16
    862c:	vldr	s15, [lr, #4]
    size_t size,
    bool* already_enveloped) {
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  ONE_POLE(harmonics_lp_, parameters.harmonics, 0.01f);
    8630:	vsub.f32	s14, s14, s2
    8634:	vldr	s12, [pc, #172]	; 86e4 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfc>
    8638:	vsub.f32	s15, s15, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    863c:	vldr	s13, [pc, #168]	; 86e8 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x100>
  
  voice_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
    8640:	ldrb.w	r2, [lr]
    size_t size,
    bool* already_enveloped) {
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  ONE_POLE(harmonics_lp_, parameters.harmonics, 0.01f);
    8644:	vfma.f32	s2, s14, s12
  
  voice_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
    8648:	vldr	s0, [lr, #20]
    864c:	vcmpe.f32	s15, s13
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  ONE_POLE(harmonics_lp_, parameters.harmonics, 0.01f);
  
  voice_.Render(
    8650:	ubfx	r1, r2, #1, #1
    8654:	and.w	r2, r2, #1
    8658:	vmrs	APSR_nzcv, fpscr
    size_t size,
    bool* already_enveloped) {
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  ONE_POLE(harmonics_lp_, parameters.harmonics, 0.01f);
    865c:	vstr	s2, [r0, #320]	; 0x140
    8660:	bmi.n	86dc <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf4>
    8662:	vldr	s14, [pc, #136]	; 86ec <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x104>
    8666:	vcmpe.f32	s15, s14
    866a:	vmrs	APSR_nzcv, fpscr
    866e:	ble.n	86b6 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xce>
    8670:	movs	r4, #0
    8672:	mov.w	r8, #255	; 0xff
    8676:	ldr.w	ip, [pc, #132]	; 86fc <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x114>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    867a:	ldr	r3, [pc, #116]	; (86f0 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x108>)
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    867c:	add.w	r4, ip, r4, lsl #2
      parameters.timbre,
      parameters.morph,
      temp_buffer_,
      out,
      aux,
      size);
    8680:	vldr	s1, [pc, #112]	; 86f4 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10c>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    8684:	add.w	r8, r3, r8, lsl #2
    8688:	vldr	s4, [lr, #12]
    868c:	vldr	s14, [r4]
    8690:	vldr	s15, [r8]
    8694:	ldr.w	r3, [r0, #316]	; 0x13c
    8698:	mov	r0, r9
    869a:	vmul.f32	s15, s15, s14
    869e:	vldr	s3, [lr, #8]
    86a2:	str	r7, [sp, #8]
    86a4:	vmul.f32	s1, s15, s1
    86a8:	stmia.w	sp, {r5, r6}
    86ac:	bl	139a4 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)>
}
    86b0:	add	sp, #20
    86b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    86b6:	vldr	s14, [pc, #64]	; 86f8 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x110>
    86ba:	vadd.f32	s15, s15, s14
    86be:	vcvt.s32.f32	s14, s15
    86c2:	vmov	r8, s14
    86c6:	vcvt.f32.s32	s14, s14
    86ca:	vsub.f32	s15, s15, s14
    86ce:	vmov.f32	s14, s15
    86d2:	vcvt.s32.f32	s14, s14, #8
    86d6:	vmov	r4, s14
    86da:	b.n	8676 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8e>
    86dc:	movs	r4, #0
    86de:	mov	r8, r4
    86e0:	b.n	8676 <plaits::ModalEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8e>
    86e2:	nop
    86e4:	.word	0x3c23d70a
    86e8:	.word	0xc3000000
    86ec:	.word	0x42fe0000
    86f0:	.word	0x20000554
    86f4:	.word	0x39962fc9
    86f8:	.word	0x43000000
    86fc:	.word	0x20000958

00008700 <plaits::ModalEngine::Init(stmlib::BufferAllocator*)>:
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    8700:	ldr	r2, [r1, #8]
    8702:	cmp.w	r2, #512	; 0x200
namespace plaits {

using namespace std;
using namespace stmlib;

void ModalEngine::Init(BufferAllocator* allocator) {
    8706:	push	{r4}
    8708:	bcc.n	8736 <plaits::ModalEngine::Init(stmlib::BufferAllocator*)+0x36>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    870a:	ldr	r3, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    870c:	sub.w	r2, r2, #512	; 0x200
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    8710:	add.w	r4, r3, #512	; 0x200
      free_ -= size_bytes;
    8714:	str	r2, [r1, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    8716:	str	r4, [r1, #0]
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  harmonics_lp_ = 0.0f;
  Reset();
    8718:	ldr	r2, [r0, #0]
using namespace std;
using namespace stmlib;

void ModalEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  harmonics_lp_ = 0.0f;
    871a:	movs	r1, #0

using namespace std;
using namespace stmlib;

void ModalEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
    871c:	str.w	r3, [r0, #316]	; 0x13c
  harmonics_lp_ = 0.0f;
  Reset();
    8720:	ldr	r3, [r2, #4]
    8722:	ldr	r2, [pc, #28]	; (8740 <plaits::ModalEngine::Init(stmlib::BufferAllocator*)+0x40>)
using namespace std;
using namespace stmlib;

void ModalEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  harmonics_lp_ = 0.0f;
    8724:	str.w	r1, [r0, #320]	; 0x140
    8728:	cmp	r3, r2
    872a:	bne.n	873a <plaits::ModalEngine::Init(stmlib::BufferAllocator*)+0x3a>
  Reset();
}

void ModalEngine::Reset() {
  voice_.Init();
    872c:	adds	r0, #16

void ModalEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  harmonics_lp_ = 0.0f;
  Reset();
}
    872e:	ldr.w	r4, [sp], #4

void ModalEngine::Reset() {
  voice_.Init();
    8732:	b.w	13988 <plaits::ModalVoice::Init()>
      free_ -= size_bytes;
      return start;
    } else {
      return NULL;
    8736:	movs	r3, #0
    8738:	b.n	8718 <plaits::ModalEngine::Init(stmlib::BufferAllocator*)+0x18>

void ModalEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  harmonics_lp_ = 0.0f;
  Reset();
}
    873a:	ldr.w	r4, [sp], #4
using namespace stmlib;

void ModalEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  harmonics_lp_ = 0.0f;
  Reset();
    873e:	bx	r3
    8740:	.word	0x000085e1

00008744 <plaits::SpeechEngine::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace std;
using namespace stmlib;

void SpeechEngine::Init(BufferAllocator* allocator) {
    8744:	push	{r4, r5, r6, lr}
    8746:	mov	r4, r0
    8748:	mov	r5, r1
  sam_speech_synth_.Init();
    874a:	adds	r0, #176	; 0xb0
  naive_speech_synth_.Init();
  lpc_speech_synth_word_bank_.Init(
    874c:	add.w	r6, r4, #360	; 0x168

using namespace std;
using namespace stmlib;

void SpeechEngine::Init(BufferAllocator* allocator) {
  sam_speech_synth_.Init();
    8750:	bl	72a0 <plaits::SAMSpeechSynth::Init()>
  naive_speech_synth_.Init();
    8754:	add.w	r0, r4, #20
    8758:	bl	6d90 <plaits::NaiveSpeechSynth::Init()>
  lpc_speech_synth_word_bank_.Init(
      word_banks_,
      LPC_SPEECH_SYNTH_NUM_WORD_BANKS,
      allocator);
    875c:	mov	r3, r5
    875e:	movs	r2, #5
    8760:	mov	r0, r6
    8762:	ldr	r1, [pc, #92]	; (87c0 <plaits::SpeechEngine::Init(stmlib::BufferAllocator*)+0x7c>)
    8764:	bl	7b38 <plaits::LPCSpeechSynthWordBank::Init(plaits::LPCSpeechSynthWordBankData const*, int, stmlib::BufferAllocator*)>
  lpc_speech_synth_controller_.Init(&lpc_speech_synth_word_bank_);
    8768:	mov	r1, r6
    876a:	add.w	r0, r4, #212	; 0xd4
    876e:	bl	816c <plaits::LPCSpeechSynthController::Init(plaits::LPCSpeechSynthWordBank*)>
 public:
  HysteresisQuantizer() { }
  ~HysteresisQuantizer() { }

  void Init() {
    quantized_value_ = 0;
    8772:	movs	r3, #0
    8774:	str	r3, [r4, #16]
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    8776:	ldr	r2, [r5, #8]
    8778:	cmp.w	r2, #512	; 0x200
    877c:	bcc.n	87b8 <plaits::SpeechEngine::Init(stmlib::BufferAllocator*)+0x74>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    877e:	ldr	r0, [r5, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    8780:	sub.w	r1, r2, #512	; 0x200
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    8784:	add.w	r6, r0, #512	; 0x200
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    8788:	cmp.w	r1, #512	; 0x200
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
      free_ -= size_bytes;
    878c:	str	r1, [r5, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    878e:	str	r6, [r5, #0]
  word_bank_quantizer_.Init();
  
  temp_buffer_[0] = allocator->Allocate<float>(kMaxBlockSize);
    8790:	str.w	r0, [r4, #512]	; 0x200
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    8794:	bcc.n	87a4 <plaits::SpeechEngine::Init(stmlib::BufferAllocator*)+0x60>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    8796:	ldr	r3, [r5, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    8798:	sub.w	r2, r2, #1024	; 0x400
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    879c:	add.w	r1, r3, #512	; 0x200
      free_ -= size_bytes;
    87a0:	str	r2, [r5, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    87a2:	str	r1, [r5, #0]
  temp_buffer_[1] = allocator->Allocate<float>(kMaxBlockSize);
  
  prosody_amount_ = 0.0f;
  speed_ = 1.0f;
    87a4:	mov.w	r2, #1065353216	; 0x3f800000
  word_bank_quantizer_.Init();
  
  temp_buffer_[0] = allocator->Allocate<float>(kMaxBlockSize);
  temp_buffer_[1] = allocator->Allocate<float>(kMaxBlockSize);
  
  prosody_amount_ = 0.0f;
    87a8:	movs	r1, #0
      allocator);
  lpc_speech_synth_controller_.Init(&lpc_speech_synth_word_bank_);
  word_bank_quantizer_.Init();
  
  temp_buffer_[0] = allocator->Allocate<float>(kMaxBlockSize);
  temp_buffer_[1] = allocator->Allocate<float>(kMaxBlockSize);
    87aa:	str.w	r3, [r4, #516]	; 0x204
  
  prosody_amount_ = 0.0f;
    87ae:	str.w	r1, [r4, #520]	; 0x208
  speed_ = 1.0f;
    87b2:	str.w	r2, [r4, #524]	; 0x20c
}
    87b6:	pop	{r4, r5, r6, pc}
      LPC_SPEECH_SYNTH_NUM_WORD_BANKS,
      allocator);
  lpc_speech_synth_controller_.Init(&lpc_speech_synth_word_bank_);
  word_bank_quantizer_.Init();
  
  temp_buffer_[0] = allocator->Allocate<float>(kMaxBlockSize);
    87b8:	str.w	r3, [r4, #512]	; 0x200
    87bc:	b.n	87a4 <plaits::SpeechEngine::Init(stmlib::BufferAllocator*)+0x60>
    87be:	nop
    87c0:	.word	0x20020630

000087c4 <plaits::SpeechEngine::Reset()>:
  prosody_amount_ = 0.0f;
  speed_ = 1.0f;
}

void SpeechEngine::Reset() {
  lpc_speech_synth_word_bank_.Reset();
    87c4:	add.w	r0, r0, #360	; 0x168
    87c8:	b.w	7b80 <plaits::LPCSpeechSynthWordBank::Reset()>

000087cc <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    87cc:	vmov.f32	s13, #34	; 0x41100000  9.0
    87d0:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    87d4:	vldr	s14, [pc, #684]	; 8a84 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b8>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    87d8:	vsub.f32	s15, s15, s13
void SpeechEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    87dc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    87e0:	vcmpe.f32	s15, s14
    87e4:	mov	r8, r1
    87e6:	mov	r7, r0
    87e8:	mov	r4, r2
    87ea:	mov	r5, r3
    87ec:	vmrs	APSR_nzcv, fpscr
    87f0:	vpush	{d8-d9}
    87f4:	sub	sp, #16
    87f6:	ldr	r6, [sp, #56]	; 0x38
    87f8:	bmi.n	8810 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>
    87fa:	vldr	s14, [pc, #652]	; 8a88 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
    87fe:	vcmpe.f32	s15, s14
    8802:	vmrs	APSR_nzcv, fpscr
    8806:	ble.w	89dc <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x210>
    880a:	movs	r3, #0
    880c:	movs	r0, #255	; 0xff
    880e:	b.n	8814 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48>
    8810:	movs	r3, #0
    8812:	mov	r0, r3
  const float f0 = NoteToFrequency(parameters.note);
  
  const float group = parameters.harmonics * 6.0f;
    8814:	vmov.f32	s16, #24	; 0x40c00000  6.0
    8818:	vldr	s15, [r8, #16]
    881c:	ldr	r1, [pc, #620]	; (8a8c <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c0>)
  
  // Interpolates between the 3 models: naive, SAM, LPC.
  if (group <= 2.0f) {
    881e:	vmov.f32	s18, #0	; 0x40000000  2.0
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    8822:	ldr	r2, [pc, #620]	; (8a90 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c4>)
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  const float group = parameters.harmonics * 6.0f;
    8824:	vmul.f32	s16, s15, s16

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    8828:	add.w	r1, r1, r0, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    882c:	add.w	r3, r2, r3, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    8830:	vldr	s12, [pc, #608]	; 8a94 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c8>
    8834:	vldr	s13, [r1]
  
  // Interpolates between the 3 models: naive, SAM, LPC.
  if (group <= 2.0f) {
    8838:	vcmpe.f32	s16, s18
    883c:	vldr	s17, [r3]
    8840:	vmul.f32	s15, s13, s17
    8844:	vmrs	APSR_nzcv, fpscr
    8848:	vmul.f32	s17, s15, s12
    884c:	bhi.n	8932 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x166>
    *already_enveloped = false;
    
    float blend = group;
    if (group <= 1.0f) {
    884e:	vmov.f32	s5, #112	; 0x3f800000  1.0
  
  const float group = parameters.harmonics * 6.0f;
  
  // Interpolates between the 3 models: naive, SAM, LPC.
  if (group <= 2.0f) {
    *already_enveloped = false;
    8852:	movs	r3, #0
    8854:	ldr	r2, [sp, #60]	; 0x3c
    
    float blend = group;
    if (group <= 1.0f) {
    8856:	vcmpe.f32	s16, s5
  
  const float group = parameters.harmonics * 6.0f;
  
  // Interpolates between the 3 models: naive, SAM, LPC.
  if (group <= 2.0f) {
    *already_enveloped = false;
    885a:	strb	r3, [r2, #0]
    
    float blend = group;
    if (group <= 1.0f) {
    885c:	vmrs	APSR_nzcv, fpscr
    8860:	bls.w	8a0a <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x23e>
          aux,
          out,
          size);
    } else {
      lpc_speech_synth_controller_.Render(
          parameters.trigger & TRIGGER_UNPATCHED,
    8864:	ldrb.w	r1, [r8]
          parameters.morph,
          parameters.timbre,
          1.0f,
          aux,
          out,
          size);
    8868:	vmov.f32	s0, s17
    886c:	vldr	s2, [pc, #552]	; 8a98 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2cc>
    8870:	mov.w	r3, #4294967295
    8874:	vldr	s4, [r8, #8]
    8878:	and.w	r2, r1, #1
    887c:	vldr	s3, [r8, #12]
    8880:	ubfx	r1, r1, #1, #1
    8884:	str	r6, [sp, #8]
    8886:	vmov.f32	s1, s2
    888a:	str	r4, [sp, #4]
    888c:	add.w	r0, r7, #212	; 0xd4
    8890:	str	r5, [sp, #0]
    8892:	bl	81b4 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)>
      blend = 2.0f - blend;
    8896:	vsub.f32	s16, s18, s16
        f0,
        parameters.morph,
        parameters.timbre,
        temp_buffer_[0],
        temp_buffer_[1],
        size);
    889a:	ldrb.w	r1, [r8]
    889e:	vmov.f32	s0, s17
    88a2:	ldr.w	r3, [r7, #516]	; 0x204
    88a6:	add.w	r0, r7, #176	; 0xb0
    88aa:	sub.w	r1, r1, #1
    88ae:	ldr.w	r2, [r7, #512]	; 0x200
    88b2:	vldr	s2, [r8, #8]
    88b6:	clz	r1, r1
    88ba:	vldr	s1, [r8, #12]
    88be:	str	r6, [sp, #0]
    88c0:	lsrs	r1, r1, #5
    88c2:	bl	738c <plaits::SAMSpeechSynth::Render(bool, float, float, float, float*, float*, unsigned int)>
    
    blend *= blend * (3.0f - 2.0f * blend);
    88c6:	vmov.f32	s15, #8	; 0x40400000  3.0
    88ca:	vmov.f32	s13, #0	; 0x40000000  2.0
    88ce:	vmov.f32	s14, s15
    88d2:	vfms.f32	s14, s16, s13
    88d6:	vmul.f32	s14, s14, s16
    88da:	vmul.f32	s16, s16, s14
    blend *= blend * (3.0f - 2.0f * blend);
    88de:	vfms.f32	s15, s16, s13
    88e2:	vmul.f32	s14, s15, s16
    88e6:	vmul.f32	s14, s16, s14
    for (size_t i = 0; i < size; ++i) {
    88ea:	cbz	r6, 8928 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x15c>
    88ec:	ldr.w	r1, [r7, #512]	; 0x200
    88f0:	mov	r3, r5
    88f2:	mov	r2, r4
    88f4:	ldr.w	r0, [r7, #516]	; 0x204
    88f8:	add.w	r6, r1, r6, lsl #2
      aux[i] += (temp_buffer_[0][i] - aux[i]) * blend;
    88fc:	vldmia	r1!, {s13}
    8900:	vldr	s15, [r3]
        temp_buffer_[1],
        size);
    
    blend *= blend * (3.0f - 2.0f * blend);
    blend *= blend * (3.0f - 2.0f * blend);
    for (size_t i = 0; i < size; ++i) {
    8904:	cmp	r6, r1
      aux[i] += (temp_buffer_[0][i] - aux[i]) * blend;
    8906:	vsub.f32	s13, s13, s15
    890a:	vfma.f32	s15, s14, s13
    890e:	vstmia	r3!, {s15}
      out[i] += (temp_buffer_[1][i] - out[i]) * blend;
    8912:	vldr	s15, [r2]
    8916:	vldmia	r0!, {s13}
    891a:	vsub.f32	s13, s13, s15
    891e:	vfma.f32	s15, s14, s13
    8922:	vstmia	r2!, {s15}
        temp_buffer_[1],
        size);
    
    blend *= blend * (3.0f - 2.0f * blend);
    blend *= blend * (3.0f - 2.0f * blend);
    for (size_t i = 0; i < size; ++i) {
    8926:	bne.n	88fc <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x130>
        replay_prosody ? parameters.accent : 1.0f,
        aux,
        out,
        size);
  }
}
    8928:	add	sp, #16
    892a:	vpop	{d8-d9}
    892e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    8932:	vsub.f32	s16, s16, s18
    8936:	vldr	s13, [pc, #356]	; 8a9c <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d0>
    893a:	vmov.f32	s12, #20	; 0x40a00000  5.0
    893e:	vldr	s15, [pc, #344]	; 8a98 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2cc>
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    8942:	vmov.f32	s14, #208	; 0xbe800000 -0.250
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    8946:	vmul.f32	s16, s16, s13
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    894a:	vldr	s13, [r7, #16]
    894e:	vmov.f32	s11, #80	; 0x3e800000  0.250
    8952:	vcvt.f32.s32	s13, s13
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    8956:	vfma.f32	s15, s16, s12
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    895a:	vmov.f32	s12, #96	; 0x3f000000  0.5
  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    895e:	vcmpe.f32	s15, s13
    8962:	vmrs	APSR_nzcv, fpscr
    8966:	it	le
    8968:	vmovle.f32	s14, s11
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    896c:	vadd.f32	s15, s15, s14
    8970:	vadd.f32	s15, s15, s12
    8974:	vcvt.s32.f32	s15, s15
    8978:	vmov	r2, s15
    CONSTRAIN(q, 0, num_steps - 1);
    897c:	cmp	r2, #0
    897e:	blt.n	8a38 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x26c>
    8980:	cmp	r2, #5
    8982:	bgt.n	8a02 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x236>
    quantized_value_ = q;
    8984:	vstr	s15, [r7, #16]
    // Change phonemes/words for LPC.
    const int word_bank = word_bank_quantizer_.Process(
        (group - 2.0f) * 0.275f,
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    
    const bool replay_prosody = word_bank >= 0 && \
    8988:	subs	r3, r2, #1
    898a:	cmp	r2, #0
    898c:	beq.n	8a78 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
        !(parameters.trigger & TRIGGER_UNPATCHED);
    898e:	ldrb.w	r2, [r8]
    8992:	and.w	r0, r2, #2
    // Change phonemes/words for LPC.
    const int word_bank = word_bank_quantizer_.Process(
        (group - 2.0f) * 0.275f,
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    
    const bool replay_prosody = word_bank >= 0 && \
    8996:	and.w	r1, r0, #255	; 0xff
    899a:	cmp	r0, #0
    899c:	bne.n	8a4a <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x27e>
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    899e:	mov.w	lr, #1
    89a2:	ldr	r0, [sp, #60]	; 0x3c
    
    lpc_speech_synth_controller_.Render(
    89a4:	vldr	s1, [r7, #520]	; 0x208
    89a8:	and.w	r2, r2, lr
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    89ac:	strb.w	lr, [r0]
    
    lpc_speech_synth_controller_.Render(
    89b0:	vldr	s2, [r7, #524]	; 0x20c
    89b4:	add.w	r0, r7, #212	; 0xd4
        parameters.trigger & TRIGGER_RISING_EDGE,
        word_bank,
        f0,
        prosody_amount_,
        speed_,
        parameters.morph,
    89b8:	vldr	s3, [r8, #12]
        parameters.timbre,
    89bc:	vldr	s4, [r8, #8]
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    
    lpc_speech_synth_controller_.Render(
    89c0:	vldr	s5, [r8, #20]
        parameters.morph,
        parameters.timbre,
        replay_prosody ? parameters.accent : 1.0f,
        aux,
        out,
        size);
    89c4:	vmov.f32	s0, s17
    89c8:	str	r6, [sp, #8]
    89ca:	str	r4, [sp, #4]
    89cc:	str	r5, [sp, #0]
    89ce:	bl	81b4 <plaits::LPCSpeechSynthController::Render(bool, bool, int, float, float, float, float, float, float, float*, float*, unsigned int)>
  }
}
    89d2:	add	sp, #16
    89d4:	vpop	{d8-d9}
    89d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    89dc:	vldr	s14, [pc, #192]	; 8aa0 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d4>
    89e0:	vadd.f32	s15, s15, s14
    89e4:	vcvt.s32.f32	s14, s15
    89e8:	vmov	r0, s14
    89ec:	vcvt.f32.s32	s14, s14
    89f0:	vsub.f32	s15, s15, s14
    89f4:	vmov.f32	s14, s15
    89f8:	vcvt.s32.f32	s14, s14, #8
    89fc:	vmov	r3, s14
    8a00:	b.n	8814 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48>
    8a02:	movs	r2, #5
    }
  } else {
    // Change phonemes/words for LPC.
    const int word_bank = word_bank_quantizer_.Process(
        (group - 2.0f) * 0.275f,
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    8a04:	movs	r3, #4
    8a06:	str	r2, [r7, #16]
    8a08:	b.n	898e <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1c2>
          parameters.morph,
          parameters.timbre,
          temp_buffer_[0],
          aux,
          out,
          size);
    8a0a:	ldrb.w	r1, [r8]
    8a0e:	mov	r3, r5
    8a10:	ldr.w	r2, [r7, #512]	; 0x200
    8a14:	vmov.f32	s0, s17
    8a18:	sub.w	r1, r1, #1
    8a1c:	vldr	s2, [r8, #8]
    8a20:	vldr	s1, [r8, #12]
    8a24:	add.w	r0, r7, #20
    8a28:	clz	r1, r1
    8a2c:	stmia.w	sp, {r4, r6}
    8a30:	lsrs	r1, r1, #5
    8a32:	bl	6e10 <plaits::NaiveSpeechSynth::Render(bool, float, float, float, float*, float*, float*, unsigned int)>
    8a36:	b.n	889a <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xce>
    8a38:	ldrb.w	r2, [r8]
    8a3c:	movs	r0, #0
    }
  } else {
    // Change phonemes/words for LPC.
    const int word_bank = word_bank_quantizer_.Process(
        (group - 2.0f) * 0.275f,
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    8a3e:	mov.w	r3, #4294967295
    8a42:	and.w	r1, r2, #2
    8a46:	str	r0, [r7, #16]
    8a48:	uxtb	r1, r1
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    
    lpc_speech_synth_controller_.Render(
    8a4a:	adds	r1, #0
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    8a4c:	mov.w	lr, #0
    
    lpc_speech_synth_controller_.Render(
    8a50:	vldr	s1, [r7, #520]	; 0x208
    8a54:	add.w	r0, r7, #212	; 0xd4
    8a58:	vldr	s2, [r7, #524]	; 0x20c
    8a5c:	vmov.f32	s5, #112	; 0x3f800000  1.0
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    8a60:	ldr	r7, [sp, #60]	; 0x3c
    
    lpc_speech_synth_controller_.Render(
    8a62:	it	ne
    8a64:	movne	r1, #1
        parameters.trigger & TRIGGER_RISING_EDGE,
        word_bank,
        f0,
        prosody_amount_,
        speed_,
        parameters.morph,
    8a66:	vldr	s3, [r8, #12]
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    
    lpc_speech_synth_controller_.Render(
    8a6a:	and.w	r2, r2, #1
        word_bank,
        f0,
        prosody_amount_,
        speed_,
        parameters.morph,
        parameters.timbre,
    8a6e:	vldr	s4, [r8, #8]
        LPC_SPEECH_SYNTH_NUM_WORD_BANKS + 1) - 1;
    
    const bool replay_prosody = word_bank >= 0 && \
        !(parameters.trigger & TRIGGER_UNPATCHED);
    
    *already_enveloped = replay_prosody;
    8a72:	strb.w	lr, [r7]
    8a76:	b.n	89c4 <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f8>
    8a78:	ldrb.w	r2, [r8]
    8a7c:	and.w	r1, r2, #2
    8a80:	uxtb	r1, r1
    8a82:	b.n	8a4a <plaits::SpeechEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x27e>
    8a84:	.word	0xc3000000
    8a88:	.word	0x42fe0000
    8a8c:	.word	0x20000554
    8a90:	.word	0x20000958
    8a94:	.word	0x39962fc9
    8a98:	.word	0x00000000
    8a9c:	.word	0x3e8ccccd
    8aa0:	.word	0x43000000

00008aa4 <plaits::WaveshapingEngine::Init(stmlib::BufferAllocator*)>:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    8aa4:	movs	r3, #0
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    8aa6:	mov.w	r2, #1056964608	; 0x3f000000
    next_sample_ = 0.0f;
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    high_ = true;

    frequency_ = 0.001f;
    8aaa:	ldr	r1, [pc, #52]	; (8ae0 <plaits::WaveshapingEngine::Init(stmlib::BufferAllocator*)+0x3c>)
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    8aac:	str	r2, [r0, #16]
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    high_ = true;

    frequency_ = 0.001f;
    pw_ = 0.5f;
    8aae:	str	r2, [r0, #40]	; 0x28
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    8ab0:	str	r2, [r0, #44]	; 0x2c
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    high_ = true;

    frequency_ = 0.001f;
    pw_ = 0.5f;
    8ab2:	str	r2, [r0, #68]	; 0x44
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    8ab4:	str	r3, [r0, #20]
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    8ab6:	str	r3, [r0, #28]
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    8ab8:	str	r3, [r0, #48]	; 0x30
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    8aba:	str	r3, [r0, #56]	; 0x38
using namespace stmlib;

void WaveshapingEngine::Init(BufferAllocator* allocator) {
  slope_.Init();
  triangle_.Init();
  previous_shape_ = 0.0f;
    8abc:	str	r3, [r0, #72]	; 0x48
  previous_wavefolder_gain_ = 0.0f;
    8abe:	str	r3, [r0, #76]	; 0x4c
  previous_overtone_gain_ = 0.0f;
    8ac0:	str	r3, [r0, #80]	; 0x50
    high_ = true;

    frequency_ = 0.001f;
    8ac2:	str	r1, [r0, #36]	; 0x24
    8ac4:	str	r1, [r0, #64]	; 0x40
namespace plaits {

using namespace std;
using namespace stmlib;

void WaveshapingEngine::Init(BufferAllocator* allocator) {
    8ac6:	push	{r4, r5}
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    lp_state_ = 1.0f;
    8ac8:	mov.w	r5, #1065353216	; 0x3f800000
    hp_state_ = 0.0f;
    high_ = true;
    8acc:	movs	r4, #1
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    lp_state_ = 1.0f;
    8ace:	str	r5, [r0, #24]
    8ad0:	str	r5, [r0, #52]	; 0x34
    hp_state_ = 0.0f;
    high_ = true;
    8ad2:	strb.w	r4, [r0, #32]
    8ad6:	strb.w	r4, [r0, #60]	; 0x3c
  slope_.Init();
  triangle_.Init();
  previous_shape_ = 0.0f;
  previous_wavefolder_gain_ = 0.0f;
  previous_overtone_gain_ = 0.0f;
}
    8ada:	pop	{r4, r5}
    8adc:	bx	lr
    8ade:	nop
    8ae0:	.word	0x3a83126f

00008ae4 <plaits::WaveshapingEngine::Reset()>:

void WaveshapingEngine::Reset() {
    8ae4:	bx	lr
    8ae6:	nop

00008ae8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    8ae8:	vmov.f32	s13, #34	; 0x41100000  9.0
    8aec:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    8af0:	vldr	s14, [pc, #660]	; 8d88 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a0>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    8af4:	vsub.f32	s15, s15, s13
void WaveshapingEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    8af8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    8afc:	vcmpe.f32	s15, s14
    8b00:	mov	r8, r1
    8b02:	vpush	{d8-d12}
    8b06:	vmrs	APSR_nzcv, fpscr
    8b0a:	sub	sp, #12
    8b0c:	ldr	r1, [sp, #88]	; 0x58
    8b0e:	bmi.n	8b26 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e>
    8b10:	vldr	s14, [pc, #632]	; 8d8c <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a4>
    8b14:	vcmpe.f32	s15, s14
    8b18:	vmrs	APSR_nzcv, fpscr
    8b1c:	ble.w	923e <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x756>
    8b20:	movs	r4, #0
    8b22:	movs	r7, #255	; 0xff
    8b24:	b.n	8b2a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42>
    8b26:	movs	r4, #0
    8b28:	mov	r7, r4

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    8b2a:	ldr	r6, [pc, #612]	; (8d90 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a8>)
  const float root = parameters.note;
  
  const float f0 = NoteToFrequency(root);
  const float pw = parameters.morph * 0.45f + 0.5f;
    8b2c:	vmov.f32	s15, #96	; 0x3f000000  0.5
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    8b30:	ldr	r5, [pc, #608]	; (8d94 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>)

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    8b32:	add.w	r6, r6, r7, lsl #2
    8b36:	vldr	s12, [pc, #608]	; 8d98 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b0>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    8b3a:	add.w	r4, r5, r4, lsl #2
    8b3e:	vldr	s9, [r8, #12]
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    8b42:	vldr	s14, [r6]
    8b46:	vldr	s11, [r4]
    8b4a:	vldr	s10, [pc, #592]	; 8d9c <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b4>
    8b4e:	vmul.f32	s13, s14, s11
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    8b52:	vldr	s14, [pc, #588]	; 8da0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b8>
    8b56:	vmov.f32	s11, s15
    8b5a:	vfma.f32	s11, s9, s12
    8b5e:	vmov.f32	s12, s11
    8b62:	vmul.f32	s11, s13, s10
    8b66:	vcmpe.f32	s11, s14
    8b6a:	vmrs	APSR_nzcv, fpscr
    8b6e:	bmi.w	920e <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x726>
    8b72:	vmov.f32	s14, #80	; 0x3e800000  0.250
    8b76:	vcmpe.f32	s11, s14
    8b7a:	vmrs	APSR_nzcv, fpscr
    8b7e:	ble.w	9230 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x748>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    8b82:	vcmpe.f32	s12, s15
    8b86:	vmrs	APSR_nzcv, fpscr
    8b8a:	bmi.n	8ba2 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xba>
    8b8c:	vmov.f32	s13, #112	; 0x3f800000  1.0
    8b90:	vsub.f32	s15, s13, s15
    8b94:	vcmpe.f32	s12, s15
    8b98:	vmrs	APSR_nzcv, fpscr
    8b9c:	it	le
    8b9e:	vmovle.f32	s15, s12
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    8ba2:	vmov	s13, r1
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    8ba6:	vldr	s6, [r0, #36]	; 0x24
    8baa:	vldr	s7, [r0, #40]	; 0x28
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8bae:	subs	r4, r1, #1
    increment_ = (new_value - *state) / static_cast<float>(size);
    8bb0:	vcvt.f32.u32	s10, s13
    8bb4:	vsub.f32	s15, s15, s7
    8bb8:	vsub.f32	s13, s14, s6
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    8bbc:	vldr	s14, [r0, #20]
    8bc0:	vdiv.f32	s1, s15, s10
    8bc4:	vdiv.f32	s2, s13, s10
  
    while (size--) {
    8bc8:	cmp	r1, #0
    8bca:	beq.w	8d14 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22c>
    8bce:	mov	r7, r2
    8bd0:	mov	r5, r4
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8bd2:	vldr	s17, [pc, #464]	; 8da4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = true;
    8bd6:	mov.w	lr, #1
        }
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
    8bda:	vmov.f32	s8, #112	; 0x3f800000  1.0
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    8bde:	vmov.f32	s3, #96	; 0x3f000000  0.5
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8be2:	vmov.f32	s4, #72	; 0x3e400000  0.1875000
    8be6:	vmov.f32	s5, #120	; 0x3fc00000  1.5
          high_ = false;
        }
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
    8bea:	vmov.f32	s16, #0	; 0x40000000  2.0
    8bee:	vmov.f32	s0, #240	; 0xbf800000 -1.0
    8bf2:	b.n	8cb6 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1ce>
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
          float t = (phase_ - pw) / frequency;
    8bf4:	vsub.f32	s9, s15, s7
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
    8bf8:	strb.w	r6, [r0, #32]
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
    8bfc:	vadd.f32	s20, s13, s18
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8c00:	vcmpe.f32	s15, s8
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
          float t = (phase_ - pw) / frequency;
    8c04:	vdiv.f32	s12, s9, s6
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c08:	vnmul.f32	s20, s6, s20
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8c0c:	vmrs	APSR_nzcv, fpscr
    8c10:	vsub.f32	s9, s8, s12
    8c14:	vmul.f32	s12, s12, s3
    8c18:	vmul.f32	s9, s9, s3
  const float t2 = t1 * t1;
    8c1c:	vmul.f32	s21, s12, s12
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c20:	vsub.f32	s12, s4, s12
    8c24:	vmul.f32	s19, s9, s9
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c28:	vsub.f32	s9, s4, s9
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c2c:	vfma.f32	s12, s21, s5
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c30:	vfma.f32	s9, s19, s5
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c34:	vfms.f32	s12, s21, s21
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c38:	vfms.f32	s9, s19, s19
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c3c:	vmov.f32	s19, s17
    8c40:	vfma.f32	s19, s20, s12
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c44:	vfma.f32	s14, s20, s9
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8c48:	blt.n	8cfa <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x212>
          phase_ -= 1.0f;
    8c4a:	vsub.f32	s15, s15, s8
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = true;
    8c4e:	strb.w	lr, [r0, #32]
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
    8c52:	vadd.f32	s18, s13, s18
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
    8c56:	vdiv.f32	s12, s15, s6
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    8c5a:	vstr	s15, [r0, #16]
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
    8c5e:	vmul.f32	s18, s18, s6
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    8c62:	vsub.f32	s9, s8, s12
    8c66:	vmul.f32	s12, s12, s3
    8c6a:	vmul.f32	s9, s9, s3
  const float t2 = t1 * t1;
    8c6e:	vmul.f32	s21, s12, s12
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c72:	vsub.f32	s12, s4, s12
    8c76:	vmul.f32	s20, s9, s9
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c7a:	vsub.f32	s9, s4, s9
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c7e:	vfma.f32	s12, s21, s5
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c82:	vfma.f32	s9, s20, s5
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c86:	vfms.f32	s12, s21, s21
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c8a:	vfms.f32	s9, s20, s20
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8c8e:	vfma.f32	s19, s18, s12
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8c92:	vfma.f32	s14, s18, s9
    8c96:	vmov.f32	s12, s14
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = false;
        }
        next_sample += high_
    8c9a:	vmul.f32	s14, s13, s15
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
    8c9e:	vmov.f32	s15, s0
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8ca2:	subs	r5, #1
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = false;
        }
        next_sample += high_
    8ca4:	vadd.f32	s14, s14, s19
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8ca8:	cmp.w	r5, #4294967295
          high_ = false;
        }
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
    8cac:	vfma.f32	s15, s12, s16
    8cb0:	vstmia	r7!, {s15}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8cb4:	beq.n	8d14 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22c>
  }

  inline float Next() {
    value_ += increment_;
    8cb6:	vadd.f32	s6, s6, s2
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    8cba:	vldr	s15, [r0, #16]
    8cbe:	vadd.f32	s7, s7, s1
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
    8cc2:	ldrb.w	ip, [r0, #32]
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    8cc6:	vadd.f32	s15, s6, s15
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
    8cca:	vsub.f32	s12, s8, s7
        }
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
    8cce:	vdiv.f32	s13, s8, s7
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    8cd2:	vstr	s15, [r0, #16]
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
    8cd6:	vcmpe.f32	s7, s15
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
    8cda:	vdiv.f32	s18, s8, s12
        }
        if (high_ ^ (phase_ < pw)) {
    8cde:	vmrs	APSR_nzcv, fpscr
    8ce2:	ite	gt
    8ce4:	movgt	r6, #1
    8ce6:	movle	r6, #0
    8ce8:	cmp	ip, r6
    8cea:	bne.n	8bf4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10c>
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8cec:	vcmpe.f32	s15, s8
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    8cf0:	vldr	s19, [pc, #176]	; 8da4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8cf4:	vmrs	APSR_nzcv, fpscr
    8cf8:	bge.n	8c4a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x162>
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = false;
        }
        next_sample += high_
    8cfa:	ldrb.w	r6, [r0, #32]
    8cfe:	vmov.f32	s12, s14
    8d02:	cmp	r6, #0
    8d04:	bne.n	8c9a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b2>
    8d06:	vsub.f32	s15, s15, s7
    8d0a:	vmov.f32	s14, s8
    8d0e:	vfms.f32	s14, s18, s15
    8d12:	b.n	8c9e <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b6>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    8d14:	vldr	s15, [pc, #136]	; 8da0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b8>
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    8d18:	vstr	s14, [r0, #20]
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    8d1c:	vcmpe.f32	s11, s15
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    8d20:	vstr	s7, [r0, #40]	; 0x28
    8d24:	vstr	s6, [r0, #36]	; 0x24
    8d28:	vmrs	APSR_nzcv, fpscr
    8d2c:	bmi.n	8d3e <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x256>
    8d2e:	vmov.f32	s15, #80	; 0x3e800000  0.250
    8d32:	vcmpe.f32	s11, s15
    8d36:	vmrs	APSR_nzcv, fpscr
    8d3a:	ble.w	9214 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x72c>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    8d3e:	vmov.f32	s13, #96	; 0x3f000000  0.5
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    8d42:	vldr	s6, [r0, #64]	; 0x40
    8d46:	vldr	s7, [r0, #68]	; 0x44
    increment_ = (new_value - *state) / static_cast<float>(size);
    8d4a:	vsub.f32	s15, s15, s6
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    8d4e:	vldr	s14, [r0, #48]	; 0x30
    8d52:	vsub.f32	s13, s13, s7
    8d56:	vdiv.f32	s2, s15, s10
    8d5a:	vdiv.f32	s1, s13, s10
  
    while (size--) {
    8d5e:	cmp	r1, #0
    8d60:	beq.w	8ede <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f6>
    8d64:	mov	r6, r3
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8d66:	vldr	s17, [pc, #60]	; 8da4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = true;
    8d6a:	mov.w	lr, #1
        }
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
    8d6e:	vmov.f32	s8, #112	; 0x3f800000  1.0
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    8d72:	vmov.f32	s3, #96	; 0x3f000000  0.5
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8d76:	vmov.f32	s4, #72	; 0x3e400000  0.1875000
    8d7a:	vmov.f32	s5, #120	; 0x3fc00000  1.5
          high_ = false;
        }
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
    8d7e:	vmov.f32	s16, #0	; 0x40000000  2.0
    8d82:	vmov.f32	s0, #240	; 0xbf800000 -1.0
    8d86:	b.n	8e7c <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x394>
    8d88:	.word	0xc3000000
    8d8c:	.word	0x42fe0000
    8d90:	.word	0x20000554
    8d94:	.word	0x20000958
    8d98:	.word	0x3ee66666
    8d9c:	.word	0x39962fc9
    8da0:	.word	0x358637bd
    8da4:	.word	0x00000000
    8da8:	.word	0xbd000000
    8dac:	.word	0xbd2aaaab
    8db0:	.word	0x3eeaaaab
    8db4:	.word	0x3eeb851f
    8db8:	.word	0x3cf5c28f
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
          float t = (phase_ - pw) / frequency;
    8dbc:	vsub.f32	s9, s15, s7
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
    8dc0:	strb.w	r5, [r0, #60]	; 0x3c
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
    8dc4:	vadd.f32	s20, s13, s18
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8dc8:	vcmpe.f32	s15, s8
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
          float t = (phase_ - pw) / frequency;
    8dcc:	vdiv.f32	s12, s9, s6
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8dd0:	vnmul.f32	s20, s6, s20
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8dd4:	vmrs	APSR_nzcv, fpscr
    8dd8:	vsub.f32	s9, s8, s12
    8ddc:	vmul.f32	s12, s12, s3
    8de0:	vmul.f32	s9, s9, s3
  const float t2 = t1 * t1;
    8de4:	vmul.f32	s21, s12, s12
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8de8:	vsub.f32	s12, s4, s12
    8dec:	vmul.f32	s19, s9, s9
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8df0:	vsub.f32	s9, s4, s9
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8df4:	vfma.f32	s12, s21, s5
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8df8:	vfma.f32	s9, s19, s5
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8dfc:	vfms.f32	s12, s21, s21
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8e00:	vfms.f32	s9, s19, s19
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8e04:	vmov.f32	s19, s17
    8e08:	vfma.f32	s19, s20, s12
          float t = (phase_ - pw) / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8e0c:	vfma.f32	s14, s20, s9
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8e10:	blt.n	8ec0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d8>
          phase_ -= 1.0f;
    8e12:	vsub.f32	s15, s15, s8
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = true;
    8e16:	strb.w	lr, [r0, #60]	; 0x3c
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
    8e1a:	vadd.f32	s18, s13, s18
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
    8e1e:	vdiv.f32	s12, s15, s6
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    8e22:	vstr	s15, [r0, #44]	; 0x2c
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
    8e26:	vmul.f32	s18, s18, s6
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    8e2a:	vsub.f32	s9, s8, s12
    8e2e:	vmul.f32	s12, s12, s3
    8e32:	vmul.f32	s9, s9, s3
  const float t2 = t1 * t1;
    8e36:	vmul.f32	s21, s12, s12
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8e3a:	vsub.f32	s12, s4, s12
    8e3e:	vmul.f32	s20, s9, s9
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8e42:	vsub.f32	s9, s4, s9
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8e46:	vfma.f32	s12, s21, s5
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8e4a:	vfma.f32	s9, s20, s5
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8e4e:	vfms.f32	s12, s21, s21
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8e52:	vfms.f32	s9, s20, s20
          next_sample += stmlib::NextIntegratedBlepSample(t) * discontinuity;
    8e56:	vfma.f32	s19, s18, s12
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample += stmlib::ThisIntegratedBlepSample(t) * discontinuity;
    8e5a:	vfma.f32	s14, s18, s9
    8e5e:	vmov.f32	s12, s14
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = false;
        }
        next_sample += high_
    8e62:	vmul.f32	s15, s13, s15
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
    8e66:	vmov.f32	s13, s0
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8e6a:	subs	r4, #1
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = false;
        }
        next_sample += high_
    8e6c:	vadd.f32	s14, s15, s19
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8e70:	adds	r7, r4, #1
          high_ = false;
        }
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
    8e72:	vfma.f32	s13, s12, s16
    8e76:	vstmia	r6!, {s13}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    8e7a:	beq.n	8ede <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f6>
  }

  inline float Next() {
    value_ += increment_;
    8e7c:	vadd.f32	s6, s6, s2
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    8e80:	vldr	s15, [r0, #44]	; 0x2c
    8e84:	vadd.f32	s7, s7, s1
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
    8e88:	ldrb.w	r7, [r0, #60]	; 0x3c
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    8e8c:	vadd.f32	s15, s6, s15
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
    8e90:	vsub.f32	s12, s8, s7
        }
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
    8e94:	vdiv.f32	s13, s8, s7
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    8e98:	vstr	s15, [r0, #44]	; 0x2c
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
        }
        if (high_ ^ (phase_ < pw)) {
    8e9c:	vcmpe.f32	s7, s15
      } else if (shape <= OSCILLATOR_SHAPE_SLOPE) {
        float slope_up = 2.0f;
        float slope_down = 2.0f;
        if (shape == OSCILLATOR_SHAPE_SLOPE) {
          slope_up = 1.0f / (pw);
          slope_down = 1.0f / (1.0f - pw);
    8ea0:	vdiv.f32	s18, s8, s12
        }
        if (high_ ^ (phase_ < pw)) {
    8ea4:	vmrs	APSR_nzcv, fpscr
    8ea8:	ite	gt
    8eaa:	movgt	r5, #1
    8eac:	movle	r5, #0
    8eae:	cmp	r7, r5
    8eb0:	bne.n	8dbc <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d4>
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8eb2:	vcmpe.f32	s15, s8
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    8eb6:	vldr	s19, [pc, #-276]	; 8da4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
          }
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = phase_ < pw;
        }
        if (phase_ >= 1.0f) {
    8eba:	vmrs	APSR_nzcv, fpscr
    8ebe:	bge.n	8e12 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x32a>
          float discontinuity = (slope_up + slope_down) * frequency;
          this_sample -= stmlib::ThisIntegratedBlepSample(t) * discontinuity;
          next_sample -= stmlib::NextIntegratedBlepSample(t) * discontinuity;
          high_ = false;
        }
        next_sample += high_
    8ec0:	ldrb.w	r5, [r0, #60]	; 0x3c
    8ec4:	vmov.f32	s12, s14
    8ec8:	cmp	r5, #0
    8eca:	bne.n	8e62 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37a>
    8ecc:	vsub.f32	s15, s15, s7
    8ed0:	vmov.f32	s14, s8
    8ed4:	vfms.f32	s14, s18, s15
    8ed8:	vmov.f32	s15, s14
    8edc:	b.n	8e66 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37e>
  slope_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, pw, out, size);
  triangle_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, 0.5f, aux, size);

  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
    8ede:	vmov.f32	s15, #96	; 0x3f000000  0.5
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    8ee2:	vstr	s7, [r0, #68]	; 0x44
    8ee6:	vstr	s6, [r0, #64]	; 0x40
    8eea:	vmov.f32	s5, #20	; 0x40a00000  5.0
    8eee:	vldr	s12, [r8, #12]
    8ef2:	vmov.f32	s8, #8	; 0x40400000  3.0
  const float shape_amount = fabsf(parameters.harmonics - 0.5f) * 2.0f;
    8ef6:	vldr	s9, [r8, #16]
}

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
    8efa:	vmov.f32	s6, #94	; 0x3ef00000  0.4687500
  slope_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, pw, out, size);
  triangle_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, 0.5f, aux, size);

  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
    8efe:	vsub.f32	s12, s12, s15
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    8f02:	vstr	s14, [r0, #48]	; 0x30
}

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
    8f06:	vldr	s7, [pc, #-352]	; 8da8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c0>
    8f0a:	vmov.f32	s13, #112	; 0x3f800000  1.0
  triangle_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, 0.5f, aux, size);

  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
  const float shape_amount = fabsf(parameters.harmonics - 0.5f) * 2.0f;
    8f0e:	vsub.f32	s9, s9, s15
  slope_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, pw, out, size);
  triangle_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, 0.5f, aux, size);

  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
    8f12:	vabs.f32	s14, s12
  const float shape_amount = fabsf(parameters.harmonics - 0.5f) * 2.0f;
    8f16:	vabs.f32	s15, s9
  slope_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, pw, out, size);
  triangle_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, 0.5f, aux, size);

  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
    8f1a:	vfma.f32	s8, s14, s5
}

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
    8f1e:	vmov.f32	s14, s7
  triangle_.Render<OSCILLATOR_SHAPE_SLOPE>(f0, 0.5f, aux, size);

  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
  const float shape_amount = fabsf(parameters.harmonics - 0.5f) * 2.0f;
    8f22:	vadd.f32	s15, s15, s15
}

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
    8f26:	vfma.f32	s14, s8, s11
    8f2a:	vdiv.f32	s12, s14, s6
    8f2e:	vsub.f32	s12, s13, s12
  CONSTRAIN(max_amount, 0.0f, 1.0f);
    8f32:	vcmpe.f32	s12, #0.0
    8f36:	vmrs	APSR_nzcv, fpscr
    8f3a:	bmi.w	926a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x782>
    8f3e:	vcmpe.f32	s12, s13
    8f42:	vmrs	APSR_nzcv, fpscr
    8f46:	ble.w	928c <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a4>
}

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
    8f4a:	vmul.f32	s15, s15, s13
    8f4e:	vldr	s7, [pc, #-420]	; 8dac <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c4>
    8f52:	vmov.f32	s5, #20	; 0x40a00000  5.0
    8f56:	vldr	s6, [pc, #-424]	; 8db0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c8>
    8f5a:	vmov.f32	s14, #8	; 0x40400000  3.0
  // Try to estimate how rich the spectrum is, and reduce the range of the
  // waveshaping control accordingly.
  const float slope = 3.0f + fabsf(parameters.morph - 0.5f) * 5.0f;
  const float shape_amount = fabsf(parameters.harmonics - 0.5f) * 2.0f;
  const float shape_amount_attenuation = Tame(f0, slope, 16.0f);
  const float wavefolder_gain = parameters.timbre;
    8f5e:	vldr	s4, [r8, #8]
}

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
    8f62:	vmov.f32	s12, #112	; 0x3f800000  1.0
    8f66:	vfma.f32	s14, s15, s5
    8f6a:	vmul.f32	s15, s14, s8
    8f6e:	vfma.f32	s7, s15, s11
    8f72:	vdiv.f32	s14, s7, s6
    8f76:	vsub.f32	s14, s12, s14
  CONSTRAIN(max_amount, 0.0f, 1.0f);
    8f7a:	vcmpe.f32	s14, #0.0
    8f7e:	vmrs	APSR_nzcv, fpscr
    8f82:	bmi.w	9264 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x77c>
    8f86:	vcmpe.f32	s14, s12
    8f8a:	vmrs	APSR_nzcv, fpscr
    8f8e:	ble.w	9296 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7ae>
      size);
  ParameterInterpolator wf_gain_modulation(
      &previous_wavefolder_gain_,
      0.03f + 0.46f * wavefolder_gain * wavefolder_gain_attenuation,
      size);
  const float overtone_gain = parameters.timbre * (2.0f - parameters.timbre);
    8f92:	vmov.f32	s14, #0	; 0x40000000  2.0
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    8f96:	vldr	s3, [pc, #-484]	; 8db4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2cc>
    8f9a:	vmov.f32	s11, #96	; 0x3f000000  0.5
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    8f9e:	vldr	s7, [r0, #80]	; 0x50
    increment_ = (new_value - *state) / static_cast<float>(size);
    8fa2:	vmul.f32	s3, s4, s3
    8fa6:	vldr	s15, [pc, #-496]	; 8db8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d0>
    8faa:	vsub.f32	s6, s14, s4
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    8fae:	vldr	s8, [r0, #76]	; 0x4c
    increment_ = (new_value - *state) / static_cast<float>(size);
    8fb2:	vmov.f32	s5, s11
    8fb6:	vfma.f32	s15, s3, s12
    8fba:	vfma.f32	s5, s9, s13
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    8fbe:	vldr	s9, [r0, #72]	; 0x48
    8fc2:	vmul.f32	s13, s6, s4
    increment_ = (new_value - *state) / static_cast<float>(size);
    8fc6:	vmov.f32	s6, s7
    8fca:	vsub.f32	s14, s14, s13
    8fce:	vsub.f32	s15, s15, s8
    8fd2:	vsub.f32	s12, s5, s9
    8fd6:	vfnms.f32	s6, s13, s14
    8fda:	vdiv.f32	s5, s15, s10
    8fde:	vmov.f32	s14, s6
    8fe2:	vdiv.f32	s4, s12, s10
    8fe6:	vdiv.f32	s6, s14, s10
  ParameterInterpolator overtone_gain_modulation(
      &previous_overtone_gain_,
      overtone_gain * (2.0f - overtone_gain),
      size);
  
  for (size_t i = 0; i < size; ++i) {
    8fea:	cmp	r1, #0
    8fec:	beq.w	91f8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x710>
    8ff0:	mov	lr, r3
    8ff2:	add.w	r3, r2, r1, lsl #2
    8ff6:	ldr.w	fp, [pc, #724]	; 92cc <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e4>
    8ffa:	mov	r1, r3
    8ffc:	ldr.w	ip, [pc, #720]	; 92d0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e8>
    9000:	ldr	r3, [pc, #668]	; (92a0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b8>)
    float fold = InterpolateHermite(
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    9002:	vmov.f32	s17, #80	; 0x3e800000  0.250
    9006:	ldr	r7, [pc, #668]	; (92a4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7bc>)
      &previous_overtone_gain_,
      overtone_gain * (2.0f - overtone_gain),
      size);
  
  for (size_t i = 0; i < size; ++i) {
    float shape = shape_modulation.Next() * 3.9999f;
    9008:	vldr	s16, [pc, #668]	; 92a8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c0>
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    900c:	mov	sl, r1
    MAKE_INTEGRAL_FRACTIONAL(shape);
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    900e:	vldr	s0, [pc, #668]	; 92ac <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c4>
    9012:	vldr	s1, [pc, #668]	; 92b0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c8>
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    float x = x0 + (x1 - x0) * ws_index_fractional;
    9016:	vldr	s10, [pc, #668]	; 92b4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7cc>
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    901a:	vldr	s2, [pc, #668]	; 92b8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d0>
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    901e:	vldr	s3, [pc, #668]	; 92bc <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d4>
    9022:	str	r0, [sp, #4]
  }

  inline float Next() {
    value_ += increment_;
    9024:	vadd.f32	s9, s9, s4
    MAKE_INTEGRAL_FRACTIONAL(shape);
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    9028:	vldr	s15, [r2]
    902c:	vmov.f32	s12, s1


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
    9030:	mvn.w	r1, #3221225472	; 0xc0000000
    float fold = InterpolateHermite(
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    9034:	vmov.f32	s13, s11
      &previous_overtone_gain_,
      overtone_gain * (2.0f - overtone_gain),
      size);
  
  for (size_t i = 0; i < size; ++i) {
    float shape = shape_modulation.Next() * 3.9999f;
    9038:	vmul.f32	s18, s9, s16
    MAKE_INTEGRAL_FRACTIONAL(shape);
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    903c:	vfma.f32	s12, s15, s0
    float fold = InterpolateHermite(
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    9040:	vldr	s15, [lr]
    9044:	vadd.f32	s8, s8, s5
    9048:	vfma.f32	s13, s15, s17
      overtone_gain * (2.0f - overtone_gain),
      size);
  
  for (size_t i = 0; i < size; ++i) {
    float shape = shape_modulation.Next() * 3.9999f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    904c:	vcvt.s32.f32	s15, s18
    9050:	vadd.f32	s7, s7, s6
    9054:	vmov	r0, s15
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    9058:	vcvt.s32.f32	s15, s12
  
  for (size_t i = 0; i < size; ++i) {
    float shape = shape_modulation.Next() * 3.9999f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    905c:	ldr.w	r4, [ip, r0, lsl #2]
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    9060:	vcvt.s32.f32	s14, s13
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    9064:	vstr	s15, [sp]
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    9068:	vmov	s15, r0
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    906c:	ldrb.w	r5, [sp]
  for (size_t i = 0; i < size; ++i) {
    float shape = shape_modulation.Next() * 3.9999f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    9070:	adds	r0, #1
    9072:	vcvt.f32.s32	s19, s15
    9076:	ldr.w	r6, [ip, r0, lsl #2]
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    907a:	lsls	r0, r5, #1
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    907c:	vcvt.s32.f32	s15, s12
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    9080:	ldrsh.w	r8, [r4, r5, lsl #1]
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    9084:	adds	r0, #2
    9086:	vsub.f32	s18, s18, s19
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    908a:	vcvt.f32.s32	s14, s14
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    908e:	vmov	s21, r8
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    float x = x0 + (x1 - x0) * ws_index_fractional;
    9092:	ldrsh	r4, [r4, r0]
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    9094:	vcvt.f32.s32	s15, s15
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    9098:	ldrsh	r0, [r6, r0]
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    909a:	vcvt.f32.s32	s21, s21
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    float x = x0 + (x1 - x0) * ws_index_fractional;
    909e:	vmov	s19, r4

    float y0 = static_cast<float>(shape_2[ws_index_integral]) / 32768.0f;
    90a2:	ldrsh.w	r5, [r6, r5, lsl #1]
    
    const int16_t* shape_1 = lookup_table_i16_table[shape_integral];
    const int16_t* shape_2 = lookup_table_i16_table[shape_integral + 1];
    
    float ws_index = 127.0f * out[i] + 128.0f;
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    90a6:	vsub.f32	s15, s12, s15
    90aa:	vmov	s12, r0
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    float x = x0 + (x1 - x0) * ws_index_fractional;
    90ae:	vcvt.f32.s32	s19, s19

    float y0 = static_cast<float>(shape_2[ws_index_integral]) / 32768.0f;
    90b2:	vmov	s20, r5
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    90b6:	vsub.f32	s14, s13, s14
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
  float b = table[index_integral + 1];
    90ba:	ldr	r5, [pc, #516]	; (92c0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d8>)
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    90bc:	vcvt.f32.s32	s12, s12
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    float x = x0 + (x1 - x0) * ws_index_fractional;
    90c0:	vmul.f32	s19, s19, s10

    float y0 = static_cast<float>(shape_2[ws_index_integral]) / 32768.0f;
    90c4:	vcvt.f32.s32	s20, s20
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    90c8:	vmul.f32	s14, s14, s3
    MAKE_INTEGRAL_FRACTIONAL(ws_index)
    ws_index_integral &= 255;
    
    float x0 = static_cast<float>(shape_1[ws_index_integral]) / 32768.0f;
    float x1 = static_cast<float>(shape_1[ws_index_integral + 1]) / 32768.0f;
    float x = x0 + (x1 - x0) * ws_index_fractional;
    90cc:	vfms.f32	s19, s21, s10
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    90d0:	vmul.f32	s12, s12, s10
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
    90d4:	vcvt.s32.f32	s13, s14
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    90d8:	vfms.f32	s12, s20, s10

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    90dc:	vmov	r0, s13
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    90e0:	vcvt.f32.s32	s13, s13
    90e4:	vmul.f32	s19, s19, s15

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    90e8:	lsls	r0, r0, #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    90ea:	vsub.f32	s14, s14, s13
    90ee:	vmov.f32	s13, s19

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    90f2:	add.w	r4, fp, r0
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    90f6:	vmul.f32	s15, s12, s15
inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
  float b = table[index_integral + 1];
    90fa:	add	r0, r5

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    90fc:	vldr	s19, [r4]
    9100:	vfma.f32	s13, s21, s10
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    9104:	vldr	s12, [r0]
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    9108:	vfma.f32	s15, s20, s10
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    910c:	vsub.f32	s12, s12, s19
    9110:	vfma.f32	s19, s14, s12
  return a + (b - a) * index_fractional;
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
    9114:	vsub.f32	s15, s15, s13
    9118:	vfma.f32	s13, s18, s15
    911c:	vmov.f32	s15, s11
    9120:	vfma.f32	s15, s13, s8
    9124:	vmul.f32	s15, s15, s2
  MAKE_INTEGRAL_FRACTIONAL(index)
    9128:	vcvt.s32.f32	s14, s15
  const float xm1 = table[index_integral - 1];
    912c:	vmov	r0, s14
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
    9130:	vcvt.f32.s32	s14, s14
  const float xm1 = table[index_integral - 1];
    9134:	add	r1, r0
}


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
    9136:	vsub.f32	s15, s15, s14
  const float xm1 = table[index_integral - 1];
    913a:	lsls	r1, r1, #2
  const float x0 = table[index_integral + 0];
    913c:	adds	r5, r1, #4
  const float x1 = table[index_integral + 1];
    913e:	add.w	r4, r1, #8


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
    9142:	add.w	r9, r7, r1
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
    9146:	add.w	r0, r1, #12

inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
    914a:	add.w	r8, r7, r5
  const float x1 = table[index_integral + 1];
    914e:	adds	r6, r7, r4
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
    9150:	vldr	s20, [r9]

inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
    9154:	add	r5, r3
    9156:	vldr	s12, [r8]
  const float x1 = table[index_integral + 1];
    915a:	add	r4, r3
    915c:	vldr	s14, [r6]
  const float x2 = table[index_integral + 2];
    9160:	add.w	r8, r7, r0

inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
    9164:	vldr	s22, [r5]


inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
    9168:	add	r1, r3
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
    916a:	vsub.f32	s23, s12, s14
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
    916e:	vldr	s25, [r8]
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
    9172:	vsub.f32	s20, s14, s20
inline float InterpolateHermite(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
    9176:	vldr	s14, [r4]
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
    917a:	vldr	s18, [r1]
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
    917e:	vsub.f32	s25, s25, s12
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
    9182:	vmov.f32	s13, s23
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
    9186:	add	r0, r3
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
    9188:	vsub.f32	s21, s22, s14
  MAKE_INTEGRAL_FRACTIONAL(index)
  const float xm1 = table[index_integral - 1];
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
    918c:	vsub.f32	s18, s14, s18
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
    9190:	vldr	s24, [r0]
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
    9194:	vfma.f32	s13, s20, s11
    9198:	vmov.f32	s14, s21
  const float a = w + v + (x2 - x0) * 0.5f;
    919c:	vsub.f32	s24, s24, s22
  const float x0 = table[index_integral + 0];
  const float x1 = table[index_integral + 1];
  const float x2 = table[index_integral + 2];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
    91a0:	vfma.f32	s14, s18, s11
  const float a = w + v + (x2 - x0) * 0.5f;
    91a4:	vadd.f32	s23, s23, s13
    91a8:	vfma.f32	s23, s25, s11
    91ac:	vadd.f32	s21, s21, s14
    91b0:	vfma.f32	s21, s24, s11
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    aux[i] = sine + (fold_2 - sine) * overtone_gain_modulation.Next();
    91b4:	vadd.f32	s13, s13, s23
    91b8:	vfnms.f32	s13, s23, s15
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    91bc:	vadd.f32	s14, s14, s21
    91c0:	vfnms.f32	s14, s15, s21
    aux[i] = sine + (fold_2 - sine) * overtone_gain_modulation.Next();
    91c4:	vmul.f32	s13, s13, s15
    91c8:	vfma.f32	s13, s20, s11
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    91cc:	vmul.f32	s14, s14, s15
    91d0:	vfma.f32	s14, s18, s11
    aux[i] = sine + (fold_2 - sine) * overtone_gain_modulation.Next();
    91d4:	vfma.f32	s12, s13, s15
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    91d8:	vfma.f32	s22, s15, s14
    aux[i] = sine + (fold_2 - sine) * overtone_gain_modulation.Next();
    91dc:	vneg.f32	s12, s12
    91e0:	vsub.f32	s12, s12, s19
        lut_fold + 1, index, 512.0f);
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    91e4:	vstmia	r2!, {s22}
  ParameterInterpolator overtone_gain_modulation(
      &previous_overtone_gain_,
      overtone_gain * (2.0f - overtone_gain),
      size);
  
  for (size_t i = 0; i < size; ++i) {
    91e8:	cmp	sl, r2
    float fold_2 = -InterpolateHermite(
        lut_fold_2 + 1, index, 512.0f);
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    aux[i] = sine + (fold_2 - sine) * overtone_gain_modulation.Next();
    91ea:	vfma.f32	s19, s12, s7
    91ee:	vstmia	lr!, {s19}
  ParameterInterpolator overtone_gain_modulation(
      &previous_overtone_gain_,
      overtone_gain * (2.0f - overtone_gain),
      size);
  
  for (size_t i = 0; i < size; ++i) {
    91f2:	bne.w	9024 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x53c>
    91f6:	ldr	r0, [sp, #4]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    91f8:	vstr	s7, [r0, #80]	; 0x50
    91fc:	vstr	s8, [r0, #76]	; 0x4c
    9200:	vstr	s9, [r0, #72]	; 0x48
    
    float sine = InterpolateWrap(lut_sine, aux[i] * 0.25f + 0.5f, 1024.0f);
    out[i] = fold;
    aux[i] = sine + (fold_2 - sine) * overtone_gain_modulation.Next();
  }
}
    9204:	add	sp, #12
    9206:	vpop	{d8-d12}
    920a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    920e:	vldr	s15, [pc, #180]	; 92c4 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7dc>
    9212:	b.n	8b82 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    9214:	vabs.f32	s13, s11
    9218:	vmov.f32	s15, #96	; 0x3f000000  0.5
    921c:	vadd.f32	s13, s13, s13
    9220:	vcmpe.f32	s13, s15
    9224:	vmrs	APSR_nzcv, fpscr
    9228:	ble.n	9270 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x788>
    922a:	vmov.f32	s15, s11
    922e:	b.n	8d42 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x25a>
    9230:	vabs.f32	s15, s11
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    9234:	vmov.f32	s14, s11
    9238:	vadd.f32	s15, s15, s15
    923c:	b.n	8b82 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a>
    923e:	vldr	s14, [pc, #112]	; 92b0 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c8>
    9242:	vadd.f32	s15, s15, s14
    9246:	vcvt.s32.f32	s14, s15
    924a:	vmov	r7, s14
    924e:	vcvt.f32.s32	s14, s14
    9252:	vsub.f32	s15, s15, s14
    9256:	vmov.f32	s14, s15
    925a:	vcvt.s32.f32	s14, s14, #8
    925e:	vmov	r4, s14
    9262:	b.n	8b2a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42>

float Tame(float f0, float harmonics, float order) {
  f0 *= harmonics;
  float max_f = 0.5f / order;
  float max_amount = 1.0f - (f0 - max_f) / (0.5f - max_f);
  CONSTRAIN(max_amount, 0.0f, 1.0f);
    9264:	vldr	s12, [pc, #96]	; 92c8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e0>
    9268:	b.n	8f92 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4aa>
    926a:	vldr	s13, [pc, #92]	; 92c8 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e0>
    926e:	b.n	8f4a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x462>
    9270:	vmov.f32	s14, #112	; 0x3f800000  1.0
    9274:	vsub.f32	s13, s14, s13
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    9278:	vcmpe.f32	s13, s15
    927c:	vmrs	APSR_nzcv, fpscr
    9280:	bmi.n	922a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x742>
    9282:	vmov.f32	s13, s15
    9286:	vmov.f32	s15, s11
    928a:	b.n	8d42 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x25a>
    928c:	vmul.f32	s14, s12, s12
    9290:	vmul.f32	s13, s14, s12
    9294:	b.n	8f4a <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x462>
    9296:	vmul.f32	s15, s14, s14
    929a:	vmul.f32	s12, s15, s14
    929e:	b.n	8f92 <plaits::WaveshapingEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4aa>
    92a0:	.word	0x20001878
    92a4:	.word	0x20001068
    92a8:	.word	0x407ffe5d
    92ac:	.word	0x42fe0000
    92b0:	.word	0x43000000
    92b4:	.word	0x38000000
    92b8:	.word	0x44000000
    92bc:	.word	0x44800000
    92c0:	.word	0x20002b14
    92c4:	.word	0x360637bd
    92c8:	.word	0x00000000
    92cc:	.word	0x20002b10
    92d0:	.word	0x20020474

000092d4 <plaits::VirtualAnalogEngine::Init(stmlib::BufferAllocator*)>:
 public:
  VariableShapeOscillator() { }
  ~VariableShapeOscillator() { }

  void Init() {
    master_phase_ = 0.0f;
    92d4:	movs	r3, #0
    slave_phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    high_ = false;
    92d6:	movs	r2, #0
namespace plaits {

using namespace std;
using namespace stmlib;

void VirtualAnalogEngine::Init(BufferAllocator* allocator) {
    92d8:	push	{r4, r5}

  void Init() {
    master_phase_ = 0.0f;
    slave_phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    92da:	mov.w	r4, #1056964608	; 0x3f000000
    high_ = false;
  
    master_frequency_ = 0.0f;
    slave_frequency_ = 0.01f;
    92de:	ldr	r5, [pc, #124]	; (935c <plaits::VirtualAnalogEngine::Init(stmlib::BufferAllocator*)+0x88>)
 public:
  VariableShapeOscillator() { }
  ~VariableShapeOscillator() { }

  void Init() {
    master_phase_ = 0.0f;
    92e0:	str	r3, [r0, #16]
    slave_phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    92e2:	str	r4, [r0, #28]
    high_ = false;
  
    master_frequency_ = 0.0f;
    slave_frequency_ = 0.01f;
    pw_ = 0.5f;
    92e4:	str	r4, [r0, #44]	; 0x2c

  void Init() {
    master_phase_ = 0.0f;
    slave_phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    92e6:	str	r4, [r0, #64]	; 0x40
    high_ = false;
  
    master_frequency_ = 0.0f;
    slave_frequency_ = 0.01f;
    pw_ = 0.5f;
    92e8:	str	r4, [r0, #80]	; 0x50

  void Init() {
    master_phase_ = 0.0f;
    slave_phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    92ea:	str	r4, [r0, #100]	; 0x64
    high_ = false;
  
    master_frequency_ = 0.0f;
    slave_frequency_ = 0.01f;
    pw_ = 0.5f;
    92ec:	str	r4, [r0, #116]	; 0x74
  ~VariableSawOscillator() { }

  void Init() {
    phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    92ee:	str.w	r4, [r0, #132]	; 0x84
  VariableShapeOscillator() { }
  ~VariableShapeOscillator() { }

  void Init() {
    master_phase_ = 0.0f;
    slave_phase_ = 0.0f;
    92f2:	str	r3, [r0, #20]
    next_sample_ = 0.0f;
    92f4:	str	r3, [r0, #24]
    previous_pw_ = 0.5f;
    high_ = false;
  
    master_frequency_ = 0.0f;
    92f6:	str	r3, [r0, #36]	; 0x24
    slave_frequency_ = 0.01f;
    pw_ = 0.5f;
    waveshape_ = 0.0f;
    92f8:	str	r3, [r0, #48]	; 0x30
 public:
  VariableShapeOscillator() { }
  ~VariableShapeOscillator() { }

  void Init() {
    master_phase_ = 0.0f;
    92fa:	str	r3, [r0, #52]	; 0x34
    slave_phase_ = 0.0f;
    92fc:	str	r3, [r0, #56]	; 0x38
    next_sample_ = 0.0f;
    92fe:	str	r3, [r0, #60]	; 0x3c
    previous_pw_ = 0.5f;
    high_ = false;
  
    master_frequency_ = 0.0f;
    9300:	str	r3, [r0, #72]	; 0x48
    slave_frequency_ = 0.01f;
    pw_ = 0.5f;
    waveshape_ = 0.0f;
    9302:	str	r3, [r0, #84]	; 0x54
 public:
  VariableShapeOscillator() { }
  ~VariableShapeOscillator() { }

  void Init() {
    master_phase_ = 0.0f;
    9304:	str	r3, [r0, #88]	; 0x58
    slave_phase_ = 0.0f;
    9306:	str	r3, [r0, #92]	; 0x5c
    next_sample_ = 0.0f;
    9308:	str	r3, [r0, #96]	; 0x60
    previous_pw_ = 0.5f;
    high_ = false;
  
    master_frequency_ = 0.0f;
    930a:	str	r3, [r0, #108]	; 0x6c
    slave_frequency_ = 0.01f;
    pw_ = 0.5f;
    waveshape_ = 0.0f;
    930c:	str	r3, [r0, #120]	; 0x78
 public:
  VariableSawOscillator() { }
  ~VariableSawOscillator() { }

  void Init() {
    phase_ = 0.0f;
    930e:	str	r3, [r0, #124]	; 0x7c
    next_sample_ = 0.0f;
    9310:	str.w	r3, [r0, #128]	; 0x80
  void Init() {
    master_phase_ = 0.0f;
    slave_phase_ = 0.0f;
    next_sample_ = 0.0f;
    previous_pw_ = 0.5f;
    high_ = false;
    9314:	strb.w	r2, [r0, #32]
    9318:	strb.w	r2, [r0, #68]	; 0x44
    931c:	strb.w	r2, [r0, #104]	; 0x68
    previous_pw_ = 0.5f;
    high_ = false;
    9320:	strb.w	r2, [r0, #136]	; 0x88
  
    master_frequency_ = 0.0f;
    slave_frequency_ = 0.01f;
    9324:	str	r5, [r0, #40]	; 0x28
    9326:	str	r5, [r0, #76]	; 0x4c
    9328:	str	r5, [r0, #112]	; 0x70
  
    frequency_ = 0.01f;
    932a:	str.w	r5, [r0, #140]	; 0x8c
    pw_ = 0.5f;
    932e:	str.w	r4, [r0, #144]	; 0x90
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    9332:	ldr	r4, [r1, #8]
    waveshape_ = 0.0f;
    9334:	str.w	r3, [r0, #148]	; 0x94
    9338:	cmp.w	r4, #512	; 0x200
  primary_.Init();
  auxiliary_.Init();
  sync_.Init();
  variable_saw_.Init();
  
  auxiliary_amount_ = 0.0f;
    933c:	str.w	r3, [r0, #152]	; 0x98
  xmod_amount_ = 0.0f;
    9340:	str.w	r3, [r0, #156]	; 0x9c
    9344:	bcc.n	9354 <plaits::VirtualAnalogEngine::Init(stmlib::BufferAllocator*)+0x80>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    9346:	ldr	r2, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    9348:	sub.w	r4, r4, #512	; 0x200
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    934c:	add.w	r3, r2, #512	; 0x200
      free_ -= size_bytes;
    9350:	str	r4, [r1, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    9352:	str	r3, [r1, #0]
  
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
    9354:	str.w	r2, [r0, #160]	; 0xa0
}
    9358:	pop	{r4, r5}
    935a:	bx	lr
    935c:	.word	0x3c23d70a

00009360 <plaits::VirtualAnalogEngine::Reset()>:

void VirtualAnalogEngine::Reset() {
    9360:	bx	lr
    9362:	nop

00009364 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const>:
inline float Squash(float x) {
  return x * x * (3.0f - 2.0f * x);
}

float VirtualAnalogEngine::ComputeDetuning(float detune) const {
  detune = 2.05f * detune - 1.025f;
    9364:	vldr	s13, [pc, #228]	; 944c <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xe8>
  CONSTRAIN(detune, -1.0f, 1.0f);
    9368:	vmov.f32	s14, #240	; 0xbf800000 -1.0
inline float Squash(float x) {
  return x * x * (3.0f - 2.0f * x);
}

float VirtualAnalogEngine::ComputeDetuning(float detune) const {
  detune = 2.05f * detune - 1.025f;
    936c:	vldr	s15, [pc, #224]	; 9450 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xec>
    9370:	vfma.f32	s15, s0, s13
  CONSTRAIN(detune, -1.0f, 1.0f);
    9374:	vcmpe.f32	s15, s14
    9378:	vmrs	APSR_nzcv, fpscr
    937c:	bmi.n	9392 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0x2e>
    937e:	vmov.f32	s14, #112	; 0x3f800000  1.0
    9382:	vcmpe.f32	s15, s14
    9386:	vmrs	APSR_nzcv, fpscr
    938a:	ble.n	9398 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0x34>
    938c:	vldr	s0, [pc, #196]	; 9454 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xf0>
  MAKE_INTEGRAL_FRACTIONAL(detune);
  
  float a = intervals[detune_integral];
  float b = intervals[detune_integral + 1];
  return (a + (b - a) * Squash(Squash(detune_fractional))) * sign;
}
    9390:	bx	lr
    9392:	vldr	s0, [pc, #196]	; 9458 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xf4>
    9396:	bx	lr

float VirtualAnalogEngine::ComputeDetuning(float detune) const {
  detune = 2.05f * detune - 1.025f;
  CONSTRAIN(detune, -1.0f, 1.0f);
  
  float sign = detune < 0.0f ? -1.0f : 1.0f;
    9398:	vcmpe.f32	s15, #0.0
    939c:	vldr	s14, [pc, #188]	; 945c <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xf8>
    93a0:	vmrs	APSR_nzcv, fpscr
    93a4:	bmi.n	93f6 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0x92>
    93a6:	vmul.f32	s15, s15, s14
    93aa:	ldr	r3, [pc, #180]	; (9460 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xfc>)
    93ac:	vmov.f32	s13, #8	; 0x40400000  3.0
    93b0:	vmov.f32	s11, #0	; 0x40000000  2.0
    93b4:	vcvt.s32.f32	s14, s15
    93b8:	vmov	r2, s14
    93bc:	vcvt.f32.s32	s14, s14
    93c0:	add.w	r1, r3, r2, lsl #2
    93c4:	vsub.f32	s15, s15, s14
    93c8:	vmov.f32	s14, s13
    93cc:	vldr	s0, [r1]
    93d0:	vldr	s12, [r1, #4]
    93d4:	vfms.f32	s14, s15, s11
    93d8:	vmul.f32	s15, s15, s15
    93dc:	vsub.f32	s12, s12, s0
    93e0:	vmul.f32	s15, s14, s15
    93e4:	vfms.f32	s13, s15, s11
    93e8:	vmul.f32	s15, s15, s15
    93ec:	vmul.f32	s15, s13, s15
    93f0:	vfma.f32	s0, s12, s15
    93f4:	bx	lr
    93f6:	vnmul.f32	s15, s15, s14
    93fa:	ldr	r3, [pc, #100]	; (9460 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const+0xfc>)
    93fc:	vmov.f32	s12, #8	; 0x40400000  3.0
    9400:	vmov.f32	s10, #0	; 0x40000000  2.0
    9404:	vcvt.s32.f32	s14, s15
    9408:	vcvt.f32.s32	s13, s14
    940c:	vmov	r2, s14
    9410:	add.w	r1, r3, r2, lsl #2
    9414:	vsub.f32	s15, s15, s13
    9418:	vmov.f32	s13, s12
    941c:	vldr	s14, [r1]
    9420:	vldr	s11, [r1, #4]
    9424:	vfms.f32	s13, s15, s10
    9428:	vmul.f32	s15, s15, s15
    942c:	vsub.f32	s11, s11, s14
    9430:	vmul.f32	s15, s13, s15
    9434:	vfms.f32	s12, s15, s10
    9438:	vmul.f32	s15, s15, s15
    943c:	vmul.f32	s15, s12, s15
    9440:	vfma.f32	s14, s11, s15
    9444:	vneg.f32	s0, s14
    9448:	bx	lr
    944a:	nop
    944c:	.word	0x40033333
    9450:	.word	0xbf833333
    9454:	.word	0x41c0147b
    9458:	.word	0xc1c0147b
    945c:	.word	0x407ffe5d
    9460:	.word	0x2001f738

00009464 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
void VirtualAnalogEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    9464:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // 1 = variable square controlled by TIMBRE.
  // 2 = variable saw controlled by MORPH.
  // OUT = 1 + 2.
  // AUX = dual variable waveshape controlled by MORPH, self sync by TIMBRE.
  
  const float sync_amount = parameters.timbre * parameters.timbre;
    9468:	vldr	s15, [r1, #8]
void VirtualAnalogEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    946c:	mov	r7, r1
  // 2 = variable saw controlled by MORPH.
  // OUT = 1 + 2.
  // AUX = dual variable waveshape controlled by MORPH, self sync by TIMBRE.
  
  const float sync_amount = parameters.timbre * parameters.timbre;
  const float auxiliary_detune = ComputeDetuning(parameters.harmonics);
    946e:	vldr	s0, [r1, #16]
void VirtualAnalogEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    9472:	mov	r5, r2
  // 1 = variable square controlled by TIMBRE.
  // 2 = variable saw controlled by MORPH.
  // OUT = 1 + 2.
  // AUX = dual variable waveshape controlled by MORPH, self sync by TIMBRE.
  
  const float sync_amount = parameters.timbre * parameters.timbre;
    9474:	vmul.f32	s9, s15, s15
void VirtualAnalogEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    9478:	mov	r4, r0
    947a:	vpush	{d8-d15}
    947e:	sub	sp, #36	; 0x24
    9480:	str	r3, [sp, #16]
  // 2 = variable saw controlled by MORPH.
  // OUT = 1 + 2.
  // AUX = dual variable waveshape controlled by MORPH, self sync by TIMBRE.
  
  const float sync_amount = parameters.timbre * parameters.timbre;
  const float auxiliary_detune = ComputeDetuning(parameters.harmonics);
    9482:	bl	9364 <plaits::VirtualAnalogEngine::ComputeDetuning(float) const>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    9486:	vmov.f32	s15, #34	; 0x41100000  9.0
  const float primary_f = NoteToFrequency(parameters.note);
    948a:	vldr	s14, [r7, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    948e:	vldr	s13, [pc, #308]	; 95c4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x160>
void VirtualAnalogEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    9492:	ldr.w	lr, [sp, #136]	; 0x88
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    9496:	vsub.f32	s15, s14, s15
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    949a:	vcmpe.f32	s15, s13
    949e:	vmrs	APSR_nzcv, fpscr
    94a2:	bmi.n	94ba <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x56>
    94a4:	vldr	s13, [pc, #288]	; 95c8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x164>
    94a8:	vcmpe.f32	s15, s13
    94ac:	vmrs	APSR_nzcv, fpscr
    94b0:	ble.w	a5ee <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x118a>
    94b4:	movs	r3, #0
    94b6:	movs	r2, #255	; 0xff
    94b8:	b.n	94be <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5a>
    94ba:	movs	r3, #0
    94bc:	mov	r2, r3

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    94be:	ldr.w	ip, [pc, #272]	; 95d0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x16c>
  // AUX = dual variable waveshape controlled by MORPH, self sync by TIMBRE.
  
  const float sync_amount = parameters.timbre * parameters.timbre;
  const float auxiliary_detune = ComputeDetuning(parameters.harmonics);
  const float primary_f = NoteToFrequency(parameters.note);
  const float auxiliary_f = NoteToFrequency(parameters.note + auxiliary_detune);
    94c2:	vadd.f32	s15, s0, s14
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    94c6:	ldr.w	r8, [pc, #268]	; 95d4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x170>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    94ca:	vmov.f32	s13, #34	; 0x41100000  9.0

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    94ce:	add.w	r2, ip, r2, lsl #2
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    94d2:	vldr	s11, [pc, #240]	; 95c4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x160>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    94d6:	add.w	r3, r8, r3, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    94da:	vldr	s10, [pc, #252]	; 95d8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x174>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    94de:	vsub.f32	s13, s15, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    94e2:	vldr	s12, [r2]
    94e6:	vldr	s8, [r3]

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    94ea:	vcmpe.f32	s13, s11
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    94ee:	vmul.f32	s12, s12, s8

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    94f2:	vmrs	APSR_nzcv, fpscr
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    94f6:	vmul.f32	s12, s12, s10
    94fa:	vstr	s12, [sp, #4]

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    94fe:	bmi.n	9516 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb2>
    9500:	vldr	s12, [pc, #196]	; 95c8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x164>
    9504:	vcmpe.f32	s13, s12
    9508:	vmrs	APSR_nzcv, fpscr
    950c:	ble.w	a5c6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1162>
    9510:	movs	r3, #0
    9512:	movs	r2, #255	; 0xff
    9514:	b.n	951a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb6>
    9516:	movs	r3, #0
    9518:	mov	r2, r3
  const float primary_sync_f = NoteToFrequency(
      parameters.note + sync_amount * 48.0f);
    951a:	vldr	s13, [pc, #176]	; 95cc <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x168>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    951e:	vmov.f32	s8, #34	; 0x41100000  9.0

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    9522:	add.w	r2, ip, r2, lsl #2
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    9526:	vldr	s11, [pc, #156]	; 95c4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x160>
    952a:	vmul.f32	s13, s9, s13
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    952e:	add.w	r3, r8, r3, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    9532:	vldr	s12, [r2]
    9536:	vldr	s9, [r3]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    953a:	vadd.f32	s14, s14, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    953e:	vldr	s10, [pc, #152]	; 95d8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x174>
    9542:	vmul.f32	s12, s12, s9
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    9546:	vsub.f32	s14, s14, s8
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    954a:	vmul.f32	s12, s12, s10

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    954e:	vcmpe.f32	s14, s11
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    9552:	vstr	s12, [sp, #8]

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    9556:	vmrs	APSR_nzcv, fpscr
    955a:	bmi.n	9572 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10e>
    955c:	vldr	s12, [pc, #104]	; 95c8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x164>
    9560:	vcmpe.f32	s14, s12
    9564:	vmrs	APSR_nzcv, fpscr
    9568:	ble.w	a59e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x113a>
    956c:	movs	r3, #0
    956e:	movs	r2, #255	; 0xff
    9570:	b.n	9576 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x112>
    9572:	movs	r3, #0
    9574:	mov	r2, r3
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    9576:	vadd.f32	s15, s15, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    957a:	add.w	r2, ip, r2, lsl #2
    957e:	vmov.f32	s12, #34	; 0x41100000  9.0
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    9582:	add.w	r3, r8, r3, lsl #2
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    9586:	vldr	s13, [r2]
    958a:	vldr	s14, [r3]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    958e:	vsub.f32	s15, s15, s12
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    9592:	vldr	s12, [pc, #68]	; 95d8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x174>
    9596:	vmul.f32	s14, s13, s14

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    959a:	vldr	s13, [pc, #40]	; 95c4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x160>
    959e:	vcmpe.f32	s15, s13
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    95a2:	vmul.f32	s14, s14, s12

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    95a6:	vmrs	APSR_nzcv, fpscr
    95aa:	bmi.n	95ec <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x188>
    95ac:	vldr	s13, [pc, #24]	; 95c8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x164>
    95b0:	vcmpe.f32	s15, s13
    95b4:	vmrs	APSR_nzcv, fpscr
    95b8:	ble.w	a576 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1112>
    95bc:	movs	r3, #0
    95be:	movs	r2, #255	; 0xff
    95c0:	b.n	95f0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x18c>
    95c2:	nop
    95c4:	.word	0xc3000000
    95c8:	.word	0x42fe0000
    95cc:	.word	0x42400000
    95d0:	.word	0x20000554
    95d4:	.word	0x20000958
    95d8:	.word	0x39962fc9
    95dc:	.word	0x3f28f5c3
    95e0:	.word	0x3fbae148
    95e4:	.word	0x3f7eb852
    95e8:	.word	0x00000000
    95ec:	movs	r3, #0
    95ee:	mov	r2, r3
  const float auxiliary_sync_f = NoteToFrequency(
      parameters.note + auxiliary_detune + sync_amount * 48.0f);

  float shape = parameters.morph * 1.5f;
    95f0:	vmov.f32	s30, #120	; 0x3fc00000  1.5
    95f4:	vldr	s15, [r7, #12]

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    95f8:	add.w	r2, ip, r2, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    95fc:	vldr	s12, [pc, #-40]	; 95d8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x174>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    9600:	add.w	r3, r8, r3, lsl #2
    9604:	vmul.f32	s30, s15, s30
    9608:	vldr	s13, [r2]
    960c:	vldr	s11, [r3]
  CONSTRAIN(shape, 0.0f, 1.0f);
    9610:	vcmpe.f32	s30, #0.0
    9614:	vmul.f32	s13, s13, s11
    9618:	vmrs	APSR_nzcv, fpscr
    961c:	vmul.f32	s13, s13, s12
    9620:	vstr	s13, [sp, #12]
    9624:	bmi.w	a682 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x121e>
    9628:	vmov.f32	s13, #112	; 0x3f800000  1.0
    962c:	vcmp.f32	s30, s13
    9630:	vmrs	APSR_nzcv, fpscr
    9634:	it	gt
    9636:	vmovgt.f32	s30, s13

  float pw = 0.5f + (parameters.morph - 0.66f) * 1.46f;
    963a:	vmov.f32	s13, #96	; 0x3f000000  0.5
    963e:	vldr	s11, [pc, #-100]	; 95dc <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x178>
    9642:	vldr	s12, [pc, #-100]	; 95e0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x17c>
    9646:	vsub.f32	s15, s15, s11
    964a:	vmov.f32	s11, s13
    964e:	vfma.f32	s11, s15, s12
  CONSTRAIN(pw, 0.5f, 0.995f);
    9652:	vcmpe.f32	s11, s13
    9656:	vmrs	APSR_nzcv, fpscr
    965a:	bmi.w	9e84 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa20>
    965e:	vldr	s15, [pc, #-124]	; 95e4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x180>
    9662:	vcmp.f32	s11, s15
    9666:	vmrs	APSR_nzcv, fpscr
    966a:	it	le
    966c:	vmovle.f32	s15, s11
    9670:	vstr	s15, [sp, #20]
      float frequency,
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
    9674:	vmov.f32	s15, #80	; 0x3e800000  0.250
    9678:	vldr	s13, [sp, #4]
    967c:	vcmpe.f32	s13, s15
    9680:	vmrs	APSR_nzcv, fpscr
      master_frequency = kMaxFrequency;
    }
    if (frequency >= kMaxFrequency) {
    9684:	vcmpe.f32	s14, s15
      float frequency,
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
    9688:	it	ge
    968a:	vmovge.f32	s13, s15
      master_frequency = kMaxFrequency;
    }
    if (frequency >= kMaxFrequency) {
    968e:	vmrs	APSR_nzcv, fpscr
    9692:	bge.w	9e7a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa16>
      frequency = kMaxFrequency;
    }
    
    if (frequency >= 0.25f) {
    9696:	bge.w	a6b6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1252>
      pw = 0.5f;
    } else {
      CONSTRAIN(pw, frequency * 2.0f, 1.0f - 2.0f * frequency);
    969a:	vadd.f32	s15, s14, s14
    969e:	vldr	s11, [sp, #20]
    96a2:	vcmpe.f32	s11, s15
    96a6:	vmrs	APSR_nzcv, fpscr
    96aa:	bpl.w	a55c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10f8>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    96ae:	vmov	s12, lr
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    96b2:	vldr	s23, [r4, #36]	; 0x24
    96b6:	vldr	s1, [r4, #40]	; 0x28
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    96ba:	add.w	r0, lr, #4294967295
    96be:	vldr	s3, [r4, #44]	; 0x2c
    increment_ = (new_value - *state) / static_cast<float>(size);
    96c2:	vcvt.f32.u32	s31, s12
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    96c6:	vldr	s22, [r4, #48]	; 0x30
    increment_ = (new_value - *state) / static_cast<float>(size);
    96ca:	vsub.f32	s13, s13, s23
    96ce:	vsub.f32	s14, s14, s1
    stmlib::ParameterInterpolator fm(&slave_frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    96d2:	vldr	s11, [r4, #24]
    96d6:	vsub.f32	s15, s15, s3
    96da:	vsub.f32	s12, s30, s22
    96de:	vdiv.f32	s26, s13, s31
    96e2:	vdiv.f32	s27, s14, s31
    96e6:	vdiv.f32	s28, s15, s31
    96ea:	vdiv.f32	s29, s12, s31
    
    while (size--) {
    96ee:	cmp.w	lr, #0
    96f2:	beq.w	9964 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x500>
    96f6:	mov	sl, r5
    96f8:	mov	r6, r0
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    96fa:	vldr	s25, [pc, #-276]	; 95e8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x184>
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    96fe:	mov	fp, r0
    
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
    9700:	vmov.f32	s0, #96	; 0x3f000000  0.5
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9704:	vmov.f32	s24, #0	; 0x40000000  2.0
    9708:	vmov.f32	s6, #112	; 0x3f800000  1.0
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    970c:	vmov.f32	s21, #224	; 0xbf000000 -0.5
  }

  inline float Next() {
    value_ += increment_;
    9710:	vadd.f32	s22, s22, s29
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
    9714:	vldr	s15, [r4, #16]
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9718:	vmov.f32	s7, s6
    971c:	vadd.f32	s23, s23, s26
    
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
    9720:	vsub.f32	s10, s22, s0
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9724:	vfms.f32	s7, s22, s24
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
    9728:	vadd.f32	s15, s23, s15
    972c:	vcmpe.f32	s10, #0.0
    9730:	vadd.f32	s3, s3, s28
    9734:	vadd.f32	s1, s1, s27
    9738:	vstr	s15, [r4, #16]
    973c:	vmrs	APSR_nzcv, fpscr
	return __b;
    9740:	vcmp.f32	s7, #0.0
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    9744:	vsub.f32	s14, s6, s3
    9748:	ite	pl
    974a:	vaddpl.f32	s10, s10, s10
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    974e:	vldrmi	s10, [pc, #-360]	; 95e8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x184>
	return __b;
    9752:	vmrs	APSR_nzcv, fpscr

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9756:	vcmpe.f32	s15, s6
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
    975a:	vdiv.f32	s5, s6, s3
    975e:	it	mi
    9760:	vmovmi.f32	s7, s25
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9764:	vmrs	APSR_nzcv, fpscr
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    9768:	vdiv.f32	s4, s6, s14

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    976c:	blt.w	9e4e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9ea>
          master_phase_ -= 1.0f;
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
    9770:	vldr	s13, [r4, #20]
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
          master_phase_ -= 1.0f;
    9774:	vsub.f32	s15, s15, s6
          reset_time = master_phase_ / master_frequency;
    9778:	vdiv.f32	s2, s15, s23
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
          master_phase_ -= 1.0f;
    977c:	vstr	s15, [r4, #16]
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
              (1.0f - reset_time) * slave_frequency;
    9780:	vmov.f32	s15, s13
    9784:	vsub.f32	s9, s6, s2
    9788:	vfma.f32	s15, s1, s9
          reset = true;
          if (slave_phase_at_reset >= 1.0f) {
    978c:	vcmpe.f32	s15, s6
    9790:	vmrs	APSR_nzcv, fpscr
    9794:	blt.w	9e72 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa0e>
            slave_phase_at_reset -= 1.0f;
    9798:	vsub.f32	s15, s15, s6
            transition_during_reset = true;
    979c:	movs	r2, #1
          }
          if (!high_ && slave_phase_at_reset >= pw) {
    979e:	ldrb.w	r3, [r4, #32]
    97a2:	cbnz	r3, 97b0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x34c>
            transition_during_reset = true;
    97a4:	vcmp.f32	s3, s15
    97a8:	vmrs	APSR_nzcv, fpscr
    97ac:	it	ls
    97ae:	movls	r2, #1
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    97b0:	vcmpe.f32	s3, s15
    97b4:	vmrs	APSR_nzcv, fpscr
    97b8:	ble.w	9e1a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9b6>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    97bc:	vmul.f32	s8, s5, s15
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    97c0:	vldr	s12, [pc, #-476]	; 95e8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x184>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    97c4:	vsub.f32	s12, s12, s15
          master_phase_ -= 1.0f;
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
              (1.0f - reset_time) * slave_frequency;
          reset = true;
    97c8:	movs	r0, #1
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    97ca:	vmul.f32	s14, s2, s0
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    97ce:	vfma.f32	s15, s12, s10
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    97d2:	vmul.f32	s12, s9, s21
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    97d6:	vmul.f32	s14, s14, s2
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    97da:	vmul.f32	s12, s12, s9
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    saw += (triangle - saw) * triangle_amount;
    97de:	vsub.f32	s9, s8, s15
    97e2:	vfma.f32	s15, s7, s9
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    97e6:	vneg.f32	s15, s15
    97ea:	vfma.f32	s11, s15, s14
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    97ee:	vmov.f32	s14, s25
    97f2:	vfma.f32	s14, s15, s12
    97f6:	vmov.f32	s12, s14
        }
      }
      
      slave_phase_ += slave_frequency;
    97fa:	vadd.f32	s15, s1, s13
      while (transition_during_reset || !reset) {
    97fe:	cmp	r0, r2
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = true;
    9800:	mov.w	r3, #1
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9804:	vmov.f32	s8, #72	; 0x3e400000  0.1875000

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
    9808:	mov.w	r9, #0
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    980c:	vmov.f32	s9, #120	; 0x3fc00000  1.5
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
    9810:	vstr	s15, [r4, #20]
      while (transition_during_reset || !reset) {
    9814:	bhi.n	9914 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4b0>
        if (!high_) {
    9816:	ldrb.w	r1, [r4, #32]
          if (slave_phase_ < pw) {
    981a:	vldr	s13, [r4, #20]
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
        if (!high_) {
    981e:	cbnz	r1, 9898 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x434>
          if (slave_phase_ < pw) {
    9820:	vcmpe.f32	s3, s13
    9824:	vmrs	APSR_nzcv, fpscr
    9828:	bgt.w	9e46 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9e2>
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    982c:	vldr	s15, [r4, #28]
    9830:	vsub.f32	s16, s13, s3
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    9834:	vadd.f32	s14, s5, s4
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = true;
    9838:	strb.w	r3, [r4, #32]
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    983c:	vsub.f32	s15, s15, s3
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    9840:	vmul.f32	s14, s14, s1
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    9844:	vadd.f32	s15, s15, s1
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9848:	vnmul.f32	s14, s14, s7
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    984c:	vdiv.f32	s17, s16, s15
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    9850:	vsub.f32	s20, s6, s17
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    9854:	vmul.f32	s15, s17, s0
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    9858:	vmul.f32	s16, s20, s0
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
    985c:	vmul.f32	s17, s17, s15
  const float t2 = t1 * t1;
    9860:	vmul.f32	s18, s15, s15
    9864:	vmul.f32	s19, s16, s16
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9868:	vsub.f32	s15, s8, s15
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    986c:	vsub.f32	s16, s8, s16
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
    9870:	vfma.f32	s11, s17, s10
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9874:	vfma.f32	s15, s18, s9
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9878:	vfma.f32	s16, s19, s9
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
    987c:	vmul.f32	s17, s20, s21
    9880:	vmul.f32	s20, s17, s20
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9884:	vfms.f32	s15, s18, s18
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9888:	vfms.f32	s16, s19, s19
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
    988c:	vfma.f32	s12, s20, s10
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9890:	vfma.f32	s11, s14, s16
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9894:	vfma.f32	s12, s14, s15
          high_ = true;
        }
      
        if (high_) {
          if (slave_phase_ < 1.0f) {
    9898:	vcmpe.f32	s13, s6
    989c:	vmrs	APSR_nzcv, fpscr
    98a0:	bmi.w	9e46 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9e2>
            break;
          }
          slave_phase_ -= 1.0f;
    98a4:	vsub.f32	s13, s13, s6
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
    98a8:	cmp	r0, r2
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    98aa:	vsub.f32	s16, s6, s7
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
    98ae:	strb.w	r9, [r4, #32]
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    98b2:	vadd.f32	s15, s5, s4
        if (high_) {
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
    98b6:	vdiv.f32	s17, s13, s1
      
        if (high_) {
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
    98ba:	vstr	s13, [r4, #20]
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    98be:	vneg.f32	s16, s16
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    98c2:	vmul.f32	s15, s15, s1
          triangle_step *= triangle_amount;
    98c6:	vmul.f32	s15, s7, s15
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    98ca:	vsub.f32	s20, s6, s17
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    98ce:	vmul.f32	s14, s17, s0
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    98d2:	vmul.f32	s13, s20, s0

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    98d6:	vmul.f32	s17, s17, s14
  const float t2 = t1 * t1;
    98da:	vmul.f32	s18, s14, s14
    98de:	vmul.f32	s19, s13, s13
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    98e2:	vsub.f32	s14, s8, s14
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    98e6:	vsub.f32	s13, s8, s13
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    98ea:	vfma.f32	s11, s16, s17
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    98ee:	vfma.f32	s14, s18, s9
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    98f2:	vfma.f32	s13, s19, s9
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
    98f6:	vmul.f32	s17, s20, s21
    98fa:	vmul.f32	s20, s17, s20
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    98fe:	vfms.f32	s14, s18, s18
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9902:	vfms.f32	s13, s19, s19
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
    9906:	vfma.f32	s12, s16, s20
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    990a:	vfma.f32	s11, s15, s13
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    990e:	vfma.f32	s12, s15, s14
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
    9912:	bls.n	9816 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b2>
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
    9914:	vmul.f32	s13, s1, s2
        high_ = false;
    9918:	movs	r3, #0
    991a:	strb.w	r3, [r4, #32]
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
    991e:	vstr	s13, [r4, #20]
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9922:	vcmpe.f32	s3, s13
    9926:	vmrs	APSR_nzcv, fpscr
    992a:	ble.w	9e08 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a4>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    992e:	vmul.f32	s5, s5, s13
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9932:	vldr	s14, [pc, #-844]	; 95e8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x184>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    9936:	vsub.f32	s14, s14, s13
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    993a:	subs	r6, #1
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    993c:	vmov.f32	s15, #240	; 0xbf800000 -1.0
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;
    9940:	vstr	s3, [r4, #28]
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    9944:	adds	r3, r6, #1
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    9946:	vfma.f32	s13, s14, s10
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    994a:	vfma.f32	s15, s11, s24
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    saw += (triangle - saw) * triangle_amount;
    994e:	vsub.f32	s5, s5, s13
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    9952:	vstmia	sl!, {s15}
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
        high_ = false;
      }
    
      next_sample += ComputeNaiveSample(
    9956:	vfma.f32	s13, s7, s5
    995a:	vadd.f32	s11, s13, s12
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    995e:	bne.w	9710 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
    9962:	mov	r0, fp
      float frequency,
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
    9964:	vmov.f32	s15, #80	; 0x3e800000  0.250
    9968:	vldr	s14, [sp, #8]
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    }
    
    next_sample_ = next_sample;
    996c:	vstr	s11, [r4, #24]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    9970:	vstr	s22, [r4, #48]	; 0x30
      float frequency,
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
    9974:	vcmpe.f32	s14, s15
    9978:	vstr	s3, [r4, #44]	; 0x2c
    997c:	vstr	s1, [r4, #40]	; 0x28
    9980:	vstr	s23, [r4, #36]	; 0x24
    9984:	vmrs	APSR_nzcv, fpscr
    9988:	ite	lt
    998a:	vmovlt.f32	s13, s14
    998e:	vmovge.f32	s13, s15
      master_frequency = kMaxFrequency;
    }
    if (frequency >= kMaxFrequency) {
    9992:	vldr	s14, [sp, #12]
    9996:	vcmpe.f32	s14, s15
    999a:	vmrs	APSR_nzcv, fpscr
    999e:	bge.w	9e8c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa28>
      frequency = kMaxFrequency;
    }
    
    if (frequency >= 0.25f) {
    99a2:	bge.w	a6ca <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1266>
      pw = 0.5f;
    } else {
      CONSTRAIN(pw, frequency * 2.0f, 1.0f - 2.0f * frequency);
    99a6:	vadd.f32	s14, s14, s14
    99aa:	vldr	s12, [sp, #20]
    99ae:	vcmpe.f32	s12, s14
    99b2:	vmrs	APSR_nzcv, fpscr
    99b6:	bpl.w	a542 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10de>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    99ba:	vldr	s22, [r4, #72]	; 0x48
    99be:	vldr	s2, [r4, #76]	; 0x4c
    99c2:	vldr	s4, [r4, #80]	; 0x50
    increment_ = (new_value - *state) / static_cast<float>(size);
    99c6:	vsub.f32	s13, s13, s22
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    99ca:	vldr	s21, [r4, #84]	; 0x54
    increment_ = (new_value - *state) / static_cast<float>(size);
    99ce:	vldr	s15, [sp, #12]
    99d2:	vsub.f32	s14, s14, s4
    99d6:	vsub.f32	s30, s30, s21
    stmlib::ParameterInterpolator fm(&slave_frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    99da:	vldr	s29, [r4, #60]	; 0x3c
    99de:	vsub.f32	s15, s15, s2
    99e2:	vdiv.f32	s25, s13, s31
    99e6:	vdiv.f32	s26, s15, s31
    99ea:	vdiv.f32	s27, s14, s31
    99ee:	vdiv.f32	s28, s30, s31
    
    while (size--) {
    99f2:	cmp.w	lr, #0
    99f6:	beq.w	9ca2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x83e>
    99fa:	ldr.w	sl, [sp, #16]
    99fe:	mov	r1, r0
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    9a00:	vldr	s24, [pc, #976]	; 9dd4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    9a04:	mov	fp, r0
    
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
    9a06:	vmov.f32	s1, #96	; 0x3f000000  0.5
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9a0a:	vmov.f32	s23, #0	; 0x40000000  2.0
    9a0e:	vmov.f32	s7, #112	; 0x3f800000  1.0
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    9a12:	vmov.f32	s20, #224	; 0xbf000000 -0.5
  }

  inline float Next() {
    value_ += increment_;
    9a16:	vadd.f32	s21, s21, s28
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
    9a1a:	vldr	s15, [r4, #52]	; 0x34
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9a1e:	vmov.f32	s8, s7
    9a22:	vadd.f32	s22, s22, s25
    
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
    9a26:	vsub.f32	s11, s21, s1
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9a2a:	vfms.f32	s8, s21, s23
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
    9a2e:	vadd.f32	s15, s22, s15
    9a32:	vcmpe.f32	s11, #0.0
    9a36:	vadd.f32	s4, s4, s27
    9a3a:	vadd.f32	s2, s2, s26
    9a3e:	vstr	s15, [r4, #52]	; 0x34
    9a42:	vmrs	APSR_nzcv, fpscr
	return __b;
    9a46:	vcmp.f32	s8, #0.0
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    9a4a:	vsub.f32	s14, s7, s4
    9a4e:	ite	pl
    9a50:	vaddpl.f32	s11, s11, s11
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    9a54:	vldrmi	s11, [pc, #892]	; 9dd4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
	return __b;
    9a58:	vmrs	APSR_nzcv, fpscr

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9a5c:	vcmpe.f32	s15, s7
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
    9a60:	vdiv.f32	s6, s7, s4
    9a64:	it	mi
    9a66:	vmovmi.f32	s8, s24
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9a6a:	vmrs	APSR_nzcv, fpscr
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    9a6e:	vdiv.f32	s5, s7, s14

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9a72:	blt.w	9e60 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9fc>
          master_phase_ -= 1.0f;
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
    9a76:	vldr	s13, [r4, #56]	; 0x38
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
          master_phase_ -= 1.0f;
    9a7a:	vsub.f32	s15, s15, s7
          reset_time = master_phase_ / master_frequency;
    9a7e:	vdiv.f32	s3, s15, s22
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
          master_phase_ -= 1.0f;
    9a82:	vstr	s15, [r4, #52]	; 0x34
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
              (1.0f - reset_time) * slave_frequency;
    9a86:	vmov.f32	s15, s13
    9a8a:	vsub.f32	s10, s7, s3
    9a8e:	vfma.f32	s15, s2, s10
          reset = true;
          if (slave_phase_at_reset >= 1.0f) {
    9a92:	vcmpe.f32	s15, s7
    9a96:	vmrs	APSR_nzcv, fpscr
    9a9a:	blt.w	9e76 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa12>
            slave_phase_at_reset -= 1.0f;
    9a9e:	vsub.f32	s15, s15, s7
            transition_during_reset = true;
    9aa2:	movs	r2, #1
          }
          if (!high_ && slave_phase_at_reset >= pw) {
    9aa4:	ldrb.w	r3, [r4, #68]	; 0x44
    9aa8:	cbnz	r3, 9ab6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x652>
            transition_during_reset = true;
    9aaa:	vcmp.f32	s4, s15
    9aae:	vmrs	APSR_nzcv, fpscr
    9ab2:	it	ls
    9ab4:	movls	r2, #1
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9ab6:	vcmpe.f32	s4, s15
    9aba:	vmrs	APSR_nzcv, fpscr
    9abe:	ble.w	9e2c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9c8>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9ac2:	vmul.f32	s9, s6, s15
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9ac6:	vldr	s0, [pc, #780]	; 9dd4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    9aca:	vsub.f32	s0, s0, s15
          master_phase_ -= 1.0f;
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
              (1.0f - reset_time) * slave_frequency;
          reset = true;
    9ace:	movs	r0, #1
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    9ad0:	vmul.f32	s12, s10, s20
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    9ad4:	vmul.f32	s14, s3, s1
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    9ad8:	vfma.f32	s15, s0, s11
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    9adc:	vmul.f32	s12, s12, s10
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    9ae0:	vmul.f32	s14, s14, s3
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    saw += (triangle - saw) * triangle_amount;
    9ae4:	vsub.f32	s10, s9, s15
    9ae8:	vfma.f32	s15, s8, s10
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    9aec:	vneg.f32	s15, s15
    9af0:	vfma.f32	s29, s15, s14
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    9af4:	vmov.f32	s14, s24
    9af8:	vfma.f32	s14, s15, s12
    9afc:	vmov.f32	s12, s14
        }
      }
      
      slave_phase_ += slave_frequency;
    9b00:	vadd.f32	s15, s2, s13
      while (transition_during_reset || !reset) {
    9b04:	cmp	r0, r2
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = true;
    9b06:	mov.w	r3, #1
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b0a:	vmov.f32	s9, #72	; 0x3e400000  0.1875000

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
    9b0e:	mov.w	r9, #0
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b12:	vmov.f32	s10, #120	; 0x3fc00000  1.5
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
    9b16:	vstr	s15, [r4, #56]	; 0x38
      while (transition_during_reset || !reset) {
    9b1a:	bhi.n	9c1a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b6>
        if (!high_) {
    9b1c:	ldrb.w	r6, [r4, #68]	; 0x44
          if (slave_phase_ < pw) {
    9b20:	vldr	s13, [r4, #56]	; 0x38
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
        if (!high_) {
    9b24:	cbnz	r6, 9b9e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x73a>
          if (slave_phase_ < pw) {
    9b26:	vcmpe.f32	s4, s13
    9b2a:	vmrs	APSR_nzcv, fpscr
    9b2e:	bgt.w	9e3e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9da>
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    9b32:	vldr	s14, [r4, #64]	; 0x40
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    9b36:	vadd.f32	s15, s6, s5
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    9b3a:	vsub.f32	s16, s13, s4
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = true;
    9b3e:	strb.w	r3, [r4, #68]	; 0x44
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    9b42:	vsub.f32	s14, s14, s4
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    9b46:	vmul.f32	s15, s15, s2
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    9b4a:	vadd.f32	s14, s14, s2
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b4e:	vnmul.f32	s0, s15, s8
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    9b52:	vdiv.f32	s15, s16, s14
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    9b56:	vsub.f32	s18, s7, s15
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    9b5a:	vmul.f32	s14, s15, s1
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    9b5e:	vmul.f32	s19, s18, s1
  const float t2 = t1 * t1;
    9b62:	vmul.f32	s16, s14, s14
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
    9b66:	vmul.f32	s15, s15, s14
    9b6a:	vmul.f32	s17, s19, s19
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9b6e:	vsub.f32	s14, s9, s14
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b72:	vsub.f32	s19, s9, s19
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
    9b76:	vfma.f32	s29, s15, s11
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9b7a:	vfma.f32	s14, s16, s10
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b7e:	vfma.f32	s19, s17, s10
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
    9b82:	vmul.f32	s15, s18, s20
    9b86:	vmul.f32	s18, s15, s18
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9b8a:	vfms.f32	s14, s16, s16
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b8e:	vfms.f32	s19, s17, s17
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
    9b92:	vfma.f32	s12, s18, s11
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9b96:	vfma.f32	s29, s0, s19
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    9b9a:	vfma.f32	s12, s0, s14
          high_ = true;
        }
      
        if (high_) {
          if (slave_phase_ < 1.0f) {
    9b9e:	vcmpe.f32	s13, s7
    9ba2:	vmrs	APSR_nzcv, fpscr
    9ba6:	bmi.w	9e3e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9da>
            break;
          }
          slave_phase_ -= 1.0f;
    9baa:	vsub.f32	s13, s13, s7
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
    9bae:	cmp	r0, r2
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    9bb0:	vadd.f32	s15, s6, s5

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
    9bb4:	strb.w	r9, [r4, #68]	; 0x44
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    9bb8:	vsub.f32	s0, s7, s8
        if (high_) {
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
    9bbc:	vdiv.f32	s16, s13, s2
      
        if (high_) {
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
    9bc0:	vstr	s13, [r4, #56]	; 0x38
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    9bc4:	vmul.f32	s15, s15, s2
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    9bc8:	vneg.f32	s0, s0
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
    9bcc:	vmul.f32	s13, s8, s15
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    9bd0:	vsub.f32	s18, s7, s16
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    9bd4:	vmul.f32	s14, s16, s1
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    9bd8:	vmul.f32	s15, s18, s1

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    9bdc:	vmul.f32	s16, s16, s14
  const float t2 = t1 * t1;
    9be0:	vmul.f32	s19, s14, s14
    9be4:	vmul.f32	s17, s15, s15
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    9be8:	vsub.f32	s14, s9, s14
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9bec:	vsub.f32	s15, s9, s15
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    9bf0:	vfma.f32	s29, s0, s16
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    9bf4:	vfma.f32	s14, s19, s10
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9bf8:	vfma.f32	s15, s17, s10
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
    9bfc:	vmul.f32	s16, s18, s20
    9c00:	vmul.f32	s18, s16, s18
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    9c04:	vfms.f32	s14, s19, s19
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9c08:	vfms.f32	s15, s17, s17
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
    9c0c:	vfma.f32	s12, s0, s18
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    9c10:	vfma.f32	s29, s13, s15
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    9c14:	vfma.f32	s12, s13, s14
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
    9c18:	bls.n	9b1c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6b8>
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
    9c1a:	vmul.f32	s13, s2, s3
        high_ = false;
    9c1e:	movs	r3, #0
    9c20:	strb.w	r3, [r4, #68]	; 0x44
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
    9c24:	vstr	s13, [r4, #56]	; 0x38
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9c28:	vcmpe.f32	s4, s13
    9c2c:	vmrs	APSR_nzcv, fpscr
    9c30:	ble.w	9dc2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x95e>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9c34:	vmul.f32	s6, s6, s13
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9c38:	vldr	s14, [pc, #408]	; 9dd4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    9c3c:	vsub.f32	s14, s14, s13
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    9c40:	subs	r1, #1
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    9c42:	vmov.f32	s15, #240	; 0xbf800000 -1.0
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;
    9c46:	vstr	s4, [r4, #64]	; 0x40
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    9c4a:	adds	r0, r1, #1
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    9c4c:	vfma.f32	s13, s14, s11
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    9c50:	vfma.f32	s15, s29, s23
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    saw += (triangle - saw) * triangle_amount;
    9c54:	vsub.f32	s6, s6, s13
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    9c58:	vstmia	sl!, {s15}
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
        high_ = false;
      }
    
      next_sample += ComputeNaiveSample(
    9c5c:	vfma.f32	s13, s8, s6
    9c60:	vadd.f32	s29, s13, s12
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    9c64:	bne.w	9a16 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5b2>
    9c68:	ldr	r3, [sp, #16]
  
  // Render monster sync to AUX.
  primary_.Render<true>(primary_f, primary_sync_f, pw, shape, out, size);
  auxiliary_.Render<true>(auxiliary_f, auxiliary_sync_f, pw, shape, aux, size);
  for (size_t i = 0; i < size; ++i) {
    aux[i] = (aux[i] - out[i]) * 0.5f;
    9c6a:	vmov.f32	s13, #96	; 0x3f000000  0.5
    9c6e:	mov	r0, fp
    9c70:	mov	r2, r5
    9c72:	add.w	r1, r3, lr, lsl #2
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    }
    
    next_sample_ = next_sample;
    9c76:	vstr	s29, [r4, #60]	; 0x3c
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    9c7a:	vstr	s21, [r4, #84]	; 0x54
    9c7e:	vstr	s4, [r4, #80]	; 0x50
    9c82:	vstr	s2, [r4, #76]	; 0x4c
    9c86:	vstr	s22, [r4, #72]	; 0x48
    9c8a:	vldmia	r2!, {s14}
    9c8e:	vldr	s15, [r3]
    9c92:	vsub.f32	s15, s15, s14
    9c96:	vmul.f32	s15, s15, s13
    9c9a:	vstmia	r3!, {s15}
  CONSTRAIN(pw, 0.5f, 0.995f);
  
  // Render monster sync to AUX.
  primary_.Render<true>(primary_f, primary_sync_f, pw, shape, out, size);
  auxiliary_.Render<true>(auxiliary_f, auxiliary_sync_f, pw, shape, aux, size);
  for (size_t i = 0; i < size; ++i) {
    9c9e:	cmp	r3, r1
    9ca0:	bne.n	9c8a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x826>
    aux[i] = (aux[i] - out[i]) * 0.5f;
  }
  
  // Render double varishape to OUT.
  float square_pw = 1.3f * parameters.timbre - 0.15f;
    9ca2:	vldr	s14, [r7, #8]
    9ca6:	vldr	s13, [pc, #304]	; 9dd8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x974>
    9caa:	vldr	s12, [pc, #304]	; 9ddc <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x978>
  CONSTRAIN(square_pw, 0.005f, 0.5f);
    9cae:	vldr	s15, [pc, #304]	; 9de0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x97c>
  for (size_t i = 0; i < size; ++i) {
    aux[i] = (aux[i] - out[i]) * 0.5f;
  }
  
  // Render double varishape to OUT.
  float square_pw = 1.3f * parameters.timbre - 0.15f;
    9cb2:	vfma.f32	s12, s14, s13
  CONSTRAIN(square_pw, 0.005f, 0.5f);
    9cb6:	vcmpe.f32	s12, s15
    9cba:	vmrs	APSR_nzcv, fpscr
    9cbe:	bpl.w	a514 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10b0>
    9cc2:	vmov.f32	s12, s15
  
  const float square_sync_ratio = parameters.timbre < 0.5f
      ? 0.0f
      : (parameters.timbre - 0.5f) * (parameters.timbre - 0.5f) * 4.0f * 48.0f;
    9cc6:	vmov.f32	s15, #96	; 0x3f000000  0.5
    9cca:	vcmpe.f32	s14, s15
    9cce:	vmrs	APSR_nzcv, fpscr
    9cd2:	bmi.w	9edc <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
    9cd6:	vsub.f32	s15, s14, s15
    9cda:	vldr	s13, [pc, #264]	; 9de4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x980>
    9cde:	vmov.f32	s11, #16	; 0x40800000  4.0
    9ce2:	vmul.f32	s15, s15, s15
    9ce6:	vmul.f32	s15, s15, s11
    9cea:	vmul.f32	s13, s15, s13
  
  const float square_gain = min(parameters.timbre * 8.0f, 1.0f);
    9cee:	vmov.f32	s11, #32	; 0x41000000  8.0
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    9cf2:	vmov.f32	s15, #112	; 0x3f800000  1.0
    9cf6:	vmul.f32	s14, s14, s11
    9cfa:	vcmpe.f32	s14, s15
    9cfe:	vmrs	APSR_nzcv, fpscr
    9d02:	ble.w	a692 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x122e>
	return __b;
    9d06:	vstr	s15, [sp, #16]
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    9d0a:	vldr	s15, [pc, #220]	; 9de8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x984>
    9d0e:	vstr	s15, [sp, #20]
  
  float saw_pw = parameters.morph < 0.5f
      ? parameters.morph + 0.5f
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
    9d12:	vmov.f32	s15, #96	; 0x3f000000  0.5
      ? 0.0f
      : (parameters.timbre - 0.5f) * (parameters.timbre - 0.5f) * 4.0f * 48.0f;
  
  const float square_gain = min(parameters.timbre * 8.0f, 1.0f);
  
  float saw_pw = parameters.morph < 0.5f
    9d16:	vldr	s14, [r7, #12]
      ? parameters.morph + 0.5f
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
    9d1a:	vcmpe.f32	s14, s15
    9d1e:	vmrs	APSR_nzcv, fpscr
    9d22:	bpl.w	a52a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10c6>
    9d26:	vadd.f32	s15, s14, s15
  saw_pw *= 1.1f;
    9d2a:	vldr	s10, [pc, #192]	; 9dec <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x988>
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    9d2e:	vldr	s11, [pc, #176]	; 9de0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x97c>
  const float square_gain = min(parameters.timbre * 8.0f, 1.0f);
  
  float saw_pw = parameters.morph < 0.5f
      ? parameters.morph + 0.5f
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
  saw_pw *= 1.1f;
    9d32:	vmul.f32	s15, s15, s10
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    9d36:	vcmpe.f32	s15, s11
  const float square_gain = min(parameters.timbre * 8.0f, 1.0f);
  
  float saw_pw = parameters.morph < 0.5f
      ? parameters.morph + 0.5f
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
  saw_pw *= 1.1f;
    9d3a:	vmov.f32	s10, s15
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    9d3e:	vmrs	APSR_nzcv, fpscr
    9d42:	bmi.w	9ed6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa72>
    9d46:	vmov.f32	s15, #112	; 0x3f800000  1.0
    9d4a:	vcmp.f32	s10, s15
    9d4e:	vmrs	APSR_nzcv, fpscr
    9d52:	it	le
    9d54:	vmovle.f32	s15, s10
    9d58:	vstr	s15, [sp, #28]
    
  float saw_shape = 10.0f - 21.0f * parameters.morph;
    9d5c:	vmov.f32	s15, #53	; 0x41a80000  21.0
    9d60:	vmov.f32	s30, #36	; 0x41200000  10.0
    9d64:	vfms.f32	s30, s14, s15
  CONSTRAIN(saw_shape, 0.0f, 1.0f);
    9d68:	vcmpe.f32	s30, #0.0
    9d6c:	vmrs	APSR_nzcv, fpscr
    9d70:	bmi.w	a68a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1226>
    9d74:	vmov.f32	s15, #112	; 0x3f800000  1.0
    9d78:	vcmp.f32	s30, s15
    9d7c:	vmrs	APSR_nzcv, fpscr
    9d80:	it	gt
    9d82:	vmovgt.f32	s30, s15
  
  float saw_gain = 8.0f * (1.0f - parameters.morph);
    9d86:	vmov.f32	s15, #112	; 0x3f800000  1.0
  CONSTRAIN(saw_gain, 0.02f, 1.0f);
    9d8a:	vldr	s11, [pc, #100]	; 9df0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x98c>
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    
  float saw_shape = 10.0f - 21.0f * parameters.morph;
  CONSTRAIN(saw_shape, 0.0f, 1.0f);
  
  float saw_gain = 8.0f * (1.0f - parameters.morph);
    9d8e:	vmov.f32	s10, #32	; 0x41000000  8.0
    9d92:	vsub.f32	s14, s15, s14
    9d96:	vmul.f32	s14, s14, s10
  CONSTRAIN(saw_gain, 0.02f, 1.0f);
    9d9a:	vcmpe.f32	s14, s11
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    
  float saw_shape = 10.0f - 21.0f * parameters.morph;
  CONSTRAIN(saw_shape, 0.0f, 1.0f);
  
  float saw_gain = 8.0f * (1.0f - parameters.morph);
    9d9e:	vstr	s14, [sp, #12]
  CONSTRAIN(saw_gain, 0.02f, 1.0f);
    9da2:	vmrs	APSR_nzcv, fpscr
    9da6:	bmi.n	9e96 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa32>
    9da8:	vcmpe.f32	s14, s15
    9dac:	vmrs	APSR_nzcv, fpscr
    9db0:	ble.w	a6a6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1242>
    9db4:	vmov.f32	s14, #96	; 0x3f000000  0.5
    9db8:	vstr	s15, [sp, #12]
    9dbc:	vstr	s14, [sp, #24]
    9dc0:	b.n	9ea2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa3e>
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9dc2:	vsub.f32	s15, s13, s4
    9dc6:	vmov.f32	s6, s7
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9dca:	vmov.f32	s14, #112	; 0x3f800000  1.0
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9dce:	vfms.f32	s6, s5, s15
    9dd2:	b.n	9c3c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d8>
    9dd4:	.word	0x00000000
    9dd8:	.word	0x3fa66666
    9ddc:	.word	0xbe19999a
    9de0:	.word	0x3ba3d70a
    9de4:	.word	0x42400000
    9de8:	.word	0x3e99999a
    9dec:	.word	0x3f8ccccd
    9df0:	.word	0x3ca3d70a
    9df4:	.word	0x3c23d70a
    9df8:	.word	0xc3000000
    9dfc:	.word	0x42fe0000
    9e00:	.word	0x39962fc9
    9e04:	.word	0x00000000
    9e08:	vsub.f32	s15, s13, s3
    9e0c:	vmov.f32	s5, s6
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9e10:	vmov.f32	s14, #112	; 0x3f800000  1.0
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9e14:	vfms.f32	s5, s4, s15
    9e18:	b.n	9936 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4d2>
    9e1a:	vsub.f32	s14, s15, s3
    9e1e:	vmov.f32	s8, s6
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9e22:	vmov.f32	s12, #112	; 0x3f800000  1.0
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9e26:	vfms.f32	s8, s4, s14
    9e2a:	b.n	97c4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x360>
    9e2c:	vsub.f32	s14, s15, s4
    9e30:	vmov.f32	s9, s7
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    9e34:	vmov.f32	s0, #112	; 0x3f800000  1.0
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    9e38:	vfms.f32	s9, s5, s14
    9e3c:	b.n	9aca <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x666>
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
    9e3e:	cmp	r0, #0
    9e40:	beq.w	9c28 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c4>
    9e44:	b.n	9c1a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b6>
    9e46:	cmp	r0, #0
    9e48:	beq.w	9922 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4be>
    9e4c:	b.n	9914 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4b0>
    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
      bool transition_during_reset = false;
      float reset_time = 0.0f;
    9e4e:	vldr	s2, [pc, #-76]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>

    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
      bool transition_during_reset = false;
    9e52:	movs	r2, #0
    9e54:	vldr	s13, [r4, #20]
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    9e58:	vmov.f32	s12, s2
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
    9e5c:	mov	r0, r2
    9e5e:	b.n	97fa <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x396>
      bool transition_during_reset = false;
      float reset_time = 0.0f;
    9e60:	vldr	s3, [pc, #-96]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>

    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
      bool transition_during_reset = false;
    9e64:	movs	r2, #0
    9e66:	vldr	s13, [r4, #56]	; 0x38
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    9e6a:	vmov.f32	s12, s3
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
    9e6e:	mov	r0, r2
    9e70:	b.n	9b00 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x69c>
      bool transition_during_reset = false;
    9e72:	movs	r2, #0
    9e74:	b.n	979e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x33a>
    9e76:	movs	r2, #0
    9e78:	b.n	9aa4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x640>
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
      master_frequency = kMaxFrequency;
    }
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    9e7a:	vmov.f32	s14, s15
    }
    
    if (frequency >= 0.25f) {
      pw = 0.5f;
    9e7e:	vmov.f32	s15, #96	; 0x3f000000  0.5
    9e82:	b.n	96ae <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x24a>

  float shape = parameters.morph * 1.5f;
  CONSTRAIN(shape, 0.0f, 1.0f);

  float pw = 0.5f + (parameters.morph - 0.66f) * 1.46f;
  CONSTRAIN(pw, 0.5f, 0.995f);
    9e84:	vstr	s13, [sp, #20]
    9e88:	b.w	9674 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x210>
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
      master_frequency = kMaxFrequency;
    }
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    9e8c:	vstr	s15, [sp, #12]
    }
    
    if (frequency >= 0.25f) {
      pw = 0.5f;
    9e90:	vmov.f32	s14, #96	; 0x3f000000  0.5
    9e94:	b.n	99ba <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x556>
    9e96:	vldr	s15, [pc, #-164]	; 9df4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x990>
    
  float saw_shape = 10.0f - 21.0f * parameters.morph;
  CONSTRAIN(saw_shape, 0.0f, 1.0f);
  
  float saw_gain = 8.0f * (1.0f - parameters.morph);
  CONSTRAIN(saw_gain, 0.02f, 1.0f);
    9e9a:	vstr	s11, [sp, #12]
    9e9e:	vstr	s15, [sp, #24]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    9ea2:	vldr	s15, [r7, #4]
    9ea6:	vmov.f32	s11, #34	; 0x41100000  9.0
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    9eaa:	vldr	s14, [pc, #-180]	; 9df8 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x994>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    9eae:	vadd.f32	s15, s13, s15
    9eb2:	vsub.f32	s15, s15, s11
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    9eb6:	vcmpe.f32	s15, s14
    9eba:	vmrs	APSR_nzcv, fpscr
    9ebe:	bmi.n	9ee2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa7e>
    9ec0:	vldr	s14, [pc, #-200]	; 9dfc <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x998>
    9ec4:	vcmpe.f32	s15, s14
    9ec8:	vmrs	APSR_nzcv, fpscr
    9ecc:	ble.w	a65c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11f8>
    9ed0:	movs	r3, #0
    9ed2:	movs	r2, #255	; 0xff
    9ed4:	b.n	9ee6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa82>
  
  float saw_pw = parameters.morph < 0.5f
      ? parameters.morph + 0.5f
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
  saw_pw *= 1.1f;
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    9ed6:	vstr	s11, [sp, #28]
    9eda:	b.n	9d5c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8f8>
  float square_pw = 1.3f * parameters.timbre - 0.15f;
  CONSTRAIN(square_pw, 0.005f, 0.5f);
  
  const float square_sync_ratio = parameters.timbre < 0.5f
      ? 0.0f
      : (parameters.timbre - 0.5f) * (parameters.timbre - 0.5f) * 4.0f * 48.0f;
    9edc:	vldr	s13, [pc, #-220]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
    9ee0:	b.n	9cee <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x88a>
    9ee2:	movs	r3, #0
    9ee4:	mov	r2, r3

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    9ee6:	add.w	r2, ip, r2, lsl #2
      float frequency,
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
    9eea:	vmov.f32	s13, #80	; 0x3e800000  0.250
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    9eee:	add.w	r3, r8, r3, lsl #2
      master_frequency = kMaxFrequency;
    9ef2:	vldr	s10, [sp, #4]
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    9ef6:	vldr	s14, [r2]
    9efa:	vldr	s15, [r3]
    9efe:	vcmp.f32	s10, s13
    9f02:	vldr	s11, [pc, #-260]	; 9e00 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x99c>
    9f06:	vmul.f32	s15, s14, s15
  CONSTRAIN(saw_gain, 0.02f, 1.0f);
  
  const float square_sync_f = NoteToFrequency(
      parameters.note + square_sync_ratio);
  
  sync_.Render<true>(
    9f0a:	ldr.w	ip, [r4, #160]	; 0xa0
    9f0e:	vmrs	APSR_nzcv, fpscr
    9f12:	vmul.f32	s15, s15, s11
    9f16:	ite	ge
    9f18:	vmovge.f32	s14, s13
    9f1c:	vmovlt.f32	s14, s10
    }
    if (frequency >= kMaxFrequency) {
    9f20:	vcmpe.f32	s15, s13
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
      master_frequency = kMaxFrequency;
    9f24:	vstr	s14, [sp, #4]
    }
    if (frequency >= kMaxFrequency) {
    9f28:	vmrs	APSR_nzcv, fpscr
    9f2c:	bge.w	a50a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10a6>
      frequency = kMaxFrequency;
    }
    
    if (frequency >= 0.25f) {
    9f30:	bge.w	a6be <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x125a>
      pw = 0.5f;
    } else {
      CONSTRAIN(pw, frequency * 2.0f, 1.0f - 2.0f * frequency);
    9f34:	vadd.f32	s14, s15, s15
    9f38:	vcmpe.f32	s12, s14
    9f3c:	vmrs	APSR_nzcv, fpscr
    9f40:	bpl.w	a644 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e0>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    9f44:	vmov.f32	s10, #112	; 0x3f800000  1.0
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    9f48:	vldr	s22, [r4, #120]	; 0x78
    9f4c:	vldr	s23, [r4, #108]	; 0x6c
    9f50:	vldr	s1, [r4, #112]	; 0x70
    9f54:	vldr	s3, [r4, #116]	; 0x74
    increment_ = (new_value - *state) / static_cast<float>(size);
    9f58:	vsub.f32	s12, s10, s22
    9f5c:	vldr	s13, [sp, #4]
    9f60:	vsub.f32	s15, s15, s1
    9f64:	vsub.f32	s14, s14, s3
    stmlib::ParameterInterpolator fm(&slave_frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    9f68:	vldr	s11, [r4, #96]	; 0x60
    9f6c:	vsub.f32	s13, s13, s23
    9f70:	vdiv.f32	s29, s12, s31
    9f74:	vdiv.f32	s26, s13, s31
    9f78:	vdiv.f32	s27, s15, s31
    9f7c:	vdiv.f32	s28, s14, s31
    
    while (size--) {
    9f80:	cmp.w	lr, #0
    9f84:	beq.w	a1ee <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd8a>
    9f88:	mov	r8, ip
    9f8a:	mov	r6, r0
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    9f8c:	vldr	s25, [pc, #-396]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
    
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
    9f90:	vmov.f32	s0, #96	; 0x3f000000  0.5
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9f94:	vmov.f32	s24, #0	; 0x40000000  2.0
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    9f98:	vmov.f32	s21, #224	; 0xbf000000 -0.5
  }

  inline float Next() {
    value_ += increment_;
    9f9c:	vadd.f32	s22, s22, s29
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
    9fa0:	vldr	s15, [r4, #88]	; 0x58
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9fa4:	vmov.f32	s6, s10
    9fa8:	vadd.f32	s23, s23, s26
    
      const float master_frequency = master_fm.Next();
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
    9fac:	vsub.f32	s9, s22, s0
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
    9fb0:	vfms.f32	s6, s22, s24
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
    9fb4:	vadd.f32	s15, s23, s15
    9fb8:	vcmpe.f32	s9, #0.0
    9fbc:	vadd.f32	s3, s3, s28
    9fc0:	vadd.f32	s1, s1, s27
    9fc4:	vstr	s15, [r4, #88]	; 0x58
    9fc8:	vmrs	APSR_nzcv, fpscr
	return __b;
    9fcc:	vcmp.f32	s6, #0.0
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    9fd0:	vsub.f32	s14, s10, s3
    9fd4:	ite	pl
    9fd6:	vaddpl.f32	s9, s9, s9
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    9fda:	vldrmi	s9, [pc, #-472]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
	return __b;
    9fde:	vmrs	APSR_nzcv, fpscr

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9fe2:	vcmpe.f32	s15, s10
      const float slave_frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
    9fe6:	vdiv.f32	s5, s10, s3
    9fea:	it	mi
    9fec:	vmovmi.f32	s6, s25
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9ff0:	vmrs	APSR_nzcv, fpscr
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float square_amount = std::max(waveshape - 0.5f, 0.0f) * 2.0f;
      const float triangle_amount = std::max(1.0f - waveshape * 2.0f, 0.0f);
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    9ff4:	vdiv.f32	s4, s10, s14

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
    9ff8:	blt.w	a444 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfe0>
          master_phase_ -= 1.0f;
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
    9ffc:	vldr	s13, [r4, #92]	; 0x5c
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
          master_phase_ -= 1.0f;
    a000:	vsub.f32	s15, s15, s10
          reset_time = master_phase_ / master_frequency;
    a004:	vdiv.f32	s2, s15, s23
      const float slope_down = 1.0f / (1.0f - pw);

      if (enable_sync) {
        master_phase_ += master_frequency;
        if (master_phase_ >= 1.0f) {
          master_phase_ -= 1.0f;
    a008:	vstr	s15, [r4, #88]	; 0x58
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
              (1.0f - reset_time) * slave_frequency;
    a00c:	vmov.f32	s15, s13
    a010:	vsub.f32	s8, s10, s2
    a014:	vfma.f32	s15, s1, s8
          reset = true;
          if (slave_phase_at_reset >= 1.0f) {
    a018:	vcmpe.f32	s15, s10
    a01c:	vmrs	APSR_nzcv, fpscr
    a020:	blt.w	a460 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xffc>
            slave_phase_at_reset -= 1.0f;
    a024:	vsub.f32	s15, s15, s10
            transition_during_reset = true;
    a028:	movs	r2, #1
          }
          if (!high_ && slave_phase_at_reset >= pw) {
    a02a:	ldrb.w	r3, [r4, #104]	; 0x68
    a02e:	cbnz	r3, a03c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbd8>
            transition_during_reset = true;
    a030:	vcmp.f32	s3, s15
    a034:	vmrs	APSR_nzcv, fpscr
    a038:	it	ls
    a03a:	movls	r2, #1
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    a03c:	vcmpe.f32	s3, s15
    a040:	vmrs	APSR_nzcv, fpscr
    a044:	ble.w	a42a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfc6>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a048:	vmul.f32	s7, s5, s15
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    a04c:	vldr	s12, [pc, #-588]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    a050:	vsub.f32	s12, s12, s15
          master_phase_ -= 1.0f;
          reset_time = master_phase_ / master_frequency;
      
          float slave_phase_at_reset = slave_phase_ + \
              (1.0f - reset_time) * slave_frequency;
          reset = true;
    a054:	movs	r7, #1
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    a056:	vmul.f32	s14, s2, s0
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    a05a:	vfma.f32	s15, s12, s9
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    a05e:	vmul.f32	s12, s8, s21
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    a062:	vmul.f32	s14, s14, s2
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    a066:	vmul.f32	s12, s12, s8
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    saw += (triangle - saw) * triangle_amount;
    a06a:	vsub.f32	s8, s7, s15
    a06e:	vfma.f32	s15, s6, s8
              pw,
              slope_up,
              slope_down,
              triangle_amount,
              square_amount);
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
    a072:	vneg.f32	s15, s15
    a076:	vfma.f32	s11, s15, s14
          next_sample -= value * stmlib::NextBlepSample(reset_time);
    a07a:	vmov.f32	s14, s25
    a07e:	vfma.f32	s14, s15, s12
    a082:	vmov.f32	s12, s14
        }
      }
      
      slave_phase_ += slave_frequency;
    a086:	vadd.f32	s15, s1, s13
      while (transition_during_reset || !reset) {
    a08a:	cmp	r7, r2
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = true;
    a08c:	mov.w	r3, #1
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a090:	vmov.f32	s7, #72	; 0x3e400000  0.1875000

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
    a094:	mov.w	r9, #0
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a098:	vmov.f32	s8, #120	; 0x3fc00000  1.5
          this_sample -= value * stmlib::ThisBlepSample(reset_time);
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
    a09c:	vstr	s15, [r4, #92]	; 0x5c
      while (transition_during_reset || !reset) {
    a0a0:	bhi.n	a1a0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd3c>
        if (!high_) {
    a0a2:	ldrb.w	r1, [r4, #104]	; 0x68
          if (slave_phase_ < pw) {
    a0a6:	vldr	s13, [r4, #92]	; 0x5c
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
        if (!high_) {
    a0aa:	cbnz	r1, a124 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcc0>
          if (slave_phase_ < pw) {
    a0ac:	vcmpe.f32	s3, s13
    a0b0:	vmrs	APSR_nzcv, fpscr
    a0b4:	bgt.w	a43c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfd8>
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    a0b8:	vldr	s15, [r4, #100]	; 0x64
    a0bc:	vsub.f32	s16, s13, s3
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    a0c0:	vadd.f32	s14, s5, s4
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = true;
    a0c4:	strb.w	r3, [r4, #104]	; 0x68
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    a0c8:	vsub.f32	s15, s15, s3
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    a0cc:	vmul.f32	s14, s14, s1
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    a0d0:	vadd.f32	s15, s15, s1
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a0d4:	vnmul.f32	s14, s14, s6
      while (transition_during_reset || !reset) {
        if (!high_) {
          if (slave_phase_ < pw) {
            break;
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
    a0d8:	vdiv.f32	s17, s16, s15
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    a0dc:	vsub.f32	s20, s10, s17
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    a0e0:	vmul.f32	s15, s17, s0
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    a0e4:	vmul.f32	s16, s20, s0
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
    a0e8:	vmul.f32	s17, s17, s15
  const float t2 = t1 * t1;
    a0ec:	vmul.f32	s18, s15, s15
    a0f0:	vmul.f32	s19, s16, s16
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a0f4:	vsub.f32	s15, s7, s15
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a0f8:	vsub.f32	s16, s7, s16
          }
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
    a0fc:	vfma.f32	s11, s17, s9
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a100:	vfma.f32	s15, s18, s8
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a104:	vfma.f32	s16, s19, s8
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
    a108:	vmul.f32	s17, s20, s21
    a10c:	vmul.f32	s20, s17, s20
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a110:	vfms.f32	s15, s18, s18
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a114:	vfms.f32	s16, s19, s19
          float t = (slave_phase_ - pw) / (previous_pw_ - pw + slave_frequency);
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;
          
          this_sample += square_amount * stmlib::ThisBlepSample(t);
          next_sample += square_amount * stmlib::NextBlepSample(t);
    a118:	vfma.f32	s12, s20, s9
          this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a11c:	vfma.f32	s11, s14, s16
          next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a120:	vfma.f32	s12, s14, s15
          high_ = true;
        }
      
        if (high_) {
          if (slave_phase_ < 1.0f) {
    a124:	vcmpe.f32	s13, s10
    a128:	vmrs	APSR_nzcv, fpscr
    a12c:	bmi.w	a43c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfd8>
            break;
          }
          slave_phase_ -= 1.0f;
    a130:	vsub.f32	s13, s13, s10
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
    a134:	cmp	r7, r2
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    a136:	vsub.f32	s16, s10, s6
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
    a13a:	strb.w	r9, [r4, #104]	; 0x68
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    a13e:	vadd.f32	s15, s5, s4
        if (high_) {
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
    a142:	vdiv.f32	s17, s13, s1
      
        if (high_) {
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
    a146:	vstr	s13, [r4, #92]	; 0x5c
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    a14a:	vneg.f32	s16, s16
          if (slave_phase_ < 1.0f) {
            break;
          }
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
    a14e:	vmul.f32	s15, s15, s1
          triangle_step *= triangle_amount;
    a152:	vmul.f32	s15, s6, s15
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    a156:	vsub.f32	s20, s10, s17
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    a15a:	vmul.f32	s14, s17, s0
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    a15e:	vmul.f32	s13, s20, s0

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    a162:	vmul.f32	s17, s17, s14
  const float t2 = t1 * t1;
    a166:	vmul.f32	s18, s14, s14
    a16a:	vmul.f32	s19, s13, s13
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a16e:	vsub.f32	s14, s7, s14
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a172:	vsub.f32	s13, s7, s13
          slave_phase_ -= 1.0f;
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
    a176:	vfma.f32	s11, s16, s17
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a17a:	vfma.f32	s14, s18, s8
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a17e:	vfma.f32	s13, s19, s8
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
    a182:	vmul.f32	s17, s20, s21
    a186:	vmul.f32	s20, s17, s20
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a18a:	vfms.f32	s14, s18, s18
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a18e:	vfms.f32	s13, s19, s19
          float t = slave_phase_ / slave_frequency;
          float triangle_step = (slope_up + slope_down) * slave_frequency;
          triangle_step *= triangle_amount;

          this_sample -= (1.0f - triangle_amount) * stmlib::ThisBlepSample(t);
          next_sample -= (1.0f - triangle_amount) * stmlib::NextBlepSample(t);
    a192:	vfma.f32	s12, s16, s20
          this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a196:	vfma.f32	s11, s15, s13
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a19a:	vfma.f32	s12, s15, s14
          next_sample -= value * stmlib::NextBlepSample(reset_time);
        }
      }
      
      slave_phase_ += slave_frequency;
      while (transition_during_reset || !reset) {
    a19e:	bls.n	a0a2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc3e>
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
    a1a0:	vmul.f32	s13, s1, s2
        high_ = false;
    a1a4:	movs	r3, #0
    a1a6:	strb.w	r3, [r4, #104]	; 0x68
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
    a1aa:	vstr	s13, [r4, #92]	; 0x5c
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    a1ae:	vcmpe.f32	s3, s13
    a1b2:	vmrs	APSR_nzcv, fpscr
    a1b6:	ble.w	a418 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfb4>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a1ba:	vmul.f32	s5, s5, s13
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    a1be:	vldr	s14, [pc, #-956]	; 9e04 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    a1c2:	vsub.f32	s14, s14, s13
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    a1c6:	subs	r6, #1
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    a1c8:	vmov.f32	s15, #240	; 0xbf800000 -1.0
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;
    a1cc:	vstr	s3, [r4, #100]	; 0x64
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    a1d0:	adds	r1, r6, #1
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    a1d2:	vfma.f32	s13, s14, s9
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    a1d6:	vfma.f32	s15, s11, s24
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    saw += (square - saw) * square_amount;
    saw += (triangle - saw) * triangle_amount;
    a1da:	vsub.f32	s5, s5, s13
          slope_down,
          triangle_amount,
          square_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    a1de:	vstmia	r8!, {s15}
      if (enable_sync && reset) {
        slave_phase_ = reset_time * slave_frequency;
        high_ = false;
      }
    
      next_sample += ComputeNaiveSample(
    a1e2:	vfma.f32	s13, s6, s5
    a1e6:	vadd.f32	s11, s13, s12
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    a1ea:	bne.w	9f9c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb38>
      float frequency,
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (frequency >= kMaxFrequency) {
    a1ee:	vmov.f32	s15, #80	; 0x3e800000  0.250
    a1f2:	vldr	s14, [sp, #8]
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f);
    }
    
    next_sample_ = next_sample;
    a1f6:	vstr	s11, [r4, #96]	; 0x60
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    a1fa:	vstr	s22, [r4, #120]	; 0x78
    a1fe:	vcmpe.f32	s14, s15
    a202:	vstr	s3, [r4, #116]	; 0x74
    a206:	vstr	s1, [r4, #112]	; 0x70
    a20a:	vstr	s23, [r4, #108]	; 0x6c
    a20e:	vmrs	APSR_nzcv, fpscr
    a212:	bge.w	a500 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x109c>
      frequency = kMaxFrequency;
    }
    
    if (frequency >= 0.25f) {
    a216:	bge.w	a6c4 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1260>
      pw = 0.5f;
    } else {
      CONSTRAIN(pw, frequency * 2.0f, 1.0f - 2.0f * frequency);
    a21a:	vadd.f32	s15, s14, s14
    a21e:	vldr	s13, [sp, #28]
    a222:	vcmpe.f32	s13, s15
    a226:	vmrs	APSR_nzcv, fpscr
    a22a:	bpl.w	a616 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11b2>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    a22e:	vldr	s14, [sp, #8]
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    a232:	vldr	s8, [r4, #140]	; 0x8c
    a236:	vldr	s11, [r4, #144]	; 0x90
    a23a:	vldr	s9, [r4, #148]	; 0x94
    increment_ = (new_value - *state) / static_cast<float>(size);
    a23e:	vsub.f32	s13, s14, s8
    a242:	vsub.f32	s15, s15, s11
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    a246:	vldr	s14, [r4, #128]	; 0x80
    a24a:	vsub.f32	s30, s30, s9
    a24e:	vdiv.f32	s3, s13, s31
    a252:	vdiv.f32	s2, s15, s31
    a256:	vdiv.f32	s1, s30, s31
    
    while (size--) {
    a25a:	cmp.w	lr, #0
    a25e:	beq.w	a464 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1000>
    a262:	mov	r3, r5
      float this_sample = next_sample;
      next_sample = 0.0f;
    a264:	vldr	s16, [pc, #968]	; a630 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11cc>
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
    a268:	vldr	s7, [pc, #968]	; a634 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d0>
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = false;
    a26c:	movs	r1, #0
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
    a26e:	movs	r6, #1
    
      const float frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float triangle_amount = waveshape;
      const float notch_amount = 1.0f - waveshape;
    a270:	vmov.f32	s10, #112	; 0x3f800000  1.0
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    a274:	vmov.f32	s4, #96	; 0x3f000000  0.5
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
    a278:	vmov.f32	s0, #224	; 0xbf000000 -0.5
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a27c:	vmov.f32	s5, #72	; 0x3e400000  0.1875000
    a280:	vmov.f32	s6, #120	; 0x3fc00000  1.5
    a284:	b.n	a34a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xee6>
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
    a286:	vcmpe.f32	s11, s15
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
    a28a:	vmov.f32	s18, s15
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
    a28e:	vmrs	APSR_nzcv, fpscr
    a292:	bhi.n	a37a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf16>
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
    a294:	vldr	s17, [r4, #132]	; 0x84
    a298:	vsub.f32	s13, s15, s11

      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
    a29c:	vsub.f32	s22, s7, s11
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
    a2a0:	strb.w	r6, [r4, #136]	; 0x88
      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
    a2a4:	vsub.f32	s15, s17, s11
      const float slope_down = 1.0f / (1.0f - pw);

      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
    a2a8:	vadd.f32	s21, s12, s20
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
    a2ac:	vmul.f32	s22, s22, s19
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
    a2b0:	vadd.f32	s15, s15, s8
      const float slope_down = 1.0f / (1.0f - pw);

      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
    a2b4:	vmul.f32	s21, s21, s8
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
    a2b8:	vdiv.f32	s17, s13, s15
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a2bc:	vnmul.f32	s21, s9, s21
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    a2c0:	vsub.f32	s24, s10, s17
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    a2c4:	vmul.f32	s15, s17, s4
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    a2c8:	vmul.f32	s13, s24, s4
      
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
    a2cc:	vmul.f32	s23, s17, s15
  const float t2 = t1 * t1;
    a2d0:	vmul.f32	s25, s13, s13
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a2d4:	vsub.f32	s17, s5, s13
    a2d8:	vmul.f32	s13, s15, s15
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a2dc:	vsub.f32	s15, s5, s15
      
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
    a2e0:	vfma.f32	s14, s22, s23
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a2e4:	vfma.f32	s17, s25, s6
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a2e8:	vfma.f32	s15, s13, s6
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
    a2ec:	vmul.f32	s23, s24, s0
    a2f0:	vmul.f32	s24, s23, s24
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a2f4:	vfms.f32	s17, s25, s25
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a2f8:	vfms.f32	s15, s13, s13
      if (!high_ && phase_ >= pw) {
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f - pw) * notch_amount;
        const float t = (phase_ - pw) / (previous_pw_ - pw + frequency);
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
    a2fc:	vmov.f32	s13, s16
    a300:	vfma.f32	s13, s22, s24
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a304:	vfma.f32	s14, s21, s17
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
    a308:	vfma.f32	s13, s21, s15
      float pw,
      float slope_up,
      float slope_down,
      float triangle_amount,
      float notch_amount) const {
    float notch_saw = phase < pw ? phase : 1.0f + kVariableSawNotchDepth;
    a30c:	vcmpe.f32	s11, s18
    a310:	vmov.f32	s17, s18
    a314:	vmrs	APSR_nzcv, fpscr
    a318:	ble.n	a406 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfa2>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a31a:	vmul.f32	s12, s12, s18
          slope_down,
          triangle_amount,
          notch_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f) / (1.0f + kVariableSawNotchDepth);
    a31e:	vmov.f32	s18, #0	; 0x40000000  2.0
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    a322:	subs	r0, #1
          slope_down,
          triangle_amount,
          notch_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f) / (1.0f + kVariableSawNotchDepth);
    a324:	vmov.f32	s15, #240	; 0xbf800000 -1.0
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          notch_amount);
      previous_pw_ = pw;
    a328:	vstr	s11, [r4, #132]	; 0x84
          phase_,
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          notch_amount);
    a32c:	vmul.f32	s12, s9, s12
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    a330:	adds	r2, r0, #1
          slope_down,
          triangle_amount,
          notch_amount);
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f) / (1.0f + kVariableSawNotchDepth);
    a332:	vfma.f32	s15, s14, s18
          phase_,
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          notch_amount);
    a336:	vfma.f32	s12, s17, s19
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f) / (1.0f + kVariableSawNotchDepth);
    a33a:	vdiv.f32	s17, s15, s7
          phase_,
          pw,
          slope_up,
          slope_down,
          triangle_amount,
          notch_amount);
    a33e:	vadd.f32	s14, s12, s13
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f) / (1.0f + kVariableSawNotchDepth);
    a342:	vstmia	r3!, {s17}
    stmlib::ParameterInterpolator waveshape_modulation(
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
    a346:	beq.w	a464 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1000>
  }

  inline float Next() {
    value_ += increment_;
    a34a:	vadd.f32	s11, s11, s2
      const float triangle_amount = waveshape;
      const float notch_amount = 1.0f - waveshape;
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);

      phase_ += frequency;
    a34e:	vldr	s15, [r4, #124]	; 0x7c
    a352:	vadd.f32	s8, s8, s3
      
      if (!high_ && phase_ >= pw) {
    a356:	ldrb.w	r2, [r4, #136]	; 0x88
    a35a:	vadd.f32	s9, s9, s1
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float triangle_amount = waveshape;
      const float notch_amount = 1.0f - waveshape;
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    a35e:	vsub.f32	s13, s10, s11

      phase_ += frequency;
    a362:	vadd.f32	s15, s8, s15
    
      const float frequency = fm.Next();
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float triangle_amount = waveshape;
      const float notch_amount = 1.0f - waveshape;
    a366:	vsub.f32	s19, s10, s9
      const float slope_up = 1.0f / (pw);
    a36a:	vdiv.f32	s12, s10, s11
      const float slope_down = 1.0f / (1.0f - pw);

      phase_ += frequency;
    a36e:	vstr	s15, [r4, #124]	; 0x7c
      const float pw = pwm.Next();
      const float waveshape = waveshape_modulation.Next();
      const float triangle_amount = waveshape;
      const float notch_amount = 1.0f - waveshape;
      const float slope_up = 1.0f / (pw);
      const float slope_down = 1.0f / (1.0f - pw);
    a372:	vdiv.f32	s20, s10, s13

      phase_ += frequency;
      
      if (!high_ && phase_ >= pw) {
    a376:	cmp	r2, #0
    a378:	beq.n	a286 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe22>
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
    a37a:	vcmpe.f32	s15, s10
    a37e:	vmrs	APSR_nzcv, fpscr
    a382:	blt.n	a456 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xff2>
        phase_ -= 1.0f;
    a384:	vsub.f32	s15, s15, s10
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = false;
    a388:	strb.w	r1, [r4, #136]	; 0x88
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
    a38c:	vnmul.f32	s23, s7, s19
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
    a390:	vadd.f32	s21, s12, s20
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
    a394:	vdiv.f32	s22, s15, s8
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
    a398:	vstr	s15, [r4, #124]	; 0x7c
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = false;
    a39c:	vmov.f32	s18, s15
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
    a3a0:	vmul.f32	s21, s21, s8
      float pw,
      float slope_up,
      float slope_down,
      float triangle_amount,
      float notch_amount) const {
    float notch_saw = phase < pw ? phase : 1.0f + kVariableSawNotchDepth;
    a3a4:	vcmpe.f32	s11, s18
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
    a3a8:	vmul.f32	s21, s21, s9
      float pw,
      float slope_up,
      float slope_down,
      float triangle_amount,
      float notch_amount) const {
    float notch_saw = phase < pw ? phase : 1.0f + kVariableSawNotchDepth;
    a3ac:	vmrs	APSR_nzcv, fpscr
#include "stmlib/stmlib.h"

namespace stmlib {

inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
    a3b0:	vmul.f32	s13, s22, s4
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    a3b4:	vsub.f32	s24, s10, s22
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
  const float t2 = t1 * t1;
    a3b8:	vmul.f32	s15, s13, s13
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
    a3bc:	vmul.f32	s22, s22, s13
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a3c0:	vsub.f32	s13, s5, s13
  t = 1.0f - t;
  return -0.5f * t * t;
}

inline float NextIntegratedBlepSample(float t) {
  const float t1 = 0.5f * t;
    a3c4:	vmul.f32	s17, s24, s4
      } else if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
    a3c8:	vfma.f32	s14, s23, s22
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a3cc:	vfma.f32	s13, s15, s6
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
    a3d0:	vmul.f32	s22, s24, s0
  const float t2 = t1 * t1;
    a3d4:	vmul.f32	s25, s17, s17
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a3d8:	vsub.f32	s17, s5, s17
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
    a3dc:	vmul.f32	s24, s22, s24
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a3e0:	vfms.f32	s13, s15, s15
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
    a3e4:	vmov.f32	s15, s16
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a3e8:	vfma.f32	s17, s25, s6
        phase_ -= 1.0f;
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
    a3ec:	vfma.f32	s15, s23, s24
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a3f0:	vfms.f32	s17, s25, s25
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a3f4:	vfma.f32	s15, s21, s13
        const float triangle_step = (slope_up + slope_down) * frequency * triangle_amount;
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
    a3f8:	vfma.f32	s14, s21, s17
      float pw,
      float slope_up,
      float slope_down,
      float triangle_amount,
      float notch_amount) const {
    float notch_saw = phase < pw ? phase : 1.0f + kVariableSawNotchDepth;
    a3fc:	vmov.f32	s17, s18
        const float notch = (kVariableSawNotchDepth + 1.0f) * notch_amount;
        const float t = phase_ / frequency;
        this_sample -= notch * stmlib::ThisBlepSample(t);
        next_sample -= notch * stmlib::NextBlepSample(t);
        this_sample += triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
    a400:	vmov.f32	s13, s15
      float pw,
      float slope_up,
      float slope_down,
      float triangle_amount,
      float notch_amount) const {
    float notch_saw = phase < pw ? phase : 1.0f + kVariableSawNotchDepth;
    a404:	bgt.n	a31a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xeb6>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a406:	vsub.f32	s15, s18, s11
      float pw,
      float slope_up,
      float slope_down,
      float triangle_amount,
      float notch_amount) const {
    float notch_saw = phase < pw ? phase : 1.0f + kVariableSawNotchDepth;
    a40a:	vldr	s17, [pc, #552]	; a634 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d0>
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a40e:	vmov.f32	s12, s10
    a412:	vfms.f32	s12, s20, s15
    a416:	b.n	a31e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xeba>
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a418:	vsub.f32	s15, s13, s3
    a41c:	vmov.f32	s5, s10
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    a420:	vmov.f32	s14, #112	; 0x3f800000  1.0
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a424:	vfms.f32	s5, s4, s15
    a428:	b.n	a1c2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd5e>
    a42a:	vsub.f32	s14, s15, s3
    a42e:	vmov.f32	s7, s10
      float slope_up,
      float slope_down,
      float triangle_amount,
      float square_amount) const {
    float saw = phase;
    float square = phase < pw ? 0.0f : 1.0f;
    a432:	vmov.f32	s12, #112	; 0x3f800000  1.0
    float triangle = phase < pw
        ? phase * slope_up
        : 1.0f - (phase - pw) * slope_down;
    a436:	vfms.f32	s7, s4, s14
    a43a:	b.n	a050 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbec>
          next_sample += triangle_step * stmlib::NextIntegratedBlepSample(t);
          high_ = false;
        }
      }
    
      if (enable_sync && reset) {
    a43c:	cmp	r7, #0
    a43e:	beq.w	a1ae <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd4a>
    a442:	b.n	a1a0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd3c>
    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
      bool transition_during_reset = false;
      float reset_time = 0.0f;
    a444:	vldr	s2, [pc, #488]	; a630 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11cc>

    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
      bool transition_during_reset = false;
    a448:	movs	r2, #0
    a44a:	vldr	s13, [r4, #92]	; 0x5c
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    a44e:	vmov.f32	s12, s2
        &waveshape_, waveshape, size);

    float next_sample = next_sample_;
    
    while (size--) {
      bool reset = false;
    a452:	mov	r7, r2
    a454:	b.n	a086 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc22>
        this_sample += notch * stmlib::ThisBlepSample(t);
        next_sample += notch * stmlib::NextBlepSample(t);
        this_sample -= triangle_step * stmlib::ThisIntegratedBlepSample(t);
        next_sample -= triangle_step * stmlib::NextIntegratedBlepSample(t);
        high_ = true;
      } else if (phase_ >= 1.0f) {
    a456:	vmov.f32	s18, s15

    float next_sample = next_sample_;
    
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    a45a:	vldr	s13, [pc, #468]	; a630 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11cc>
    a45e:	b.n	a30c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xea8>
      bool transition_during_reset = false;
    a460:	movs	r2, #0
    a462:	b.n	a02a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbc6>
    a464:	vldr	s15, [sp, #16]
      primary_f, square_sync_f, square_pw, 1.0f, temp_buffer_, size);
  variable_saw_.Render(auxiliary_f, saw_pw, saw_shape, out, size);
  
  float norm = 1.0f / (std::max(square_gain, saw_gain));
    a468:	vmov.f32	s10, #112	; 0x3f800000  1.0
    a46c:	vldr	s7, [sp, #12]
      previous_pw_ = pw;

      *out++ = (2.0f * this_sample - 1.0f) / (1.0f + kVariableSawNotchDepth);
    }
    
    next_sample_ = next_sample;
    a470:	vstr	s14, [r4, #128]	; 0x80
    a474:	vcmp.f32	s15, s7
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    a478:	vldr	s13, [r4, #152]	; 0x98
    a47c:	vldr	s12, [r4, #156]	; 0x9c
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    a480:	vstr	s11, [r4, #144]	; 0x90
    a484:	vmrs	APSR_nzcv, fpscr
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    a488:	vldr	s11, [sp, #20]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    a48c:	vstr	s9, [r4, #148]	; 0x94
    a490:	vstr	s8, [r4, #140]	; 0x8c
    a494:	it	mi
    a496:	vmovmi.f32	s15, s7
    a49a:	vmov.f32	s14, s15
    a49e:	vdiv.f32	s15, s10, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    a4a2:	vldr	s10, [sp, #24]
    a4a6:	vmov.f32	s14, s13
    a4aa:	vfnms.f32	s14, s15, s11
    a4ae:	vmov.f32	s11, s12
    a4b2:	vfnms.f32	s11, s15, s10
    a4b6:	vdiv.f32	s10, s14, s31
    a4ba:	vmov.f32	s15, s11
    a4be:	vdiv.f32	s11, s15, s31
  ParameterInterpolator saw_gain_modulation(
      &xmod_amount_,
      saw_gain * 0.5f * norm,
      size);
  
  for (size_t i = 0; i < size; ++i) {
    a4c2:	cmp.w	lr, #0
    a4c6:	beq.n	a4ee <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x108a>
    a4c8:	mov	r3, ip
    a4ca:	add.w	lr, r5, lr, lsl #2
    out[i] = out[i] * saw_gain_modulation.Next() + \
        square_gain_modulation.Next() * temp_buffer_[i];
    a4ce:	vldmia	r3!, {s15}
    a4d2:	vldr	s14, [r5]
  }

  inline float Next() {
    value_ += increment_;
    a4d6:	vadd.f32	s13, s13, s10
    a4da:	vadd.f32	s12, s12, s11
    a4de:	vmul.f32	s15, s15, s13
    a4e2:	vfma.f32	s15, s14, s12
    a4e6:	vstmia	r5!, {s15}
  ParameterInterpolator saw_gain_modulation(
      &xmod_amount_,
      saw_gain * 0.5f * norm,
      size);
  
  for (size_t i = 0; i < size; ++i) {
    a4ea:	cmp	lr, r5
    a4ec:	bne.n	a4ce <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x106a>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    a4ee:	vstr	s12, [r4, #156]	; 0x9c
    a4f2:	vstr	s13, [r4, #152]	; 0x98
        square_gain_modulation.Next() * temp_buffer_[i];
  }

#endif  // VA_VARIANT values

}
    a4f6:	add	sp, #36	; 0x24
    a4f8:	vpop	{d8-d15}
    a4fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      float pw,
      float waveshape,
      float* out,
      size_t size) {
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    a500:	vstr	s15, [sp, #8]
    }
    
    if (frequency >= 0.25f) {
      pw = 0.5f;
    a504:	vmov.f32	s15, #96	; 0x3f000000  0.5
    a508:	b.n	a22e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdca>
      size_t size) {
    if (master_frequency >= kMaxFrequency) {
      master_frequency = kMaxFrequency;
    }
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    a50a:	vmov.f32	s15, s13
    }
    
    if (frequency >= 0.25f) {
      pw = 0.5f;
    a50e:	vmov.f32	s14, #96	; 0x3f000000  0.5
    a512:	b.n	9f44 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xae0>
    aux[i] = (aux[i] - out[i]) * 0.5f;
  }
  
  // Render double varishape to OUT.
  float square_pw = 1.3f * parameters.timbre - 0.15f;
  CONSTRAIN(square_pw, 0.005f, 0.5f);
    a514:	vmov.f32	s15, #96	; 0x3f000000  0.5
    a518:	vcmp.f32	s12, s15
    a51c:	vmrs	APSR_nzcv, fpscr
    a520:	it	gt
    a522:	vmovgt.f32	s12, s15
    a526:	b.w	9cc6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x862>
  
  const float square_gain = min(parameters.timbre * 8.0f, 1.0f);
  
  float saw_pw = parameters.morph < 0.5f
      ? parameters.morph + 0.5f
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
    a52a:	vsub.f32	s15, s14, s15
    a52e:	vmov.f32	s10, #0	; 0x40000000  2.0
    a532:	vmov.f32	s11, #112	; 0x3f800000  1.0
    a536:	vfms.f32	s11, s15, s10
    a53a:	vmov.f32	s15, s11
    a53e:	b.w	9d2a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8c6>
    } else {
      CONSTRAIN(pw, frequency * 2.0f, 1.0f - 2.0f * frequency);
    a542:	vmov.f32	s15, #112	; 0x3f800000  1.0
    a546:	vsub.f32	s14, s15, s14
    a54a:	vcmpe.f32	s12, s14
    a54e:	vmrs	APSR_nzcv, fpscr
    a552:	it	le
    a554:	vmovle.f32	s14, s12
    a558:	b.w	99ba <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x556>
    a55c:	vmov.f32	s12, #112	; 0x3f800000  1.0
    a560:	vsub.f32	s15, s12, s15
    a564:	vcmpe.f32	s11, s15
    a568:	vmrs	APSR_nzcv, fpscr
    a56c:	it	le
    a56e:	vmovle.f32	s15, s11
    a572:	b.w	96ae <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x24a>
    a576:	vldr	s13, [pc, #192]	; a638 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d4>
    a57a:	vadd.f32	s15, s15, s13
    a57e:	vcvt.s32.f32	s13, s15
    a582:	vmov	r2, s13
    a586:	vcvt.f32.s32	s13, s13
    a58a:	vsub.f32	s15, s15, s13
    a58e:	vmov.f32	s13, s15
    a592:	vcvt.s32.f32	s13, s13, #8
    a596:	vmov	r3, s13
    a59a:	b.w	95f0 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x18c>
    a59e:	vldr	s12, [pc, #152]	; a638 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d4>
    a5a2:	vadd.f32	s14, s14, s12
    a5a6:	vcvt.s32.f32	s12, s14
    a5aa:	vmov	r2, s12
    a5ae:	vcvt.f32.s32	s12, s12
    a5b2:	vsub.f32	s14, s14, s12
    a5b6:	vmov.f32	s12, s14
    a5ba:	vcvt.s32.f32	s12, s12, #8
    a5be:	vmov	r3, s12
    a5c2:	b.w	9576 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x112>
    a5c6:	vldr	s12, [pc, #112]	; a638 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d4>
    a5ca:	vadd.f32	s13, s13, s12
    a5ce:	vcvt.s32.f32	s12, s13
    a5d2:	vmov	r2, s12
    a5d6:	vcvt.f32.s32	s12, s12
    a5da:	vsub.f32	s13, s13, s12
    a5de:	vmov.f32	s12, s13
    a5e2:	vcvt.s32.f32	s12, s12, #8
    a5e6:	vmov	r3, s12
    a5ea:	b.w	951a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb6>
    a5ee:	vldr	s13, [pc, #72]	; a638 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d4>
    a5f2:	vadd.f32	s15, s15, s13
    a5f6:	vcvt.s32.f32	s13, s15
    a5fa:	vmov	r2, s13
    a5fe:	vcvt.f32.s32	s13, s13
    a602:	vsub.f32	s15, s15, s13
    a606:	vmov.f32	s13, s15
    a60a:	vcvt.s32.f32	s13, s13, #8
    a60e:	vmov	r3, s13
    a612:	b.w	94be <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5a>
    } else {
      CONSTRAIN(pw, frequency * 2.0f, 1.0f - 2.0f * frequency);
    a616:	vmov.f32	s14, #112	; 0x3f800000  1.0
    a61a:	vsub.f32	s15, s14, s15
    a61e:	vcmpe.f32	s13, s15
    a622:	vmrs	APSR_nzcv, fpscr
    a626:	it	le
    a628:	vmovle.f32	s15, s13
    a62c:	b.n	a22e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdca>
    a62e:	nop
    a630:	.word	0x00000000
    a634:	.word	0x3f99999a
    a638:	.word	0x43000000
    a63c:	.word	0x00000000
    a640:	.word	0x3e99999a
    a644:	vmov.f32	s13, #112	; 0x3f800000  1.0
    a648:	vsub.f32	s14, s13, s14
    a64c:	vcmpe.f32	s12, s14
    a650:	vmrs	APSR_nzcv, fpscr
    a654:	it	le
    a656:	vmovle.f32	s14, s12
    a65a:	b.n	9f44 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xae0>
    a65c:	vldr	s14, [pc, #-40]	; a638 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d4>
    a660:	vadd.f32	s15, s15, s14
    a664:	vcvt.s32.f32	s14, s15
    a668:	vmov	r2, s14
    a66c:	vcvt.f32.s32	s14, s14
    a670:	vsub.f32	s15, s15, s14
    a674:	vmov.f32	s14, s15
    a678:	vcvt.s32.f32	s14, s14, #8
    a67c:	vmov	r3, s14
    a680:	b.n	9ee6 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa82>
      parameters.note + sync_amount * 48.0f);
  const float auxiliary_sync_f = NoteToFrequency(
      parameters.note + auxiliary_detune + sync_amount * 48.0f);

  float shape = parameters.morph * 1.5f;
  CONSTRAIN(shape, 0.0f, 1.0f);
    a682:	vldr	s30, [pc, #-72]	; a63c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d8>
    a686:	b.w	963a <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1d6>
      : 1.0f - (parameters.morph - 0.5f) * 2.0f;
  saw_pw *= 1.1f;
  CONSTRAIN(saw_pw, 0.005f, 1.0f);
    
  float saw_shape = 10.0f - 21.0f * parameters.morph;
  CONSTRAIN(saw_shape, 0.0f, 1.0f);
    a68a:	vldr	s30, [pc, #-80]	; a63c <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d8>
    a68e:	b.w	9d86 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x922>
    a692:	vldr	s15, [pc, #-84]	; a640 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11dc>
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
      return __a;
    a696:	vstr	s14, [sp, #16]
    a69a:	vmul.f32	s15, s14, s15
    a69e:	vstr	s15, [sp, #20]
    a6a2:	b.w	9d12 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8ae>
    a6a6:	vmov.f32	s15, #96	; 0x3f000000  0.5
    a6aa:	vmul.f32	s15, s14, s15
    a6ae:	vstr	s15, [sp, #24]
    a6b2:	b.w	9ea2 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa3e>
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    }
    
    if (frequency >= 0.25f) {
      pw = 0.5f;
    a6b6:	vmov.f32	s15, #96	; 0x3f000000  0.5
    a6ba:	b.w	96ae <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x24a>
    a6be:	vmov.f32	s14, #96	; 0x3f000000  0.5
    a6c2:	b.n	9f44 <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xae0>
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    }
    
    if (frequency >= 0.25f) {
      pw = 0.5f;
    a6c4:	vmov.f32	s15, #96	; 0x3f000000  0.5
    a6c8:	b.n	a22e <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdca>
    a6ca:	vmov.f32	s14, #96	; 0x3f000000  0.5
    a6ce:	b.w	99ba <plaits::VirtualAnalogEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x556>
    a6d2:	nop

0000a6d4 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace std;
using namespace stmlib;

void ParticleEngine::Init(BufferAllocator* allocator) {
    a6d4:	push	{r4, r5, r6, r7}
 public:
  Particle() { }
  ~Particle() { }

  inline void Init() {
    pre_gain_ = 0.0f;
    a6d6:	movs	r2, #0
    a6d8:	mov	r3, r0
    a6da:	add.w	r7, r0, #144	; 0x90

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    a6de:	ldr	r6, [pc, #116]	; (a754 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x80>)
    r_ = 1.0f / resonance;
    a6e0:	ldr	r5, [pc, #116]	; (a758 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x84>)
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    a6e2:	ldr	r4, [pc, #120]	; (a75c <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x88>)
    a6e4:	str	r2, [r3, #16]
    a6e6:	adds	r3, #24

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    a6e8:	str.w	r6, [r3, #-4]
    r_ = 1.0f / resonance;
    a6ec:	str	r5, [r3, #0]
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    a6ee:	str	r4, [r3, #4]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    a6f0:	str	r2, [r3, #12]
    a6f2:	str	r2, [r3, #8]
  for (int i = 0; i < kNumParticles; ++i) {
    a6f4:	cmp	r3, r7
    a6f6:	bne.n	a6e4 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x10>
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    a6f8:	ldr	r3, [r1, #8]
    a6fa:	cmp.w	r3, #16384	; 0x4000
    a6fe:	bcc.n	a74e <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x7a>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    a700:	ldr	r2, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    a702:	sub.w	r3, r3, #16384	; 0x4000
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    a706:	add.w	r4, r2, #16384	; 0x4000
      free_ -= size_bytes;
    a70a:	str	r3, [r1, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    a70c:	str	r4, [r1, #0]
  ~Diffuser() { }
  
  void Init(uint16_t* buffer) {
    engine_.Init(buffer);
    engine_.SetLFOFrequency(LFO_1, 0.3f / 48000.0f);
    lp_decay_ = 0.0f;
    a70e:	movs	r3, #0
    initial_amplitude_ = iir_coefficient_ * 0.25f;
  }
  
  inline void Start() {
    y1_ = initial_amplitude_;
    y0_ = 0.5f;
    a710:	mov.w	r7, #1056964608	; 0x3f000000
        frequency -= 0.5f;
      } else {
        sign = -16.0f;
      }
    }
    iir_coefficient_ = sign * frequency * (1.0f - 2.0f * frequency);
    a714:	ldr	r6, [pc, #72]	; (a760 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x8c>)
    initial_amplitude_ = iir_coefficient_ * 0.25f;
    a716:	ldr	r1, [pc, #76]	; (a764 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x90>)

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    a718:	ldr	r5, [pc, #56]	; (a754 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x80>)
    r_ = 1.0f / resonance;
    a71a:	ldr	r4, [pc, #60]	; (a758 <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x84>)
  typedef typename DataType<format>::T T;
  FxEngine() { }
  ~FxEngine() { }

  void Init(T* buffer) {
    buffer_ = buffer;
    a71c:	str.w	r2, [r0, #164]	; 0xa4
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    a720:	ldr	r2, [pc, #56]	; (a75c <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x88>)
  }
  
  inline void Start() {
    y1_ = initial_amplitude_;
    y0_ = 0.5f;
    a722:	str.w	r7, [r0, #172]	; 0xac
        frequency -= 0.5f;
      } else {
        sign = -16.0f;
      }
    }
    iir_coefficient_ = sign * frequency * (1.0f - 2.0f * frequency);
    a726:	str.w	r6, [r0, #176]	; 0xb0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    a72a:	str.w	r5, [r0, #204]	; 0xcc
    r_ = 1.0f / resonance;
    a72e:	str.w	r4, [r0, #208]	; 0xd0
    initial_amplitude_ = iir_coefficient_ * 0.25f;
    a732:	str.w	r1, [r0, #180]	; 0xb4
  }
  
  inline void Start() {
    y1_ = initial_amplitude_;
    a736:	str.w	r1, [r0, #168]	; 0xa8
    a73a:	str.w	r3, [r0, #200]	; 0xc8
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    a73e:	str.w	r3, [r0, #220]	; 0xdc
    a742:	str.w	r3, [r0, #216]	; 0xd8
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    a746:	str.w	r2, [r0, #212]	; 0xd4
    particle_[i].Init();
  }
  diffuser_.Init(allocator->Allocate<uint16_t>(8192));
  post_filter_.Init();
}
    a74a:	pop	{r4, r5, r6, r7}
    a74c:	bx	lr
      free_ -= size_bytes;
      return start;
    } else {
      return NULL;
    a74e:	movs	r2, #0
    a750:	b.n	a70e <plaits::ParticleEngine::Init(stmlib::BufferAllocator*)+0x3a>
    a752:	nop
    a754:	.word	0x3d00ba22
    a758:	.word	0x3c23d70a
    a75c:	.word	0x3f7faaca
    a760:	.word	0x3ffffff5
    a764:	.word	0x3efffff5

0000a768 <plaits::ParticleEngine::Reset()>:

void ParticleEngine::Reset() {
    a768:	ldr.w	r3, [r0, #164]	; 0xa4
    a76c:	push	{r4}
  }
  
  void Clear() {
    std::fill(&buffer_[0], &buffer_[size], 0);
    a76e:	add.w	r1, r3, #16384	; 0x4000
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    a772:	movs	r4, #0
    a774:	strh.w	r4, [r3], #2
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    a778:	cmp	r1, r3
	*__first = __tmp;
    a77a:	mov.w	r2, #0
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    a77e:	bne.n	a774 <plaits::ParticleEngine::Reset()+0xc>
    write_ptr_ = 0;
    a780:	str.w	r2, [r0, #160]	; 0xa0
  diffuser_.Clear();
}
    a784:	ldr.w	r4, [sp], #4
    a788:	bx	lr
    a78a:	nop

0000a78c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    a78c:	vmov.f32	s13, #34	; 0x41100000  9.0
    a790:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    a794:	vldr	s14, [pc, #928]	; ab38 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ac>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    a798:	vsub.f32	s15, s15, s13
void ParticleEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    a79c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    a7a0:	vcmpe.f32	s15, s14
    a7a4:	mov	sl, r0
    a7a6:	mov	r8, r3
    a7a8:	vmrs	APSR_nzcv, fpscr
    a7ac:	vpush	{d8-d11}
    a7b0:	sub	sp, #20
    a7b2:	str	r2, [sp, #0]
    a7b4:	ldr.w	r9, [sp, #88]	; 0x58
    a7b8:	bmi.n	a7d0 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>
    a7ba:	vldr	s14, [pc, #896]	; ab3c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b0>
    a7be:	vcmpe.f32	s15, s14
    a7c2:	vmrs	APSR_nzcv, fpscr
    a7c6:	ble.w	af7c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7f0>
    a7ca:	movs	r3, #0
    a7cc:	movs	r2, #255	; 0xff
    a7ce:	b.n	a7d4 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48>
    a7d0:	movs	r3, #0
    a7d2:	mov	r2, r3
  const float f0 = NoteToFrequency(parameters.note);
  const float density_sqrt = NoteToFrequency(
      60.0f + parameters.timbre * parameters.timbre * 72.0f);
    a7d4:	vldr	s14, [r1, #8]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    a7d8:	vmov.f32	s11, #34	; 0x41100000  9.0
    a7dc:	vldr	s13, [pc, #864]	; ab40 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b4>
    a7e0:	vmul.f32	s14, s14, s14
    a7e4:	vldr	s15, [pc, #860]	; ab44 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b8>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    a7e8:	ldr.w	lr, [pc, #912]	; ab7c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f0>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    a7ec:	ldr.w	ip, [pc, #912]	; ab80 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f4>
    a7f0:	vfma.f32	s15, s14, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    a7f4:	vldr	s13, [pc, #832]	; ab38 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ac>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    a7f8:	add.w	r2, lr, r2, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    a7fc:	vldr	s12, [pc, #840]	; ab48 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3bc>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    a800:	add.w	r3, ip, r3, lsl #2
    a804:	vldr	s14, [r2]
    a808:	vldr	s6, [r3]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    a80c:	vsub.f32	s15, s15, s11
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    a810:	vmul.f32	s14, s14, s6

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    a814:	vcmpe.f32	s15, s13
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    a818:	vmul.f32	s6, s14, s12

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    a81c:	vmrs	APSR_nzcv, fpscr
    a820:	bmi.n	a838 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xac>
    a822:	vldr	s14, [pc, #792]	; ab3c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b0>
    a826:	vcmpe.f32	s15, s14
    a82a:	vmrs	APSR_nzcv, fpscr
    a82e:	ble.w	af56 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7ca>
    a832:	movs	r3, #0
    a834:	movs	r2, #255	; 0xff
    a836:	b.n	a83c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb0>
    a838:	movs	r3, #0
    a83a:	mov	r2, r3

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    a83c:	add.w	r2, lr, r2, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    a840:	vldr	s9, [pc, #772]	; ab48 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3bc>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    a844:	add.w	r3, ip, r3, lsl #2
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
  const float gain = 1.0f / density;
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
    a848:	vmov.f32	s13, #96	; 0x3f000000  0.5
    a84c:	vldr	s14, [r2]
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float density_sqrt = NoteToFrequency(
      60.0f + parameters.timbre * parameters.timbre * 72.0f);
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
  const float gain = 1.0f / density;
    a850:	vmov.f32	s11, #112	; 0x3f800000  1.0
    a854:	vldr	s15, [r3]
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
    a858:	vldr	s12, [r1, #12]
    a85c:	vmul.f32	s15, s14, s15
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float density_sqrt = NoteToFrequency(
      60.0f + parameters.timbre * parameters.timbre * 72.0f);
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
    a860:	vldr	s10, [pc, #744]	; ab4c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
  const float gain = 1.0f / density;
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
    a864:	vcmpe.f32	s12, s13
      ? (parameters.morph - 0.5f) * 120.0f
    a868:	vsub.f32	s13, s12, s13
    a86c:	vmul.f32	s15, s15, s9
  const float f0 = NoteToFrequency(parameters.note);
  const float density_sqrt = NoteToFrequency(
      60.0f + parameters.timbre * parameters.timbre * 72.0f);
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
  const float gain = 1.0f / density;
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
    a870:	vmrs	APSR_nzcv, fpscr
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float density_sqrt = NoteToFrequency(
      60.0f + parameters.timbre * parameters.timbre * 72.0f);
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
    a874:	vmul.f32	s15, s15, s15
    a878:	vmul.f32	s10, s15, s10
  const float gain = 1.0f / density;
    a87c:	vdiv.f32	s8, s11, s10
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
    a880:	bge.w	af2c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a0>
    a884:	movs	r3, #0
    a886:	movs	r2, #128	; 0x80

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    a888:	add.w	r2, lr, r2, lsl #2
      ? (parameters.morph - 0.5f) * 120.0f
      : 0.0f);
  const float q = 0.5f + q_sqrt * q_sqrt;
  const float spread = 48.0f * parameters.harmonics * parameters.harmonics;
    a88c:	vldr	s5, [r1, #16]
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    a890:	add.w	r3, ip, r3, lsl #2
    a894:	vldr	s14, [pc, #696]	; ab50 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c4>
    a898:	vldr	s15, [r2]
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
  const float gain = 1.0f / density;
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
      ? (parameters.morph - 0.5f) * 120.0f
      : 0.0f);
  const float q = 0.5f + q_sqrt * q_sqrt;
    a89c:	vmov.f32	s11, #96	; 0x3f000000  0.5
    a8a0:	vldr	s9, [r3]
  const float spread = 48.0f * parameters.harmonics * parameters.harmonics;
    a8a4:	vmul.f32	s14, s5, s14
    a8a8:	vmul.f32	s15, s15, s9
  const float raw_diffusion_sqrt = 2.0f * fabsf(parameters.morph - 0.5f);
  const float raw_diffusion = raw_diffusion_sqrt * raw_diffusion_sqrt;
  const float diffusion = parameters.morph < 0.5f
      ? raw_diffusion
      : 0.0f;
    a8ac:	vcmpe.f32	s12, s11
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
  const float gain = 1.0f / density;
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
      ? (parameters.morph - 0.5f) * 120.0f
      : 0.0f);
  const float q = 0.5f + q_sqrt * q_sqrt;
    a8b0:	vmov.f32	s7, s11
  const float spread = 48.0f * parameters.harmonics * parameters.harmonics;
    a8b4:	vmul.f32	s5, s14, s5
  const float raw_diffusion_sqrt = 2.0f * fabsf(parameters.morph - 0.5f);
  const float raw_diffusion = raw_diffusion_sqrt * raw_diffusion_sqrt;
  const float diffusion = parameters.morph < 0.5f
      ? raw_diffusion
      : 0.0f;
    a8b8:	vmrs	APSR_nzcv, fpscr
  const float density = density_sqrt * density_sqrt * (1.0f / kNumParticles);
  const float gain = 1.0f / density;
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
      ? (parameters.morph - 0.5f) * 120.0f
      : 0.0f);
  const float q = 0.5f + q_sqrt * q_sqrt;
    a8bc:	vfma.f32	s7, s15, s15
  const float spread = 48.0f * parameters.harmonics * parameters.harmonics;
  const float raw_diffusion_sqrt = 2.0f * fabsf(parameters.morph - 0.5f);
  const float raw_diffusion = raw_diffusion_sqrt * raw_diffusion_sqrt;
  const float diffusion = parameters.morph < 0.5f
      ? raw_diffusion
      : 0.0f;
    a8c0:	bpl.w	af26 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x79a>
  const float q_sqrt = SemitonesToRatio(parameters.morph >= 0.5f
      ? (parameters.morph - 0.5f) * 120.0f
      : 0.0f);
  const float q = 0.5f + q_sqrt * q_sqrt;
  const float spread = 48.0f * parameters.harmonics * parameters.harmonics;
  const float raw_diffusion_sqrt = 2.0f * fabsf(parameters.morph - 0.5f);
    a8c4:	vabs.f32	s0, s13
    a8c8:	vadd.f32	s0, s0, s0
  const float raw_diffusion = raw_diffusion_sqrt * raw_diffusion_sqrt;
    a8cc:	vmul.f32	s0, s0, s0
  const float diffusion = parameters.morph < 0.5f
      ? raw_diffusion
      : 0.0f;
  const bool sync = parameters.trigger & TRIGGER_RISING_EDGE;
  
  fill(&out[0], &out[size], 0.0f);
    a8d0:	ldr	r3, [sp, #0]
    a8d2:	mov.w	r2, r9, lsl #2
    a8d6:	ldrb.w	fp, [r1]
    a8da:	adds	r1, r3, r2
    a8dc:	and.w	r0, fp, #1
    a8e0:	cmp	r3, r1
    a8e2:	mov	r4, r0
    a8e4:	beq.n	a8f2 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x166>
    a8e6:	ldr	r3, [sp, #0]
	*__first = __tmp;
    a8e8:	movs	r0, #0
    a8ea:	str.w	r0, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    a8ee:	cmp	r1, r3
    a8f0:	bne.n	a8ea <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x15e>
  fill(&aux[0], &aux[size], 0.0f);
    a8f2:	add	r2, r8
    a8f4:	cmp	r8, r2
    a8f6:	beq.n	a904 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x178>
    a8f8:	mov	r3, r8
	*__first = __tmp;
    a8fa:	movs	r1, #0
    a8fc:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    a900:	cmp	r2, r3
    a902:	bne.n	a8fc <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x170>
    a904:	add.w	r3, r9, #4294967295
    a908:	mov	r2, sl
    a90a:	add.w	fp, sl, #144	; 0x90
    a90e:	str.w	sl, [sp, #8]
    a912:	str	r3, [sp, #4]
    a914:	mov	sl, r4
    a916:	ldr	r3, [pc, #572]	; (ab54 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>)
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
    a918:	vldr	s9, [pc, #572]	; ab58 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3cc>
    a91c:	ldr	r1, [r3, #0]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    a91e:	vldr	s3, [pc, #648]	; aba8 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41c>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    a922:	vldr	s4, [pc, #568]	; ab5c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d0>
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
    a926:	ldr	r3, [pc, #568]	; (ab60 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d4>)
    a928:	mul.w	r3, r3, r1
    a92c:	ldr	r1, [pc, #564]	; (ab64 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d8>)
    a92e:	add	r1, r3
      float q,
      float* out,
      float* aux,
      size_t size) {
    float u = stmlib::Random::GetFloat();
    if (sync) {
    a930:	cmp.w	sl, #0
    a934:	bne.w	af0e <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x782>
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
    a938:	vmov	s15, r1
    a93c:	vcvt.f32.u32	s16, s15
    a940:	vmul.f32	s16, s16, s9
      u = density;
    }
    bool can_radomize_frequency = true;
    while (size--) {
    a944:	cmp.w	r9, #0
    a948:	beq.w	aac4 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x338>
    a94c:	ldr	r4, [sp, #0]
    a94e:	mov	r0, r8
    a950:	ldr	r3, [sp, #4]
    a952:	movs	r7, #1
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
    a954:	ldr	r6, [pc, #520]	; (ab60 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d4>)
    a956:	vldr	s1, [pc, #528]	; ab68 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3dc>
    a95a:	vldr	s2, [pc, #528]	; ab6c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e0>
    a95e:	b.n	aa34 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a8>
    a960:	vmul.f32	s14, s15, s1
    a964:	vmov.f32	s11, s2
    a968:	vfma.f32	s11, s15, s14
    a96c:	vmul.f32	s11, s11, s15
    a970:	vmul.f32	s12, s11, s11
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    a974:	vmov.f32	s13, #112	; 0x3f800000  1.0
              stmlib::SemitonesToRatio(spread * u) * frequency,
              0.25f);
          pre_gain_ = 0.5f / stmlib::Sqrt(q * f * stmlib::Sqrt(density));
          filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(f, q);
          // Keep the cutoff constant for this whole block.
          can_radomize_frequency = false;
    a978:	movs	r7, #0
    return sqrtf(x);
  }
#else
  inline float Sqrt(float x) {
    float result;
    __asm ("vsqrt.f32 %0, %1" : "=w" (result) : "w" (x) );
    a97a:	vmul.f32	s15, s7, s15

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    a97e:	vstr	s11, [r2, #20]
        if (can_radomize_frequency) {
          const float u = 2.0f * stmlib::Random::GetFloat() - 1.0f;
          const float f = std::min(
              stmlib::SemitonesToRatio(spread * u) * frequency,
              0.25f);
          pre_gain_ = 0.5f / stmlib::Sqrt(q * f * stmlib::Sqrt(density));
    a982:	vmov.f32	s18, #96	; 0x3f000000  0.5
    r_ = 1.0f / resonance;
    a986:	vdiv.f32	s16, s13, s7
    a98a:	vsqrt.f32	s14, s10
    a98e:	vmul.f32	s15, s15, s14
    a992:	vsqrt.f32	s15, s15
    a996:	vdiv.f32	s14, s18, s15
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    a99a:	vmov.f32	s15, s13
    a99e:	vfma.f32	s15, s16, s11
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    a9a2:	vstr	s16, [r2, #24]
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    a9a6:	vadd.f32	s12, s15, s12
    a9aa:	vstr	s14, [r2, #16]
    a9ae:	vdiv.f32	s15, s13, s12
    a9b2:	vstr	s15, [r2, #28]
          filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(f, q);
          // Keep the cutoff constant for this whole block.
          can_radomize_frequency = false;
        }
      }
      *aux++ += s;
    a9b6:	vldmia	r0!, {s15}
    a9ba:	mul.w	r5, r6, r1
    a9be:	ldr	r1, [pc, #420]	; (ab64 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d8>)
    float u = stmlib::Random::GetFloat();
    if (sync) {
      u = density;
    }
    bool can_radomize_frequency = true;
    while (size--) {
    a9c0:	subs	r3, #1
          filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(f, q);
          // Keep the cutoff constant for this whole block.
          can_radomize_frequency = false;
        }
      }
      *aux++ += s;
    a9c2:	vadd.f32	s15, s15, s17
    a9c6:	add	r1, r5
    float u = stmlib::Random::GetFloat();
    if (sync) {
      u = density;
    }
    bool can_radomize_frequency = true;
    while (size--) {
    a9c8:	adds	r5, r3, #1
          filter_.set_f_q<stmlib::FREQUENCY_DIRTY>(f, q);
          // Keep the cutoff constant for this whole block.
          can_radomize_frequency = false;
        }
      }
      *aux++ += s;
    a9ca:	vstr	s15, [r0, #-4]
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
    a9ce:	vmov	s15, r1
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    a9d2:	vldr	s13, [r2, #32]
    a9d6:	vcvt.f32.u32	s16, s15
    a9da:	vldr	s15, [r2, #24]
    a9de:	vldr	s18, [r2, #16]
    a9e2:	vnmul.f32	s15, s15, s13
    a9e6:	vldr	s11, [r2, #20]
    a9ea:	vldr	s12, [r2, #36]	; 0x24
    a9ee:	vmul.f32	s16, s16, s9
    a9f2:	vldr	s14, [r2, #28]
    a9f6:	vfma.f32	s15, s17, s18
    a9fa:	vfms.f32	s15, s13, s11
    a9fe:	vsub.f32	s15, s15, s12
    aa02:	vmul.f32	s15, s15, s14
    bp = g_ * hp + state_1_;
    aa06:	vmov.f32	s14, s13
    aa0a:	vfma.f32	s14, s11, s15
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    aa0e:	vfma.f32	s12, s11, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    aa12:	vmov.f32	s13, s14
    aa16:	vfma.f32	s13, s11, s15
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    aa1a:	vfma.f32	s12, s11, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    aa1e:	vstr	s13, [r2, #32]
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    aa22:	vstr	s12, [r2, #36]	; 0x24
      *out++ += filter_.Process<stmlib::FILTER_MODE_BAND_PASS>(pre_gain_ * s);
    aa26:	vldmia	r4!, {s15}
    aa2a:	vadd.f32	s14, s15, s14
    aa2e:	vstr	s14, [r4, #-4]
    float u = stmlib::Random::GetFloat();
    if (sync) {
      u = density;
    }
    bool can_radomize_frequency = true;
    while (size--) {
    aa32:	beq.n	aac4 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x338>
      float s = 0.0f;
      if (u <= density) {
    aa34:	vcmpe.f32	s10, s16
    if (sync) {
      u = density;
    }
    bool can_radomize_frequency = true;
    while (size--) {
      float s = 0.0f;
    aa38:	vldr	s17, [pc, #356]	; aba0 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x414>
      if (u <= density) {
    aa3c:	vmrs	APSR_nzcv, fpscr
    aa40:	blt.n	a9b6 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22a>
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
    aa42:	mul.w	r5, r6, r1

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    aa46:	vmov.f32	s13, #0	; 0x40000000  2.0
    aa4a:	vmov.f32	s15, #240	; 0xbf800000 -1.0
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    aa4e:	vmov.f32	s18, #80	; 0x3e800000  0.250
        s = u * gain;
    aa52:	vmul.f32	s17, s8, s16
        if (can_radomize_frequency) {
    aa56:	cmp	r7, #0
    aa58:	beq.n	a9b6 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22a>
    aa5a:	ldr	r1, [pc, #264]	; (ab64 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d8>)
    aa5c:	vldr	s11, [pc, #272]	; ab70 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e4>
    aa60:	add	r1, r5
    aa62:	vldr	s12, [pc, #272]	; ab74 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e8>
    aa66:	vmov	s14, r1
    aa6a:	vcvt.f32.u32	s14, s14
    aa6e:	vmul.f32	s14, s14, s9
    aa72:	vfma.f32	s15, s14, s13
    aa76:	vmov.f32	s14, s3
    aa7a:	vfma.f32	s14, s5, s15
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    aa7e:	vcvt.s32.f32	s15, s14

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    aa82:	vcvt.f32.s32	s13, s15

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    aa86:	vmov	r5, s15
    aa8a:	add.w	r5, lr, r5, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    aa8e:	vsub.f32	s14, s14, s13
          const float u = 2.0f * stmlib::Random::GetFloat() - 1.0f;
          const float f = std::min(
              stmlib::SemitonesToRatio(spread * u) * frequency,
    aa92:	vldr	s15, [r5]
    aa96:	vmul.f32	s14, s14, s4
    aa9a:	vcvt.s32.f32	s14, s14
    aa9e:	vmov	r5, s14
    aaa2:	add.w	r5, ip, r5, lsl #2
    aaa6:	vldr	s14, [r5]
    aaaa:	vmul.f32	s15, s14, s15
    aaae:	vmul.f32	s15, s15, s6
    aab2:	vcmpe.f32	s15, s18
    aab6:	vmrs	APSR_nzcv, fpscr
    aaba:	ble.w	a960 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1d4>
	return __b;
    aabe:	vmov.f32	s15, s18
    aac2:	b.n	a974 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1e8>
    aac4:	adds	r2, #24
  
  for (int i = 0; i < kNumParticles; ++i) {
    aac6:	cmp	fp, r2
    aac8:	bne.w	a926 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x19a>
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    aacc:	vldr	s15, [pc, #168]	; ab78 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ec>
    aad0:	ldr	r3, [pc, #128]	; (ab54 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>)
    aad2:	vcmpe.f32	s6, s15
    aad6:	ldr.w	sl, [sp, #8]
    aada:	str	r1, [r3, #0]
    aadc:	vmrs	APSR_nzcv, fpscr
    aae0:	bgt.w	afa2 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x816>
    aae4:	vldr	s14, [pc, #128]	; ab68 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3dc>
    aae8:	vmov.f32	s13, #112	; 0x3f800000  1.0
    aaec:	vldr	s15, [pc, #124]	; ab6c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e0>
    aaf0:	vmov.f32	s12, #0	; 0x40000000  2.0
    aaf4:	vmul.f32	s14, s6, s14
    aaf8:	vfma.f32	s15, s6, s14
    aafc:	vmul.f32	s6, s15, s6
    ab00:	vmov.f32	s15, s13
    ab04:	vfma.f32	s15, s6, s12
    ab08:	vfma.f32	s15, s6, s6
    ab0c:	vdiv.f32	s14, s13, s15

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    ab10:	vstr	s6, [sl, #204]	; 0xcc
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    ab14:	vstr	s14, [sl, #212]	; 0xd4
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    ab18:	vldr	s12, [sl, #216]	; 0xd8
    float state_2 = state_2_;
    ab1c:	vldr	s13, [sl, #220]	; 0xdc
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    ab20:	vmov.f32	s10, #0	; 0x40000000  2.0
    ab24:	vstr	s10, [sl, #208]	; 0xd0
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    ab28:	cmp.w	r9, #0
    ab2c:	beq.w	af14 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x788>
    ab30:	ldmia.w	sp, {r2, r3}
    ab34:	b.n	abb8 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42c>
    ab36:	nop
    ab38:	.word	0xc3000000
    ab3c:	.word	0x42fe0000
    ab40:	.word	0x42900000
    ab44:	.word	0x42700000
    ab48:	.word	0x39962fc9
    ab4c:	.word	0x3e2aaaab
    ab50:	.word	0x42400000
    ab54:	.word	0x20020470
    ab58:	.word	0x2f800000
    ab5c:	.word	0x43800000
    ab60:	.word	0x0019660d
    ab64:	.word	0x3c6ef35f
    ab68:	.word	0x413957d7
    ab6c:	.word	0x40490fdb
    ab70:	.word	0x3f7765d1
    ab74:	.word	0x3f6f15a2
    ab78:	.word	0x3efae148
    ab7c:	.word	0x20000554
    ab80:	.word	0x20000958
    ab84:	.word	0x3f4ccccd
    ab88:	.word	0x39800000
    ab8c:	.word	0x45800000
    ab90:	.word	0x422c0000
    ab94:	.word	0x43c80000
    ab98:	.word	0x43aa0000
    ab9c:	.word	0x453fe000
    aba0:	.word	0x00000000
    aba4:	.word	0x42f00000
    aba8:	.word	0x43000000
    abac:	vldr	s10, [sl, #208]	; 0xd0
    abb0:	vldr	s6, [sl, #204]	; 0xcc
    abb4:	vldr	s14, [sl, #212]	; 0xd4
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    abb8:	vneg.f32	s11, s12
    abbc:	vldr	s15, [r2]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    abc0:	subs	r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    abc2:	vfma.f32	s15, s11, s10
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    abc6:	adds	r0, r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    abc8:	vfma.f32	s15, s11, s6
    abcc:	vsub.f32	s15, s15, s13
    abd0:	vmul.f32	s15, s15, s14
      bp = g_ * hp + state_1;
    abd4:	vmov.f32	s14, s12
    abd8:	vfma.f32	s14, s15, s6
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    abdc:	vfma.f32	s13, s14, s6
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    abe0:	vmov.f32	s12, s14
    abe4:	vfma.f32	s12, s15, s6
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
    abe8:	vstmia	r2!, {s13}
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    abec:	vfma.f32	s13, s14, s6
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    abf0:	bne.n	abac <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x420>
  }
  
  post_filter_.set_f_q<FREQUENCY_DIRTY>(min(f0, 0.49f), 0.5f);
  post_filter_.Process<FILTER_MODE_LOW_PASS>(out, out, size);
  
  diffuser_.Process(
    abf2:	vldr	s15, [pc, #-112]	; ab84 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f8>
    abf6:	vmov.f32	s14, #96	; 0x3f000000  0.5
    abfa:	vmov.f32	s8, #80	; 0x3e800000  0.250
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    abfe:	vstr	s12, [sl, #216]	; 0xd8
    ac02:	vmul.f32	s15, s0, s15
    state_2_ = state_2;
    ac06:	vstr	s13, [sl, #220]	; 0xdc
    y0_ = 0.5f;
  }
  
  inline float value() const {
    return y1_ + 0.5f;
    ac0a:	vmov.f32	s3, s14
    E::DelayLine<Memory, 5> dapb;
    E::DelayLine<Memory, 6> del;
    E::Context c;
    const float kap = 0.625f;
    const float klp = 0.75f;
    float lp = lp_decay_;
    ac0e:	vldr	s9, [sl, #200]	; 0xc8
    ac12:	vfma.f32	s8, s0, s14
    ac16:	ldr.w	r3, [sl, #160]	; 0xa0
    ac1a:	vmul.f32	s0, s15, s0
    ac1e:	ldr.w	r2, [sl, #164]	; 0xa4
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ac22:	vldr	s13, [pc, #-156]	; ab88 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3fc>
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ac26:	vmov.f32	s11, #100	; 0x3f200000  0.625
    ac2a:	vldr	s2, [pc, #-140]	; aba0 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x414>
    }
  }
#else
  inline int32_t Clip16(int32_t x) {
    int32_t result;
    __asm ("ssat %0, %1, %2" : "=r" (result) :  "I" (16), "r" (x) );
    ac2e:	vldr	s12, [pc, #-164]	; ab8c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x400>
    
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
    ac32:	vldr	s4, [pc, #-164]	; ab90 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x404>
    ac36:	vldr	s5, [pc, #-164]	; ab94 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x408>
    ac3a:	vldr	s6, [pc, #-164]	; ab98 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40c>
    ac3e:	vldr	s7, [pc, #-164]	; ab9c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x410>
    ac42:	ldr.w	r8, [sp, #4]
    ac46:	ldr.w	r9, [sp]
    ac4a:	b.n	aec6 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x73a>
    ac4c:	vldr	s1, [sl, #168]	; 0xa8
    ac50:	vadd.f32	s1, s1, s3
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ac54:	add.w	r1, r3, #125	; 0x7d
    while (size--) {
      float wet;
      engine_.Start(&c);
      c.Read(*in_out);
    ac58:	vldr	s10, [r9]
    
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
    ac5c:	vmov.f32	s15, s5
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ac60:	add.w	r4, r3, #306	; 0x132
    ac64:	ubfx	r1, r1, #0, #13
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ac68:	vadd.f32	s22, s10, s2
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ac6c:	ubfx	fp, r3, #0, #13
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ac70:	ubfx	r4, r4, #0, #13
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ac74:	ldrsh.w	r1, [r2, r1, lsl #1]
    
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
    ac78:	vfma.f32	s15, s1, s4
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ac7c:	vmov.f32	s16, #228	; 0xbf200000 -0.625
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ac80:	add.w	lr, r3, #127	; 0x7f
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ac84:	vmov	s20, r1
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ac88:	add.w	r1, r3, #308	; 0x134
    
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
    ac8c:	vmov.f32	s19, s7
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ac90:	add.w	r0, r3, #576	; 0x240
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ac94:	vcvt.f32.s32	s20, s20
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ac98:	ubfx	r1, r1, #0, #13
    ac9c:	ubfx	lr, lr, #0, #13
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    aca0:	ubfx	r0, r0, #0, #13
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
    aca4:	vcvt.s32.f32	s17, s15
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    aca8:	str	r1, [sp, #0]
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    acaa:	vmul.f32	s20, s20, s13
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    acae:	addw	r1, r3, #578	; 0x242
    
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
    acb2:	vfma.f32	s19, s1, s6
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
    acb6:	movw	r7, #4689	; 0x1251
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    acba:	ubfx	r5, r1, #0, #13
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    acbe:	vcvt.f32.s32	s14, s17
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    acc2:	vfma.f32	s22, s20, s11
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
    acc6:	vmov	r1, s17
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    acca:	str	r5, [sp, #4]
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
    accc:	movw	r6, #4688	; 0x1250
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    acd0:	vsub.f32	s14, s15, s14
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
    acd4:	add	r1, r3
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    acd6:	vmov.f32	s15, s20
    E::DelayLine<Memory, 6> del;
    E::Context c;
    const float kap = 0.625f;
    const float klp = 0.75f;
    float lp = lp_decay_;
    while (size--) {
    acda:	add.w	r8, r8, #4294967295
    template<typename D>
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
    acde:	vcvt.s32.f32	s21, s19
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
    ace2:	addw	ip, r1, #579	; 0x243
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
    ace6:	addw	r1, r1, #578	; 0x242
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    acea:	vmov.f32	s18, #104	; 0x3f400000  0.750
    acee:	vmul.f32	s23, s22, s12
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
    acf2:	ubfx	ip, ip, #0, #13
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    acf6:	vfma.f32	s15, s22, s16
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
    acfa:	ubfx	r1, r1, #0, #13
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    acfe:	vcvt.f32.s32	s20, s21
    ad02:	cmp.w	r8, #4294967295
    ad06:	vcvt.s32.f32	s17, s23
      c.WriteAllPass(dapa, kap);
      c.Read(dapb TAIL, kap);
      c.WriteAllPass(dapb, -kap);
      c.Write(del, 2.0f);
      c.Write(wet, 0.0f);
      *in_out += amount * (wet - *in_out);
    ad0a:	vmov.f32	s1, #0	; 0x40000000  2.0
    ad0e:	vsub.f32	s19, s19, s20
    ad12:	vmov	r5, s17
    ad16:	ssat	r5, #16, r5
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad1a:	strh.w	r5, [r2, fp, lsl #1]
    ad1e:	addw	r5, r3, #1023	; 0x3ff
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad22:	ldrsh.w	r4, [r2, r4, lsl #1]
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad26:	ubfx	r5, r5, #0, #13
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad2a:	vmov	s17, r4
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
    ad2e:	vmov	r4, s21
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad32:	vcvt.f32.s32	s17, s17
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
    ad36:	add	r4, r3
      float b = DataType<format>::Decompress(
    ad38:	add	r7, r4
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
    ad3a:	add	r6, r4
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad3c:	vmul.f32	s17, s17, s13
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ad40:	addw	r4, r3, #2675	; 0xa73
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
    ad44:	ubfx	r7, r7, #0, #13
    inline void Interpolate(
        D& d, float offset, LFOIndex index, float amplitude, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      offset += amplitude * lfo_value_[index];
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
    ad48:	ubfx	r6, r6, #0, #13
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ad4c:	ubfx	r4, r4, #0, #13
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ad50:	vfma.f32	s15, s17, s11
    template<typename D>
    inline void Read(D& d, int32_t offset, float scale) {
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T r;
      if (offset == -1) {
        r = buffer_[(write_ptr_ + D::base + D::length - 1) & MASK];
    ad54:	str	r4, [sp, #8]
    ad56:	movw	r4, #4686	; 0x124e
    ad5a:	add	r4, r3
    ad5c:	ubfx	r4, r4, #0, #13
    ad60:	vmul.f32	s20, s15, s12
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ad64:	vfma.f32	s17, s15, s16
    ad68:	vcvt.s32.f32	s15, s20
    ad6c:	vmov	fp, s15
    ad70:	ssat	fp, #16, fp
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad74:	strh.w	fp, [r2, lr, lsl #1]
    ad78:	addw	fp, r3, #2677	; 0xa75
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad7c:	ldrsh.w	lr, [r2, r0, lsl #1]
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad80:	movw	r0, #4688	; 0x1250
    ad84:	ubfx	fp, fp, #0, #13
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad88:	vmov	s15, lr
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad8c:	add	r0, r3
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad8e:	vcvt.f32.s32	s15, s15
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad92:	ubfx	r0, r0, #0, #13
    ad96:	str	r0, [sp, #12]
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ad98:	vmul.f32	s15, s15, s13
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ad9c:	ldr	r0, [sp, #0]
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ad9e:	vfma.f32	s17, s15, s11
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
      previous_read_ = x;
      accumulator_ += x * scale;
    ada2:	vfma.f32	s15, s17, s16
    ada6:	vmul.f32	s20, s17, s12
    adaa:	vmov.f32	s17, s15
    adae:	vcvt.s32.f32	s15, s20
    adb2:	vmov	lr, s15
    adb6:	ssat	lr, #16, lr
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    adba:	strh.w	lr, [r2, r0, lsl #1]
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    adbe:	ldrsh.w	lr, [r2, ip, lsl #1]
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    adc2:	ldr	r0, [sp, #4]
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    adc4:	vmov	s15, lr
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    adc8:	ldrsh.w	lr, [r2, r1, lsl #1]
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    adcc:	vcvt.f32.s32	s15, s15
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    add0:	vmov	s20, lr
    add4:	vcvt.f32.s32	s20, s20
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    add8:	vmul.f32	s15, s15, s13
    addc:	vfms.f32	s15, s20, s13
    ade0:	vmul.f32	s15, s15, s14
      previous_read_ = x;
      accumulator_ += x * scale;
    ade4:	vmov.f32	s14, s17
      MAKE_INTEGRAL_FRACTIONAL(offset);
      float a = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base) & MASK]);
      float b = DataType<format>::Decompress(
          buffer_[(write_ptr_ + offset_integral + D::base + 1) & MASK]);
      float x = a + (b - a) * offset_fractional;
    ade8:	vfma.f32	s15, s20, s13
      previous_read_ = x;
      accumulator_ += x * scale;
    adec:	vfma.f32	s14, s15, s11
    adf0:	vmul.f32	s17, s14, s12
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    adf4:	vfma.f32	s15, s14, s16
    adf8:	vcvt.s32.f32	s14, s17
    adfc:	vmov	r1, s14
    ae00:	ssat	r1, #16, r1
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ae04:	strh.w	r1, [r2, r0, lsl #1]
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    ae08:	ldrsh.w	r0, [r2, r7, lsl #1]
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae0c:	ldr	r1, [sp, #8]
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    ae0e:	vmov	s17, r0
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae12:	ldrsh.w	r0, [r2, r6, lsl #1]
    ae16:	ldrsh.w	r1, [r2, r1, lsl #1]
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    ae1a:	vcvt.f32.s32	s17, s17
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae1e:	vmov	s20, r0
    ae22:	vmov	s14, r1
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ae26:	ldr	r0, [sp, #12]
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae28:	vcvt.f32.s32	s20, s20
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    ae2c:	vmul.f32	s17, s17, s13
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae30:	vcvt.f32.s32	s14, s14
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    ae34:	vfms.f32	s17, s20, s13
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae38:	vmul.f32	s14, s14, s13
    inline void Read(D& d, float scale) {
      Read(d, 0, scale);
    }
    
    inline void Lp(float& state, float coefficient) {
      state += coefficient * (accumulator_ - state);
    ae3c:	vmul.f32	s17, s17, s19
    ae40:	vfma.f32	s17, s20, s13
    ae44:	vfma.f32	s15, s17, s8
    ae48:	vsub.f32	s15, s15, s9
    ae4c:	vfma.f32	s9, s15, s18
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ae50:	vmov.f32	s15, s9
    ae54:	vfma.f32	s15, s14, s16
    ae58:	vfma.f32	s14, s15, s11
    ae5c:	vmul.f32	s17, s15, s12
    ae60:	vmov.f32	s15, s14
    ae64:	vcvt.s32.f32	s14, s17
    ae68:	vmov	r1, s14
    ae6c:	ssat	r1, #16, r1
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    ae70:	strh.w	r1, [r2, r5, lsl #1]
template<>
struct DataType<FORMAT_12_BIT> {
  typedef uint16_t T;
  
  static inline float Decompress(T value) {
    return static_cast<float>(static_cast<int16_t>(value)) / 4096.0f;
    ae74:	ldrsh.w	r1, [r2, r4, lsl #1]
    ae78:	vmov	s14, r1
    ae7c:	vcvt.f32.s32	s14, s14
    ae80:	vmul.f32	s14, s14, s13
      } else {
        r = buffer_[(write_ptr_ + D::base + offset) & MASK];
      }
      float r_f = DataType<format>::Decompress(r);
      previous_read_ = r_f;
      accumulator_ += r_f * scale;
    ae84:	vfma.f32	s15, s14, s11
    }

    template<typename D>
    inline void WriteAllPass(D& d, int32_t offset, float scale) {
      Write(d, offset, scale);
      accumulator_ += previous_read_;
    ae88:	vfma.f32	s14, s15, s16
    ae8c:	vmul.f32	s15, s15, s12
    ae90:	vcvt.s32.f32	s15, s15
    ae94:	vmov	r1, s15
    ae98:	vmov.f32	s15, s10
    ae9c:	ssat	r1, #16, r1
      STATIC_ASSERT(D::base + D::length <= size, delay_memory_full);
      T w = DataType<format>::Compress(accumulator_);
      if (offset == -1) {
        buffer_[(write_ptr_ + D::base + D::length - 1) & MASK] = w;
      } else {
        buffer_[(write_ptr_ + D::base + offset) & MASK] = w;
    aea0:	strh.w	r1, [r2, fp, lsl #1]
    aea4:	vfnms.f32	s15, s14, s1
    aea8:	vmul.f32	s14, s14, s12
    aeac:	vcvt.s32.f32	s14, s14
    aeb0:	vfma.f32	s10, s15, s0
    aeb4:	vmov	r1, s14
    aeb8:	ssat	r1, #16, r1
    aebc:	strh.w	r1, [r2, r0, lsl #1]
    aec0:	vstmia	r9!, {s10}
    E::DelayLine<Memory, 6> del;
    E::Context c;
    const float kap = 0.625f;
    const float klp = 0.75f;
    float lp = lp_decay_;
    while (size--) {
    aec4:	beq.n	af18 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x78c>
    lfo_[index].template Init<stmlib::COSINE_OSCILLATOR_APPROXIMATE>(frequency * 32.0f);
  }
  
  inline void Start(Context* c) {
    --write_ptr_;
    if (write_ptr_ < 0) {
    aec6:	subs	r3, #1
      write_ptr_ += size;
    aec8:	it	mi
    aeca:	addmi.w	r3, r3, #8192	; 0x2000
    }
    c->accumulator_ = 0.0f;
    c->previous_read_ = 0.0f;
    c->buffer_ = buffer_;
    c->write_ptr_ = write_ptr_;
    if ((write_ptr_ & 31) == 0) {
    aece:	lsls	r1, r3, #27
  }
  
  inline void Start(Context* c) {
    --write_ptr_;
    if (write_ptr_ < 0) {
      write_ptr_ += size;
    aed0:	str.w	r3, [sl, #160]	; 0xa0
    }
    c->accumulator_ = 0.0f;
    c->previous_read_ = 0.0f;
    c->buffer_ = buffer_;
    c->write_ptr_ = write_ptr_;
    if ((write_ptr_ & 31) == 0) {
    aed4:	bne.w	ac4c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4c0>
  }

  inline float Next() {
    float temp = y0_;
    aed8:	vldr	s10, [sl, #172]	; 0xac
    y0_ = iir_coefficient_ * y0_ - y1_;
    aedc:	vldr	s14, [sl, #168]	; 0xa8
    aee0:	vldr	s17, [sl, #176]	; 0xb0
    y1_ = temp;
    return temp + 0.5f;
    aee4:	vadd.f32	s1, s10, s3
  inline float value() const {
    return y1_ + 0.5f;
  }

  inline float Next() {
    float temp = y0_;
    aee8:	vldr	s16, [sl, #188]	; 0xbc
    y0_ = iir_coefficient_ * y0_ - y1_;
    aeec:	vldr	s15, [sl, #184]	; 0xb8
    aef0:	vfnms.f32	s14, s10, s17
    aef4:	vldr	s17, [sl, #192]	; 0xc0
    y1_ = temp;
    aef8:	vstr	s10, [sl, #168]	; 0xa8
    return y1_ + 0.5f;
  }

  inline float Next() {
    float temp = y0_;
    y0_ = iir_coefficient_ * y0_ - y1_;
    aefc:	vfnms.f32	s15, s16, s17
    y1_ = temp;
    af00:	vstr	s16, [sl, #184]	; 0xb8
    return y1_ + 0.5f;
  }

  inline float Next() {
    float temp = y0_;
    y0_ = iir_coefficient_ * y0_ - y1_;
    af04:	vstr	s14, [sl, #172]	; 0xac
    af08:	vstr	s15, [sl, #188]	; 0xbc
    af0c:	b.n	ac54 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4c8>
      float* out,
      float* aux,
      size_t size) {
    float u = stmlib::Random::GetFloat();
    if (sync) {
      u = density;
    af0e:	vmov.f32	s16, s10
    af12:	b.n	a944 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b8>
    E::DelayLine<Memory, 5> dapb;
    E::DelayLine<Memory, 6> del;
    E::Context c;
    const float kap = 0.625f;
    const float klp = 0.75f;
    float lp = lp_decay_;
    af14:	vldr	s9, [sl, #200]	; 0xc8
      c.Write(del, 2.0f);
      c.Write(wet, 0.0f);
      *in_out += amount * (wet - *in_out);
      ++in_out;
    }
    lp_decay_ = lp;
    af18:	vstr	s9, [sl, #200]	; 0xc8
      0.8f * diffusion * diffusion,
      0.5f * diffusion + 0.25f,
      out,
      size);
}
    af1c:	add	sp, #20
    af1e:	vpop	{d8-d11}
    af22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const float spread = 48.0f * parameters.harmonics * parameters.harmonics;
  const float raw_diffusion_sqrt = 2.0f * fabsf(parameters.morph - 0.5f);
  const float raw_diffusion = raw_diffusion_sqrt * raw_diffusion_sqrt;
  const float diffusion = parameters.morph < 0.5f
      ? raw_diffusion
      : 0.0f;
    af26:	vldr	s0, [pc, #-904]	; aba0 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x414>
    af2a:	b.n	a8d0 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x144>
    af2c:	vldr	s14, [pc, #-908]	; aba4 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x418>
    af30:	vldr	s15, [pc, #-908]	; aba8 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41c>
    af34:	vfma.f32	s15, s13, s14
    af38:	vcvt.s32.f32	s14, s15
    af3c:	vmov	r2, s14
    af40:	vcvt.f32.s32	s14, s14
    af44:	vsub.f32	s15, s15, s14
    af48:	vmov.f32	s14, s15
    af4c:	vcvt.s32.f32	s14, s14, #8
    af50:	vmov	r3, s14
    af54:	b.n	a888 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfc>
    af56:	vldr	s14, [pc, #-944]	; aba8 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41c>
    af5a:	vadd.f32	s15, s15, s14
    af5e:	vcvt.s32.f32	s14, s15
    af62:	vmov	r2, s14
    af66:	vcvt.f32.s32	s14, s14
    af6a:	vsub.f32	s15, s15, s14
    af6e:	vmov.f32	s14, s15
    af72:	vcvt.s32.f32	s14, s14, #8
    af76:	vmov	r3, s14
    af7a:	b.n	a83c <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb0>
    af7c:	vldr	s14, [pc, #44]	; afac <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x820>
    af80:	vadd.f32	s15, s15, s14
    af84:	vcvt.s32.f32	s14, s15
    af88:	vmov	r2, s14
    af8c:	vcvt.f32.s32	s14, s14
    af90:	vsub.f32	s15, s15, s14
    af94:	vmov.f32	s14, s15
    af98:	vcvt.s32.f32	s14, s14, #8
    af9c:	vmov	r3, s14
    afa0:	b.n	a7d4 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48>
    afa2:	vldr	s14, [pc, #12]	; afb0 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x824>
    afa6:	vldr	s6, [pc, #12]	; afb4 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x828>
    afaa:	b.n	ab10 <plaits::ParticleEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x384>
    afac:	.word	0x43000000
    afb0:	.word	0x3d867ebe
    afb4:	.word	0x4039bdfa

0000afb8 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)>:

namespace plaits {

using namespace stmlib;

void HiHatEngine::Init(BufferAllocator* allocator) {
    afb8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 public:
  SquareNoise() { }
  ~SquareNoise() { }

  void Init() {
    std::fill(&phase_[0], &phase_[6], 0);
    afbc:	add.w	r3, r0, #32
 public:
  HiHat() { }
  ~HiHat() { }

  void Init() {
    envelope_ = 0.0f;
    afc0:	movs	r5, #0
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    afc2:	movs	r4, #0
 public:
  SquareNoise() { }
  ~SquareNoise() { }

  void Init() {
    std::fill(&phase_[0], &phase_[6], 0);
    afc4:	add.w	r2, r0, #56	; 0x38
 public:
  HiHat() { }
  ~HiHat() { }

  void Init() {
    envelope_ = 0.0f;
    afc8:	str	r5, [r0, #16]
    noise_clock_ = 0.0f;
    afca:	str	r5, [r0, #20]
    noise_sample_ = 0.0f;
    afcc:	str	r5, [r0, #24]
    sustain_gain_ = 0.0f;
    afce:	str	r5, [r0, #28]
    afd0:	str.w	r4, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    afd4:	cmp	r2, r3
    afd6:	bne.n	afd0 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0x18>
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    afd8:	movs	r5, #0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    afda:	ldr	r6, [pc, #208]	; (b0ac <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xf4>)
    r_ = 1.0f / resonance;
    afdc:	ldr.w	r9, [pc, #212]	; b0b4 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xfc>
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    afe0:	mov.w	r4, #1056964608	; 0x3f000000
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    afe4:	ldr.w	r8, [pc, #208]	; b0b8 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0x100>
    next_sample_ = 0.0f;
    lp_state_ = 1.0f;
    afe8:	mov.w	ip, #1065353216	; 0x3f800000

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    afec:	str	r6, [r0, #56]	; 0x38
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    next_sample_ = 0.0f;
    afee:	mov	r2, r5
    aff0:	str	r6, [r0, #76]	; 0x4c
    aff2:	mov	r3, r0
    aff4:	add.w	lr, r0, #168	; 0xa8
    lp_state_ = 1.0f;
    hp_state_ = 0.0f;
    high_ = true;
    aff8:	movs	r7, #1

    frequency_ = 0.001f;
    affa:	ldr	r6, [pc, #180]	; (b0b0 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xf8>)
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    affc:	str	r5, [r0, #72]	; 0x48
    affe:	str	r5, [r0, #68]	; 0x44
    b000:	str	r5, [r0, #92]	; 0x5c
    b002:	str	r5, [r0, #88]	; 0x58
 public:
  HiHat() { }
  ~HiHat() { }

  void Init() {
    envelope_ = 0.0f;
    b004:	str	r5, [r0, #96]	; 0x60
    noise_clock_ = 0.0f;
    b006:	str	r5, [r0, #100]	; 0x64
    noise_sample_ = 0.0f;
    b008:	str	r5, [r0, #104]	; 0x68
    sustain_gain_ = 0.0f;
    b00a:	str	r5, [r0, #108]	; 0x6c
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    b00c:	str.w	r9, [r0, #60]	; 0x3c
    b010:	str.w	r9, [r0, #80]	; 0x50
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b014:	str.w	r8, [r0, #64]	; 0x40
    b018:	str.w	r8, [r0, #84]	; 0x54
 public:
  Oscillator() { }
  ~Oscillator() { }
  
  void Init() {
    phase_ = 0.5f;
    b01c:	str	r4, [r3, #112]	; 0x70
    b01e:	adds	r3, #28
    next_sample_ = 0.0f;
    b020:	str	r2, [r3, #88]	; 0x58
    b022:	movs	r5, #0
    lp_state_ = 1.0f;
    b024:	str.w	ip, [r3, #92]	; 0x5c
    hp_state_ = 0.0f;
    b028:	str	r2, [r3, #96]	; 0x60
    high_ = true;
    b02a:	strb.w	r7, [r3, #100]	; 0x64

    frequency_ = 0.001f;
    b02e:	str	r6, [r3, #104]	; 0x68
    pw_ = 0.5f;
    b030:	str	r4, [r3, #108]	; 0x6c
 public:
  RingModNoise() { }
  ~RingModNoise() { }

  void Init() {
    for (int i = 0; i < 6; ++i) {
    b032:	cmp	r3, lr
    b034:	bne.n	b01c <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0x64>
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    b036:	ldr	r2, [r1, #8]

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    b038:	ldr	r6, [pc, #112]	; (b0ac <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xf4>)
    r_ = 1.0f / resonance;
    b03a:	ldr	r4, [pc, #120]	; (b0b4 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xfc>)
    b03c:	cmp.w	r2, #512	; 0x200
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b040:	ldr	r3, [pc, #116]	; (b0b8 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0x100>)
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    b042:	str.w	r5, [r0, #296]	; 0x128
    b046:	str.w	r5, [r0, #292]	; 0x124
    b04a:	str.w	r5, [r0, #316]	; 0x13c
    b04e:	str.w	r5, [r0, #312]	; 0x138

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    b052:	str.w	r6, [r0, #280]	; 0x118
    b056:	str.w	r6, [r0, #300]	; 0x12c
    r_ = 1.0f / resonance;
    b05a:	str.w	r4, [r0, #284]	; 0x11c
    b05e:	str.w	r4, [r0, #304]	; 0x130
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b062:	str.w	r3, [r0, #288]	; 0x120
    b066:	str.w	r3, [r0, #308]	; 0x134
    b06a:	bcc.n	b09a <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xe2>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    b06c:	ldr	r4, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    b06e:	sub.w	r3, r2, #512	; 0x200
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    b072:	add.w	r5, r4, #512	; 0x200
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    b076:	cmp.w	r3, #512	; 0x200
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
      free_ -= size_bytes;
    b07a:	str	r3, [r1, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    b07c:	str	r5, [r1, #0]
  hi_hat_1_.Init();
  hi_hat_2_.Init();
  temp_buffer_[0] = allocator->Allocate<float>(kMaxBlockSize);
    b07e:	str.w	r4, [r0, #320]	; 0x140
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    b082:	bcc.n	b0a8 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xf0>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    b084:	ldr	r3, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    b086:	sub.w	r2, r2, #1024	; 0x400
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    b08a:	add.w	r4, r3, #512	; 0x200
      free_ -= size_bytes;
    b08e:	str	r2, [r1, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    b090:	str	r4, [r1, #0]
  temp_buffer_[1] = allocator->Allocate<float>(kMaxBlockSize);
    b092:	str.w	r3, [r0, #324]	; 0x144
}
    b096:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
using namespace stmlib;

void HiHatEngine::Init(BufferAllocator* allocator) {
  hi_hat_1_.Init();
  hi_hat_2_.Init();
  temp_buffer_[0] = allocator->Allocate<float>(kMaxBlockSize);
    b09a:	movs	r3, #0
    b09c:	str.w	r3, [r0, #320]	; 0x140
  temp_buffer_[1] = allocator->Allocate<float>(kMaxBlockSize);
    b0a0:	str.w	r3, [r0, #324]	; 0x144
}
    b0a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      free_ -= size_bytes;
      return start;
    } else {
      return NULL;
    b0a8:	movs	r3, #0
    b0aa:	b.n	b092 <plaits::HiHatEngine::Init(stmlib::BufferAllocator*)+0xda>
    b0ac:	.word	0x3d00ba22
    b0b0:	.word	0x3a83126f
    b0b4:	.word	0x3c23d70a
    b0b8:	.word	0x3f7faaca

0000b0bc <plaits::HiHatEngine::Reset()>:

void HiHatEngine::Reset() {
    b0bc:	bx	lr
    b0be:	nop

0000b0c0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    b0c0:	vmov.f32	s13, #34	; 0x41100000  9.0
    b0c4:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    b0c8:	vldr	s14, [pc, #740]	; b3b0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f0>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    b0cc:	vsub.f32	s15, s15, s13
void HiHatEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    b0d0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    b0d4:	vcmpe.f32	s15, s14
    b0d8:	mov	r4, r0
    b0da:	mov	r7, r2
    b0dc:	mov	r6, r3
    b0de:	vmrs	APSR_nzcv, fpscr
    b0e2:	vpush	{d8-d14}
    b0e6:	sub	sp, #164	; 0xa4
    b0e8:	str	r1, [sp, #36]	; 0x24
    b0ea:	ldr	r5, [sp, #256]	; 0x100
    b0ec:	bmi.w	c388 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12c8>
    b0f0:	vldr	s14, [pc, #704]	; b3b4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f4>
    b0f4:	vcmpe.f32	s15, s14
    b0f8:	vmrs	APSR_nzcv, fpscr
    b0fc:	ble.w	b606 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x546>
    b100:	movs	r3, #0
    b102:	movs	r2, #255	; 0xff
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
    b104:	ldr	r0, [sp, #36]	; 0x24
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b106:	vmov.f32	s9, #112	; 0x3f800000  1.0

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b10a:	vldr	s15, [pc, #748]	; b3f8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x338>
    b10e:	vldr	s4, [r0, #12]
    b112:	vmov.f32	s11, s15
    b116:	vldr	s14, [pc, #672]	; b3b8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f8>
      float noisiness,
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
    b11a:	vneg.f32	s13, s4
    b11e:	vldr	s12, [pc, #668]	; b3bc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2fc>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b122:	ldr	r1, [pc, #668]	; (b3c0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x300>)
    b124:	vldr	s8, [pc, #668]	; b3c4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x304>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b128:	vfma.f32	s11, s13, s14
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b12c:	add.w	r3, r1, r3, lsl #2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b130:	vfma.f32	s15, s13, s12
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b134:	ldr	r1, [pc, #656]	; (b3c8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x308>)
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    b136:	vldr	s12, [r3]
    b13a:	add.w	r2, r1, r2, lsl #2
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  hi_hat_1_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
    b13e:	ldrb	r1, [r0, #0]
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
    b140:	vldr	s3, [r0, #20]
    b144:	and.w	r3, r1, #2
      f0,
      parameters.timbre,
      parameters.morph,
      parameters.harmonics,
    b148:	vldr	s0, [r0, #16]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b14c:	vmov.f32	s14, s11
    b150:	vldr	s11, [r2]
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    b154:	vcvt.s32.f32	s13, s15
    b158:	uxtb	r3, r3
    b15a:	vmul.f32	s12, s11, s12
  hi_hat_1_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
    b15e:	vldr	s11, [r0, #8]
    b162:	vcvt.s32.f32	s10, s14
    b166:	str	r3, [sp, #40]	; 0x28

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b168:	vcvt.f32.s32	s5, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b16c:	ldr	r3, [pc, #600]	; (b3c8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x308>)
        -decay * 84.0f);
    b16e:	vldr	s6, [pc, #604]	; b3cc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x30c>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b172:	vcvt.f32.s32	s2, s10

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b176:	vmov	r2, s10
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b17a:	vsub.f32	s15, s15, s5
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b17e:	vldr	s7, [pc, #592]	; b3d0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x310>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b182:	add.w	r3, r3, r2, lsl #2
    b186:	vmov	r2, s13
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b18a:	vsub.f32	s14, s14, s2
    b18e:	vldr	s1, [pc, #580]	; b3d4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x314>
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b192:	vldr	s10, [r3]
    b196:	vmul.f32	s15, s15, s8

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b19a:	ldr	r3, [pc, #556]	; (b3c8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x308>)
    b19c:	vmul.f32	s12, s12, s1
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b1a0:	vmul.f32	s14, s14, s8

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b1a4:	add.w	r3, r3, r2, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b1a8:	vcvt.s32.f32	s15, s15
    b1ac:	vmov.f32	s8, s9
    b1b0:	vcvt.s32.f32	s14, s14
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b1b4:	vldr	s13, [r3]
    b1b8:	ldr	r3, [pc, #516]	; (b3c0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x300>)
    b1ba:	vmov	r0, s15
    b1be:	vmov	r2, s14
    b1c2:	add.w	r2, r3, r2, lsl #2
    b1c6:	add.w	r3, r3, r0, lsl #2
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b1ca:	vldr	s14, [r2]
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b1ce:	vldr	s15, [r3]
    
    if (trigger) {
    b1d2:	ands.w	r3, r1, #1
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b1d6:	vnmul.f32	s14, s10, s14
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b1da:	vnmul.f32	s15, s13, s15
    
    if (trigger) {
    b1de:	str	r3, [sp, #64]	; 0x40
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b1e0:	vfma.f32	s8, s14, s6
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b1e4:	vmov.f32	s14, s9
    b1e8:	vfma.f32	s14, s15, s7
    b1ec:	vmov.f32	s7, s14
    
    if (trigger) {
    b1f0:	beq.n	b216 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x156>
      envelope_ = (1.5f + 0.5f * (1.0f - decay)) * (0.3f + 0.7f * accent);
    b1f2:	vsub.f32	s9, s9, s4
    b1f6:	vldr	s10, [pc, #480]	; b3d8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x318>
    b1fa:	vmov.f32	s13, #96	; 0x3f000000  0.5
    b1fe:	vldr	s14, [pc, #476]	; b3dc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x31c>
    b202:	vmov.f32	s15, #120	; 0x3fc00000  1.5
    b206:	vfma.f32	s14, s3, s10
    b20a:	vfma.f32	s15, s9, s13
    b20e:	vmul.f32	s15, s15, s14
    b212:	vstr	s15, [r4, #16]
    b216:	add.w	r3, r4, #28
    b21a:	add	r2, sp, #136	; 0x88
    
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratios[6] = {
        // Nominal f0: 414 Hz
        1.0f, 1.304f, 1.466f, 1.787f, 1.932f, 2.536f
    };
    b21c:	ldr.w	ip, [pc, #464]	; b3f0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x330>
    b220:	add.w	lr, sp, #88	; 0x58
    b224:	str	r3, [sp, #28]
    if (trigger) {
      envelope_ = (1.5f + 0.5f * (1.0f - decay)) * (0.3f + 0.7f * accent);
    }

    // Render the metallic noise.
    metallic_noise_.Render(2.0f * f0, temp_1, temp_2, out, size);
    b226:	vadd.f32	s5, s12, s12
    b22a:	str	r2, [sp, #32]
    b22c:	add.w	r8, sp, #88	; 0x58
  
    uint32_t increment[6];
    uint32_t phase[6];
    for (int i = 0; i < 6; ++i) {
      float f = f0 * ratios[i];
      if (f >= 0.499f) f = 0.499f;
    b230:	vldr	s14, [pc, #428]	; b3e0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x320>
    b234:	vldr	s13, [pc, #428]	; b3e4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x324>
    
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratios[6] = {
        // Nominal f0: 414 Hz
        1.0f, 1.304f, 1.466f, 1.787f, 1.932f, 2.536f
    };
    b238:	ldr.w	r9, [sp, #32]
    b23c:	ldmia.w	ip!, {r0, r1, r2, r3}
    b240:	stmia.w	lr!, {r0, r1, r2, r3}
    b244:	ldmia.w	ip, {r0, r1}
    b248:	ldr	r3, [sp, #28]
    b24a:	add	r2, sp, #112	; 0x70
    b24c:	stmia.w	lr, {r0, r1}
    b250:	add.w	lr, r4, #52	; 0x34
  
    uint32_t increment[6];
    uint32_t phase[6];
    for (int i = 0; i < 6; ++i) {
      float f = f0 * ratios[i];
    b254:	vldmia	r8!, {s15}
      if (f >= 0.499f) f = 0.499f;
    b258:	ldr	r1, [pc, #396]	; (b3e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x328>)
    };
  
    uint32_t increment[6];
    uint32_t phase[6];
    for (int i = 0; i < 6; ++i) {
      float f = f0 * ratios[i];
    b25a:	vmul.f32	s15, s5, s15
      if (f >= 0.499f) f = 0.499f;
    b25e:	vcmpe.f32	s15, s14
    b262:	vmrs	APSR_nzcv, fpscr
    b266:	bge.n	b274 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b4>
    b268:	vmul.f32	s15, s15, s13
    b26c:	vcvt.u32.f32	s15, s15
    b270:	vmov	r1, s15
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    b274:	ldr.w	r0, [r3, #4]!
    uint32_t increment[6];
    uint32_t phase[6];
    for (int i = 0; i < 6; ++i) {
      float f = f0 * ratios[i];
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
    b278:	str.w	r1, [r2], #4
        1.0f, 1.304f, 1.466f, 1.787f, 1.932f, 2.536f
    };
  
    uint32_t increment[6];
    uint32_t phase[6];
    for (int i = 0; i < 6; ++i) {
    b27c:	cmp	lr, r3
      float f = f0 * ratios[i];
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    b27e:	str.w	r0, [r9], #4
        1.0f, 1.304f, 1.466f, 1.787f, 1.932f, 2.536f
    };
  
    uint32_t increment[6];
    uint32_t phase[6];
    for (int i = 0; i < 6; ++i) {
    b282:	bne.n	b254 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x194>
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b284:	subs	r2, r5, #1
    b286:	cmp	r5, #0
    b288:	beq.w	c3da <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x131a>
    b28c:	ldr	r3, [sp, #112]	; 0x70
      noise += (phase[1] >> 31);
      noise += (phase[2] >> 31);
      noise += (phase[3] >> 31);
      noise += (phase[4] >> 31);
      noise += (phase[5] >> 31);
      *out++ = 0.33f * static_cast<float>(noise) - 1.0f;
    b28e:	vmov.f32	s13, #240	; 0xbf800000 -1.0
    b292:	ldr	r1, [sp, #116]	; 0x74
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b294:	mov	sl, r7
    b296:	mov	r0, r3
    b298:	str	r3, [sp, #0]
    b29a:	ldr	r3, [sp, #136]	; 0x88
    b29c:	mov	r9, r2
    b29e:	str	r1, [sp, #8]
    b2a0:	add	r0, r3
    b2a2:	ldr	r1, [sp, #140]	; 0x8c
    b2a4:	ldr	r3, [sp, #8]
    b2a6:	str	r0, [sp, #60]	; 0x3c
    b2a8:	adds	r1, r3, r1
    b2aa:	ldr	r0, [sp, #120]	; 0x78
    b2ac:	ldr	r3, [sp, #148]	; 0x94
    b2ae:	str	r1, [sp, #56]	; 0x38
    b2b0:	ldr	r1, [sp, #124]	; 0x7c
    b2b2:	str	r0, [sp, #12]
    b2b4:	str	r1, [sp, #16]
    b2b6:	ldr	r0, [sp, #144]	; 0x90
    b2b8:	ldr	r1, [sp, #12]
    b2ba:	ldr.w	r8, [sp, #60]	; 0x3c
    b2be:	adds	r0, r1, r0
    b2c0:	ldr	r1, [sp, #152]	; 0x98
    b2c2:	ldr.w	ip, [sp, #56]	; 0x38
    b2c6:	str	r0, [sp, #52]	; 0x34
    b2c8:	ldr	r0, [sp, #128]	; 0x80
    b2ca:	ldr.w	lr, [sp, #52]	; 0x34
    b2ce:	str	r0, [sp, #20]
    b2d0:	ldr	r0, [sp, #16]
      noise += (phase[1] >> 31);
      noise += (phase[2] >> 31);
      noise += (phase[3] >> 31);
      noise += (phase[4] >> 31);
      noise += (phase[5] >> 31);
      *out++ = 0.33f * static_cast<float>(noise) - 1.0f;
    b2d2:	vldr	s14, [pc, #280]	; b3ec <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x32c>
    b2d6:	adds	r3, r0, r3
    b2d8:	ldr	r0, [sp, #20]
    b2da:	str	r3, [sp, #48]	; 0x30
    b2dc:	adds	r1, r0, r1
    b2de:	ldr	r3, [sp, #132]	; 0x84
    b2e0:	str	r1, [sp, #44]	; 0x2c
    b2e2:	str	r3, [sp, #24]
    b2e4:	ldr	r1, [sp, #24]
    b2e6:	ldr	r3, [sp, #156]	; 0x9c
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b2e8:	ldr	r0, [sp, #48]	; 0x30
    b2ea:	adds	r3, r1, r3
    b2ec:	str	r3, [sp, #68]	; 0x44
    b2ee:	mov	r1, r3
    b2f0:	str	r4, [sp, #76]	; 0x4c
    b2f2:	ldr	r3, [sp, #8]
    b2f4:	str	r7, [sp, #80]	; 0x50
    b2f6:	str	r6, [sp, #84]	; 0x54
    b2f8:	str	r5, [sp, #256]	; 0x100
    b2fa:	ldr.w	fp, [sp, #44]	; 0x2c
    b2fe:	ldr	r4, [sp, #12]
    b300:	ldr	r7, [sp, #24]
    b302:	ldr	r6, [sp, #20]
    b304:	ldr	r5, [sp, #16]
    b306:	str	r2, [sp, #72]	; 0x48
    b308:	str	r3, [sp, #4]
      phase[3] += increment[3];
      phase[4] += increment[4];
      phase[5] += increment[5];
      uint32_t noise = 0;
      noise += (phase[0] >> 31);
      noise += (phase[1] >> 31);
    b30a:	mov.w	r3, ip, lsr #31
      noise += (phase[2] >> 31);
      noise += (phase[3] >> 31);
      noise += (phase[4] >> 31);
      noise += (phase[5] >> 31);
      *out++ = 0.33f * static_cast<float>(noise) - 1.0f;
    b30e:	vmov.f32	s10, s13
    b312:	ldr	r2, [sp, #4]
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b314:	add.w	r9, r9, #4294967295
      phase[3] += increment[3];
      phase[4] += increment[4];
      phase[5] += increment[5];
      uint32_t noise = 0;
      noise += (phase[0] >> 31);
      noise += (phase[1] >> 31);
    b318:	add.w	r3, r3, r8, lsr #31
    b31c:	add	ip, r2
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b31e:	cmp.w	r9, #4294967295
      phase[4] += increment[4];
      phase[5] += increment[5];
      uint32_t noise = 0;
      noise += (phase[0] >> 31);
      noise += (phase[1] >> 31);
      noise += (phase[2] >> 31);
    b322:	add.w	r3, r3, lr, lsr #31
    b326:	ldr	r2, [sp, #0]
    b328:	add	lr, r4
      noise += (phase[3] >> 31);
    b32a:	add.w	r3, r3, r0, lsr #31
    b32e:	add	r8, r2
    b330:	add	r0, r5
      noise += (phase[4] >> 31);
    b332:	add.w	r3, r3, fp, lsr #31
    b336:	add	fp, r6
      noise += (phase[5] >> 31);
      *out++ = 0.33f * static_cast<float>(noise) - 1.0f;
    b338:	add.w	r3, r3, r1, lsr #31
    b33c:	add	r1, r7
    b33e:	vmov	s15, r3
    b342:	vcvt.f32.s32	s15, s15
    b346:	vfma.f32	s10, s15, s14
    b34a:	vstmia	sl!, {s10}
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b34e:	bne.n	b30a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x24a>
    b350:	add	r2, sp, #72	; 0x48
    b352:	ldr	r1, [sp, #60]	; 0x3c
    b354:	ldr	r3, [sp, #0]
    b356:	ldr	r0, [sp, #56]	; 0x38
    b358:	ldr	r6, [sp, #84]	; 0x54
    b35a:	ldr	r5, [sp, #256]	; 0x100
    b35c:	ldmia	r2, {r2, r4, r7}
    b35e:	mla	r3, r3, r2, r1
    b362:	ldr	r1, [sp, #8]
    b364:	mla	r9, r1, r2, r0
    b368:	ldr	r0, [sp, #12]
    b36a:	str	r3, [sp, #136]	; 0x88
    b36c:	mov	r1, r0
    b36e:	ldr	r0, [sp, #52]	; 0x34
    b370:	str.w	r9, [sp, #140]	; 0x8c
    b374:	mla	r0, r1, r2, r0
    b378:	ldr	r1, [sp, #16]
    b37a:	mov	lr, r1
    b37c:	ldr	r1, [sp, #48]	; 0x30
    b37e:	str	r0, [sp, #144]	; 0x90
    b380:	mla	lr, lr, r2, r1
    b384:	ldr	r1, [sp, #20]
    b386:	mov	ip, r1
    b388:	ldr	r1, [sp, #44]	; 0x2c
    b38a:	str.w	lr, [sp, #148]	; 0x94
    b38e:	mla	ip, ip, r2, r1
    b392:	ldr	r1, [sp, #24]
    b394:	mov	r8, r1
    b396:	ldr	r1, [sp, #68]	; 0x44
    b398:	str.w	ip, [sp, #152]	; 0x98
    b39c:	mla	r8, r8, r2, r1
    b3a0:	str.w	r8, [sp, #156]	; 0x9c
    b3a4:	movs	r1, #0
    b3a6:	ldr	r0, [sp, #28]
    b3a8:	ldr.w	lr, [sp, #32]
    b3ac:	b.n	b400 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x340>
    b3ae:	nop
    b3b0:	.word	0xc3000000
    b3b4:	.word	0x42fe0000
    b3b8:	.word	0x42a80000
    b3bc:	.word	0x42100000
    b3c0:	.word	0x20000958
    b3c4:	.word	0x43800000
    b3c8:	.word	0x20000554
    b3cc:	.word	0x3b449ba6
    b3d0:	.word	0x3b23d70a
    b3d4:	.word	0x39962fc9
    b3d8:	.word	0x3f333333
    b3dc:	.word	0x3e99999a
    b3e0:	.word	0x3eff7cee
    b3e4:	.word	0x4f800000
    b3e8:	.word	0x7fbe7700
    b3ec:	.word	0x3ea8f5c3
    b3f0:	.word	0x2001f774
    b3f4:	.word	0x42900000
    b3f8:	.word	0x43000000
    b3fc:	ldr.w	r3, [lr, #4]!
      noise += (phase[4] >> 31);
      noise += (phase[5] >> 31);
      *out++ = 0.33f * static_cast<float>(noise) - 1.0f;
    }
  
    for (int i = 0; i < 6; ++i) {
    b400:	adds	r1, #1
      phase_[i] = phase[i];
    b402:	str.w	r3, [r0, #4]!
      noise += (phase[4] >> 31);
      noise += (phase[5] >> 31);
      *out++ = 0.33f * static_cast<float>(noise) - 1.0f;
    }
  
    for (int i = 0; i < 6; ++i) {
    b406:	cmp	r1, #6
    b408:	bne.n	b3fc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x33c>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b40a:	vldr	s14, [pc, #-24]	; b3f4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x334>
    b40e:	vldr	s15, [pc, #-24]	; b3f8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x338>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b412:	ldr	r3, [pc, #712]	; (b6dc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x61c>)

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b414:	vfma.f32	s15, s11, s14
    // Render the metallic noise.
    metallic_noise_.Render(2.0f * f0, temp_1, temp_2, out, size);

    // Apply BPF on the metallic noise.
    float cutoff = 150.0f / kSampleRate * stmlib::SemitonesToRatio(
        tone * 72.0f);
    b418:	vldr	s9, [pc, #708]	; b6e0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x620>
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    b41c:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b420:	vcvt.f32.s32	s10, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b424:	vmov	r1, s14
    b428:	add.w	r3, r3, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b42c:	vsub.f32	s15, s15, s10
    b430:	vldr	s13, [r3]
    b434:	ldr	r3, [pc, #684]	; (b6e4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x624>)
    b436:	vcvt.s32.f32	s15, s15, #8
    b43a:	vmov	r1, s15
    b43e:	add.w	r3, r3, r1, lsl #2
    b442:	vldr	s14, [r3]
    b446:	vmul.f32	s15, s14, s13
    b44a:	vmul.f32	s15, s15, s9
    CONSTRAIN(cutoff, 0.0f, 16000.0f / kSampleRate);
    b44e:	vcmpe.f32	s15, #0.0
    b452:	vmrs	APSR_nzcv, fpscr
    b456:	bmi.w	c3bc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12fc>
    b45a:	vldr	s14, [pc, #652]	; b6e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x628>
    b45e:	vcmpe.f32	s15, s14
    b462:	vmrs	APSR_nzcv, fpscr
    b466:	bgt.w	c39e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12de>
    b46a:	vmul.f32	s14, s15, s15
    b46e:	vldr	s13, [pc, #636]	; b6ec <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x62c>
    b472:	vldr	s2, [pc, #636]	; b6f0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x630>
    b476:	vmov.f32	s1, #112	; 0x3f800000  1.0
    b47a:	vldr	s6, [pc, #632]	; b6f4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x634>
    b47e:	vmov.f32	s16, #0	; 0x40000000  2.0
    b482:	vfma.f32	s2, s14, s13
    b486:	vldr	s10, [pc, #624]	; b6f8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x638>
    b48a:	vldr	s13, [pc, #624]	; b6fc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x63c>
    b48e:	vldr	s9, [pc, #624]	; b700 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x640>
    b492:	vfma.f32	s6, s14, s2
    b496:	vfma.f32	s10, s14, s6
    b49a:	vfma.f32	s13, s14, s10
    b49e:	vfma.f32	s9, s14, s13
    b4a2:	vmul.f32	s9, s9, s15
    b4a6:	vmov.f32	s15, s1
    b4aa:	vfma.f32	s15, s9, s16
    b4ae:	vmul.f32	s16, s9, s9
    b4b2:	vadd.f32	s15, s15, s16
    b4b6:	vdiv.f32	s13, s1, s15

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    b4ba:	vstr	s9, [r4, #56]	; 0x38
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    b4be:	vldr	s6, [r4, #68]	; 0x44
    float state_2 = state_2_;
    b4c2:	vldr	s10, [r4, #72]	; 0x48
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    b4c6:	vmov.f32	s15, #24	; 0x40c00000  6.0
    b4ca:	vmov.f32	s14, #8	; 0x40400000  3.0
    b4ce:	vmov.f32	s2, #112	; 0x3f800000  1.0
    b4d2:	vfma.f32	s14, s11, s15
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b4d6:	vmov.f32	s15, s2
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    b4da:	vdiv.f32	s1, s2, s14
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b4de:	vfma.f32	s15, s1, s9
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    b4e2:	vstr	s1, [r4, #60]	; 0x3c
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b4e6:	vadd.f32	s15, s15, s16
    b4ea:	vdiv.f32	s14, s2, s15
    b4ee:	vstr	s14, [r4, #64]	; 0x40
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b4f2:	cmp	r5, #0
    b4f4:	beq.w	c3fe <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x133e>
    b4f8:	vmov.f32	s11, s9
    b4fc:	mov	r1, r7
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b4fe:	mov	r3, r2
    b500:	b.n	b50e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44e>
    b502:	vldr	s1, [r4, #60]	; 0x3c
    b506:	vldr	s11, [r4, #56]	; 0x38
    b50a:	vldr	s14, [r4, #64]	; 0x40
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    b50e:	vneg.f32	s2, s6
    b512:	vldr	s15, [r1]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b516:	subs	r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    b518:	vfma.f32	s15, s2, s1
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b51c:	adds	r0, r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    b51e:	vfma.f32	s15, s2, s11
    b522:	vsub.f32	s15, s15, s10
    b526:	vmul.f32	s15, s15, s14
      bp = g_ * hp + state_1;
    b52a:	vmov.f32	s14, s6
    b52e:	vfma.f32	s14, s15, s11
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    b532:	vfma.f32	s10, s14, s11
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
    b536:	vstmia	r1!, {s14}
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    b53a:	vmov.f32	s6, s14
    b53e:	vfma.f32	s6, s15, s11
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    b542:	vfma.f32	s10, s14, s11
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b546:	bne.n	b502 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x442>
        out, out, size);
    
    // This is not at all part of the 808 circuit! But to add more variety, we
    // add a variable amount of clocked noise to the output of the 6 schmitt
    // trigger oscillators.
    noisiness *= noisiness;
    b548:	vmul.f32	s2, s0, s0
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    b54c:	vstr	s6, [r4, #68]	; 0x44
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    b550:	vmov.f32	s15, #112	; 0x3f800000  1.0
    state_2_ = state_2;
    b554:	vstr	s10, [r4, #72]	; 0x48
    b558:	vmov.f32	s11, #48	; 0x41800000  16.0
    b55c:	vsub.f32	s15, s15, s2
    b560:	vfma.f32	s11, s15, s11
    b564:	vmul.f32	s11, s11, s12
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    b568:	vcmpe.f32	s11, #0.0
    b56c:	vmrs	APSR_nzcv, fpscr
    b570:	bmi.w	c3d2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1312>
    b574:	vmov.f32	s15, #96	; 0x3f000000  0.5
    b578:	vcmp.f32	s11, s15
    b57c:	vmrs	APSR_nzcv, fpscr
    b580:	it	gt
    b582:	vmovgt.f32	s11, s15
    b586:	ldr.w	sl, [pc, #392]	; b710 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x650>
    b58a:	mov.w	r9, #0
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
    b58e:	vmov.f32	s10, #112	; 0x3f800000  1.0
    b592:	mov	r1, r7
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    b594:	vmov.f32	s1, #224	; 0xbf000000 -0.5
    b598:	ldr.w	r3, [sl]
    // This is not at all part of the 808 circuit! But to add more variety, we
    // add a variable amount of clocked noise to the output of the 6 schmitt
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    b59c:	mov	lr, r9
    b59e:	mov	r0, r7
    b5a0:	ldr.w	r8, [pc, #368]	; b714 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x654>
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    b5a4:	vldr	s6, [pc, #348]	; b704 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x644>
    b5a8:	b.n	b5e6 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x526>
    b5aa:	ldr	r3, [pc, #348]	; (b708 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x648>)
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
    b5ac:	vsub.f32	s15, s15, s10
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    b5b0:	vmov.f32	s14, s1
    b5b4:	mov.w	r9, #1
    b5b8:	add	r3, ip
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
    b5ba:	vstr	s15, [r4, #20]
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    b5be:	vmov	s15, r3
    b5c2:	vcvt.f32.u32	s15, s15
    b5c6:	vfma.f32	s14, s15, s6
    b5ca:	vstr	s14, [r4, #24]
      }
      out[i] += noisiness * (noise_sample_ - out[i]);
    b5ce:	vldr	s15, [r0]
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
    b5d2:	add.w	lr, lr, #1
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
      }
      out[i] += noisiness * (noise_sample_ - out[i]);
    b5d6:	vsub.f32	s14, s14, s15
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
    b5da:	cmp	r5, lr
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
      }
      out[i] += noisiness * (noise_sample_ - out[i]);
    b5dc:	vfma.f32	s15, s14, s2
    b5e0:	vstmia	r0!, {s15}
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
    b5e4:	bls.n	b62c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x56c>
      noise_clock_ += noise_f;
    b5e6:	vldr	s15, [r4, #20]
    b5ea:	mul.w	ip, r8, r3
    b5ee:	vadd.f32	s15, s11, s15
      if (noise_clock_ >= 1.0f) {
    b5f2:	vcmpe.f32	s15, s10
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
    b5f6:	vstr	s15, [r4, #20]
      if (noise_clock_ >= 1.0f) {
    b5fa:	vmrs	APSR_nzcv, fpscr
    b5fe:	bge.n	b5aa <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4ea>
    b600:	vldr	s14, [r4, #24]
    b604:	b.n	b5ce <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x50e>
    b606:	vldr	s14, [pc, #272]	; b718 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x658>
    b60a:	vadd.f32	s15, s15, s14
    b60e:	vcvt.s32.f32	s14, s15
    b612:	vmov	r2, s14
    b616:	vcvt.f32.s32	s14, s14
    b61a:	vsub.f32	s15, s15, s14
    b61e:	vmov.f32	s14, s15
    b622:	vcvt.s32.f32	s14, s14, #8
    b626:	vmov	r3, s14
    b62a:	b.n	b104 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>
    b62c:	cmp.w	r9, #0
    b630:	bne.w	c426 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1366>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    b634:	vmov	s15, r5
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    b638:	vldr	s2, [r4, #28]
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
    b63c:	vmov.f32	s0, #96	; 0x3f000000  0.5
    increment_ = (new_value - *state) / static_cast<float>(size);
    b640:	movs	r3, #0
    b642:	vcvt.f32.u32	s10, s15
};

class SwingVCA {
 public:
  float operator()(float s, float gain) {
   s *= s > 0.0f ? 10.0f : 0.1f;
    b646:	vldr	s1, [pc, #196]	; b70c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x64c>
    b64a:	vmov.f32	s15, s2
    b64e:	ldr	r0, [sp, #40]	; 0x28
    b650:	vfnms.f32	s15, s3, s4
    b654:	vmov.f32	s3, #36	; 0x41200000  10.0
   s = s / (1.0f + fabsf(s));
    b658:	vmov.f32	s4, #112	; 0x3f800000  1.0
    b65c:	vdiv.f32	s16, s15, s10
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
    b660:	vldr	s15, [r4, #16]
    // Apply VCA.
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
    b664:	adds	r3, #1
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
    b666:	vcmpe.f32	s15, s0
    b66a:	vmrs	APSR_nzcv, fpscr
    b66e:	ite	le
    b670:	vmovle.f32	s14, s7
    b674:	vmovgt.f32	s14, s8
    b678:	vmul.f32	s15, s15, s14
    b67c:	vstr	s15, [r4, #16]
      out[i] = vca(out[i], sustain ? sustain_gain.Next() : envelope_);
    b680:	vldr	s14, [r1]
    b684:	cbz	r0, b68e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5ce>
  }

  inline float Next() {
    value_ += increment_;
    b686:	vadd.f32	s2, s2, s16
    b68a:	vmov.f32	s15, s2
};

class SwingVCA {
 public:
  float operator()(float s, float gain) {
   s *= s > 0.0f ? 10.0f : 0.1f;
    b68e:	vcmpe.f32	s14, #0.0
    b692:	vmrs	APSR_nzcv, fpscr
    b696:	ite	le
    b698:	vmovle.f32	s11, s1
    b69c:	vmovgt.f32	s11, s3
    // Apply VCA.
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
    b6a0:	cmp	r5, r3
};

class SwingVCA {
 public:
  float operator()(float s, float gain) {
   s *= s > 0.0f ? 10.0f : 0.1f;
    b6a2:	vmul.f32	s11, s14, s11
   s = s / (1.0f + fabsf(s));
    b6a6:	vabs.f32	s6, s11
    b6aa:	vadd.f32	s6, s6, s4
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
      out[i] = vca(out[i], sustain ? sustain_gain.Next() : envelope_);
    b6ae:	vdiv.f32	s14, s11, s6
    b6b2:	vadd.f32	s14, s14, s4
    b6b6:	vmul.f32	s15, s14, s15
    b6ba:	vstmia	r1!, {s15}
    // Apply VCA.
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
    b6be:	bhi.n	b660 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5a0>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    b6c0:	vmov.f32	s7, #0	; 0x40000000  2.0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    b6c4:	vstr	s9, [r4, #76]	; 0x4c
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    b6c8:	vstr	s13, [r4, #84]	; 0x54
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b6cc:	mov	r3, r2
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    b6ce:	vldr	s11, [r4, #88]	; 0x58
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    b6d2:	vstr	s7, [r4, #80]	; 0x50
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    b6d6:	vldr	s14, [r4, #92]	; 0x5c
    b6da:	b.n	b734 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x674>
    b6dc:	.word	0x20000554
    b6e0:	.word	0x3b4ccccd
    b6e4:	.word	0x20000958
    b6e8:	.word	0x3eaaaaab
    b6ec:	.word	0x452efe23
    b6f0:	.word	0x42acec90
    b6f4:	.word	0x4321348f
    b6f8:	.word	0x42234866
    b6fc:	.word	0x41255da8
    b700:	.word	0x40490fdb
    b704:	.word	0x2f800000
    b708:	.word	0x3c6ef35f
    b70c:	.word	0x3dcccccd
    b710:	.word	0x20020470
    b714:	.word	0x0019660d
    b718:	.word	0x43000000
    b71c:	.word	0x42a80000
    b720:	.word	0x42100000
    b724:	.word	0x43800000
    b728:	vldr	s7, [r4, #80]	; 0x50
    b72c:	vldr	s9, [r4, #76]	; 0x4c
    b730:	vldr	s13, [r4, #84]	; 0x54
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    b734:	vneg.f32	s8, s11
    b738:	vldr	s15, [r7]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b73c:	subs	r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    b73e:	vfma.f32	s15, s8, s7
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b742:	adds	r1, r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    b744:	vfma.f32	s15, s8, s9
    b748:	vsub.f32	s15, s15, s14
    b74c:	vmul.f32	s15, s15, s13
      bp = g_ * hp + state_1;
    b750:	vmov.f32	s13, s11
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
    b754:	vstmia	r7!, {s15}
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
    b758:	vfma.f32	s13, s15, s9
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    b75c:	vfma.f32	s14, s13, s9
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    b760:	vmov.f32	s11, s13
    b764:	vfma.f32	s11, s15, s9
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    b768:	vfma.f32	s14, s13, s9
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    b76c:	bne.n	b728 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x668>
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
    b76e:	ldr	r1, [sp, #36]	; 0x24
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    b770:	vstr	s2, [r4, #28]
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b774:	vmov.f32	s2, #112	; 0x3f800000  1.0
    b778:	vldr	s7, [r1, #12]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b77c:	vldr	s15, [pc, #-104]	; b718 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x658>
      float noisiness,
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
    b780:	vneg.f32	s8, s7
    b784:	vldr	s13, [pc, #-108]	; b71c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x65c>
    b788:	vmov.f32	s4, s15
    b78c:	vldr	s6, [pc, #-112]	; b720 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x660>
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    b790:	vstr	s11, [r4, #88]	; 0x58
    b794:	vfma.f32	s15, s8, s6
    state_2_ = state_2;
    b798:	vstr	s14, [r4, #92]	; 0x5c
    b79c:	vfma.f32	s4, s8, s13
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b7a0:	vldr	s9, [pc, #-128]	; b724 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x664>
      size);
  
  hi_hat_2_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
    b7a4:	vldr	s6, [r1, #20]
      f0,
      parameters.timbre,
    b7a8:	vldr	s3, [r1, #8]

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b7ac:	ldr	r3, [pc, #852]	; (bb04 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa44>)
        -decay * 84.0f);
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b7ae:	vldr	s8, [pc, #856]	; bb08 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa48>
extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    b7b2:	vcvt.s32.f32	s14, s15
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b7b6:	vldr	s1, [pc, #852]	; bb0c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa4c>
    b7ba:	vcvt.s32.f32	s11, s4
      temp_buffer_[0],
      temp_buffer_[1],
      out,
      size);
  
  hi_hat_2_.Render(
    b7be:	ldr.w	r0, [r4, #320]	; 0x140

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    b7c2:	vmov.f32	s13, s4
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
      parameters.harmonics,
    b7c6:	vldr	s4, [r1, #16]
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b7ca:	vcvt.f32.s32	s0, s14
      temp_buffer_[0],
      temp_buffer_[1],
      out,
      size);
  
  hi_hat_2_.Render(
    b7ce:	ldr.w	r7, [r4, #324]	; 0x144
    b7d2:	vcvt.f32.s32	s16, s11

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b7d6:	vmov	r1, s11
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b7da:	vsub.f32	s15, s15, s0

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b7de:	add.w	r3, r3, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b7e2:	vsub.f32	s13, s13, s16

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b7e6:	vmov	r1, s14
    b7ea:	vldr	s11, [r3]
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b7ee:	vmul.f32	s15, s15, s9

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b7f2:	ldr	r3, [pc, #784]	; (bb04 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa44>)
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b7f4:	vmul.f32	s13, s13, s9

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    b7f8:	add.w	r3, r3, r1, lsl #2
    b7fc:	vmov.f32	s9, s2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    b800:	vcvt.s32.f32	s15, s15
    b804:	vcvt.s32.f32	s13, s13
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b808:	vldr	s14, [r3]
    b80c:	ldr	r3, [pc, #768]	; (bb10 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa50>)
    b80e:	vmov	lr, s15
    b812:	vmov	r1, s13
    b816:	add.w	r1, r3, r1, lsl #2
    b81a:	add.w	r3, r3, lr, lsl #2
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b81e:	vldr	s13, [r1]
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b822:	vldr	s15, [r3]
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b826:	vnmul.f32	s13, s11, s13
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    
    if (trigger) {
    b82a:	ldr	r3, [sp, #64]	; 0x40
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b82c:	vnmul.f32	s15, s14, s15
    b830:	vmov.f32	s14, s2
      float* temp_1,
      float* temp_2,
      float* out,
      size_t size) {
    const float envelope_decay = 1.0f - 0.003f * stmlib::SemitonesToRatio(
        -decay * 84.0f);
    b834:	vfma.f32	s9, s13, s1
    const float cut_decay = 1.0f - 0.0025f * stmlib::SemitonesToRatio(
        -decay * 36.0f);
    b838:	vfma.f32	s14, s15, s8
    b83c:	vmov.f32	s8, s14
    
    if (trigger) {
    b840:	cbz	r3, b866 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a6>
      envelope_ = (1.5f + 0.5f * (1.0f - decay)) * (0.3f + 0.7f * accent);
    b842:	vsub.f32	s2, s2, s7
    b846:	vldr	s11, [pc, #716]	; bb14 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa54>
    b84a:	vmov.f32	s13, #96	; 0x3f000000  0.5
    b84e:	vldr	s14, [pc, #712]	; bb18 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa58>
    b852:	vmov.f32	s15, #120	; 0x3fc00000  1.5
    b856:	vfma.f32	s14, s6, s11
    b85a:	vfma.f32	s15, s2, s13
    b85e:	vmul.f32	s15, s15, s14
    b862:	vstr	s15, [r4, #96]	; 0x60
      oscillator_[i].Init();
    }
  }
  
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratio = f0 / (0.01f + f0);
    b866:	vldr	s13, [pc, #692]	; bb1c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa5c>
    const float f2a = 510.0f / kSampleRate * ratio;
    const float f2b = 8075.0f / kSampleRate * ratio;
    const float f3a = 730.0f / kSampleRate * ratio;
    const float f3b = 10500.0f / kSampleRate * ratio;
    
    std::fill(&out[0], &out[size], 0.0f);
    b86a:	add.w	r1, r6, r5, lsl #2
    const float f1a = 200.0f / kSampleRate * ratio;
    const float f1b = 7530.0f / kSampleRate * ratio;
    const float f2a = 510.0f / kSampleRate * ratio;
    const float f2b = 8075.0f / kSampleRate * ratio;
    const float f3a = 730.0f / kSampleRate * ratio;
    const float f3b = 10500.0f / kSampleRate * ratio;
    b86e:	vmov.f32	s2, #76	; 0x3e600000  0.2187500
    }
  }
  
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratio = f0 / (0.01f + f0);
    const float f1a = 200.0f / kSampleRate * ratio;
    b872:	vldr	s15, [pc, #684]	; bb20 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa60>
      oscillator_[i].Init();
    }
  }
  
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratio = f0 / (0.01f + f0);
    b876:	vadd.f32	s13, s5, s13
    const float f1a = 200.0f / kSampleRate * ratio;
    const float f1b = 7530.0f / kSampleRate * ratio;
    b87a:	vldr	s25, [pc, #680]	; bb24 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa64>
    const float f2a = 510.0f / kSampleRate * ratio;
    b87e:	vldr	s16, [pc, #680]	; bb28 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa68>
    b882:	cmp	r6, r1
    const float f2b = 8075.0f / kSampleRate * ratio;
    b884:	vldr	s0, [pc, #676]	; bb2c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa6c>
      oscillator_[i].Init();
    }
  }
  
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratio = f0 / (0.01f + f0);
    b888:	vdiv.f32	s14, s5, s13
    const float f1a = 200.0f / kSampleRate * ratio;
    const float f1b = 7530.0f / kSampleRate * ratio;
    const float f2a = 510.0f / kSampleRate * ratio;
    const float f2b = 8075.0f / kSampleRate * ratio;
    const float f3a = 730.0f / kSampleRate * ratio;
    b88c:	vldr	s11, [pc, #672]	; bb30 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa70>
    }
  }
  
  void Render(float f0, float* temp_1, float* temp_2, float* out, size_t size) {
    const float ratio = f0 / (0.01f + f0);
    const float f1a = 200.0f / kSampleRate * ratio;
    b890:	vmul.f32	s15, s14, s15
    const float f1b = 7530.0f / kSampleRate * ratio;
    b894:	vmul.f32	s25, s14, s25
    const float f2a = 510.0f / kSampleRate * ratio;
    b898:	vmul.f32	s16, s14, s16
    const float f2b = 8075.0f / kSampleRate * ratio;
    b89c:	vmul.f32	s0, s14, s0
    const float f3a = 730.0f / kSampleRate * ratio;
    b8a0:	vmul.f32	s11, s14, s11
    const float f3b = 10500.0f / kSampleRate * ratio;
    b8a4:	vmul.f32	s5, s14, s2
    b8a8:	beq.n	b8b8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7f8>
    b8aa:	mov	r3, r6
	*__first = __tmp;
    b8ac:	mov.w	lr, #0
    b8b0:	str.w	lr, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    b8b4:	cmp	r1, r3
    b8b6:	bne.n	b8b0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7f0>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    b8b8:	vldr	s14, [pc, #632]	; bb34 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa74>
    b8bc:	vcmpe.f32	s15, s14
    b8c0:	vmrs	APSR_nzcv, fpscr
    b8c4:	bmi.w	c37c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12bc>
    b8c8:	vmov.f32	s14, #80	; 0x3e800000  0.250
    b8cc:	vcmpe.f32	s15, s14
    b8d0:	vmrs	APSR_nzcv, fpscr
    b8d4:	bgt.w	c37c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12bc>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    b8d8:	vabs.f32	s14, s15
    b8dc:	vmov.f32	s13, #96	; 0x3f000000  0.5
    b8e0:	vadd.f32	s14, s14, s14
    b8e4:	vcmpe.f32	s14, s13
    b8e8:	vmrs	APSR_nzcv, fpscr
    b8ec:	bgt.n	b904 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x844>
    b8ee:	vmov.f32	s2, #112	; 0x3f800000  1.0
    b8f2:	vsub.f32	s14, s2, s14
    b8f6:	vcmpe.f32	s14, s13
    b8fa:	vmrs	APSR_nzcv, fpscr
    b8fe:	it	pl
    b900:	vmovpl.f32	s14, s13
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    b904:	vldr	s1, [r4, #132]	; 0x84
    b908:	vldr	s2, [r4, #136]	; 0x88
    increment_ = (new_value - *state) / static_cast<float>(size);
    b90c:	vsub.f32	s15, s15, s1
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    b910:	vldr	s26, [r4, #116]	; 0x74
    b914:	vsub.f32	s14, s14, s2
    b918:	vdiv.f32	s21, s15, s10
    b91c:	vdiv.f32	s22, s14, s10
  
    while (size--) {
    b920:	cmp	r5, #0
    b922:	beq.n	ba08 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x948>
    b924:	mov	lr, r0
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    b926:	mov	r3, r2
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    b928:	vldr	s18, [pc, #524]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
          high_ = false;
    b92c:	mov.w	r8, #0
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    b930:	vmov.f32	s20, #96	; 0x3f000000  0.5
inline float ThisBlepSample(float t) {
  return 0.5f * t * t;
}

inline float NextBlepSample(float t) {
  t = 1.0f - t;
    b934:	vmov.f32	s17, #112	; 0x3f800000  1.0
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    b938:	vmov.f32	s19, #224	; 0xbf000000 -0.5
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    b93c:	vmov.f32	s24, #0	; 0x40000000  2.0
    b940:	vmov.f32	s23, #240	; 0xbf800000 -1.0
    b944:	b.n	b9ca <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x90a>
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
          float t = (phase_ - pw) / frequency;
    b946:	vsub.f32	s14, s13, s2
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
    b94a:	strb.w	r1, [r4, #128]	; 0x80
        }
        if (phase_ >= 1.0f) {
    b94e:	vcmpe.f32	s13, s17
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
          float t = (phase_ - pw) / frequency;
    b952:	vdiv.f32	s15, s14, s1
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    b956:	vmrs	APSR_nzcv, fpscr
    b95a:	vsub.f32	s14, s17, s15
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    b95e:	vmul.f32	s28, s15, s20
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    b962:	vmul.f32	s27, s14, s19
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    b966:	vfma.f32	s26, s15, s28
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    b96a:	vmov.f32	s15, s18
    b96e:	vfma.f32	s15, s14, s27
    b972:	vmov.f32	s27, s15
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    b976:	blt.n	ba02 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x942>
          phase_ -= 1.0f;
    b978:	vsub.f32	s13, s13, s17
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
          high_ = false;
    b97c:	strb.w	r8, [r4, #128]	; 0x80
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
    b980:	vdiv.f32	s15, s13, s1
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    b984:	vstr	s13, [r4, #112]	; 0x70
    b988:	vsub.f32	s14, s17, s15
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    b98c:	vmul.f32	s29, s15, s20
          next_sample -= stmlib::NextBlepSample(t);
    b990:	vmul.f32	s28, s14, s19
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    b994:	vfms.f32	s26, s15, s29
          next_sample -= stmlib::NextBlepSample(t);
    b998:	vfms.f32	s27, s14, s28
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    b99c:	vmov.f32	s15, s26
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    b9a0:	vcmpe.f32	s2, s13
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    b9a4:	subs	r3, #1
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    b9a6:	vmov.f32	s14, s23
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    b9aa:	vmrs	APSR_nzcv, fpscr
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    b9ae:	vfma.f32	s14, s15, s24
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    b9b2:	ite	le
    b9b4:	vmovle.f32	s15, s17
    b9b8:	vmovgt.f32	s15, s18
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    b9bc:	cmp.w	r3, #4294967295
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    b9c0:	vadd.f32	s26, s27, s15
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    b9c4:	vstmia	lr!, {s14}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    b9c8:	beq.n	ba08 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x948>
  }

  inline float Next() {
    value_ += increment_;
    b9ca:	vadd.f32	s1, s1, s21
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    b9ce:	vldr	s13, [r4, #112]	; 0x70
    b9d2:	vadd.f32	s2, s2, s22
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    b9d6:	ldrb.w	ip, [r4, #128]	; 0x80
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    b9da:	vadd.f32	s13, s1, s13
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    b9de:	vcmpe.f32	s2, s13
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    b9e2:	vstr	s13, [r4, #112]	; 0x70
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    b9e6:	vmrs	APSR_nzcv, fpscr
    b9ea:	ite	ls
    b9ec:	movls	r1, #1
    b9ee:	movhi	r1, #0
    b9f0:	cmp	ip, r1
    b9f2:	bne.n	b946 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x886>
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    b9f4:	vcmpe.f32	s13, s17
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    b9f8:	vldr	s27, [pc, #316]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    b9fc:	vmrs	APSR_nzcv, fpscr
    ba00:	bge.n	b978 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8b8>
    ba02:	vmov.f32	s15, s26
    ba06:	b.n	b9a0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8e0>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    ba08:	vldr	s15, [pc, #296]	; bb34 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa74>
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    ba0c:	vstr	s26, [r4, #116]	; 0x74
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    ba10:	vcmpe.f32	s25, s15
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    ba14:	vstr	s2, [r4, #136]	; 0x88
    ba18:	vstr	s1, [r4, #132]	; 0x84
    ba1c:	vmrs	APSR_nzcv, fpscr
    ba20:	bmi.w	c370 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12b0>
    ba24:	vmov.f32	s15, #80	; 0x3e800000  0.250
    ba28:	vcmpe.f32	s25, s15
    ba2c:	vmrs	APSR_nzcv, fpscr
    ba30:	bgt.w	c370 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12b0>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    ba34:	vabs.f32	s15, s25
    ba38:	vmov.f32	s14, #96	; 0x3f000000  0.5
    ba3c:	vadd.f32	s15, s15, s15
    ba40:	vcmpe.f32	s15, s14
    ba44:	vmrs	APSR_nzcv, fpscr
    ba48:	bgt.n	ba60 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
    ba4a:	vmov.f32	s13, #112	; 0x3f800000  1.0
    ba4e:	vsub.f32	s15, s13, s15
    ba52:	vcmpe.f32	s15, s14
    ba56:	vmrs	APSR_nzcv, fpscr
    ba5a:	it	pl
    ba5c:	vmovpl.f32	s15, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    ba60:	vldr	s17, [r4, #160]	; 0xa0
    ba64:	vldr	s18, [r4, #164]	; 0xa4
    increment_ = (new_value - *state) / static_cast<float>(size);
    ba68:	vsub.f32	s25, s25, s17
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    ba6c:	vldr	s14, [r4, #144]	; 0x90
    ba70:	vsub.f32	s15, s15, s18
    ba74:	vdiv.f32	s21, s25, s10
    ba78:	vdiv.f32	s22, s15, s10
  
    while (size--) {
    ba7c:	cmp	r5, #0
    ba7e:	beq.n	bb6c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xaac>
    ba80:	mov	r1, r7
    ba82:	mov	r3, r2
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
    ba84:	vldr	s27, [pc, #176]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    ba88:	vmov.f32	s2, #112	; 0x3f800000  1.0
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    ba8c:	vmov.f32	s26, #96	; 0x3f000000  0.5
          next_sample -= stmlib::NextBlepSample(t);
    ba90:	vmov.f32	s25, #224	; 0xbf000000 -0.5
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    ba94:	vmov.f32	s24, #0	; 0x40000000  2.0
    ba98:	vmov.f32	s23, #240	; 0xbf800000 -1.0
    ba9c:	b.n	bade <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa1e>
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    ba9e:	vsub.f32	s15, s15, s2
          float t = phase_ / frequency;
    baa2:	vdiv.f32	s13, s15, s17
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    baa6:	vstr	s15, [r4, #140]	; 0x8c
    baaa:	vsub.f32	s1, s2, s13
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    baae:	vmul.f32	s20, s13, s26
          next_sample -= stmlib::NextBlepSample(t);
    bab2:	vmul.f32	s19, s1, s25
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bab6:	vfms.f32	s14, s13, s20
          next_sample -= stmlib::NextBlepSample(t);
    baba:	vmov.f32	s13, s27
    babe:	vfms.f32	s13, s1, s19
    bac2:	vmov.f32	s1, s13
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bac6:	vmov.f32	s13, s23
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    baca:	subs	r3, #1
    bacc:	cmp.w	r3, #4294967295
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bad0:	vfma.f32	s13, s14, s24
          float t = phase_ / frequency;
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;
    bad4:	vadd.f32	s14, s1, s15

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bad8:	vstmia	r1!, {s13}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    badc:	beq.n	bb3c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa7c>
  }

  inline float Next() {
    value_ += increment_;
    bade:	vadd.f32	s17, s17, s21
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bae2:	vldr	s15, [r4, #140]	; 0x8c
    bae6:	vadd.f32	s18, s18, s22
    baea:	vadd.f32	s15, s17, s15
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    baee:	vcmpe.f32	s15, s2
    baf2:	vmrs	APSR_nzcv, fpscr
    baf6:	bge.n	ba9e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9de>
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    baf8:	vstr	s15, [r4, #140]	; 0x8c
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    bafc:	vldr	s1, [pc, #56]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
    bb00:	b.n	bac6 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa06>
    bb02:	nop
    bb04:	.word	0x20000554
    bb08:	.word	0x3b23d70a
    bb0c:	.word	0x3b449ba6
    bb10:	.word	0x20000958
    bb14:	.word	0x3f333333
    bb18:	.word	0x3e99999a
    bb1c:	.word	0x3c23d70a
    bb20:	.word	0x3b888889
    bb24:	.word	0x3e20a3d7
    bb28:	.word	0x3c2e147b
    bb2c:	.word	0x3e2c4444
    bb30:	.word	0x3c792c60
    bb34:	.word	0x358637bd
    bb38:	.word	0x00000000
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    bb3c:	mov	r1, r6
    bb3e:	mov	ip, r7
    bb40:	mov	lr, r0
    bb42:	mov	r3, r2
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    bb44:	vstr	s14, [r4, #144]	; 0x90
    bb48:	vstr	s18, [r4, #164]	; 0xa4
    bb4c:	vstr	s17, [r4, #160]	; 0xa0
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
      *out++ += *temp_1++ * *temp_2++;
    bb50:	vldmia	lr!, {s13}
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    bb54:	subs	r3, #1
      *out++ += *temp_1++ * *temp_2++;
    bb56:	vldmia	ip!, {s14}
    bb5a:	vldmia	r1!, {s15}
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    bb5e:	cmp.w	r3, #4294967295
      *out++ += *temp_1++ * *temp_2++;
    bb62:	vfma.f32	s15, s13, s14
    bb66:	vstr	s15, [r1, #-4]
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    bb6a:	bne.n	bb50 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa90>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    bb6c:	vldr	s15, [pc, #-60]	; bb34 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa74>
    bb70:	vcmpe.f32	s16, s15
    bb74:	vmrs	APSR_nzcv, fpscr
    bb78:	bmi.w	c366 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12a6>
    bb7c:	vmov.f32	s15, #80	; 0x3e800000  0.250
    bb80:	vcmpe.f32	s16, s15
    bb84:	vmrs	APSR_nzcv, fpscr
    bb88:	bgt.w	c366 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12a6>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    bb8c:	vabs.f32	s15, s16
    bb90:	vmov.f32	s14, #96	; 0x3f000000  0.5
    bb94:	vadd.f32	s15, s15, s15
    bb98:	vcmpe.f32	s15, s14
    bb9c:	vmrs	APSR_nzcv, fpscr
    bba0:	bgt.n	bbb8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xaf8>
    bba2:	vmov.f32	s13, #112	; 0x3f800000  1.0
    bba6:	vsub.f32	s15, s13, s15
    bbaa:	vcmpe.f32	s15, s14
    bbae:	vmrs	APSR_nzcv, fpscr
    bbb2:	it	pl
    bbb4:	vmovpl.f32	s15, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    bbb8:	vldr	s17, [r4, #188]	; 0xbc
    bbbc:	vldr	s1, [r4, #192]	; 0xc0
    increment_ = (new_value - *state) / static_cast<float>(size);
    bbc0:	vsub.f32	s16, s16, s17
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    bbc4:	vldr	s25, [r4, #172]	; 0xac
    bbc8:	vsub.f32	s15, s15, s1
    bbcc:	vdiv.f32	s21, s16, s10
    bbd0:	vdiv.f32	s22, s15, s10
  
    while (size--) {
    bbd4:	cmp	r5, #0
    bbd6:	beq.n	bcb8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbf8>
    bbd8:	mov	lr, r0
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    bbda:	mov	r3, r2
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    bbdc:	vldr	s18, [pc, #-168]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
          high_ = false;
    bbe0:	mov.w	r8, #0
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    bbe4:	vmov.f32	s20, #96	; 0x3f000000  0.5
    bbe8:	vmov.f32	s16, #112	; 0x3f800000  1.0
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    bbec:	vmov.f32	s19, #224	; 0xbf000000 -0.5
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    bbf0:	vmov.f32	s24, #0	; 0x40000000  2.0
    bbf4:	vmov.f32	s23, #240	; 0xbf800000 -1.0
    bbf8:	b.n	bc7a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbba>
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
          float t = (phase_ - pw) / frequency;
    bbfa:	vsub.f32	s14, s2, s1
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
    bbfe:	strb.w	r1, [r4, #184]	; 0xb8
        }
        if (phase_ >= 1.0f) {
    bc02:	vcmpe.f32	s2, s16
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
          float t = (phase_ - pw) / frequency;
    bc06:	vdiv.f32	s15, s14, s17
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    bc0a:	vmrs	APSR_nzcv, fpscr
    bc0e:	vsub.f32	s14, s16, s15
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    bc12:	vmul.f32	s26, s15, s20
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    bc16:	vmul.f32	s13, s14, s19
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    bc1a:	vfma.f32	s25, s15, s26
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    bc1e:	vmov.f32	s15, s18
    bc22:	vfma.f32	s15, s14, s13
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    bc26:	blt.n	bcb2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbf2>
          phase_ -= 1.0f;
    bc28:	vsub.f32	s2, s2, s16
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
          high_ = false;
    bc2c:	strb.w	r8, [r4, #184]	; 0xb8
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
    bc30:	vdiv.f32	s14, s2, s17
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    bc34:	vstr	s2, [r4, #168]	; 0xa8
    bc38:	vsub.f32	s13, s16, s14
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bc3c:	vmul.f32	s27, s14, s20
          next_sample -= stmlib::NextBlepSample(t);
    bc40:	vmul.f32	s26, s13, s19
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bc44:	vfms.f32	s25, s14, s27
          next_sample -= stmlib::NextBlepSample(t);
    bc48:	vfms.f32	s15, s13, s26
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bc4c:	vmov.f32	s14, s25
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bc50:	vcmpe.f32	s1, s2
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bc54:	subs	r3, #1
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    bc56:	vmov.f32	s13, s23
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bc5a:	vmrs	APSR_nzcv, fpscr
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    bc5e:	vfma.f32	s13, s14, s24
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bc62:	ite	le
    bc64:	vmovle.f32	s14, s16
    bc68:	vmovgt.f32	s14, s18
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bc6c:	cmp.w	r3, #4294967295
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bc70:	vadd.f32	s25, s15, s14
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    bc74:	vstmia	lr!, {s13}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bc78:	beq.n	bcb8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbf8>
  }

  inline float Next() {
    value_ += increment_;
    bc7a:	vadd.f32	s17, s17, s21
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bc7e:	vldr	s2, [r4, #168]	; 0xa8
    bc82:	vadd.f32	s1, s1, s22
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    bc86:	ldrb.w	ip, [r4, #184]	; 0xb8
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bc8a:	vadd.f32	s2, s17, s2
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    bc8e:	vcmpe.f32	s1, s2
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bc92:	vstr	s2, [r4, #168]	; 0xa8
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    bc96:	vmrs	APSR_nzcv, fpscr
    bc9a:	ite	ls
    bc9c:	movls	r1, #1
    bc9e:	movhi	r1, #0
    bca0:	cmp	ip, r1
    bca2:	bne.n	bbfa <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb3a>
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    bca4:	vcmpe.f32	s2, s16
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    bca8:	vldr	s15, [pc, #-372]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    bcac:	vmrs	APSR_nzcv, fpscr
    bcb0:	bge.n	bc28 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb68>
    bcb2:	vmov.f32	s14, s25
    bcb6:	b.n	bc50 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb90>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    bcb8:	vldr	s15, [pc, #-392]	; bb34 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa74>
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    bcbc:	vstr	s25, [r4, #172]	; 0xac
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    bcc0:	vcmpe.f32	s0, s15
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    bcc4:	vstr	s1, [r4, #192]	; 0xc0
    bcc8:	vstr	s17, [r4, #188]	; 0xbc
    bccc:	vmrs	APSR_nzcv, fpscr
    bcd0:	bmi.w	c35c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x129c>
    bcd4:	vmov.f32	s15, #80	; 0x3e800000  0.250
    bcd8:	vcmpe.f32	s0, s15
    bcdc:	vmrs	APSR_nzcv, fpscr
    bce0:	bgt.w	c35c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x129c>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    bce4:	vabs.f32	s15, s0
    bce8:	vmov.f32	s14, #96	; 0x3f000000  0.5
    bcec:	vadd.f32	s15, s15, s15
    bcf0:	vcmpe.f32	s15, s14
    bcf4:	vmrs	APSR_nzcv, fpscr
    bcf8:	bgt.n	bd10 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc50>
    bcfa:	vmov.f32	s13, #112	; 0x3f800000  1.0
    bcfe:	vsub.f32	s15, s13, s15
    bd02:	vcmpe.f32	s15, s14
    bd06:	vmrs	APSR_nzcv, fpscr
    bd0a:	it	pl
    bd0c:	vmovpl.f32	s15, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    bd10:	vldr	s16, [r4, #216]	; 0xd8
    bd14:	vldr	s17, [r4, #220]	; 0xdc
    increment_ = (new_value - *state) / static_cast<float>(size);
    bd18:	vsub.f32	s0, s0, s16
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    bd1c:	vldr	s14, [r4, #200]	; 0xc8
    bd20:	vsub.f32	s15, s15, s17
    bd24:	vdiv.f32	s19, s0, s10
    bd28:	vdiv.f32	s20, s15, s10
  
    while (size--) {
    bd2c:	cmp	r5, #0
    bd2e:	beq.n	bdde <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd1e>
    bd30:	mov	r1, r7
    bd32:	mov	r3, r2
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
    bd34:	vldr	s25, [pc, #-512]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    bd38:	vmov.f32	s2, #112	; 0x3f800000  1.0
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bd3c:	vmov.f32	s24, #96	; 0x3f000000  0.5
          next_sample -= stmlib::NextBlepSample(t);
    bd40:	vmov.f32	s23, #224	; 0xbf000000 -0.5
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bd44:	vmov.f32	s22, #0	; 0x40000000  2.0
    bd48:	vmov.f32	s21, #240	; 0xbf800000 -1.0
    bd4c:	b.n	bd8a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcca>
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    bd4e:	vsub.f32	s15, s15, s2
          float t = phase_ / frequency;
    bd52:	vdiv.f32	s13, s15, s16
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    bd56:	vstr	s15, [r4, #196]	; 0xc4
    bd5a:	vsub.f32	s1, s2, s13
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bd5e:	vmul.f32	s18, s13, s24
          next_sample -= stmlib::NextBlepSample(t);
    bd62:	vmul.f32	s0, s1, s23
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bd66:	vfms.f32	s14, s13, s18
          next_sample -= stmlib::NextBlepSample(t);
    bd6a:	vmov.f32	s13, s25
    bd6e:	vfms.f32	s13, s1, s0
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bd72:	vmov.f32	s1, s21
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bd76:	subs	r3, #1
    bd78:	cmp.w	r3, #4294967295
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bd7c:	vfma.f32	s1, s14, s22
          float t = phase_ / frequency;
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;
    bd80:	vadd.f32	s14, s13, s15

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bd84:	vstmia	r1!, {s1}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bd88:	beq.n	bdae <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcee>
  }

  inline float Next() {
    value_ += increment_;
    bd8a:	vadd.f32	s16, s16, s19
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bd8e:	vldr	s15, [r4, #196]	; 0xc4
    bd92:	vadd.f32	s17, s17, s20
    bd96:	vadd.f32	s15, s16, s15
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    bd9a:	vcmpe.f32	s15, s2
    bd9e:	vmrs	APSR_nzcv, fpscr
    bda2:	bge.n	bd4e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc8e>
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bda4:	vstr	s15, [r4, #196]	; 0xc4
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    bda8:	vldr	s13, [pc, #-628]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
    bdac:	b.n	bd72 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcb2>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    bdae:	mov	r1, r6
    bdb0:	mov	ip, r7
    bdb2:	mov	lr, r0
    bdb4:	mov	r3, r2
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    bdb6:	vstr	s14, [r4, #200]	; 0xc8
    bdba:	vstr	s17, [r4, #220]	; 0xdc
    bdbe:	vstr	s16, [r4, #216]	; 0xd8
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
      *out++ += *temp_1++ * *temp_2++;
    bdc2:	vldmia	lr!, {s13}
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    bdc6:	subs	r3, #1
      *out++ += *temp_1++ * *temp_2++;
    bdc8:	vldmia	ip!, {s14}
    bdcc:	vldmia	r1!, {s15}
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    bdd0:	cmp.w	r3, #4294967295
      *out++ += *temp_1++ * *temp_2++;
    bdd4:	vfma.f32	s15, s13, s14
    bdd8:	vstr	s15, [r1, #-4]
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    bddc:	bne.n	bdc2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd02>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    bdde:	vldr	s15, [pc, #-684]	; bb34 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa74>
    bde2:	vcmpe.f32	s11, s15
    bde6:	vmrs	APSR_nzcv, fpscr
    bdea:	bmi.w	c352 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1292>
    bdee:	vmov.f32	s15, #80	; 0x3e800000  0.250
    bdf2:	vcmpe.f32	s11, s15
    bdf6:	vmrs	APSR_nzcv, fpscr
    bdfa:	bgt.w	c352 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1292>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    bdfe:	vabs.f32	s15, s11
    be02:	vmov.f32	s14, #96	; 0x3f000000  0.5
    be06:	vadd.f32	s15, s15, s15
    be0a:	vcmpe.f32	s15, s14
    be0e:	vmrs	APSR_nzcv, fpscr
    be12:	bgt.n	be2a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd6a>
    be14:	vmov.f32	s13, #112	; 0x3f800000  1.0
    be18:	vsub.f32	s15, s13, s15
    be1c:	vcmpe.f32	s15, s14
    be20:	vmrs	APSR_nzcv, fpscr
    be24:	it	pl
    be26:	vmovpl.f32	s15, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    be2a:	vldr	s0, [r4, #244]	; 0xf4
    be2e:	vldr	s1, [r4, #248]	; 0xf8
    increment_ = (new_value - *state) / static_cast<float>(size);
    be32:	vsub.f32	s11, s11, s0
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    be36:	vldr	s14, [r4, #228]	; 0xe4
    be3a:	vsub.f32	s15, s15, s1
    be3e:	vdiv.f32	s20, s11, s10
    be42:	vdiv.f32	s21, s15, s10
  
    while (size--) {
    be46:	cmp	r5, #0
    be48:	beq.n	bf18 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe58>
    be4a:	mov	lr, r0
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    be4c:	mov	r3, r2
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    be4e:	vldr	s17, [pc, #-792]	; bb38 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa78>
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
          high_ = false;
    be52:	mov.w	r8, #0
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    be56:	vmov.f32	s19, #96	; 0x3f000000  0.5
    be5a:	vmov.f32	s16, #112	; 0x3f800000  1.0
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    be5e:	vmov.f32	s18, #224	; 0xbf000000 -0.5
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    be62:	vmov.f32	s23, #0	; 0x40000000  2.0
    be66:	vmov.f32	s22, #240	; 0xbf800000 -1.0
    be6a:	b.n	bee8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe28>
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
          float t = (phase_ - pw) / frequency;
    be6c:	vsub.f32	s11, s15, s1
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
    be70:	strb.w	r1, [r4, #240]	; 0xf0
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
          float t = (phase_ - pw) / frequency;
    be74:	vdiv.f32	s13, s11, s0
    be78:	vsub.f32	s11, s16, s13
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    be7c:	vmul.f32	s24, s13, s19
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    be80:	vmul.f32	s2, s11, s18
          float t = (phase_ - pw) / frequency;
          float discontinuity = 1.0f;
          if (through_zero_fm && frequency < 0.0f) {
            discontinuity = -discontinuity;
          }
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    be84:	vfma.f32	s14, s13, s24
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    be88:	vmov.f32	s13, s17
    be8c:	vfma.f32	s13, s11, s2
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
    be90:	vcmpe.f32	s15, s16
    be94:	vmrs	APSR_nzcv, fpscr
    be98:	blt.n	bebe <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdfe>
          phase_ -= 1.0f;
    be9a:	vsub.f32	s15, s15, s16
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
          high_ = false;
    be9e:	strb.w	r8, [r4, #240]	; 0xf0
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
    bea2:	vdiv.f32	s11, s15, s0
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    bea6:	vstr	s15, [r4, #224]	; 0xe0
    beaa:	vsub.f32	s2, s16, s11
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    beae:	vmul.f32	s25, s11, s19
          next_sample -= stmlib::NextBlepSample(t);
    beb2:	vmul.f32	s24, s2, s18
          high_ = phase_ >= pw;
        }
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    beb6:	vfms.f32	s14, s11, s25
          next_sample -= stmlib::NextBlepSample(t);
    beba:	vfms.f32	s13, s2, s24
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bebe:	vcmpe.f32	s1, s15
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bec2:	subs	r3, #1
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    bec4:	vmov.f32	s15, s22
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bec8:	vmrs	APSR_nzcv, fpscr
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    becc:	vfma.f32	s15, s14, s23
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bed0:	ite	le
    bed2:	vmovle.f32	s14, s16
    bed6:	vmovgt.f32	s14, s17
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    beda:	cmp.w	r3, #4294967295
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
          high_ = true;
        }
        next_sample += phase_ < pw ? 0.0f : 1.0f;
    bede:	vadd.f32	s14, s13, s14
          this_sample = 2.0f * this_sample - 1.0f;
          lp_state_ += integrator_coefficient * (this_sample - lp_state_);
          *out++ = (this_sample - lp_state_) * 0.5f;
        } else {
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
    bee2:	vstmia	lr!, {s15}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bee6:	beq.n	bf18 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe58>
  }

  inline float Next() {
    value_ += increment_;
    bee8:	vadd.f32	s0, s0, s20
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    beec:	vldr	s15, [r4, #224]	; 0xe0
    bef0:	vadd.f32	s1, s1, s21
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    bef4:	ldrb.w	ip, [r4, #240]	; 0xf0
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bef8:	vadd.f32	s15, s0, s15
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    befc:	vcmpe.f32	s1, s15
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bf00:	vstr	s15, [r4, #224]	; 0xe0
        next_sample += high_
          ? phase_ * slope_up
          : 1.0f - (phase_ - pw) * slope_down;
        *out++ = 2.0f * this_sample - 1.0f;
      } else {
        if (high_ ^ (phase_ >= pw)) {
    bf04:	vmrs	APSR_nzcv, fpscr
    bf08:	ite	ls
    bf0a:	movls	r1, #1
    bf0c:	movhi	r1, #0
    bf0e:	cmp	ip, r1
    bf10:	bne.n	be6c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdac>
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    bf12:	vldr	s13, [pc, #892]	; c290 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d0>
    bf16:	b.n	be90 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdd0>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    bf18:	vldr	s15, [pc, #888]	; c294 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d4>
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    bf1c:	vstr	s14, [r4, #228]	; 0xe4
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    bf20:	vcmpe.f32	s5, s15
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    bf24:	vstr	s1, [r4, #248]	; 0xf8
    bf28:	vstr	s0, [r4, #244]	; 0xf4
    bf2c:	vmrs	APSR_nzcv, fpscr
    bf30:	bmi.w	c348 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1288>
    bf34:	vmov.f32	s15, #80	; 0x3e800000  0.250
    bf38:	vcmpe.f32	s5, s15
    bf3c:	vmrs	APSR_nzcv, fpscr
    bf40:	bgt.w	c348 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1288>
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    bf44:	vabs.f32	s15, s5
    bf48:	vmov.f32	s14, #96	; 0x3f000000  0.5
    bf4c:	vadd.f32	s15, s15, s15
    bf50:	vcmpe.f32	s15, s14
    bf54:	vmrs	APSR_nzcv, fpscr
    bf58:	bgt.n	bf70 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xeb0>
    bf5a:	vmov.f32	s13, #112	; 0x3f800000  1.0
    bf5e:	vsub.f32	s15, s13, s15
    bf62:	vcmpe.f32	s15, s14
    bf66:	vmrs	APSR_nzcv, fpscr
    bf6a:	it	pl
    bf6c:	vmovpl.f32	s15, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    bf70:	vldr	s11, [r4, #272]	; 0x110
    bf74:	vldr	s2, [r4, #276]	; 0x114
    increment_ = (new_value - *state) / static_cast<float>(size);
    bf78:	vsub.f32	s5, s5, s11
    }
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
    bf7c:	vldr	s14, [r4, #256]	; 0x100
    bf80:	vsub.f32	s15, s15, s2
    bf84:	vdiv.f32	s17, s5, s10
    bf88:	vdiv.f32	s18, s15, s10
  
    while (size--) {
    bf8c:	cmp	r5, #0
    bf8e:	beq.n	c03a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf7a>
    bf90:	mov	r1, r7
    bf92:	mov	r3, r2
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
          next_sample -= stmlib::NextBlepSample(t);
    bf94:	vldr	s23, [pc, #760]	; c290 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d0>
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    bf98:	vmov.f32	s5, #112	; 0x3f800000  1.0
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bf9c:	vmov.f32	s22, #96	; 0x3f000000  0.5
          next_sample -= stmlib::NextBlepSample(t);
    bfa0:	vmov.f32	s21, #224	; 0xbf000000 -0.5
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bfa4:	vmov.f32	s20, #0	; 0x40000000  2.0
    bfa8:	vmov.f32	s19, #240	; 0xbf800000 -1.0
    bfac:	b.n	bfea <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf2a>
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    bfae:	vsub.f32	s15, s15, s5
          float t = phase_ / frequency;
    bfb2:	vdiv.f32	s13, s15, s11
      }
      phase_ += frequency;
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
    bfb6:	vstr	s15, [r4, #252]	; 0xfc
    bfba:	vsub.f32	s1, s5, s13
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bfbe:	vmul.f32	s16, s13, s22
          next_sample -= stmlib::NextBlepSample(t);
    bfc2:	vmul.f32	s0, s1, s21
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
          float t = phase_ / frequency;
          this_sample -= stmlib::ThisBlepSample(t);
    bfc6:	vfms.f32	s14, s13, s16
          next_sample -= stmlib::NextBlepSample(t);
    bfca:	vmov.f32	s13, s23
    bfce:	vfms.f32	s13, s1, s0
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bfd2:	vmov.f32	s1, s19
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bfd6:	subs	r3, #1
    bfd8:	cmp.w	r3, #4294967295
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bfdc:	vfma.f32	s1, s14, s20
          float t = phase_ / frequency;
          phase_ += 1.0f;
          this_sample += stmlib::ThisBlepSample(t);
          next_sample += stmlib::NextBlepSample(t);
        }
        next_sample += phase_;
    bfe0:	vadd.f32	s14, s13, s15

        if (shape == OSCILLATOR_SHAPE_SAW) {
          *out++ = 2.0f * this_sample - 1.0f;
    bfe4:	vstmia	r1!, {s1}
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator pwm(&pw_, pw, size);
  
    float next_sample = next_sample_;
  
    while (size--) {
    bfe8:	beq.n	c00e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf4e>
  }

  inline float Next() {
    value_ += increment_;
    bfea:	vadd.f32	s11, s11, s17
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    bfee:	vldr	s15, [r4, #252]	; 0xfc
    bff2:	vadd.f32	s2, s2, s18
    bff6:	vadd.f32	s15, s11, s15
      
      if (shape <= OSCILLATOR_SHAPE_SAW) {
        if (phase_ >= 1.0f) {
    bffa:	vcmpe.f32	s15, s5
    bffe:	vmrs	APSR_nzcv, fpscr
    c002:	bge.n	bfae <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xeee>
      float pw = (shape == OSCILLATOR_SHAPE_SQUARE_TRIANGLE ||
                  shape == OSCILLATOR_SHAPE_TRIANGLE) ? 0.5f : pwm.Next();
      if (has_external_fm) {
        CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
      }
      phase_ += frequency;
    c004:	vstr	s15, [r4, #252]	; 0xfc
  
    float next_sample = next_sample_;
  
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    c008:	vldr	s13, [pc, #644]	; c290 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d0>
    c00c:	b.n	bfd2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf12>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    c00e:	mov	r1, r6
    c010:	mov	r3, r2
          this_sample = 2.0f * this_sample - 1.0f;
          *out++ = this_sample;
        }
      }
    }
    next_sample_ = next_sample;
    c012:	vstr	s14, [r4, #256]	; 0x100
    c016:	vstr	s2, [r4, #276]	; 0x114
    c01a:	vstr	s11, [r4, #272]	; 0x110
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
      *out++ += *temp_1++ * *temp_2++;
    c01e:	vldmia	r0!, {s13}
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    c022:	subs	r3, #1
      *out++ += *temp_1++ * *temp_2++;
    c024:	vldmia	r7!, {s14}
    c028:	vldmia	r1!, {s15}
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    c02c:	cmp.w	r3, #4294967295
      *out++ += *temp_1++ * *temp_2++;
    c030:	vfma.f32	s15, s13, s14
    c034:	vstr	s15, [r1, #-4]
      float* temp_2,
      float* out,
      size_t size) {
    osc[0].Render<OSCILLATOR_SHAPE_SQUARE>(f1, 0.5f, temp_1, size);
    osc[1].Render<OSCILLATOR_SHAPE_SAW>(f2, 0.5f, temp_2, size);
    while (size--) {
    c038:	bne.n	c01e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf5e>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    c03a:	vldr	s14, [pc, #604]	; c298 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d8>
    c03e:	vldr	s15, [pc, #604]	; c29c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11dc>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    c042:	ldr	r3, [pc, #604]	; (c2a0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e0>)

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    c044:	vfma.f32	s15, s3, s14
    // Render the metallic noise.
    metallic_noise_.Render(2.0f * f0, temp_1, temp_2, out, size);

    // Apply BPF on the metallic noise.
    float cutoff = 150.0f / kSampleRate * stmlib::SemitonesToRatio(
        tone * 72.0f);
    c048:	vldr	s11, [pc, #600]	; c2a4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e4>
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    c04c:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    c050:	vcvt.f32.s32	s5, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    c054:	vmov	r1, s14
    c058:	add.w	r3, r3, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    c05c:	vsub.f32	s15, s15, s5
    c060:	vldr	s13, [r3]
    c064:	ldr	r3, [pc, #576]	; (c2a8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e8>)
    c066:	vcvt.s32.f32	s15, s15, #8
    c06a:	vmov	r1, s15
    c06e:	add.w	r3, r3, r1, lsl #2
    c072:	vldr	s14, [r3]
    c076:	vmul.f32	s15, s14, s13
    c07a:	vmul.f32	s15, s15, s11
    CONSTRAIN(cutoff, 0.0f, 16000.0f / kSampleRate);
    c07e:	vcmpe.f32	s15, #0.0
    c082:	vmrs	APSR_nzcv, fpscr
    c086:	bmi.w	c3ae <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12ee>
    c08a:	vldr	s14, [pc, #544]	; c2ac <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11ec>
    c08e:	vcmpe.f32	s15, s14
    c092:	vmrs	APSR_nzcv, fpscr
    c096:	bgt.w	c390 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12d0>
    c09a:	vmul.f32	s14, s15, s15
    c09e:	vldr	s13, [pc, #528]	; c2b0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11f0>
    c0a2:	vldr	s1, [pc, #528]	; c2b4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11f4>
    c0a6:	vmov.f32	s5, #112	; 0x3f800000  1.0
    c0aa:	vldr	s2, [pc, #524]	; c2b8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11f8>
    c0ae:	vmov.f32	s0, #0	; 0x40000000  2.0
    c0b2:	vfma.f32	s1, s14, s13
    c0b6:	vldr	s3, [pc, #516]	; c2bc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11fc>
    c0ba:	vldr	s13, [pc, #516]	; c2c0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1200>
    c0be:	vldr	s11, [pc, #516]	; c2c4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1204>
    c0c2:	vfma.f32	s2, s14, s1
    c0c6:	vfma.f32	s3, s14, s2
    c0ca:	vfma.f32	s13, s14, s3
    c0ce:	vfma.f32	s11, s14, s13
    c0d2:	vmul.f32	s11, s11, s15
    c0d6:	vmov.f32	s15, s5
    c0da:	vadd.f32	s13, s11, s5
    c0de:	vfma.f32	s15, s11, s0
    c0e2:	vfma.f32	s13, s11, s11
    c0e6:	vfma.f32	s15, s11, s11
    c0ea:	vdiv.f32	s14, s5, s13
    c0ee:	vdiv.f32	s13, s5, s15

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    c0f2:	vstr	s11, [r4, #280]	; 0x118
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    c0f6:	vstr	s14, [r4, #288]	; 0x120
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    c0fa:	vldr	s2, [r4, #292]	; 0x124
    float state_2 = state_2_;
    c0fe:	vldr	s3, [r4, #296]	; 0x128
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c102:	vmov.f32	s0, #112	; 0x3f800000  1.0
    c106:	vstr	s0, [r4, #284]	; 0x11c
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c10a:	cmp	r5, #0
    c10c:	beq.w	c3e0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1320>
    c110:	vmov.f32	s5, s11
    c114:	mov	r1, r6
      if (f >= 0.499f) f = 0.499f;
      increment[i] = static_cast<uint32_t>(f * 4294967296.0f);
      phase[i] = phase_[i];
    }

    while (size--) {
    c116:	mov	r3, r2
    c118:	b.n	c126 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1066>
    c11a:	vldr	s0, [r4, #284]	; 0x11c
    c11e:	vldr	s5, [r4, #280]	; 0x118
    c122:	vldr	s14, [r4, #288]	; 0x120
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    c126:	vneg.f32	s1, s2
    c12a:	vldr	s15, [r1]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c12e:	subs	r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    c130:	vfma.f32	s15, s1, s0
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c134:	adds	r0, r3, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    c136:	vfma.f32	s15, s1, s5
    c13a:	vsub.f32	s15, s15, s3
    c13e:	vmul.f32	s15, s15, s14
      bp = g_ * hp + state_1;
    c142:	vmov.f32	s14, s2
    c146:	vfma.f32	s14, s15, s5
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    c14a:	vfma.f32	s3, s14, s5
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
    c14e:	vstmia	r1!, {s14}
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    c152:	vmov.f32	s2, s14
    c156:	vfma.f32	s2, s15, s5
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    c15a:	vfma.f32	s3, s14, s5
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c15e:	bne.n	c11a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x105a>
        out, out, size);
    
    // This is not at all part of the 808 circuit! But to add more variety, we
    // add a variable amount of clocked noise to the output of the 6 schmitt
    // trigger oscillators.
    noisiness *= noisiness;
    c160:	vmul.f32	s4, s4, s4
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    c164:	vstr	s2, [r4, #292]	; 0x124
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    c168:	vmov.f32	s14, #112	; 0x3f800000  1.0
    state_2_ = state_2;
    c16c:	vstr	s3, [r4, #296]	; 0x128
    c170:	vmov.f32	s15, #48	; 0x41800000  16.0
    c174:	vsub.f32	s14, s14, s4
    c178:	vfma.f32	s15, s14, s15
    c17c:	vmul.f32	s12, s15, s12
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    c180:	vcmpe.f32	s12, #0.0
    c184:	vmrs	APSR_nzcv, fpscr
    c188:	bmi.w	c3cc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x130c>
    c18c:	vmov.f32	s15, #96	; 0x3f000000  0.5
    c190:	vcmp.f32	s12, s15
    c194:	vmrs	APSR_nzcv, fpscr
    c198:	it	gt
    c19a:	vmovgt.f32	s12, s15
    c19e:	ldr.w	sl, [pc, #304]	; c2d0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1210>
    c1a2:	mov.w	r8, #0
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
    c1a6:	vmov.f32	s5, #112	; 0x3f800000  1.0
    c1aa:	mov	r1, r6
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    c1ac:	vmov.f32	s2, #224	; 0xbf000000 -0.5
    c1b0:	ldr.w	r3, [sl]
    // This is not at all part of the 808 circuit! But to add more variety, we
    // add a variable amount of clocked noise to the output of the 6 schmitt
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    c1b4:	mov	r7, r8
    c1b6:	mov	r0, r6
    c1b8:	ldr.w	ip, [pc, #280]	; c2d4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1214>
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    c1bc:	vldr	s3, [pc, #264]	; c2c8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1208>
    c1c0:	b.n	c1fc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x113c>
    c1c2:	ldr	r3, [pc, #264]	; (c2cc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x120c>)
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
    c1c4:	vsub.f32	s15, s15, s5
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    c1c8:	vmov.f32	s14, s2
    c1cc:	mov.w	r8, #1
    c1d0:	add	r3, lr
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
    c1d2:	vstr	s15, [r4, #100]	; 0x64
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
    c1d6:	vmov	s15, r3
    c1da:	vcvt.f32.u32	s15, s15
    c1de:	vfma.f32	s14, s15, s3
    c1e2:	vstr	s14, [r4, #104]	; 0x68
      }
      out[i] += noisiness * (noise_sample_ - out[i]);
    c1e6:	vldr	s15, [r0]
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
    c1ea:	adds	r7, #1
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
      }
      out[i] += noisiness * (noise_sample_ - out[i]);
    c1ec:	vsub.f32	s14, s14, s15
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
    c1f0:	cmp	r5, r7
      noise_clock_ += noise_f;
      if (noise_clock_ >= 1.0f) {
        noise_clock_ -= 1.0f;
        noise_sample_ = stmlib::Random::GetFloat() - 0.5f;
      }
      out[i] += noisiness * (noise_sample_ - out[i]);
    c1f2:	vfma.f32	s15, s14, s4
    c1f6:	vstmia	r0!, {s15}
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
    c1fa:	bls.n	c21c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x115c>
      noise_clock_ += noise_f;
    c1fc:	vldr	s15, [r4, #100]	; 0x64
    c200:	mul.w	lr, ip, r3
    c204:	vadd.f32	s15, s12, s15
      if (noise_clock_ >= 1.0f) {
    c208:	vcmpe.f32	s15, s5
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    
    for (size_t i = 0; i < size; ++i) {
      noise_clock_ += noise_f;
    c20c:	vstr	s15, [r4, #100]	; 0x64
      if (noise_clock_ >= 1.0f) {
    c210:	vmrs	APSR_nzcv, fpscr
    c214:	bge.n	c1c2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1102>
    c216:	vldr	s14, [r4, #104]	; 0x68
    c21a:	b.n	c1e6 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1126>
    c21c:	cmp.w	r8, #0
    c220:	bne.w	c420 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1360>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    c224:	vldr	s5, [r4, #108]	; 0x6c
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
    c228:	vmov.f32	s12, #96	; 0x3f000000  0.5
    increment_ = (new_value - *state) / static_cast<float>(size);
    c22c:	movs	r3, #0
    c22e:	ldr	r0, [sp, #40]	; 0x28
    c230:	vmov.f32	s15, s5
    c234:	vfnms.f32	s15, s6, s7
    c238:	vdiv.f32	s7, s15, s10
    c23c:	vldr	s15, [r4, #96]	; 0x60
    // Apply VCA.
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
    c240:	adds	r3, #1
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
    c242:	vcmpe.f32	s15, s12
    c246:	vmrs	APSR_nzcv, fpscr
    c24a:	ite	le
    c24c:	vmovle.f32	s14, s8
    c250:	vmovgt.f32	s14, s9
    c254:	vmul.f32	s15, s15, s14
    c258:	vstr	s15, [r4, #96]	; 0x60
      out[i] = vca(out[i], sustain ? sustain_gain.Next() : envelope_);
    c25c:	vldr	s14, [r1]
    c260:	cbz	r0, c26a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11aa>
  }

  inline float Next() {
    value_ += increment_;
    c262:	vadd.f32	s5, s5, s7
    c266:	vmov.f32	s15, s5
    c26a:	vmul.f32	s15, s14, s15
    // Apply VCA.
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
    c26e:	cmp	r5, r3
      VCA vca;
      envelope_ *= envelope_ > 0.5f ? envelope_decay : cut_decay;
      out[i] = vca(out[i], sustain ? sustain_gain.Next() : envelope_);
    c270:	vstmia	r1!, {s15}
    // Apply VCA.
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    for (size_t i = 0; i < size; ++i) {
    c274:	bhi.n	c23c <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x117c>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c276:	vmov.f32	s9, #0	; 0x40000000  2.0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    c27a:	vstr	s11, [r4, #300]	; 0x12c
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    c27e:	vstr	s13, [r4, #308]	; 0x134
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    c282:	vldr	s12, [r4, #312]	; 0x138
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c286:	vstr	s9, [r4, #304]	; 0x130
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    c28a:	vldr	s14, [r4, #316]	; 0x13c
    c28e:	b.n	c2f8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1238>
    c290:	.word	0x00000000
    c294:	.word	0x358637bd
    c298:	.word	0x42900000
    c29c:	.word	0x43000000
    c2a0:	.word	0x20000554
    c2a4:	.word	0x3b4ccccd
    c2a8:	.word	0x20000958
    c2ac:	.word	0x3eaaaaab
    c2b0:	.word	0x452efe23
    c2b4:	.word	0x42acec90
    c2b8:	.word	0x4321348f
    c2bc:	.word	0x42234866
    c2c0:	.word	0x41255da8
    c2c4:	.word	0x40490fdb
    c2c8:	.word	0x2f800000
    c2cc:	.word	0x3c6ef35f
    c2d0:	.word	0x20020470
    c2d4:	.word	0x0019660d
    c2d8:	.word	0x3e385c19
    c2dc:	.word	0x3e0d508c
    c2e0:	.word	0x403732c1
    c2e4:	.word	0x3fd88fab
    c2e8:	.word	0x00000000
    c2ec:	vldr	s9, [r4, #304]	; 0x130
    c2f0:	vldr	s11, [r4, #300]	; 0x12c
    c2f4:	vldr	s13, [r4, #308]	; 0x134
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    c2f8:	vneg.f32	s10, s12
    c2fc:	vldr	s15, [r6]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c300:	subs	r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    c302:	vfma.f32	s15, s10, s9
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c306:	adds	r3, r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
    c308:	vfma.f32	s15, s10, s11
    c30c:	vsub.f32	s15, s15, s14
    c310:	vmul.f32	s15, s15, s13
      bp = g_ * hp + state_1;
    c314:	vmov.f32	s13, s12
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
    c318:	vstmia	r6!, {s15}
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
    c31c:	vfma.f32	s13, s15, s11
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
    c320:	vfma.f32	s14, s13, s11
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
    c324:	vmov.f32	s12, s13
    c328:	vfma.f32	s12, s15, s11
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
    c32c:	vfma.f32	s14, s13, s11
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
    c330:	bne.n	c2ec <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x122c>
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    c332:	vstr	s12, [r4, #312]	; 0x138
    state_2_ = state_2;
    c336:	vstr	s14, [r4, #316]	; 0x13c
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    c33a:	vstr	s5, [r4, #108]	; 0x6c
      parameters.harmonics,
      temp_buffer_[0],
      temp_buffer_[1],
      aux,
      size);
}
    c33e:	add	sp, #164	; 0xa4
    c340:	vpop	{d8-d14}
    c344:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    c348:	vmov.f32	s5, s15
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    c34c:	vmov.f32	s15, #96	; 0x3f000000  0.5
    c350:	b.n	bf70 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xeb0>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    c352:	vmov.f32	s11, s15
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    c356:	vmov.f32	s15, #96	; 0x3f000000  0.5
    c35a:	b.n	be2a <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd6a>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    c35c:	vmov.f32	s0, s15
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    c360:	vmov.f32	s15, #96	; 0x3f000000  0.5
    c364:	b.n	bd10 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc50>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    c366:	vmov.f32	s16, s15
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    c36a:	vmov.f32	s15, #96	; 0x3f000000  0.5
    c36e:	b.n	bbb8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xaf8>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    c370:	vmov.f32	s25, s15
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    c374:	vmov.f32	s15, #96	; 0x3f000000  0.5
    c378:	b.w	ba60 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9a0>
      float* out,
      size_t size) {
    
    if (!has_external_fm) {
      if (!through_zero_fm) {
        CONSTRAIN(frequency, kMinFrequency, kMaxFrequency);
    c37c:	vmov.f32	s15, s14
      } else {
        CONSTRAIN(frequency, -kMaxFrequency, kMaxFrequency);
      }
      CONSTRAIN(pw, fabsf(frequency) * 2.0f, 1.0f - 2.0f * fabsf(frequency))
    c380:	vmov.f32	s14, #96	; 0x3f000000  0.5
    c384:	b.w	b904 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x844>

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    c388:	movs	r3, #0
    c38a:	mov	r2, r3
    c38c:	b.w	b104 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>
    metallic_noise_.Render(2.0f * f0, temp_1, temp_2, out, size);

    // Apply BPF on the metallic noise.
    float cutoff = 150.0f / kSampleRate * stmlib::SemitonesToRatio(
        tone * 72.0f);
    CONSTRAIN(cutoff, 0.0f, 16000.0f / kSampleRate);
    c390:	vldr	s13, [pc, #-184]	; c2dc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x121c>
    c394:	vldr	s14, [pc, #-192]	; c2d8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1218>
    c398:	vldr	s11, [pc, #-184]	; c2e4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1224>
    c39c:	b.n	c0f2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1032>
    c39e:	vldr	s13, [pc, #-196]	; c2dc <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x121c>
    c3a2:	vldr	s16, [pc, #-196]	; c2e0 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1220>
    c3a6:	vldr	s9, [pc, #-196]	; c2e4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1224>
    c3aa:	b.w	b4ba <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3fa>
    c3ae:	vmov.f32	s13, #112	; 0x3f800000  1.0
    c3b2:	vldr	s11, [pc, #-204]	; c2e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1228>
    c3b6:	vmov.f32	s14, s13
    c3ba:	b.n	c0f2 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1032>
    c3bc:	vldr	s16, [pc, #-216]	; c2e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1228>
    c3c0:	vmov.f32	s13, #112	; 0x3f800000  1.0
    c3c4:	vmov.f32	s9, s16
    c3c8:	b.w	b4ba <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3fa>
    // This is not at all part of the 808 circuit! But to add more variety, we
    // add a variable amount of clocked noise to the output of the 6 schmitt
    // trigger oscillators.
    noisiness *= noisiness;
    float noise_f = f0 * (16.0f + 16.0f * (1.0f - noisiness));
    CONSTRAIN(noise_f, 0.0f, 0.5f);
    c3cc:	vldr	s12, [pc, #-232]	; c2e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1228>
    c3d0:	b.n	c19e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10de>
    c3d2:	vldr	s11, [pc, #-236]	; c2e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1228>
    c3d6:	b.w	b586 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4c6>
    c3da:	ldr	r3, [sp, #136]	; 0x88
    c3dc:	b.w	b3a4 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2e4>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c3e0:	mov.w	r3, #1073741824	; 0x40000000

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    c3e4:	vstr	s11, [r4, #300]	; 0x12c
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    c3e8:	vstr	s13, [r4, #308]	; 0x134
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    c3ec:	vldr	s5, [r4, #108]	; 0x6c
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c3f0:	str.w	r3, [r4, #304]	; 0x130
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    c3f4:	vldr	s12, [r4, #312]	; 0x138
    float state_2 = state_2_;
    c3f8:	vldr	s14, [r4, #316]	; 0x13c
    c3fc:	b.n	c332 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1272>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c3fe:	mov.w	r3, #1073741824	; 0x40000000

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    c402:	vstr	s9, [r4, #76]	; 0x4c
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    c406:	vstr	s13, [r4, #84]	; 0x54
    c40a:	vldr	s2, [r4, #28]
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    c40e:	str	r3, [r4, #80]	; 0x50
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    c410:	vldr	s11, [r4, #88]	; 0x58
    float state_2 = state_2_;
    c414:	vldr	s14, [r4, #92]	; 0x5c
    increment_ = (new_value - *state) / static_cast<float>(size);
    c418:	vldr	s10, [pc, #-308]	; c2e8 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1228>
    c41c:	b.w	b76e <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6ae>
    c420:	str.w	r3, [sl]
    c424:	b.n	c224 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1164>
    c426:	str.w	r3, [sl]
    c42a:	b.w	b634 <plaits::HiHatEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x574>
    c42e:	nop

0000c430 <plaits::ChordEngine::Init(stmlib::BufferAllocator*)>:
  { 0.00f, 4.00f,  7.00f, 12.00f },  // M
};

#endif  // JON_CHORDS

void ChordEngine::Init(BufferAllocator* allocator) {
    c430:	push	{r4, r5, r6, r7, lr}
    c432:	mov	ip, r1
 public:
  StringSynthOscillator() { }
  ~StringSynthOscillator() { }
  
  inline void Init() {
    phase_ = 0.0f;
    c434:	movs	r3, #0
    next_sample_ = 0.0f;
    segment_ = 0.0f;
    c436:	movs	r1, #0
    c438:	mov	r4, r0
    c43a:	add.w	lr, r0, #140	; 0x8c
    c43e:	mov	r2, r0
    
    frequency_ = 0.001f;
    c440:	ldr	r7, [pc, #100]	; (c4a8 <plaits::ChordEngine::Init(stmlib::BufferAllocator*)+0x78>)
 public:
  StringSynthOscillator() { }
  ~StringSynthOscillator() { }
  
  inline void Init() {
    phase_ = 0.0f;
    c442:	str	r3, [r2, #16]
    c444:	adds	r4, #28
    next_sample_ = 0.0f;
    c446:	str	r3, [r2, #20]
    segment_ = 0.0f;
    c448:	movs	r5, #0
    c44a:	str	r1, [r2, #24]
 public:
  StringSynthOscillator() { }
  ~StringSynthOscillator() { }
  
  inline void Init() {
    phase_ = 0.0f;
    c44c:	movs	r6, #0
    next_sample_ = 0.0f;
    segment_ = 0.0f;
    
    frequency_ = 0.001f;
    c44e:	str	r7, [r2, #28]
    c450:	adds	r2, #32
    saw_8_gain_ = 0.0f;
    c452:	str	r3, [r2, #0]
    saw_4_gain_ = 0.0f;
    c454:	str	r3, [r2, #4]
    saw_2_gain_ = 0.0f;
    c456:	str	r3, [r2, #8]
    saw_1_gain_ = 0.0f;
    c458:	str	r3, [r2, #12]
 public:
  WavetableOscillator() { }
  ~WavetableOscillator() { }

  void Init() {
    phase_ = 0.0f;
    c45a:	str.w	r3, [r4, #148]	; 0x94
    frequency_ = 0.0f;
    c45e:	str.w	r3, [r4, #152]	; 0x98
    amplitude_ = 0.0f;
    c462:	str.w	r3, [r4, #156]	; 0x9c
    waveform_ = 0.0f;
    c466:	str.w	r3, [r4, #160]	; 0xa0
    lp_ = 0.0f;
    c46a:	str.w	r3, [r4, #164]	; 0xa4
 public:
  Differentiator() { }
  ~Differentiator() { }

  void Init() {
    previous_ = 0.0f;
    c46e:	str.w	r3, [r4, #172]	; 0xac
    lp_ = 0.0f;
    c472:	str.w	r3, [r4, #168]	; 0xa8
  for (int i = 0; i < kChordNumVoices; ++i) {
    c476:	cmp	r4, lr
    c478:	bne.n	c442 <plaits::ChordEngine::Init(stmlib::BufferAllocator*)+0x12>
 public:
  HysteresisQuantizer() { }
  ~HysteresisQuantizer() { }

  void Init() {
    quantized_value_ = 0;
    c47a:	str.w	r5, [r0, #316]	; 0x13c
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    c47e:	ldr.w	r3, [ip, #8]
    divide_down_voice_[i].Init();
    wavetable_voice_[i].Init();
  }
  chord_index_quantizer_.Init();
  morph_lp_ = 0.0f;
    c482:	str.w	r6, [r0, #320]	; 0x140
    c486:	cmp	r3, #175	; 0xaf
  timbre_lp_ = 0.0f;
    c488:	str.w	r6, [r0, #324]	; 0x144
    c48c:	bls.n	c4a0 <plaits::ChordEngine::Init(stmlib::BufferAllocator*)+0x70>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    c48e:	ldr.w	r5, [ip]
      next_ += size_bytes;
      free_ -= size_bytes;
    c492:	subs	r3, #176	; 0xb0
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    c494:	add.w	r2, r5, #176	; 0xb0
      free_ -= size_bytes;
    c498:	str.w	r3, [ip, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    c49c:	str.w	r2, [ip]
  
  ratios_ = allocator->Allocate<float>(kChordNumChords * kChordNumNotes);
    c4a0:	str.w	r5, [r0, #332]	; 0x14c
    c4a4:	pop	{r4, r5, r6, r7, pc}
    c4a6:	nop
    c4a8:	.word	0x3a83126f

0000c4ac <plaits::ChordEngine::Reset()>:
}

void ChordEngine::Reset() {
    c4ac:	ldr.w	r2, [r0, #332]	; 0x14c
    c4b0:	vldr	s15, [pc, #112]	; c524 <plaits::ChordEngine::Reset()+0x78>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    c4b4:	vldr	s11, [pc, #112]	; c528 <plaits::ChordEngine::Reset()+0x7c>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    c4b8:	vldr	s12, [pc, #112]	; c52c <plaits::ChordEngine::Reset()+0x80>
    c4bc:	push	{r4, r5, r6, r7}
    c4be:	ldr	r6, [pc, #112]	; (c530 <plaits::ChordEngine::Reset()+0x84>)
    c4c0:	add.w	r7, r2, #176	; 0xb0
    c4c4:	ldr	r5, [pc, #108]	; (c534 <plaits::ChordEngine::Reset()+0x88>)
    c4c6:	ldr	r4, [pc, #112]	; (c538 <plaits::ChordEngine::Reset()+0x8c>)
    c4c8:	add.w	r0, r2, #16
    c4cc:	mov	r1, r6

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    c4ce:	vadd.f32	s15, s15, s11
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    c4d2:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    c4d6:	vcvt.f32.s32	s13, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    c4da:	vmov	r3, s14
    c4de:	add.w	r3, r4, r3, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    c4e2:	vsub.f32	s15, s15, s13
  for (int i = 0; i < kChordNumChords; ++i) {
    for (int j = 0; j < kChordNumNotes; ++j) {
      ratios_[i * kChordNumNotes + j] = SemitonesToRatio(chords[i][j]);
    c4e6:	vldr	s14, [r3]
    c4ea:	vmul.f32	s15, s15, s12
    c4ee:	vcvt.s32.f32	s15, s15
    c4f2:	vmov	r3, s15
    c4f6:	add.w	r3, r5, r3, lsl #2
    c4fa:	vldr	s15, [r3]
    c4fe:	vmul.f32	s15, s15, s14
    c502:	vstmia	r2!, {s15}
  ratios_ = allocator->Allocate<float>(kChordNumChords * kChordNumNotes);
}

void ChordEngine::Reset() {
  for (int i = 0; i < kChordNumChords; ++i) {
    for (int j = 0; j < kChordNumNotes; ++j) {
    c506:	cmp	r0, r2
    c508:	beq.n	c512 <plaits::ChordEngine::Reset()+0x66>
    c50a:	adds	r1, #4
    c50c:	vldr	s15, [r1]
    c510:	b.n	c4ce <plaits::ChordEngine::Reset()+0x22>
  
  ratios_ = allocator->Allocate<float>(kChordNumChords * kChordNumNotes);
}

void ChordEngine::Reset() {
  for (int i = 0; i < kChordNumChords; ++i) {
    c512:	cmp	r2, r7
    c514:	beq.n	c51e <plaits::ChordEngine::Reset()+0x72>
    c516:	adds	r6, #16
    c518:	vldr	s15, [r6]
    c51c:	b.n	c4c8 <plaits::ChordEngine::Reset()+0x1c>
    for (int j = 0; j < kChordNumNotes; ++j) {
      ratios_[i * kChordNumNotes + j] = SemitonesToRatio(chords[i][j]);
    }
  }
}
    c51e:	pop	{r4, r5, r6, r7}
    c520:	bx	lr
    c522:	nop
    c524:	.word	0x00000000
    c528:	.word	0x43000000
    c52c:	.word	0x43800000
    c530:	.word	0x2001f888
    c534:	.word	0x20000958
    c538:	.word	0x20000554

0000c53c <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)>:
    int chord_index,
    float inversion,
    float* ratios,
    float* amplitudes) {
  const float* base_ratio = &ratios_[chord_index * kChordNumNotes];
  inversion = inversion * float(kChordNumNotes * 5);
    c53c:	vmov.f32	s15, #52	; 0x41a00000  20.0

int ChordEngine::ComputeChordInversion(
    int chord_index,
    float inversion,
    float* ratios,
    float* amplitudes) {
    c540:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const float* base_ratio = &ratios_[chord_index * kChordNumNotes];
  inversion = inversion * float(kChordNumNotes * 5);
    c544:	vmul.f32	s0, s0, s15

int ChordEngine::ComputeChordInversion(
    int chord_index,
    float inversion,
    float* ratios,
    float* amplitudes) {
    c548:	sub	sp, #20
  const float* base_ratio = &ratios_[chord_index * kChordNumNotes];
  inversion = inversion * float(kChordNumNotes * 5);

  MAKE_INTEGRAL_FRACTIONAL(inversion);
    c54a:	vcvt.s32.f32	s15, s0
    c54e:	vmov	r4, s15
    c552:	vcvt.f32.s32	s15, s15
  
  int num_rotations = inversion_integral / kChordNumNotes;
    c556:	cmp	r4, #0
    float* ratios,
    float* amplitudes) {
  const float* base_ratio = &ratios_[chord_index * kChordNumNotes];
  inversion = inversion * float(kChordNumNotes * 5);

  MAKE_INTEGRAL_FRACTIONAL(inversion);
    c558:	vsub.f32	s0, s0, s15
  
  int num_rotations = inversion_integral / kChordNumNotes;
    c55c:	blt.n	c61a <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xde>
    c55e:	mov	ip, r4
    c560:	add.w	r8, r4, #3
  int rotated_note = inversion_integral % kChordNumNotes;
    c564:	ldr.w	lr, [pc, #304]	; c698 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x15c>
  const float* base_ratio = &ratios_[chord_index * kChordNumNotes];
  inversion = inversion * float(kChordNumNotes * 5);

  MAKE_INTEGRAL_FRACTIONAL(inversion);
  
  int num_rotations = inversion_integral / kChordNumNotes;
    c568:	mov.w	ip, ip, asr #2
  int rotated_note = inversion_integral % kChordNumNotes;
    c56c:	and.w	lr, r4, lr
    c570:	cmp.w	lr, #0
    c574:	blt.n	c622 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xe6>
    c576:	ldr.w	r0, [r0, #332]	; 0x14c
    c57a:	movs	r7, #1
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c57c:	vmov.f32	s13, #80	; 0x3e800000  0.250
  inversion = inversion * float(kChordNumNotes * 5);

  MAKE_INTEGRAL_FRACTIONAL(inversion);
  
  int num_rotations = inversion_integral / kChordNumNotes;
  int rotated_note = inversion_integral % kChordNumNotes;
    c580:	movs	r5, #0
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    c582:	vmov.f32	s12, #112	; 0x3f800000  1.0
    c586:	rsb	ip, ip, #5
    c58a:	add.w	r1, r0, r1, lsl #4
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c58e:	mov	sl, r7
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    c590:	ldr.w	r9, [pc, #264]	; c69c <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x160>
  int num_rotations = inversion_integral / kChordNumNotes;
  int rotated_note = inversion_integral % kChordNumNotes;
  
  const float kBaseGain = 0.25f;
  
  int mask = 0;
    c594:	str	r5, [sp, #0]
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c596:	subs.w	r0, r8, r5
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    c59a:	add.w	r6, ip, r5
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
    c59e:	vldr	s14, [r1]
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c5a2:	it	mi
    c5a4:	addmi	r0, #3
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
    c5a6:	cmp	lr, r5
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c5a8:	mov.w	r4, r0, asr #2
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    c5ac:	smull	fp, r0, r9, r6
    c5b0:	mov.w	fp, r6, asr #31
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c5b4:	lsl.w	r4, sl, r4
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    c5b8:	rsb	r0, fp, r0, asr #1
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c5bc:	vmov	s15, r4
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    c5c0:	add.w	r0, r0, r0, lsl #2
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c5c4:	vcvt.f32.s32	s15, s15
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    c5c8:	sub.w	r0, r6, r0
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    c5cc:	add.w	r6, r0, #4
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    float transposition = 0.25f * static_cast<float>(
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    c5d0:	vmul.f32	s15, s15, s13
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    c5d4:	smull	r4, fp, r9, r6
    c5d8:	mov.w	r4, r6, asr #31
    c5dc:	rsb	r4, r4, fp, asr #1
    c5e0:	add.w	r4, r4, r4, lsl #2
    c5e4:	sub.w	r4, r6, r4
    
    if (i == rotated_note) {
    c5e8:	beq.n	c650 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x114>
      ratios[target_voice] = base_ratio[i] * transposition;
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    } else if (i < rotated_note) {
      ratios[previous_voice] = base_ratio[i] * transposition;
    c5ea:	it	gt
    c5ec:	lslgt	r6, r4, #2
      amplitudes[previous_voice] = kBaseGain;
    } else {
      ratios[target_voice] = base_ratio[i] * transposition;
    c5ee:	vmul.f32	s15, s14, s15
    c5f2:	it	le
    c5f4:	lslle	r6, r0, #2
    c5f6:	add.w	fp, r2, r6
      amplitudes[target_voice] = kBaseGain;
    c5fa:	add	r6, r3
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    } else if (i < rotated_note) {
      ratios[previous_voice] = base_ratio[i] * transposition;
      amplitudes[previous_voice] = kBaseGain;
    } else {
      ratios[target_voice] = base_ratio[i] * transposition;
    c5fc:	vstr	s15, [fp]
      amplitudes[target_voice] = kBaseGain;
    c600:	vstr	s13, [r6]
    }
    
    if (i == 0) {
    c604:	cbz	r5, c630 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xf4>
  
  const float kBaseGain = 0.25f;
  
  int mask = 0;
  
  for (int i = 0; i < kChordNumNotes; ++i) {
    c606:	cmp	r7, #4
    c608:	beq.n	c612 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xd6>
    c60a:	adds	r5, #1
    c60c:	adds	r7, #1
    c60e:	adds	r1, #4
    c610:	b.n	c596 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x5a>
        mask |= 1 << previous_voice;
      }
    }
  }
  return mask;
}
    c612:	ldr	r0, [sp, #0]
    c614:	add	sp, #20
    c616:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const float* base_ratio = &ratios_[chord_index * kChordNumNotes];
  inversion = inversion * float(kChordNumNotes * 5);

  MAKE_INTEGRAL_FRACTIONAL(inversion);
  
  int num_rotations = inversion_integral / kChordNumNotes;
    c61a:	add.w	r8, r4, #3
    c61e:	mov	ip, r8
    c620:	b.n	c564 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x28>
  int rotated_note = inversion_integral % kChordNumNotes;
    c622:	add.w	lr, lr, #4294967295
    c626:	orn	lr, lr, #3
    c62a:	add.w	lr, lr, #1
    c62e:	b.n	c576 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x3a>
      ratios[target_voice] = base_ratio[i] * transposition;
      amplitudes[target_voice] = kBaseGain;
    }
    
    if (i == 0) {
      if (i >= rotated_note) {
    c630:	cmp.w	lr, #0
    c634:	bgt.n	c644 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0x108>
        mask |= 1 << target_voice;
    c636:	ldr	r6, [sp, #0]
    c638:	lsl.w	r0, sl, r0
    c63c:	orr.w	r6, r6, r0
    c640:	str	r6, [sp, #0]
      }
      if (i <= rotated_note) {
    c642:	bne.n	c60a <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xce>
        mask |= 1 << previous_voice;
    c644:	ldr	r0, [sp, #0]
    c646:	lsl.w	r4, sl, r4
    c64a:	orrs	r0, r4
    c64c:	str	r0, [sp, #0]
    c64e:	b.n	c60a <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xce>
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
    c650:	mov.w	fp, r0, lsl #2
    c654:	vmul.f32	s15, s15, s14
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    c658:	vsub.f32	s11, s12, s0
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
    c65c:	add.w	r6, r2, fp
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    c660:	add	fp, r3
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
    c662:	vmul.f32	s10, s0, s13
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
    c666:	str	r6, [sp, #4]
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
    c668:	lsls	r6, r4, #2
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    c66a:	str.w	fp, [sp, #12]
    c66e:	vmul.f32	s14, s11, s13
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
    c672:	add.w	fp, r2, r6
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
    c676:	add	r6, r3
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
    c678:	vadd.f32	s11, s15, s15
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
    c67c:	str	r6, [sp, #8]
        1 << ((kChordNumNotes - 1 + inversion_integral - i) / kChordNumNotes));
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
    c67e:	ldr	r6, [sp, #4]
    c680:	vstr	s15, [r6]
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
    c684:	ldr	r6, [sp, #8]
    int target_voice = (i - num_rotations + kChordNumVoices) % kChordNumVoices;
    int previous_voice = (target_voice - 1 + kChordNumVoices) % kChordNumVoices;
    
    if (i == rotated_note) {
      ratios[target_voice] = base_ratio[i] * transposition;
      ratios[previous_voice] = ratios[target_voice] * 2.0f;
    c686:	vstr	s11, [fp]
      amplitudes[previous_voice] = kBaseGain * inversion_fractional;
    c68a:	vstr	s10, [r6]
      amplitudes[target_voice] = kBaseGain * (1.0f - inversion_fractional);
    c68e:	ldr	r6, [sp, #12]
    c690:	vstr	s14, [r6]
    c694:	b.n	c604 <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)+0xc8>
    c696:	nop
    c698:	.word	0x80000003
    c69c:	.word	0x66666667

0000c6a0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    c6a0:	vldr	s14, [r1, #16]
    c6a4:	vmov.f32	s13, #36	; 0x41200000  10.0
    c6a8:	vldr	s12, [pc, #664]	; c944 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a4>
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    c6ac:	vmov.f32	s10, #208	; 0xbe800000 -0.250
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    c6b0:	vldr	s15, [pc, #660]	; c948 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a8>
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    c6b4:	vmov.f32	s5, #80	; 0x3e800000  0.250
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    c6b8:	vmul.f32	s14, s14, s12
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    c6bc:	vldr	s12, [r0, #316]	; 0x13c
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
    c6c0:	vldr	s8, [r1, #12]
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    c6c4:	vmov.f32	s6, #96	; 0x3f000000  0.5
  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    c6c8:	vcvt.f32.s32	s9, s12
    c6cc:	vldr	s11, [r0, #320]	; 0x140
    return Process(0, value, num_steps, hysteresis);
  }

  inline int Process(int base, float value, int num_steps, float hysteresis) {
    value *= static_cast<float>(num_steps - 1);
    value += static_cast<float>(base);
    c6d0:	vmov.f32	s12, s15
  ONE_POLE(timbre_lp_, parameters.timbre, 0.1f);
    c6d4:	vldr	s0, [r0, #324]	; 0x144
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
    c6d8:	vsub.f32	s8, s8, s11
    c6dc:	vldr	s7, [pc, #620]	; c94c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
  const int chord_index = chord_index_quantizer_.Process(
      parameters.harmonics * 1.02f, kChordNumChords);

  float harmonics[kChordNumHarmonics * 2 + 2];
  float note_amplitudes[kChordNumVoices];
  float registration = max(1.0f - morph_lp_ * 2.15f, 0.0f);
    c6e0:	vldr	s4, [pc, #620]	; c950 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b0>
    c6e4:	vfma.f32	s12, s14, s13
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
  ONE_POLE(timbre_lp_, parameters.timbre, 0.1f);
    c6e8:	vldr	s13, [r1, #8]
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
    c6ec:	vfma.f32	s11, s8, s7
  ONE_POLE(timbre_lp_, parameters.timbre, 0.1f);
    c6f0:	vsub.f32	s13, s13, s0
  const int chord_index = chord_index_quantizer_.Process(
      parameters.harmonics * 1.02f, kChordNumChords);

  float harmonics[kChordNumHarmonics * 2 + 2];
  float note_amplitudes[kChordNumVoices];
  float registration = max(1.0f - morph_lp_ * 2.15f, 0.0f);
    c6f4:	vmov.f32	s14, #112	; 0x3f800000  1.0
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
  ONE_POLE(timbre_lp_, parameters.timbre, 0.1f);
    c6f8:	vfma.f32	s0, s13, s7
    float hysteresis_feedback = value > static_cast<float>(quantized_value_)
        ? -hysteresis
        : hysteresis;
    c6fc:	vcmpe.f32	s12, s9
  const int chord_index = chord_index_quantizer_.Process(
      parameters.harmonics * 1.02f, kChordNumChords);

  float harmonics[kChordNumHarmonics * 2 + 2];
  float note_amplitudes[kChordNumVoices];
  float registration = max(1.0f - morph_lp_ * 2.15f, 0.0f);
    c700:	vmov.f32	s13, s14
    c704:	vmrs	APSR_nzcv, fpscr
    c708:	vfms.f32	s13, s11, s4
void ChordEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    c70c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c710:	vpush	{d8-d14}
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
    c714:	vstr	s11, [r0, #320]	; 0x140
    c718:	ite	le
    c71a:	vmovle.f32	s11, s5
    c71e:	vmovgt.f32	s11, s10
void ChordEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    c722:	mov	r4, r1
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    c724:	vcmpe.f32	s13, s15
    c728:	sub	sp, #132	; 0x84
    c72a:	mov	sl, r0
    int q = static_cast<int>(value + hysteresis_feedback + 0.5f);
    c72c:	vadd.f32	s12, s12, s11
  ONE_POLE(morph_lp_, parameters.morph, 0.1f);
  ONE_POLE(timbre_lp_, parameters.timbre, 0.1f);
    c730:	vstr	s0, [r0, #324]	; 0x144
void ChordEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    c734:	str	r2, [sp, #4]
    c736:	str	r3, [sp, #8]
    c738:	vadd.f32	s12, s12, s6
    c73c:	vcvt.s32.f32	s12, s12
    c740:	vmov	r1, s12
    c744:	cmp	r1, #10
    c746:	it	ge
    c748:	movge	r1, #10
    c74a:	vmrs	APSR_nzcv, fpscr
    c74e:	bic.w	r1, r1, r1, asr #31
    CONSTRAIN(q, 0, num_steps - 1);
    quantized_value_ = q;
    c752:	str.w	r1, [r0, #316]	; 0x13c
    c756:	bmi.w	ce7c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7dc>
    c75a:	vldr	s15, [pc, #504]	; c954 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b4>
    c75e:	ldr	r6, [pc, #504]	; (c958 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b8>)
    c760:	vmul.f32	s13, s13, s15
    c764:	vcvt.s32.f32	s15, s13
    c768:	vmov	r3, s15
    c76c:	vcvt.f32.s32	s15, s15
    c770:	adds	r0, r3, #1
    c772:	lsls	r2, r3, #1
    c774:	vsub.f32	s13, s13, s15
    c778:	mov.w	ip, r0, lsl #1
    c77c:	add.w	lr, r2, r3
    c780:	add.w	r7, ip, r0
    c784:	add.w	lr, r6, lr, lsl #3
    c788:	add.w	r7, r6, r7, lsl #3
    c78c:	vldr	s15, [lr]
    c790:	vldr	s14, [r7]
    c794:	add	r2, r3
    c796:	add	r0, ip
    float registration,
    float* amplitudes) {
  registration *= (kRegistrationTableSize - 1.001f);
  MAKE_INTEGRAL_FRACTIONAL(registration);
  
  for (int i = 0; i < kChordNumHarmonics * 2; ++i) {
    c798:	movs	r3, #0
    c79a:	add.w	r2, r6, r2, lsl #3
    c79e:	add.w	r0, r6, r0, lsl #3
    c7a2:	add	r6, sp, #96	; 0x60
    c7a4:	b.n	c7b2 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x112>
    c7a6:	adds	r2, #4
    c7a8:	adds	r0, #4
    c7aa:	vldr	s15, [r2]
    c7ae:	vldr	s14, [r0]
    float a = registrations[registration_integral][i];
    float b = registrations[registration_integral + 1][i];
    amplitudes[i] = a + (b - a) * registration_fractional;
    c7b2:	vsub.f32	s14, s14, s15
    float registration,
    float* amplitudes) {
  registration *= (kRegistrationTableSize - 1.001f);
  MAKE_INTEGRAL_FRACTIONAL(registration);
  
  for (int i = 0; i < kChordNumHarmonics * 2; ++i) {
    c7b6:	adds	r3, #1
    c7b8:	cmp	r3, #6
    float a = registrations[registration_integral][i];
    float b = registrations[registration_integral + 1][i];
    amplitudes[i] = a + (b - a) * registration_fractional;
    c7ba:	vfma.f32	s15, s14, s13
    c7be:	vstmia	r6!, {s15}
    float registration,
    float* amplitudes) {
  registration *= (kRegistrationTableSize - 1.001f);
  MAKE_INTEGRAL_FRACTIONAL(registration);
  
  for (int i = 0; i < kChordNumHarmonics * 2; ++i) {
    c7c2:	bne.n	c7a6 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x106>
  float harmonics[kChordNumHarmonics * 2 + 2];
  float note_amplitudes[kChordNumVoices];
  float registration = max(1.0f - morph_lp_ * 2.15f, 0.0f);
  
  ComputeRegistration(registration, harmonics);
  harmonics[kChordNumHarmonics * 2] = 0.0f;
    c7c4:	movs	r6, #0
  float ratios[kChordNumVoices];
  int aux_note_mask = ComputeChordInversion(
      chord_index,
      timbre_lp_,
      ratios,
      note_amplitudes);
    c7c6:	add	r3, sp, #28
    c7c8:	add	r2, sp, #48	; 0x30
    c7ca:	mov	r0, sl
  float harmonics[kChordNumHarmonics * 2 + 2];
  float note_amplitudes[kChordNumVoices];
  float registration = max(1.0f - morph_lp_ * 2.15f, 0.0f);
  
  ComputeRegistration(registration, harmonics);
  harmonics[kChordNumHarmonics * 2] = 0.0f;
    c7cc:	str	r6, [sp, #120]	; 0x78
  float ratios[kChordNumVoices];
  int aux_note_mask = ComputeChordInversion(
      chord_index,
      timbre_lp_,
      ratios,
      note_amplitudes);
    c7ce:	bl	c53c <plaits::ChordEngine::ComputeChordInversion(int, float, float*, float*)>
  
  fill(&out[0], &out[size], 0.0f);
    c7d2:	ldr	r3, [sp, #224]	; 0xe0
    c7d4:	ldr	r2, [sp, #4]
    c7d6:	mov.w	r8, r3, lsl #2
  float ratios[kChordNumVoices];
  int aux_note_mask = ComputeChordInversion(
      chord_index,
      timbre_lp_,
      ratios,
      note_amplitudes);
    c7da:	str	r0, [sp, #12]
  
  fill(&out[0], &out[size], 0.0f);
    c7dc:	add.w	r1, r2, r8
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    c7e0:	cmp	r2, r1
    c7e2:	beq.n	c7f0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x150>
	*__first = __tmp;
    c7e4:	mov	r2, r6
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    c7e6:	ldr	r3, [sp, #4]
	*__first = __tmp;
    c7e8:	str.w	r2, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    c7ec:	cmp	r1, r3
    c7ee:	bne.n	c7e8 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x148>
  fill(&aux[0], &aux[size], 0.0f);
    c7f0:	ldr	r2, [sp, #8]
    c7f2:	add	r8, r2
    c7f4:	mov	r3, r2
    c7f6:	cmp	r2, r8
    c7f8:	beq.n	c804 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x164>
	*__first = __tmp;
    c7fa:	movs	r2, #0
    c7fc:	str.w	r2, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    c800:	cmp	r8, r3
    c802:	bne.n	c7fc <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x15c>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    c804:	vmov.f32	s13, #34	; 0x41100000  9.0
    c808:	vldr	s15, [r4, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    c80c:	vldr	s14, [pc, #332]	; c95c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    c810:	vsub.f32	s15, s15, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    c814:	vcmpe.f32	s15, s14
    c818:	vmrs	APSR_nzcv, fpscr
    c81c:	bpl.w	ce42 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a2>
    c820:	movs	r3, #0
    c822:	mov	r1, r3
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
    c824:	vldr	s20, [pc, #312]	; c960 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c0>
    c828:	add.w	fp, sp, #28

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    c82c:	ldr	r2, [pc, #308]	; (c964 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c4>)
    c82e:	mov	r9, sl
    c830:	vldr	s15, [sl, #320]	; 0x140
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
	return __b;
    c834:	mov	r4, sl
    c836:	add.w	r1, r2, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    c83a:	ldr	r2, [pc, #300]	; (c968 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c8>)
    c83c:	vsub.f32	s14, s15, s20
    c840:	vldr	s20, [pc, #268]	; c950 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b0>
    c844:	add.w	r3, r2, r3, lsl #2
      note_amplitudes);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
    c848:	vldr	s19, [pc, #288]	; c96c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2cc>
    c84c:	vldr	s12, [pc, #248]	; c948 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a8>
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
  
  for (int note = 0; note < kChordNumVoices; ++note) {
    c850:	movs	r7, #0
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
    c852:	vmul.f32	s20, s14, s20
      note_amplitudes);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
    c856:	vldr	s13, [r3]
    c85a:	vldr	s14, [r1]
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
  
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);
    c85e:	vmov.f32	s18, s12
      note_amplitudes);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
    c862:	vldr	s11, [pc, #268]	; c970 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d0>
    c866:	vcmp.f32	s20, #0.0
    c86a:	ldr	r3, [pc, #264]	; (c974 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d4>)
    c86c:	vmul.f32	s13, s14, s13
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
  
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    c870:	vldr	s21, [pc, #260]	; c978 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2d8>
    c874:	vldr	s14, [pc, #260]	; c97c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2dc>
      note_amplitudes);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
    c878:	mov	r6, r3
    c87a:	vmrs	APSR_nzcv, fpscr
    
    float lp = lp_;
    float phase = phase_;
    while (size--) {
      const float f0 = frequency_modulation.Next();
      const float cutoff = std::min(float(wavetable_size) * f0, 1.0f);
    c87e:	vldr	s17, [pc, #256]	; c980 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2e0>
    c882:	vmul.f32	s13, s13, s19
    c886:	str.w	r8, [sp, #20]
    c88a:	it	mi
    c88c:	vmovmi.f32	s20, s12
    c890:	vmul.f32	s19, s13, s11
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
  
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    c894:	vsub.f32	s15, s15, s14
    c898:	vmul.f32	s15, s15, s21
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);
    c89c:	vcmpe.f32	s15, #0.0
    c8a0:	vmrs	APSR_nzcv, fpscr
    c8a4:	bmi.w	cdea <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x74a>
    c8a8:	vmov.f32	s16, #112	; 0x3f800000  1.0
    c8ac:	vcmpe.f32	s15, s16
    c8b0:	vmrs	APSR_nzcv, fpscr
    c8b4:	ble.w	ce2e <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x78e>
    c8b8:	vmov.f32	s15, s16
    c8bc:	vldr	s14, [pc, #136]	; c948 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a8>

    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    
    const float note_f0 = f0 * ratios[note];
    c8c0:	add	r3, sp, #48	; 0x30
    float divide_down_gain = 4.0f - note_f0 * 32.0f;
    c8c2:	vmov.f32	s16, #16	; 0x40800000  4.0
    c8c6:	vldr	s13, [pc, #188]	; c984 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2e4>
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);

    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    
    const float note_f0 = f0 * ratios[note];
    c8ca:	add.w	r2, r3, r7, lsl #2
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);

    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    c8ce:	ldr	r3, [sp, #12]
    
    const float note_f0 = f0 * ratios[note];
    c8d0:	vldr	s9, [r2]
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);

    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    c8d4:	asrs	r3, r7
    c8d6:	ldr	r2, [sp, #8]
    
    const float note_f0 = f0 * ratios[note];
    c8d8:	vmul.f32	s9, s19, s9
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);

    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    c8dc:	tst.w	r3, #1
    c8e0:	ldr	r3, [sp, #4]
    c8e2:	it	ne
    c8e4:	movne	r5, r2
    
    const float note_f0 = f0 * ratios[note];
    float divide_down_gain = 4.0f - note_f0 * 32.0f;
    c8e6:	vfms.f32	s16, s9, s13
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);

    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    c8ea:	it	eq
    c8ec:	moveq	r5, r3
    
    const float note_f0 = f0 * ratios[note];
    float divide_down_gain = 4.0f - note_f0 * 32.0f;
    CONSTRAIN(divide_down_gain, 0.0f, 1.0f);
    c8ee:	vcmpe.f32	s16, #0.0
    c8f2:	vmrs	APSR_nzcv, fpscr
    c8f6:	bmi.w	cde4 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x744>
    c8fa:	vmov.f32	s13, #112	; 0x3f800000  1.0
    c8fe:	vcmp.f32	s16, s13
    c902:	vmrs	APSR_nzcv, fpscr
    c906:	it	gt
    c908:	vmovgt.f32	s16, s13
    divide_down_amount *= divide_down_gain;
    
    if (wavetable_amount) {
    c90c:	vcmp.f32	s15, #0.0
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    
    const float note_f0 = f0 * ratios[note];
    float divide_down_gain = 4.0f - note_f0 * 32.0f;
    CONSTRAIN(divide_down_gain, 0.0f, 1.0f);
    divide_down_amount *= divide_down_gain;
    c910:	vmul.f32	s16, s16, s14
    
    if (wavetable_amount) {
    c914:	vmrs	APSR_nzcv, fpscr
    c918:	bne.n	c998 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f8>
          wavetable,
          destination,
          size);
    }
    
    if (divide_down_amount) {
    c91a:	vcmp.f32	s16, #0.0
    c91e:	vmrs	APSR_nzcv, fpscr
    c922:	bne.w	cb58 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4b8>
  fill(&aux[0], &aux[size], 0.0f);
  
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
  
  for (int note = 0; note < kChordNumVoices; ++note) {
    c926:	adds	r7, #1
    c928:	add.w	r9, r9, #32
    c92c:	add.w	fp, fp, #4
    c930:	adds	r4, #28
    c932:	cmp	r7, #5
    c934:	beq.w	cdf4 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x754>
    c938:	adds	r6, #4
    c93a:	vldr	s15, [sl, #320]	; 0x140
    c93e:	vldr	s14, [r6]
    c942:	b.n	c894 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f4>
    c944:	.word	0x3f828f5c
    c948:	.word	0x00000000
    c94c:	.word	0x3dcccccd
    c950:	.word	0x4009999a
    c954:	.word	0x40dff7cf
    c958:	.word	0x2001f7a0
    c95c:	.word	0xc3000000
    c960:	.word	0x3f08f5c3
    c964:	.word	0x20000554
    c968:	.word	0x20000958
    c96c:	.word	0x39962fc9
    c970:	.word	0x3f7f7cee
    c974:	.word	0x2001f874
    c978:	.word	0x42480000
    c97c:	.word	0x3f0ccccd
    c980:	.word	0x43800000
    c984:	.word	0x42000000
    c988:	.word	0x3f808312
    c98c:	.word	0x48000000
    c990:	.word	0x3f733333
    c994:	.word	0x415fff97
    float divide_down_gain = 4.0f - note_f0 * 32.0f;
    CONSTRAIN(divide_down_gain, 0.0f, 1.0f);
    divide_down_amount *= divide_down_gain;
    
    if (wavetable_amount) {
      wavetable_voice_[note].Render(
    c998:	vldr	s13, [pc, #-20]	; c988 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2e8>
      float amplitude,
      float waveform,
      const int16_t** wavetable,
      float* out,
      size_t size) {
    if (frequency >= kMaxFrequency) {
    c99c:	vmov.f32	s12, #80	; 0x3e800000  0.250
    c9a0:	vldr	s14, [fp]
    c9a4:	vmul.f32	s13, s9, s13
    c9a8:	vmul.f32	s15, s15, s14
    c9ac:	vcmpe.f32	s13, s12
    c9b0:	vmrs	APSR_nzcv, fpscr
    c9b4:	bge.w	ce34 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x794>
    c9b8:	vmov.f32	s8, #112	; 0x3f800000  1.0
    c9bc:	vldr	s10, [pc, #-52]	; c98c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ec>
    c9c0:	vmov.f32	s14, #0	; 0x40000000  2.0
    c9c4:	vldr	s12, [pc, #-56]	; c990 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f0>
    c9c8:	vmul.f32	s10, s13, s10
    c9cc:	vmov.f32	s11, s8
    c9d0:	vsub.f32	s12, s12, s13
    c9d4:	vfms.f32	s11, s13, s14
    c9d8:	vmov.f32	s14, s11
    c9dc:	vdiv.f32	s11, s8, s10
    c9e0:	vmul.f32	s12, s11, s12
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    c9e4:	vldr	s5, [r4, #184]	; 0xb8
    increment_ = (new_value - *state) / static_cast<float>(size);
    c9e8:	vmul.f32	s15, s15, s14
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    c9ec:	vldr	s7, [r4, #188]	; 0xbc
    increment_ = (new_value - *state) / static_cast<float>(size);
    c9f0:	vmov.f32	s10, s5
    c9f4:	vldr	s11, [pc, #-100]	; c994 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f4>
    c9f8:	vldr	s14, [sp, #224]	; 0xe0
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    c9fc:	vldr	s8, [r4, #180]	; 0xb4
    increment_ = (new_value - *state) / static_cast<float>(size);
    ca00:	vfnms.f32	s10, s15, s12
        waveform * float(num_waves - 1.0001f),
        size);
    
    float lp = lp_;
    float phase = phase_;
    while (size--) {
    ca04:	ldr	r3, [sp, #224]	; 0xe0
    ca06:	vmov.f32	s15, s7
    stmlib::ParameterInterpolator waveform_modulation(
        &waveform_,
        waveform * float(num_waves - 1.0001f),
        size);
    
    float lp = lp_;
    ca0a:	vldr	s6, [r4, #192]	; 0xc0
    ca0e:	vcvt.f32.u32	s14, s14
    float phase = phase_;
    while (size--) {
    ca12:	subs	r2, r3, #1
    ca14:	vsub.f32	s13, s13, s8
    ca18:	vfnms.f32	s15, s20, s11
    ca1c:	vmov.f32	s12, s10
        &waveform_,
        waveform * float(num_waves - 1.0001f),
        size);
    
    float lp = lp_;
    float phase = phase_;
    ca20:	vldr	s10, [r4, #176]	; 0xb0
    ca24:	vdiv.f32	s2, s13, s14
    ca28:	vdiv.f32	s1, s12, s14
    ca2c:	vdiv.f32	s0, s15, s14
    while (size--) {
    ca30:	cmp	r3, #0
    ca32:	beq.w	cb38 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x498>
    ca36:	mov	r1, r5
    ca38:	ldr.w	ip, [pc, #1144]	; ceb4 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x814>
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    ca3c:	mov	lr, r5
    ca3e:	str	r6, [sp, #16]
    ca40:	vmov.f32	s4, #112	; 0x3f800000  1.0
    ca44:	vmov.f32	s22, #96	; 0x3f000000  0.5
  }

  inline float Next() {
    value_ += increment_;
    ca48:	vadd.f32	s8, s8, s2
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
    ca4c:	vldr	s24, [r4, #200]	; 0xc8
    ca50:	vmov.f32	s3, #96	; 0x3f000000  0.5
    ca54:	vldr	s11, [r4, #196]	; 0xc4
    ca58:	vadd.f32	s7, s7, s0
        waveform * float(num_waves - 1.0001f),
        size);
    
    float lp = lp_;
    float phase = phase_;
    while (size--) {
    ca5c:	subs	r2, #1
      const float f0 = frequency_modulation.Next();
      const float cutoff = std::min(float(wavetable_size) * f0, 1.0f);
    ca5e:	vmul.f32	s23, s8, s17
      
      const float scale = approximate_scale ? 1.0f : 1.0f / (f0 * 131072.0f) * (0.95f - f0);
      
      phase += f0;
    ca62:	vadd.f32	s10, s10, s8
      if (phase >= 1.0f) {
        phase -= 1.0f;
      }
      
      const float waveform = waveform_modulation.Next();
      MAKE_INTEGRAL_FRACTIONAL(waveform);
    ca66:	vcvt.s32.f32	s15, s7
    ca6a:	vcmpe.f32	s23, s4
    ca6e:	vadd.f32	s5, s5, s1
    ca72:	vmov	r3, s15
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    ca76:	vcvt.f32.s32	s26, s15
    ca7a:	vmrs	APSR_nzcv, fpscr
      const float cutoff = std::min(float(wavetable_size) * f0, 1.0f);
      
      const float scale = approximate_scale ? 1.0f : 1.0f / (f0 * 131072.0f) * (0.95f - f0);
      
      phase += f0;
      if (phase >= 1.0f) {
    ca7e:	vcmpe.f32	s10, s4
      const float p = phase * float(wavetable_size);
      MAKE_INTEGRAL_FRACTIONAL(p);
      
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
    ca82:	add.w	r0, ip, r3, lsl #2
      MAKE_INTEGRAL_FRACTIONAL(waveform);
      
      const float p = phase * float(wavetable_size);
      MAKE_INTEGRAL_FRACTIONAL(p);
      
      const float x0 = InterpolateWave(
    ca86:	ldr.w	r8, [ip, r3, lsl #2]
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    ca8a:	vsub.f32	s26, s7, s26
    ca8e:	it	le
    ca90:	vmulle.f32	s3, s23, s22
      const float p = phase * float(wavetable_size);
      MAKE_INTEGRAL_FRACTIONAL(p);
      
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
    ca94:	ldr	r5, [r0, #4]
	return __b;
    ca96:	it	gt
    ca98:	vmovgt.f32	s23, #112	; 0x3f800000  1.0
      const float cutoff = std::min(float(wavetable_size) * f0, 1.0f);
      
      const float scale = approximate_scale ? 1.0f : 1.0f / (f0 * 131072.0f) * (0.95f - f0);
      
      phase += f0;
      if (phase >= 1.0f) {
    ca9c:	vmrs	APSR_nzcv, fpscr
        phase -= 1.0f;
    caa0:	it	ge
    caa2:	vsubge.f32	s10, s10, s4
      }
      
      const float waveform = waveform_modulation.Next();
      MAKE_INTEGRAL_FRACTIONAL(waveform);
      
      const float p = phase * float(wavetable_size);
    caa6:	vmul.f32	s15, s10, s17
      MAKE_INTEGRAL_FRACTIONAL(p);
    caaa:	vcvt.s32.f32	s14, s15
    caae:	vmov	r0, s14
    cab2:	vcvt.f32.s32	s14, s14

inline float InterpolateWave(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
    cab6:	lsls	r3, r0, #1
    cab8:	ldrsh.w	r6, [r8, r0, lsl #1]
    cabc:	ldrsh.w	r0, [r5, r0, lsl #1]
      
      const float waveform = waveform_modulation.Next();
      MAKE_INTEGRAL_FRACTIONAL(waveform);
      
      const float p = phase * float(wavetable_size);
      MAKE_INTEGRAL_FRACTIONAL(p);
    cac0:	vsub.f32	s15, s15, s14
inline float InterpolateWave(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
  float b = static_cast<float>(table[index_integral + 1]);
    cac4:	adds	r3, #2

inline float InterpolateWave(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
    cac6:	vmov	s13, r6
    caca:	vmov	s12, r0
  float b = static_cast<float>(table[index_integral + 1]);
  float t = index_fractional;
  return a + (b - a) * t;
    cace:	ldrsh.w	r0, [r8, r3]

inline float InterpolateWave(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
    cad2:	vcvt.f32.s32	s13, s13
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    cad6:	ldrsh	r3, [r5, r3]

inline float InterpolateWave(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
    cad8:	vcvt.f32.s32	s12, s12
  float b = static_cast<float>(table[index_integral + 1]);
  float t = index_fractional;
  return a + (b - a) * t;
    cadc:	vmov	s14, r0
        waveform * float(num_waves - 1.0001f),
        size);
    
    float lp = lp_;
    float phase = phase_;
    while (size--) {
    cae0:	adds	r0, r2, #1
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    cae2:	vmov	s25, r3
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
  float b = static_cast<float>(table[index_integral + 1]);
  float t = index_fractional;
  return a + (b - a) * t;
    cae6:	vcvt.f32.s32	s14, s14
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    caea:	vcvt.f32.s32	s25, s25
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
  float b = static_cast<float>(table[index_integral + 1]);
  float t = index_fractional;
  return a + (b - a) * t;
    caee:	vsub.f32	s14, s14, s13
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    caf2:	vsub.f32	s25, s25, s12
    int32_t index_integral,
    float index_fractional) {
  float a = static_cast<float>(table[index_integral]);
  float b = static_cast<float>(table[index_integral + 1]);
  float t = index_fractional;
  return a + (b - a) * t;
    caf6:	vfma.f32	s13, s15, s14
      const float x0 = InterpolateWave(
          wavetable[waveform_integral], p_integral, p_fractional);
      const float x1 = InterpolateWave(
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
    cafa:	vfma.f32	s12, s15, s25
    cafe:	vmov.f32	s15, s13
    cb02:	vsub.f32	s12, s12, s13
    cb06:	vfma.f32	s15, s26, s12
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
    cb0a:	vsub.f32	s14, s15, s24
    previous_ = s;
    cb0e:	vstr	s15, [r4, #200]	; 0xc8
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
    cb12:	vsub.f32	s15, s14, s11
    cb16:	vfma.f32	s11, s23, s15
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
          cutoff,
          x0 + (x1 - x0) * waveform_fractional);
      ONE_POLE(lp, s * scale, cutoff * 0.5f);
    cb1a:	vsub.f32	s14, s11, s6
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
    cb1e:	vstr	s11, [r4, #196]	; 0xc4
      
      const float s = differentiator_.Process(
          cutoff,
          x0 + (x1 - x0) * waveform_fractional);
      ONE_POLE(lp, s * scale, cutoff * 0.5f);
      *out++ += amplitude_modulation.Next() * lp;
    cb22:	vldmia	r1!, {s15}
          wavetable[waveform_integral + 1], p_integral, p_fractional);
      
      const float s = differentiator_.Process(
          cutoff,
          x0 + (x1 - x0) * waveform_fractional);
      ONE_POLE(lp, s * scale, cutoff * 0.5f);
    cb26:	vfma.f32	s6, s14, s3
      *out++ += amplitude_modulation.Next() * lp;
    cb2a:	vfma.f32	s15, s6, s5
    cb2e:	vstr	s15, [r1, #-4]
        waveform * float(num_waves - 1.0001f),
        size);
    
    float lp = lp_;
    float phase = phase_;
    while (size--) {
    cb32:	bne.n	ca48 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a8>
    cb34:	ldr	r6, [sp, #16]
    cb36:	mov	r5, lr
          wavetable,
          destination,
          size);
    }
    
    if (divide_down_amount) {
    cb38:	vcmp.f32	s16, #0.0
          cutoff,
          x0 + (x1 - x0) * waveform_fractional);
      ONE_POLE(lp, s * scale, cutoff * 0.5f);
      *out++ += amplitude_modulation.Next() * lp;
    }
    lp_ = lp;
    cb3c:	vstr	s6, [r4, #192]	; 0xc0
    phase_ = phase;
    cb40:	vstr	s10, [r4, #176]	; 0xb0
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    cb44:	vstr	s7, [r4, #188]	; 0xbc
    cb48:	vmrs	APSR_nzcv, fpscr
    cb4c:	vstr	s5, [r4, #184]	; 0xb8
    cb50:	vstr	s8, [r4, #180]	; 0xb4
    cb54:	beq.w	c926 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x286>
      float frequency,
      const float* unshifted_registration,
      float gain,
      float* out,
      size_t size) {
    frequency *= 8.0f;
    cb58:	vmov.f32	s22, #32	; 0x41000000  8.0
    
    // Deal with very high frequencies by shifting everything 1 or 2 octave
    // down: Instead of playing the 1nd harmonic of a 8kHz wave, we play the
    // second harmonic of a 4kHz wave.
    size_t shift = 0;
    while (frequency > 0.5f) {
    cb5c:	vmov.f32	s15, #96	; 0x3f000000  0.5
      float frequency,
      const float* unshifted_registration,
      float gain,
      float* out,
      size_t size) {
    frequency *= 8.0f;
    cb60:	vmul.f32	s22, s9, s22
    
    // Deal with very high frequencies by shifting everything 1 or 2 octave
    // down: Instead of playing the 1nd harmonic of a 8kHz wave, we play the
    // second harmonic of a 4kHz wave.
    size_t shift = 0;
    while (frequency > 0.5f) {
    cb64:	vcmpe.f32	s22, s15
    cb68:	vmrs	APSR_nzcv, fpscr
    cb6c:	ble.w	ce8e <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7ee>
    cb70:	movs	r0, #0
      shift += 2;
      frequency *= 0.5f;
    cb72:	vmul.f32	s22, s22, s15
    // Deal with very high frequencies by shifting everything 1 or 2 octave
    // down: Instead of playing the 1nd harmonic of a 8kHz wave, we play the
    // second harmonic of a 4kHz wave.
    size_t shift = 0;
    while (frequency > 0.5f) {
      shift += 2;
    cb76:	adds	r0, #2
    
    // Deal with very high frequencies by shifting everything 1 or 2 octave
    // down: Instead of playing the 1nd harmonic of a 8kHz wave, we play the
    // second harmonic of a 4kHz wave.
    size_t shift = 0;
    while (frequency > 0.5f) {
    cb78:	vcmpe.f32	s22, s15
    cb7c:	vmrs	APSR_nzcv, fpscr
    cb80:	bgt.n	cb72 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4d2>
      shift += 2;
      frequency *= 0.5f;
    }
    // Frequency is just too high.
    if (shift >= 8) {
    cb82:	cmp	r0, #7
    cb84:	bhi.w	c926 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x286>
      return;
    }
    
    float registration[7];
    std::fill(&registration[0], &registration[shift], 0.0f);
    cb88:	add	r3, sp, #68	; 0x44
    cb8a:	lsls	r2, r0, #2
      divide_down_voice_[note].Render(
          note_f0,
          harmonics,
          note_amplitudes[note] * divide_down_amount,
    cb8c:	vldr	s23, [fp]
    cb90:	add.w	r0, r3, r0, lsl #2
    cb94:	rsb	r2, r2, #28
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    cb98:	cmp	r0, r3
    cb9a:	mov.w	r1, r2, asr #2
    cb9e:	beq.n	cba8 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x508>
	*__first = __tmp;
    cba0:	vstmia	r3!, {s18}
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    cba4:	cmp	r0, r3
    cba6:	bne.n	cba0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x500>
					   is_copy_assignable<_Tp>>;
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
    cba8:	cmp	r1, #0
    cbaa:	bne.w	ce96 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7f6>
        &registration[shift]);
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator saw_8_gain_modulation(
        &saw_8_gain_,
        (registration[0] + 2.0f * registration[1]) * gain,
    cbae:	vldr	s14, [sp, #72]	; 0x48
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    cbb2:	vmov.f32	s10, #0	; 0x40000000  2.0
    cbb6:	vldr	s12, [sp, #76]	; 0x4c
          destination,
          size);
    }
    
    if (divide_down_amount) {
      divide_down_voice_[note].Render(
    cbba:	vmul.f32	s16, s16, s23
        size);
    stmlib::ParameterInterpolator saw_4_gain_modulation(
        &saw_4_gain_,
        (registration[2] - registration[1] + 2.0f * registration[3]) * gain,
    cbbe:	vldr	s9, [sp, #80]	; 0x50
    cbc2:	vsub.f32	s12, s12, s14
    cbc6:	vldr	s13, [sp, #84]	; 0x54
    cbca:	vldr	s15, [sp, #224]	; 0xe0
    cbce:	vldr	s11, [sp, #68]	; 0x44
    cbd2:	vsub.f32	s13, s13, s9
    cbd6:	vfma.f32	s12, s9, s10
        size);
    
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
    cbda:	vmov	r3, s15
    cbde:	vcvt.f32.u32	s4, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    cbe2:	vldr	s7, [r9, #36]	; 0x24
    increment_ = (new_value - *state) / static_cast<float>(size);
    cbe6:	vfma.f32	s11, s14, s10
        &saw_4_gain_,
        (registration[2] - registration[1] + 2.0f * registration[3]) * gain,
        size);
    stmlib::ParameterInterpolator saw_2_gain_modulation(
        &saw_2_gain_,
        (registration[4] - registration[3] + 2.0f * registration[5]) * gain,
    cbea:	vldr	s15, [sp, #88]	; 0x58
    cbee:	vldr	s14, [sp, #92]	; 0x5c
        size);
    
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
    cbf2:	subs	r1, r3, #1
    cbf4:	vfma.f32	s13, s15, s10
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    cbf8:	vldr	s6, [r9, #40]	; 0x28
    increment_ = (new_value - *state) / static_cast<float>(size);
    cbfc:	vsub.f32	s15, s14, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    cc00:	vldr	s5, [r9, #32]
    increment_ = (new_value - *state) / static_cast<float>(size);
    cc04:	vmov.f32	s14, s7
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    cc08:	vldr	s10, [r9, #44]	; 0x2c
    increment_ = (new_value - *state) / static_cast<float>(size);
    cc0c:	vmov.f32	s3, s5
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    cc10:	vldr	s8, [r9, #28]
        (registration[6] - registration[5]) * gain,
        size);
    
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    cc14:	ldr.w	r2, [r9, #24]
    increment_ = (new_value - *state) / static_cast<float>(size);
    cc18:	vfnms.f32	s14, s16, s12
    cc1c:	vfnms.f32	s3, s16, s11
    stmlib::ParameterInterpolator saw_1_gain_modulation(
        &saw_1_gain_,
        (registration[6] - registration[5]) * gain,
        size);
    
    float phase = phase_;
    cc20:	vldr	s11, [r9, #16]
    cc24:	vsub.f32	s9, s22, s8
    cc28:	vmov.f32	s12, s14
    cc2c:	vmov.f32	s14, s6
    cc30:	vdiv.f32	s2, s3, s4
    cc34:	vfnms.f32	s14, s16, s13
    cc38:	vdiv.f32	s1, s12, s4
    cc3c:	vmov.f32	s13, s14
    cc40:	vmov.f32	s14, s10
    cc44:	vdiv.f32	s3, s9, s4
    cc48:	vfnms.f32	s14, s16, s15
    float next_sample = next_sample_;
    cc4c:	vldr	s15, [r9, #20]
    cc50:	vdiv.f32	s0, s13, s4
    cc54:	vdiv.f32	s16, s14, s4
    int segment = segment_;
    while (size--) {
    cc58:	cmp	r3, #0
    cc5a:	beq.w	cd6c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6cc>
        }
        discontinuity -= saw_1_gain;
        if (discontinuity != 0.0f) {
          float fraction = phase - static_cast<float>(next_segment);
          float t = fraction / frequency;
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    cc5e:	vmov.f32	s9, #96	; 0x3f000000  0.5
    cc62:	vmov.f32	s4, #112	; 0x3f800000  1.0
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    cc66:	vmov.f32	s22, #224	; 0xbf000000 -0.5
      phase += frequency;
      int next_segment = static_cast<int>(phase);
      if (next_segment != segment) {
        float discontinuity = 0.0f;
        if (next_segment == 8) {
          phase -= 8.0f;
    cc6a:	vmov.f32	s23, #32	; 0x41000000  8.0
  }

  inline float Next() {
    value_ += increment_;
    cc6e:	vadd.f32	s8, s8, s3
    cc72:	vadd.f32	s5, s5, s2
    cc76:	vadd.f32	s7, s7, s1
      const float saw_8_gain = saw_8_gain_modulation.Next();
      const float saw_4_gain = saw_4_gain_modulation.Next();
      const float saw_2_gain = saw_2_gain_modulation.Next();
      const float saw_1_gain = saw_1_gain_modulation.Next();

      phase += frequency;
    cc7a:	vadd.f32	s11, s11, s8
    cc7e:	vadd.f32	s6, s6, s0
    cc82:	vadd.f32	s10, s10, s16
      int next_segment = static_cast<int>(phase);
    cc86:	vcvt.s32.f32	s14, s11
    cc8a:	vmov	r3, s14
      if (next_segment != segment) {
    cc8e:	cmp	r3, r2
    cc90:	beq.w	cdb6 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x716>
        float discontinuity = 0.0f;
        if (next_segment == 8) {
    cc94:	cmp	r3, #8
    cc96:	beq.n	cd8e <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6ee>
    cc98:	and.w	r2, r3, #4
    cc9c:	and.w	r0, r3, #1
      const float saw_1_gain = saw_1_gain_modulation.Next();

      phase += frequency;
      int next_segment = static_cast<int>(phase);
      if (next_segment != segment) {
        float discontinuity = 0.0f;
    cca0:	vldr	s25, [pc, #508]	; cea0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x800>
    cca4:	vmov	s14, r2
    cca8:	and.w	r2, r3, #6
    ccac:	vmov	s24, r2
    ccb0:	and.w	r2, r3, #7
    ccb4:	vcvt.f32.s32	s14, s14
    ccb8:	vmov	s13, r2
        if (next_segment == 8) {
          phase -= 8.0f;
          next_segment -= 8;
          discontinuity -= saw_8_gain;
        }
        if ((next_segment & 3) == 0) {
    ccbc:	mov	r2, r3
    ccbe:	lsls	r3, r3, #30
    ccc0:	vcvt.f32.s32	s24, s24
    ccc4:	vcvt.f32.s32	s13, s13
    ccc8:	beq.n	cda6 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x706>
          discontinuity -= saw_4_gain;
        }
        if ((next_segment & 1) == 0) {
    ccca:	cbnz	r0, ccd0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x630>
          discontinuity -= saw_2_gain;
    cccc:	vsub.f32	s25, s25, s6
        }
        discontinuity -= saw_1_gain;
    ccd0:	vsub.f32	s25, s25, s10
        if (discontinuity != 0.0f) {
    ccd4:	vcmp.f32	s25, #0.0
    ccd8:	vmrs	APSR_nzcv, fpscr
    ccdc:	beq.n	cdac <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x70c>
          float fraction = phase - static_cast<float>(next_segment);
          float t = fraction / frequency;
    ccde:	vmov	s12, r2
    cce2:	vcvt.f32.s32	s26, s12
    cce6:	vsub.f32	s26, s11, s26
    ccea:	vdiv.f32	s12, s26, s8
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    ccee:	vmul.f32	s26, s12, s9
    ccf2:	vsub.f32	s27, s4, s12
    ccf6:	vmul.f32	s12, s26, s12
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    ccfa:	vmul.f32	s28, s27, s22
        }
        discontinuity -= saw_1_gain;
        if (discontinuity != 0.0f) {
          float fraction = phase - static_cast<float>(next_segment);
          float t = fraction / frequency;
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    ccfe:	vfma.f32	s15, s25, s12
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    cd02:	vmul.f32	s27, s28, s27
        }
        discontinuity -= saw_1_gain;
        if (discontinuity != 0.0f) {
          float fraction = phase - static_cast<float>(next_segment);
          float t = fraction / frequency;
          this_sample += stmlib::ThisBlepSample(t) * discontinuity;
    cd06:	vmov.f32	s12, s15
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
    cd0a:	vmov.f32	s15, s18
    cd0e:	vfma.f32	s15, s25, s27
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
    cd12:	vmov.f32	s28, #16	; 0x40800000  4.0
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
      *out++ += 2.0f * this_sample;
    cd16:	vldmia	r5!, {s25}
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
    cd1a:	vmov.f32	s26, #0	; 0x40000000  2.0
        size);
    
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
    cd1e:	subs	r1, #1
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
    cd20:	vsub.f32	s14, s11, s14
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
    cd24:	vsub.f32	s28, s11, s28
        size);
    
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
    cd28:	adds	r3, r1, #1
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
    cd2a:	vmov.f32	s29, #64	; 0x3e000000  0.125
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
    cd2e:	vsub.f32	s14, s14, s26
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
    cd32:	vmul.f32	s28, s28, s5
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
    cd36:	vsub.f32	s24, s11, s24
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
    cd3a:	vmul.f32	s14, s14, s7
          next_sample += stmlib::NextBlepSample(t) * discontinuity;
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
    cd3e:	vfma.f32	s15, s28, s29
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
    cd42:	vmov.f32	s27, #80	; 0x3e800000  0.250
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
    cd46:	vsub.f32	s24, s24, s4
      *out++ += 2.0f * this_sample;
    cd4a:	vfma.f32	s25, s12, s26
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
    cd4e:	vsub.f32	s13, s11, s13
    cd52:	vmul.f32	s12, s24, s6
        }
      }
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
    cd56:	vfma.f32	s15, s14, s27
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
    cd5a:	vsub.f32	s14, s13, s9
      *out++ += 2.0f * this_sample;
    cd5e:	vstr	s25, [r5, #-4]
      segment = next_segment;
      
      next_sample += (phase - 4.0f) * saw_8_gain * 0.125f;
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
    cd62:	vfma.f32	s15, s12, s9
    cd66:	vfma.f32	s15, s10, s14
        size);
    
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
    cd6a:	bne.n	cc6e <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5ce>
      next_sample += (phase - float(segment & 4) - 2.0f) * saw_4_gain * 0.25f;
      next_sample += (phase - float(segment & 6) - 1.0f) * saw_2_gain * 0.5f;
      next_sample += (phase - float(segment & 7) - 0.5f) * saw_1_gain;
      *out++ += 2.0f * this_sample;
    }
    next_sample_ = next_sample;
    cd6c:	vstr	s15, [r9, #20]
    phase_ = phase;
    cd70:	vstr	s11, [r9, #16]
    segment_ = segment;
    cd74:	str.w	r2, [r9, #24]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    cd78:	vstr	s10, [r9, #44]	; 0x2c
    cd7c:	vstr	s6, [r9, #40]	; 0x28
    cd80:	vstr	s7, [r9, #36]	; 0x24
    cd84:	vstr	s5, [r9, #32]
    cd88:	vstr	s8, [r9, #28]
    cd8c:	b.n	c926 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x286>
      if (next_segment != segment) {
        float discontinuity = 0.0f;
        if (next_segment == 8) {
          phase -= 8.0f;
          next_segment -= 8;
          discontinuity -= saw_8_gain;
    cd8e:	vldr	s13, [pc, #272]	; cea0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x800>
    cd92:	movs	r2, #0
      phase += frequency;
      int next_segment = static_cast<int>(phase);
      if (next_segment != segment) {
        float discontinuity = 0.0f;
        if (next_segment == 8) {
          phase -= 8.0f;
    cd94:	vsub.f32	s11, s11, s23
          next_segment -= 8;
          discontinuity -= saw_8_gain;
    cd98:	vmov.f32	s24, s13
      int next_segment = static_cast<int>(phase);
      if (next_segment != segment) {
        float discontinuity = 0.0f;
        if (next_segment == 8) {
          phase -= 8.0f;
          next_segment -= 8;
    cd9c:	mov	r0, r2
          discontinuity -= saw_8_gain;
    cd9e:	vmov.f32	s14, s13
    cda2:	vsub.f32	s25, s18, s5
        }
        if ((next_segment & 3) == 0) {
          discontinuity -= saw_4_gain;
    cda6:	vsub.f32	s25, s25, s7
    cdaa:	b.n	ccca <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x62a>
        }
        if ((next_segment & 1) == 0) {
          discontinuity -= saw_2_gain;
        }
        discontinuity -= saw_1_gain;
        if (discontinuity != 0.0f) {
    cdac:	vmov.f32	s12, s15
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    cdb0:	vldr	s15, [pc, #236]	; cea0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x800>
    cdb4:	b.n	cd12 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x672>
    cdb6:	and.w	r0, r2, #6
    cdba:	and.w	lr, r2, #4
    cdbe:	and.w	r3, r2, #7
      const float saw_2_gain = saw_2_gain_modulation.Next();
      const float saw_1_gain = saw_1_gain_modulation.Next();

      phase += frequency;
      int next_segment = static_cast<int>(phase);
      if (next_segment != segment) {
    cdc2:	vmov.f32	s12, s15
    cdc6:	vmov	s13, r0
    cdca:	vmov	s15, lr
    cdce:	vcvt.f32.s32	s24, s13
    cdd2:	vmov	s13, r3
    cdd6:	vcvt.f32.s32	s14, s15
    float phase = phase_;
    float next_sample = next_sample_;
    int segment = segment_;
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    cdda:	vldr	s15, [pc, #196]	; cea0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x800>
    cdde:	vcvt.f32.s32	s13, s13
    cde2:	b.n	cd12 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x672>
    float divide_down_amount = 1.0f - wavetable_amount;
    float* destination = (1 << note) & aux_note_mask ? aux : out;
    
    const float note_f0 = f0 * ratios[note];
    float divide_down_gain = 4.0f - note_f0 * 32.0f;
    CONSTRAIN(divide_down_gain, 0.0f, 1.0f);
    cde4:	vldr	s16, [pc, #184]	; cea0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x800>
    cde8:	b.n	c90c <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x26c>
    cdea:	vmov.f32	s14, #112	; 0x3f800000  1.0
  const float f0 = NoteToFrequency(parameters.note) * 0.998f;
  const float waveform = max((morph_lp_ - 0.535f) * 2.15f, 0.0f);
  
  for (int note = 0; note < kChordNumVoices; ++note) {
    float wavetable_amount = 50.0f * (morph_lp_ - fade_point[note]);
    CONSTRAIN(wavetable_amount, 0.0f, 1.0f);
    cdee:	vldr	s15, [pc, #176]	; cea0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x800>
    cdf2:	b.n	c8c0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x220>
          destination,
          size);
    }
  }
  
  for (size_t i = 0; i < size; ++i) {
    cdf4:	ldr	r3, [sp, #224]	; 0xe0
    cdf6:	ldr.w	r8, [sp, #20]
    cdfa:	cbz	r3, ce24 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x784>
    out[i] += aux[i];
    aux[i] *= 3.0f;
    cdfc:	vmov.f32	s13, #8	; 0x40400000  3.0
    ce00:	ldr	r5, [sp, #4]
    ce02:	ldr	r3, [sp, #8]
          size);
    }
  }
  
  for (size_t i = 0; i < size; ++i) {
    out[i] += aux[i];
    ce04:	vldr	s14, [r5]
    ce08:	vldr	s15, [r3]
    ce0c:	vadd.f32	s15, s14, s15
    ce10:	vstmia	r5!, {s15}
    aux[i] *= 3.0f;
    ce14:	vldr	s15, [r3]
    ce18:	vmul.f32	s15, s15, s13
    ce1c:	vstmia	r3!, {s15}
          destination,
          size);
    }
  }
  
  for (size_t i = 0; i < size; ++i) {
    ce20:	cmp	r3, r8
    ce22:	bne.n	ce04 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x764>
    out[i] += aux[i];
    aux[i] *= 3.0f;
  }
}
    ce24:	add	sp, #132	; 0x84
    ce26:	vpop	{d8-d14}
    ce2a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ce2e:	vsub.f32	s14, s16, s15
    ce32:	b.n	c8c0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x220>
      float waveform,
      const int16_t** wavetable,
      float* out,
      size_t size) {
    if (frequency >= kMaxFrequency) {
      frequency = kMaxFrequency;
    ce34:	vmov.f32	s13, s12
      float amplitude,
      float waveform,
      const int16_t** wavetable,
      float* out,
      size_t size) {
    if (frequency >= kMaxFrequency) {
    ce38:	vldr	s12, [pc, #104]	; cea4 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x804>
    ce3c:	vmov.f32	s14, #96	; 0x3f000000  0.5
    ce40:	b.n	c9e4 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x344>
    ce42:	vldr	s14, [pc, #100]	; cea8 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x808>
    ce46:	vcmpe.f32	s15, s14
    ce4a:	vmrs	APSR_nzcv, fpscr
    ce4e:	ble.n	ce56 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b6>
    ce50:	movs	r3, #0
    ce52:	movs	r1, #255	; 0xff
    ce54:	b.n	c824 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x184>
    ce56:	vldr	s14, [pc, #84]	; ceac <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x80c>
    ce5a:	vadd.f32	s15, s15, s14
    ce5e:	vcvt.s32.f32	s14, s15
    ce62:	vmov	r1, s14
    ce66:	vcvt.f32.s32	s14, s14
    ce6a:	vsub.f32	s15, s15, s14
    ce6e:	vmov.f32	s14, s15
    ce72:	vcvt.s32.f32	s14, s14, #8
    ce76:	vmov	r3, s14
    ce7a:	b.n	c824 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x184>
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
    ce7c:	movs	r3, #0
    ce7e:	movs	r0, #1
    ce80:	vmov.f32	s13, s15
    ce84:	ldr	r6, [pc, #40]	; (ceb0 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x810>)
    ce86:	mov	r2, r3
    ce88:	mov.w	ip, #2
    ce8c:	b.n	c794 <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf4>
    
    if (divide_down_amount) {
      divide_down_voice_[note].Render(
          note_f0,
          harmonics,
          note_amplitudes[note] * divide_down_amount,
    ce8e:	vldr	s23, [fp]
    ce92:	movs	r2, #28
    ce94:	add	r0, sp, #68	; 0x44
	  // trivial types can have deleted assignment
	  static_assert( __assignable::type::value, "type is not assignable" );
#endif
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
    ce96:	add	r1, sp, #96	; 0x60
    ce98:	bl	15578 <memcpy>
    ce9c:	b.n	cbae <plaits::ChordEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x50e>
    ce9e:	nop
    cea0:	.word	0x00000000
    cea4:	.word	0x37b33333
    cea8:	.word	0x42fe0000
    ceac:	.word	0x43000000
    ceb0:	.word	0x2001f7a0
    ceb4:	.word	0x20020790

0000ceb8 <plaits::AdditiveEngine::Init(stmlib::BufferAllocator*)>:
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    ceb8:	movs	r1, #0

using namespace std;
using namespace stmlib;

void AdditiveEngine::Init(BufferAllocator* allocator) {
  fill(
    ceba:	add.w	r3, r0, #184	; 0xb8
    cebe:	add.w	r2, r0, #328	; 0x148
    cec2:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    cec6:	cmp	r2, r3
    cec8:	bne.n	cec2 <plaits::AdditiveEngine::Init(stmlib::BufferAllocator*)+0xa>
namespace plaits {

using namespace std;
using namespace stmlib;

void AdditiveEngine::Init(BufferAllocator* allocator) {
    ceca:	push	{r4}
 public:
  HarmonicOscillator() { }
  ~HarmonicOscillator() { }

  void Init() {
    phase_ = 0.0f;
    cecc:	movs	r2, #0
    cece:	add.w	r4, r0, #24
    ced2:	adds	r0, #192	; 0xc0
    ced4:	add.w	r1, r4, #48	; 0x30
    frequency_ = 0.0f;
    ced8:	mov	r3, r4
 public:
  HarmonicOscillator() { }
  ~HarmonicOscillator() { }

  void Init() {
    phase_ = 0.0f;
    ceda:	str.w	r2, [r4, #-8]
    frequency_ = 0.0f;
    cede:	str.w	r2, [r4, #-4]
    for (int i = 0; i < num_harmonics; ++i) {
      amplitude_[i] = 0.0f;
    cee2:	str.w	r2, [r3], #4
  ~HarmonicOscillator() { }

  void Init() {
    phase_ = 0.0f;
    frequency_ = 0.0f;
    for (int i = 0; i < num_harmonics; ++i) {
    cee6:	cmp	r3, r1
    cee8:	bne.n	cee2 <plaits::AdditiveEngine::Init(stmlib::BufferAllocator*)+0x2a>
    ceea:	adds	r4, #56	; 0x38
  fill(
      &amplitudes_[0],
      &amplitudes_[kNumHarmonics],
      0.0f);
  for (int i = 0; i < kNumHarmonicOscillators; ++i) {
    ceec:	cmp	r4, r0
    ceee:	bne.n	ced4 <plaits::AdditiveEngine::Init(stmlib::BufferAllocator*)+0x1c>
    harmonic_oscillator_[i].Init();
  }
}
    cef0:	ldr.w	r4, [sp], #4
    cef4:	bx	lr
    cef6:	nop

0000cef8 <plaits::AdditiveEngine::Reset()>:

void AdditiveEngine::Reset() {
    cef8:	bx	lr
    cefa:	nop

0000cefc <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)>:
    float bumps,
    float* amplitudes,
    const int* harmonic_indices,
    size_t num_harmonics) {
  const float n = (static_cast<float>(num_harmonics) - 1.0f);
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
    cefc:	vmov.f32	s10, #112	; 0x3f800000  1.0
  const float center = centroid * (n + margin) - 0.5f * margin;
    cf00:	vmov	s15, r3
    cf04:	vmov.f32	s14, #96	; 0x3f000000  0.5
    cf08:	vcvt.f32.u32	s15, s15
    float bumps,
    float* amplitudes,
    const int* harmonic_indices,
    size_t num_harmonics) {
  const float n = (static_cast<float>(num_harmonics) - 1.0f);
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
    cf0c:	vdiv.f32	s13, s10, s1
    cf10:	vadd.f32	s12, s2, s10
  const float center = centroid * (n + margin) - 0.5f * margin;
    cf14:	vsub.f32	s15, s15, s10
    float bumps,
    float* amplitudes,
    const int* harmonic_indices,
    size_t num_harmonics) {
  const float n = (static_cast<float>(num_harmonics) - 1.0f);
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
    cf18:	vsub.f32	s13, s13, s10
    cf1c:	vdiv.f32	s8, s13, s12
  const float center = centroid * (n + margin) - 0.5f * margin;
    cf20:	vadd.f32	s15, s15, s8
    cf24:	vnmul.f32	s8, s14, s8
    cf28:	vfma.f32	s8, s15, s0

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    cf2c:	cmp	r3, #0
    cf2e:	beq.n	d00c <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)+0x110>
    cf30:	vldr	s9, [pc, #220]	; d010 <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)+0x114>
    float order = fabsf(static_cast<float>(i) - center) * slope;
    float gain = 1.0f - order;
    gain += fabsf(gain);
    gain *= gain;

    float b = 0.25f + order * bumps;
    cf34:	vmov.f32	s4, #80	; 0x3e800000  0.250
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    cf38:	vldr	s6, [pc, #216]	; d014 <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)+0x118>
    //
    // I have tried both normalizing the LP-ed spectrum, and LP-ing the
    // normalized spectrum, and both of them cause more annoyances than this
    // "incorrect" solution.
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    cf3c:	vmov.f32	s5, s9
    float centroid,
    float slope,
    float bumps,
    float* amplitudes,
    const int* harmonic_indices,
    size_t num_harmonics) {
    cf40:	push	{r4, r5, r6, r7, lr}
    cf42:	ldr.w	lr, [pc, #212]	; d018 <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)+0x11c>
    cf46:	subs	r6, r2, #4
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
  const float center = centroid * (n + margin) - 0.5f * margin;

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    cf48:	movs	r5, #0
    cf4a:	add.w	ip, lr, #4
    float order = fabsf(static_cast<float>(i) - center) * slope;
    cf4e:	vmov	s15, r5
    float gain = 1.0f - order;
    gain += fabsf(gain);
    gain *= gain;

    float b = 0.25f + order * bumps;
    cf52:	vmov.f32	s13, s4
    //
    // I have tried both normalizing the LP-ed spectrum, and LP-ing the
    // normalized spectrum, and both of them cause more annoyances than this
    // "incorrect" solution.
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    cf56:	ldr.w	r0, [r6, #4]!
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
  const float center = centroid * (n + margin) - 0.5f * margin;

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    cf5a:	adds	r5, #1
    float order = fabsf(static_cast<float>(i) - center) * slope;
    cf5c:	vcvt.f32.u32	s15, s15
    //
    // I have tried both normalizing the LP-ed spectrum, and LP-ing the
    // normalized spectrum, and both of them cause more annoyances than this
    // "incorrect" solution.
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    cf60:	add.w	r0, r1, r0, lsl #2
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
  const float center = centroid * (n + margin) - 0.5f * margin;

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    cf64:	cmp	r3, r5
    float order = fabsf(static_cast<float>(i) - center) * slope;
    float gain = 1.0f - order;
    cf66:	vmov.f32	s7, #112	; 0x3f800000  1.0
  const float center = centroid * (n + margin) - 0.5f * margin;

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    float order = fabsf(static_cast<float>(i) - center) * slope;
    cf6a:	vsub.f32	s15, s15, s8
    //
    // I have tried both normalizing the LP-ed spectrum, and LP-ing the
    // normalized spectrum, and both of them cause more annoyances than this
    // "incorrect" solution.
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    cf6e:	vldr	s12, [r0]
  const float center = centroid * (n + margin) - 0.5f * margin;

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    float order = fabsf(static_cast<float>(i) - center) * slope;
    cf72:	vabs.f32	s15, s15
    cf76:	vmul.f32	s15, s15, s1
    float gain = 1.0f - order;
    gain += fabsf(gain);
    gain *= gain;

    float b = 0.25f + order * bumps;
    cf7a:	vfma.f32	s13, s2, s15

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    float order = fabsf(static_cast<float>(i) - center) * slope;
    float gain = 1.0f - order;
    cf7e:	vsub.f32	s15, s10, s15
    gain += fabsf(gain);
    cf82:	vabs.f32	s11, s15
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    cf86:	vcvt.s32.f32	s14, s13
    cf8a:	vadd.f32	s15, s15, s11
    cf8e:	vcvt.f32.s32	s14, s14
    gain *= gain;
    cf92:	vmul.f32	s15, s15, s15
    cf96:	vsub.f32	s14, s13, s14
  index *= size;
    cf9a:	vmul.f32	s14, s14, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    cf9e:	vcvt.s32.f32	s13, s14
  float a = table[index_integral];
    cfa2:	vmov	r4, s13

    float b = 0.25f + order * bumps;
    float bump_factor = 1.0f + InterpolateWrap(lut_sine, b, 1024.0f);

    gain *= bump_factor;
    cfa6:	vcvt.f32.s32	s13, s13
    cfaa:	mov.w	r4, r4, lsl #2
    cfae:	vsub.f32	s13, s14, s13
    cfb2:	add.w	r7, lr, r4
  float b = table[index_integral + 1];
    cfb6:	add	r4, ip

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    cfb8:	vldr	s14, [r7]
    cfbc:	vldr	s11, [r4]
    cfc0:	vsub.f32	s11, s11, s14
    cfc4:	vfma.f32	s14, s13, s11
    cfc8:	vadd.f32	s14, s14, s10
    cfcc:	vmul.f32	s15, s14, s15
    //
    // I have tried both normalizing the LP-ed spectrum, and LP-ing the
    // normalized spectrum, and both of them cause more annoyances than this
    // "incorrect" solution.
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    cfd0:	vmov.f32	s14, s12

    float b = 0.25f + order * bumps;
    float bump_factor = 1.0f + InterpolateWrap(lut_sine, b, 1024.0f);

    gain *= bump_factor;
    gain *= gain;
    cfd4:	vmul.f32	s15, s15, s15
    //
    // I have tried both normalizing the LP-ed spectrum, and LP-ing the
    // normalized spectrum, and both of them cause more annoyances than this
    // "incorrect" solution.
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    cfd8:	vfnms.f32	s14, s15, s15
    cfdc:	vfma.f32	s12, s14, s5
    cfe0:	vstr	s12, [r0]
    sum += amplitudes[j];
    cfe4:	vadd.f32	s9, s9, s12
  const float margin = (1.0f / slope - 1.0f) / (1.0f + bumps);
  const float center = centroid * (n + margin) - 0.5f * margin;

  float sum = 0.001f;

  for (size_t i = 0; i < num_harmonics; ++i) {
    cfe8:	bne.n	cf4e <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)+0x52>
    
    ONE_POLE(amplitudes[j], gain, 0.001f);
    sum += amplitudes[j];
  }

  sum = 1.0f / sum;
    cfea:	vdiv.f32	s14, s7, s9
    cfee:	add.w	r3, r2, r3, lsl #2

  for (size_t i = 0; i < num_harmonics; ++i) {
    amplitudes[harmonic_indices[i]] *= sum;
    cff2:	ldr.w	r0, [r2], #4
    cff6:	add.w	r0, r1, r0, lsl #2
    sum += amplitudes[j];
  }

  sum = 1.0f / sum;

  for (size_t i = 0; i < num_harmonics; ++i) {
    cffa:	cmp	r3, r2
    amplitudes[harmonic_indices[i]] *= sum;
    cffc:	vldr	s15, [r0]
    d000:	vmul.f32	s15, s15, s14
    d004:	vstr	s15, [r0]
    sum += amplitudes[j];
  }

  sum = 1.0f / sum;

  for (size_t i = 0; i < num_harmonics; ++i) {
    d008:	bne.n	cff2 <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)+0xf6>
    d00a:	pop	{r4, r5, r6, r7, pc}
    d00c:	bx	lr
    d00e:	nop
    d010:	.word	0x3a83126f
    d014:	.word	0x44800000
    d018:	.word	0x20002b10

0000d01c <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    d01c:	vmov.f32	s13, #34	; 0x41100000  9.0
    d020:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d024:	vldr	s14, [pc, #956]	; d3e4 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    d028:	vsub.f32	s15, s15, s13
void AdditiveEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    d02c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d030:	vcmpe.f32	s15, s14
    d034:	mov	r5, r1
    d036:	mov	r4, r0
    d038:	mov	r7, r2
    d03a:	mov	r8, r3
    d03c:	vmrs	APSR_nzcv, fpscr
    d040:	vpush	{d8-d10}
    d044:	sub	sp, #148	; 0x94
    d046:	bmi.w	d5a6 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x58a>
    d04a:	vldr	s14, [pc, #924]	; d3e8 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3cc>
    d04e:	vcmpe.f32	s15, s14
    d052:	vmrs	APSR_nzcv, fpscr
    d056:	ble.w	d580 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x564>
    d05a:	movs	r0, #0
    d05c:	mov.w	lr, #255	; 0xff
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
    d060:	vmov.f32	s20, #112	; 0x3f800000  1.0
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
    d064:	vldr	s13, [r5, #16]
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
    d068:	vldr	s15, [pc, #896]	; d3ec <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d0>
  const float slope = 0.01f + 1.99f * raw_slope * raw_slope * raw_slope;
  const float bumps = 16.0f * raw_bumps * raw_bumps;
    d06c:	vmov.f32	s17, #48	; 0x41800000  16.0
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
    d070:	vldr	s11, [r5, #12]
      centroid,
      slope,
      bumps,
      &amplitudes_[0],
      integer_harmonics,
      24);
    d074:	movs	r3, #24
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
    d076:	vmov.f32	s14, s20
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
    d07a:	vldr	s19, [r5, #8]
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
  const float slope = 0.01f + 1.99f * raw_slope * raw_slope * raw_slope;
    d07e:	vldr	s18, [pc, #880]	; d3f0 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d4>
  const float bumps = 16.0f * raw_bumps * raw_bumps;
    d082:	vmul.f32	s17, s13, s17

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    d086:	ldr	r2, [pc, #876]	; (d3f4 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d8>)
  UpdateAmplitudes(
    d088:	add.w	r1, r4, #184	; 0xb8
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
    d08c:	vfms.f32	s14, s13, s15
  const float slope = 0.01f + 1.99f * raw_slope * raw_slope * raw_slope;
    d090:	vldr	s15, [pc, #868]	; d3f8 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3dc>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d094:	ldr	r5, [pc, #868]	; (d3fc <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e0>)

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    d096:	add.w	r2, r2, lr, lsl #2
  const float bumps = 16.0f * raw_bumps * raw_bumps;
    d09a:	vmul.f32	s17, s17, s13
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    d09e:	vldr	s12, [pc, #864]	; d400 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e4>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d0a2:	add.w	r5, r5, r0, lsl #2
    d0a6:	vldr	s13, [r2]
      centroid,
      slope,
      bumps,
      &amplitudes_[0],
      integer_harmonics,
      24);
    d0aa:	mov	r0, r4
    d0ac:	ldr	r2, [pc, #852]	; (d404 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e8>)
    d0ae:	vldr	s16, [r5]
    d0b2:	vmov.f32	s0, s19
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
    d0b6:	vmul.f32	s14, s14, s11
    d0ba:	mov	r5, sp
    d0bc:	vmul.f32	s13, s13, s16
      centroid,
      slope,
      bumps,
      &amplitudes_[0],
      integer_harmonics,
      24);
    d0c0:	vmov.f32	s2, s17
  const float f0 = NoteToFrequency(parameters.note);

  const float centroid = parameters.timbre;
  const float raw_bumps = parameters.harmonics;
  const float raw_slope = (1.0f - 0.6f * raw_bumps) * parameters.morph;
  const float slope = 0.01f + 1.99f * raw_slope * raw_slope * raw_slope;
    d0c4:	vmul.f32	s15, s14, s15
    d0c8:	vmul.f32	s16, s13, s12
    d0cc:	vmul.f32	s15, s15, s14
    d0d0:	vfma.f32	s18, s14, s15
      centroid,
      slope,
      bumps,
      &amplitudes_[0],
      integer_harmonics,
      24);
    d0d4:	vmov.f32	s1, s18
    d0d8:	bl	cefc <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)>
  void Render(
      float frequency,
      const float* amplitudes,
      float* out,
      size_t size) {
    if (frequency >= 0.5f) {
    d0dc:	vmov.f32	s12, #96	; 0x3f000000  0.5
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    d0e0:	vldr	s15, [sp, #208]	; 0xd0
    d0e4:	vmov.f32	s9, #0	; 0x40000000  2.0
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d0e8:	vldr	s8, [r4, #20]
    d0ec:	vmov.f32	s10, s20
    d0f0:	vcmpe.f32	s16, s12
    increment_ = (new_value - *state) / static_cast<float>(size);
    d0f4:	mov	r3, sp
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
      if (f >= 0.5f) {
    d0f6:	vmov.f32	s11, s12
    d0fa:	add.w	r0, r4, #24
    d0fe:	vcvt.f32.u32	s3, s15
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d102:	movs	r2, #0
  void Render(
      float frequency,
      const float* amplitudes,
      float* out,
      size_t size) {
    if (frequency >= 0.5f) {
    d104:	vmrs	APSR_nzcv, fpscr
    d108:	it	lt
    d10a:	vmovlt.f32	s12, s16
    d10e:	vsub.f32	s15, s12, s8
    d112:	vdiv.f32	s7, s15, s3
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
    d116:	adds	r2, #1
      if (f >= 0.5f) {
    d118:	vldr	s14, [pc, #748]	; d408 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ec>
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
    d11c:	vmov	s15, r2
    d120:	vcvt.f32.s32	s15, s15
    d124:	vmul.f32	s15, s15, s12
      if (f >= 0.5f) {
    d128:	vcmpe.f32	s15, s11
    d12c:	vmrs	APSR_nzcv, fpscr
    d130:	bge.n	d13a <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e>
    d132:	vmov.f32	s14, s10
    d136:	vfms.f32	s14, s15, s9
  ~ParameterInterpolator() {
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    d13a:	str	r0, [r3, #0]
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d13c:	cmp	r2, #12
    value_ = *state;
    d13e:	vldmia	r0!, {s15}
    d142:	add.w	r3, r3, #12
      float f = frequency * static_cast<float>(first_harmonic_index + i);
      if (f >= 0.5f) {
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    d146:	vldmia	r1!, {s13}
    increment_ = (new_value - *state) / static_cast<float>(size);
    d14a:	vmov.f32	s6, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d14e:	vstr	s15, [r3, #-8]
    increment_ = (new_value - *state) / static_cast<float>(size);
    d152:	vfnms.f32	s6, s13, s14
    d156:	vdiv.f32	s15, s6, s3
    d15a:	vstr	s15, [r3, #-4]
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d15e:	bne.n	d116 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfa>
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d160:	ldr	r3, [sp, #208]	; 0xd0
    d162:	subs	r6, r3, #1
    d164:	cmp	r3, #0
    d166:	beq.n	d214 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f8>
    d168:	ldr	r1, [pc, #672]	; (d40c <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f0>)
      phase_ += fm.Next();
      if (phase_ >= 1.0f) {
    d16a:	vmov.f32	s6, #112	; 0x3f800000  1.0
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
    d16e:	vmov.f32	s4, #96	; 0x3f000000  0.5
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d172:	mov	r9, r7
    d174:	adds	r0, r1, #4
    d176:	mov	ip, r6
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
    d178:	vldr	s5, [pc, #660]	; d410 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f4>
    d17c:	add	r2, sp, #144	; 0x90
  }

  inline float Next() {
    value_ += increment_;
    d17e:	vadd.f32	s8, s8, s7
      phase_ += fm.Next();
    d182:	vldr	s15, [r4, #16]
        phase_ -= 1.0f;
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
    d186:	vmov.f32	s11, #112	; 0x3f800000  1.0
        previous = stmlib::InterpolateWrap(
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
    d18a:	vldr	s12, [pc, #636]	; d408 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ec>
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
    d18e:	mov	r3, r5
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
      phase_ += fm.Next();
    d190:	vadd.f32	s15, s8, s15
      if (phase_ >= 1.0f) {
    d194:	vcmpe.f32	s15, s6
    d198:	vmrs	APSR_nzcv, fpscr
        phase_ -= 1.0f;
    d19c:	it	ge
    d19e:	vsubge.f32	s15, s15, s6
    d1a2:	vstr	s15, [r4, #16]
    d1a6:	vmul.f32	s15, s15, s5
  MAKE_INTEGRAL_FRACTIONAL(index)
    d1aa:	vcvt.s32.f32	s14, s15
  float a = table[index_integral];
    d1ae:	vmov	lr, s14
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
    d1b2:	vcvt.f32.s32	s14, s14
    d1b6:	mov.w	lr, lr, lsl #2
    d1ba:	vsub.f32	s15, s15, s14
    d1be:	add.w	sl, r1, lr
  float b = table[index_integral + 1];
    d1c2:	add	lr, r0
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d1c4:	vldr	s9, [sl]
    d1c8:	vldr	s14, [lr]
    d1cc:	vsub.f32	s14, s14, s9
    d1d0:	vfma.f32	s9, s15, s14
    d1d4:	vadd.f32	s9, s9, s9
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
    d1d8:	vmul.f32	s13, s9, s4
    d1dc:	vldr	s15, [r3, #4]
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
        sum += am[i].Next() * current;
        float temp = current;
        current = two_x * current - previous;
    d1e0:	vfnms.f32	s11, s9, s13
    d1e4:	vldr	s14, [r3, #8]
    d1e8:	adds	r3, #12
    d1ea:	vadd.f32	s15, s14, s15
    d1ee:	vstr	s15, [r3, #-8]
    d1f2:	vmov.f32	s10, s11
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
    d1f6:	cmp	r2, r3
    d1f8:	vmov.f32	s11, s13
        sum += am[i].Next() * current;
    d1fc:	vfma.f32	s12, s15, s13
        float temp = current;
        current = two_x * current - previous;
    d200:	vmov.f32	s13, s10
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
    d204:	bne.n	d1dc <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1c0>
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d206:	add.w	ip, ip, #4294967295
        float temp = current;
        current = two_x * current - previous;
        previous = temp;
      }
      if (first_harmonic_index == 1) {
        *out++ = sum;
    d20a:	vstmia	r9!, {s12}
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d20e:	cmp.w	ip, #4294967295
    d212:	bne.n	d17e <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x162>
      size_t size) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    d214:	add	r3, sp, #144	; 0x90
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    d216:	vstr	s8, [r4, #20]
    d21a:	ldr.w	r2, [r3, #-12]!
    d21e:	ldr	r1, [r3, #4]
    d220:	cmp	r3, r5
    d222:	str	r1, [r2, #0]
    d224:	bne.n	d21a <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1fe>
  void Render(
      float frequency,
      const float* amplitudes,
      float* out,
      size_t size) {
    if (frequency >= 0.5f) {
    d226:	vmov.f32	s12, #96	; 0x3f000000  0.5
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d22a:	vldr	s8, [r4, #76]	; 0x4c
    d22e:	vmov.f32	s9, #0	; 0x40000000  2.0
    d232:	add.w	r0, r4, #232	; 0xe8
    d236:	vmov.f32	s10, #112	; 0x3f800000  1.0
    d23a:	add.w	r1, r4, #80	; 0x50
    d23e:	vcmpe.f32	s16, s12
    increment_ = (new_value - *state) / static_cast<float>(size);
    d242:	mov	r3, r5
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
      if (f >= 0.5f) {
    d244:	vmov.f32	s11, s12
    d248:	movs	r2, #13
  void Render(
      float frequency,
      const float* amplitudes,
      float* out,
      size_t size) {
    if (frequency >= 0.5f) {
    d24a:	vmrs	APSR_nzcv, fpscr
    d24e:	it	lt
    d250:	vmovlt.f32	s12, s16
    d254:	vsub.f32	s15, s12, s8
    d258:	vdiv.f32	s5, s15, s3
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
    d25c:	vmov	s15, r2
      if (f >= 0.5f) {
    d260:	vldr	s14, [pc, #420]	; d408 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ec>
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
    d264:	vcvt.f32.s32	s15, s15
    d268:	vmul.f32	s15, s15, s12
      if (f >= 0.5f) {
    d26c:	vcmpe.f32	s15, s11
    d270:	vmrs	APSR_nzcv, fpscr
    d274:	bge.n	d27e <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x262>
    d276:	vmov.f32	s14, s10
    d27a:	vfms.f32	s14, s15, s9
  ~ParameterInterpolator() {
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    d27e:	str	r1, [r3, #0]
    d280:	adds	r2, #1
    value_ = *state;
    d282:	vldmia	r1!, {s15}
    d286:	adds	r3, #12
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    d288:	vldmia	r0!, {s13}
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d28c:	cmp	r2, #25
    increment_ = (new_value - *state) / static_cast<float>(size);
    d28e:	vmov.f32	s7, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d292:	vstr	s15, [r3, #-8]
    increment_ = (new_value - *state) / static_cast<float>(size);
    d296:	vfnms.f32	s7, s13, s14
    d29a:	vdiv.f32	s15, s7, s3
    d29e:	vstr	s15, [r3, #-4]
    d2a2:	bne.n	d25c <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x240>
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d2a4:	ldr	r3, [sp, #208]	; 0xd0
    d2a6:	cmp	r3, #0
    d2a8:	beq.w	d414 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f8>
    d2ac:	ldr	r1, [pc, #348]	; (d40c <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f0>)
      phase_ += fm.Next();
      if (phase_ >= 1.0f) {
    d2ae:	vmov.f32	s6, #112	; 0x3f800000  1.0
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
      } else {
        const float k = first_harmonic_index;
        previous = stmlib::InterpolateWrap(
    d2b2:	vmov.f32	s1, #40	; 0x41400000  12.0
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d2b6:	mov	r9, r6
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
      } else {
        const float k = first_harmonic_index;
        previous = stmlib::InterpolateWrap(
    d2b8:	vmov.f32	s2, #80	; 0x3e800000  0.250
    d2bc:	adds	r0, r1, #4
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
    d2be:	vmov.f32	s4, #42	; 0x41500000  13.0
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
    d2c2:	vldr	s7, [pc, #332]	; d410 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f4>
    d2c6:	add	r2, sp, #144	; 0x90
  }

  inline float Next() {
    value_ += increment_;
    d2c8:	vadd.f32	s8, s8, s5
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
      phase_ += fm.Next();
    d2cc:	vldr	s15, [r4, #72]	; 0x48
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
      } else {
        const float k = first_harmonic_index;
        previous = stmlib::InterpolateWrap(
    d2d0:	vmov.f32	s13, s2
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    d2d4:	mov	r3, r5
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
    d2d6:	vldr	s12, [pc, #304]	; d408 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ec>
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
      phase_ += fm.Next();
    d2da:	vadd.f32	s15, s8, s15
      if (phase_ >= 1.0f) {
    d2de:	vcmpe.f32	s15, s6
    d2e2:	vmrs	APSR_nzcv, fpscr
        phase_ -= 1.0f;
    d2e6:	it	ge
    d2e8:	vsubge.f32	s15, s15, s6
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
      } else {
        const float k = first_harmonic_index;
        previous = stmlib::InterpolateWrap(
    d2ec:	vfma.f32	s13, s15, s1
    }

    while (size--) {
      phase_ += fm.Next();
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
    d2f0:	vstr	s15, [r4, #72]	; 0x48
        current = two_x * 0.5f;
      } else {
        const float k = first_harmonic_index;
        previous = stmlib::InterpolateWrap(
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
    d2f4:	vmul.f32	s14, s15, s4
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
    d2f8:	vmul.f32	s11, s15, s7
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    d2fc:	vcvt.s32.f32	s15, s14
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
    d300:	vcvt.s32.f32	s0, s11
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    d304:	vcvt.s32.f32	s10, s13
    d308:	vcvt.f32.s32	s15, s15
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d30c:	vmov	lr, s0
    while (size--) {
      phase_ += fm.Next();
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
    d310:	vcvt.f32.s32	s9, s0
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    d314:	vcvt.f32.s32	s10, s10
    d318:	vsub.f32	s15, s14, s15
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d31c:	mov.w	lr, lr, lsl #2
    d320:	vsub.f32	s11, s11, s9
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    d324:	vsub.f32	s10, s13, s10
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d328:	add.w	ip, r1, lr
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    d32c:	vmul.f32	s15, s15, s7

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
  float b = table[index_integral + 1];
    d330:	add	lr, r0
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d332:	vldr	s9, [ip]
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    d336:	vmul.f32	s10, s10, s7
    d33a:	vldr	s20, [lr]
  MAKE_INTEGRAL_FRACTIONAL(index)
    d33e:	vcvt.s32.f32	s14, s15
    d342:	vsub.f32	s20, s20, s9
    d346:	vcvt.s32.f32	s13, s10
  float a = table[index_integral];
    d34a:	vmov	lr, s14
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    d34e:	vcvt.f32.s32	s14, s14
    d352:	vfma.f32	s9, s11, s20

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d356:	vmov	ip, s13
    d35a:	mov.w	lr, lr, lsl #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    d35e:	vcvt.f32.s32	s0, s13

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d362:	mov.w	ip, ip, lsl #2
    d366:	add.w	fp, r1, lr
  float b = table[index_integral + 1];
    d36a:	add	lr, r0
  return a + (b - a) * index_fractional;
    d36c:	vsub.f32	s15, s15, s14

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d370:	add.w	sl, r1, ip
  float b = table[index_integral + 1];
    d374:	add	ip, r0

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d376:	vldr	s13, [fp]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    d37a:	vsub.f32	s10, s10, s0

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d37e:	vldr	s11, [sl]
    d382:	vadd.f32	s9, s9, s9
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    d386:	vldr	s0, [ip]
    d38a:	vldr	s14, [lr]
    d38e:	vsub.f32	s0, s0, s11
    d392:	vsub.f32	s14, s14, s13
    d396:	vfma.f32	s11, s10, s0
    d39a:	vfma.f32	s13, s15, s14
    d39e:	vldr	s15, [r3, #4]
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
        sum += am[i].Next() * current;
        float temp = current;
        current = two_x * current - previous;
    d3a2:	vfnms.f32	s11, s9, s13
    d3a6:	vldr	s14, [r3, #8]
    d3aa:	adds	r3, #12
    d3ac:	vadd.f32	s15, s14, s15
    d3b0:	vstr	s15, [r3, #-8]
    d3b4:	vmov.f32	s10, s11
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
    d3b8:	cmp	r2, r3
    d3ba:	vmov.f32	s11, s13
        sum += am[i].Next() * current;
    d3be:	vfma.f32	s12, s15, s13
        float temp = current;
        current = two_x * current - previous;
    d3c2:	vmov.f32	s13, s10
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
    d3c6:	bne.n	d39e <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x382>
        previous = temp;
      }
      if (first_harmonic_index == 1) {
        *out++ = sum;
      } else {
        *out++ += sum;
    d3c8:	vldmia	r7!, {s15}
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d3cc:	add.w	r9, r9, #4294967295
        previous = temp;
      }
      if (first_harmonic_index == 1) {
        *out++ = sum;
      } else {
        *out++ += sum;
    d3d0:	vadd.f32	s12, s15, s12
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d3d4:	cmp.w	r9, #4294967295
        previous = temp;
      }
      if (first_harmonic_index == 1) {
        *out++ = sum;
      } else {
        *out++ += sum;
    d3d8:	vstr	s12, [r7, #-4]
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d3dc:	bne.w	d2c8 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
    d3e0:	b.n	d414 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f8>
    d3e2:	nop
    d3e4:	.word	0xc3000000
    d3e8:	.word	0x42fe0000
    d3ec:	.word	0x3f19999a
    d3f0:	.word	0x3c23d70a
    d3f4:	.word	0x20000554
    d3f8:	.word	0x3ffeb852
    d3fc:	.word	0x20000958
    d400:	.word	0x39962fc9
    d404:	.word	0x2001f958
    d408:	.word	0x00000000
    d40c:	.word	0x20002b10
    d410:	.word	0x44800000
      size_t size) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    d414:	add	r3, sp, #144	; 0x90
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    d416:	vstr	s8, [r4, #76]	; 0x4c
    d41a:	ldr.w	r2, [r3, #-12]!
    d41e:	ldr	r1, [r3, #4]
    d420:	cmp	r3, r5
    d422:	str	r1, [r2, #0]
    d424:	bne.n	d41a <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3fe>
      centroid,
      slope,
      bumps,
      &amplitudes_[24],
      organ_harmonics,
      8);
    d426:	movs	r3, #8
    d428:	ldr	r2, [pc, #384]	; (d5ac <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x590>)
    d42a:	mov	r0, r4
      integer_harmonics,
      24);
  harmonic_oscillator_[0].Render<1>(f0, &amplitudes_[0], out, size);
  harmonic_oscillator_[1].Render<13>(f0, &amplitudes_[12], out, size);

  UpdateAmplitudes(
    d42c:	add.w	r1, r4, #280	; 0x118
      centroid,
      slope,
      bumps,
      &amplitudes_[24],
      organ_harmonics,
      8);
    d430:	vmov.f32	s2, s17
    d434:	vmov.f32	s1, s18
    d438:	vmov.f32	s0, s19
    d43c:	bl	cefc <plaits::AdditiveEngine::UpdateAmplitudes(float, float, float, float*, int const*, unsigned int)>
  void Render(
      float frequency,
      const float* amplitudes,
      float* out,
      size_t size) {
    if (frequency >= 0.5f) {
    d440:	vmov.f32	s15, #96	; 0x3f000000  0.5
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d444:	vldr	s8, [r4, #132]	; 0x84
    d448:	vmov.f32	s10, #0	; 0x40000000  2.0
    d44c:	vmov.f32	s11, #112	; 0x3f800000  1.0
    d450:	add.w	r0, r4, #136	; 0x88
      frequency = 0.5f;
    d454:	vcmp.f32	s16, s15
    increment_ = (new_value - *state) / static_cast<float>(size);
    d458:	mov	r3, r5
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
      if (f >= 0.5f) {
    d45a:	vmov.f32	s12, s15
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d45e:	movs	r2, #0
      float frequency,
      const float* amplitudes,
      float* out,
      size_t size) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    d460:	vmrs	APSR_nzcv, fpscr
    d464:	it	ge
    d466:	vmovge.f32	s16, s15
    d46a:	vsub.f32	s15, s16, s8
    d46e:	vdiv.f32	s6, s15, s3
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
    d472:	adds	r2, #1
      if (f >= 0.5f) {
    d474:	vldr	s14, [pc, #312]	; d5b0 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x594>
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
      float f = frequency * static_cast<float>(first_harmonic_index + i);
    d478:	vmov	s15, r2
    d47c:	vcvt.f32.s32	s15, s15
    d480:	vmul.f32	s15, s15, s16
      if (f >= 0.5f) {
    d484:	vcmpe.f32	s15, s12
    d488:	vmrs	APSR_nzcv, fpscr
    d48c:	bge.n	d496 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x47a>
    d48e:	vmov.f32	s14, s11
    d492:	vfms.f32	s14, s15, s10
  ~ParameterInterpolator() {
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    d496:	str	r0, [r3, #0]
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d498:	cmp	r2, #12
    value_ = *state;
    d49a:	vldmia	r0!, {s15}
    d49e:	add.w	r3, r3, #12
      float f = frequency * static_cast<float>(first_harmonic_index + i);
      if (f >= 0.5f) {
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    d4a2:	vldmia	r1!, {s13}
    increment_ = (new_value - *state) / static_cast<float>(size);
    d4a6:	vmov.f32	s9, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d4aa:	vstr	s15, [r3, #-8]
    increment_ = (new_value - *state) / static_cast<float>(size);
    d4ae:	vfnms.f32	s9, s13, s14
    d4b2:	vdiv.f32	s15, s9, s3
    d4b6:	vstr	s15, [r3, #-4]
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    
    for (int i = 0; i < num_harmonics; ++i) {
    d4ba:	bne.n	d472 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x456>
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d4bc:	ldr	r3, [sp, #208]	; 0xd0
    d4be:	cmp	r3, #0
    d4c0:	beq.n	d564 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x548>
    d4c2:	ldr	r1, [pc, #240]	; (d5b4 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x598>)
      phase_ += fm.Next();
      if (phase_ >= 1.0f) {
    d4c4:	vmov.f32	s7, #112	; 0x3f800000  1.0
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
    d4c8:	vmov.f32	s4, #96	; 0x3f000000  0.5
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
    d4cc:	vldr	s5, [pc, #232]	; d5b8 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x59c>
    d4d0:	adds	r0, r1, #4
    d4d2:	add	r2, sp, #144	; 0x90
  }

  inline float Next() {
    value_ += increment_;
    d4d4:	vadd.f32	s8, s8, s6
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
      phase_ += fm.Next();
    d4d8:	vldr	s15, [r4, #128]	; 0x80
        phase_ -= 1.0f;
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
    d4dc:	vmov.f32	s11, #112	; 0x3f800000  1.0
        current = two_x * 0.5f;
    d4e0:	mov	r3, r5
        previous = stmlib::InterpolateWrap(
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
    d4e2:	vldr	s12, [pc, #204]	; d5b0 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x594>
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
      phase_ += fm.Next();
    d4e6:	vadd.f32	s15, s8, s15
      if (phase_ >= 1.0f) {
    d4ea:	vcmpe.f32	s15, s7
    d4ee:	vmrs	APSR_nzcv, fpscr
        phase_ -= 1.0f;
    d4f2:	it	ge
    d4f4:	vsubge.f32	s15, s15, s7
    d4f8:	vstr	s15, [r4, #128]	; 0x80
    d4fc:	vmul.f32	s15, s15, s5
  MAKE_INTEGRAL_FRACTIONAL(index)
    d500:	vcvt.s32.f32	s14, s15
  float a = table[index_integral];
    d504:	vmov	r7, s14
      }
      const float two_x = 2.0f * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
    d508:	vcvt.f32.s32	s14, s14
    d50c:	lsls	r7, r7, #2
    d50e:	vsub.f32	s15, s15, s14
    d512:	add.w	lr, r1, r7
  float b = table[index_integral + 1];
    d516:	add	r7, r0
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d518:	vldr	s9, [lr]
    d51c:	vldr	s14, [r7]
    d520:	vsub.f32	s14, s14, s9
    d524:	vfma.f32	s9, s15, s14
    d528:	vadd.f32	s9, s9, s9
      float previous, current;
      if (first_harmonic_index == 1) {
        previous = 1.0f;
        current = two_x * 0.5f;
    d52c:	vmul.f32	s13, s9, s4
    d530:	vldr	s15, [r3, #4]
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
        sum += am[i].Next() * current;
        float temp = current;
        current = two_x * current - previous;
    d534:	vfnms.f32	s11, s9, s13
    d538:	vldr	s14, [r3, #8]
    d53c:	adds	r3, #12
    d53e:	vadd.f32	s15, s14, s15
    d542:	vstr	s15, [r3, #-8]
    d546:	vmov.f32	s10, s11
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
    d54a:	cmp	r3, r2
    d54c:	vmov.f32	s11, s13
        sum += am[i].Next() * current;
    d550:	vfma.f32	s12, s15, s13
        float temp = current;
        current = two_x * current - previous;
    d554:	vmov.f32	s13, s10
            lut_sine, phase_ * (k - 1.0f) + 0.25f, 1024.0f);
        current = stmlib::InterpolateWrap(lut_sine, phase_ * k, 1024.0f);
      }
      
      float sum = 0.0f;
      for (int i = 0; i < num_harmonics; ++i) {
    d558:	bne.n	d530 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x514>
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d55a:	subs	r6, #1
        float temp = current;
        current = two_x * current - previous;
        previous = temp;
      }
      if (first_harmonic_index == 1) {
        *out++ = sum;
    d55c:	vstmia	r8!, {s12}
        f = 0.5f;
      }
      am[i].Init(&amplitude_[i], amplitudes[i] * (1.0f - f * 2.0f), size);
    }

    while (size--) {
    d560:	adds	r3, r6, #1
    d562:	bne.n	d4d4 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4b8>
      size_t size) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    }
    
    stmlib::ParameterInterpolator am[num_harmonics];
    d564:	add	r3, sp, #144	; 0x90
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    d566:	vstr	s8, [r4, #132]	; 0x84
    d56a:	ldr.w	r2, [r3, #-12]!
    d56e:	ldr	r1, [r3, #4]
    d570:	cmp	r3, r5
    d572:	str	r1, [r2, #0]
    d574:	bne.n	d56a <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x54e>

  harmonic_oscillator_[2].Render<1>(f0, &amplitudes_[24], aux, size);
}
    d576:	add	sp, #148	; 0x94
    d578:	vpop	{d8-d10}
    d57c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d580:	vldr	s14, [pc, #56]	; d5bc <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5a0>
    d584:	vadd.f32	s15, s15, s14
    d588:	vcvt.s32.f32	s14, s15
    d58c:	vmov	lr, s14
    d590:	vcvt.f32.s32	s14, s14
    d594:	vsub.f32	s15, s15, s14
    d598:	vmov.f32	s14, s15
    d59c:	vcvt.s32.f32	s14, s14, #8
    d5a0:	vmov	r0, s14
    d5a4:	b.n	d060 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d5a6:	movs	r0, #0
    d5a8:	mov	lr, r0
    d5aa:	b.n	d060 <plaits::AdditiveEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>
    d5ac:	.word	0x2001f938
    d5b0:	.word	0x00000000
    d5b4:	.word	0x20002b10
    d5b8:	.word	0x44800000
    d5bc:	.word	0x43000000

0000d5c0 <plaits::GrainEngine::Init(stmlib::BufferAllocator*)>:
 public:
  GrainletOscillator() { }
  ~GrainletOscillator() { }

  void Init() {
    carrier_phase_ = 0.0f;
    d5c0:	movs	r3, #0
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    d5c2:	ldr	r1, [pc, #60]	; (d600 <plaits::GrainEngine::Init(stmlib::BufferAllocator*)+0x40>)
    gi_ = 1.0f / (1.0f + g_);
    d5c4:	ldr	r2, [pc, #60]	; (d604 <plaits::GrainEngine::Init(stmlib::BufferAllocator*)+0x44>)
    d5c6:	str	r3, [r0, #16]
    formant_phase_ = 0.0f;
    d5c8:	str	r3, [r0, #20]
    next_sample_ = 0.0f;
    d5ca:	str	r3, [r0, #24]
  
    carrier_frequency_ = 0.0f;
    d5cc:	str	r3, [r0, #28]
    formant_frequency_ = 0.0f;
    d5ce:	str	r3, [r0, #32]
    carrier_shape_ = 0.0f;
    d5d0:	str	r3, [r0, #36]	; 0x24
    carrier_bleed_ = 0.0f;
    d5d2:	str	r3, [r0, #40]	; 0x28
 public:
  GrainletOscillator() { }
  ~GrainletOscillator() { }

  void Init() {
    carrier_phase_ = 0.0f;
    d5d4:	str	r3, [r0, #44]	; 0x2c
    formant_phase_ = 0.0f;
    d5d6:	str	r3, [r0, #48]	; 0x30
    next_sample_ = 0.0f;
    d5d8:	str	r3, [r0, #52]	; 0x34
  
    carrier_frequency_ = 0.0f;
    d5da:	str	r3, [r0, #56]	; 0x38
    formant_frequency_ = 0.0f;
    d5dc:	str	r3, [r0, #60]	; 0x3c
    carrier_shape_ = 0.0f;
    d5de:	str	r3, [r0, #64]	; 0x40
    carrier_bleed_ = 0.0f;
    d5e0:	str	r3, [r0, #68]	; 0x44
 public:
  ZOscillator() { }
  ~ZOscillator() { }

  void Init() {
    carrier_phase_ = 0.0f;
    d5e2:	str	r3, [r0, #72]	; 0x48
    discontinuity_phase_ = 0.0f;
    d5e4:	str	r3, [r0, #76]	; 0x4c
    formant_phase_ = 0.0f;
    d5e6:	str	r3, [r0, #80]	; 0x50
    next_sample_ = 0.0f;
    d5e8:	str	r3, [r0, #84]	; 0x54
  
    carrier_frequency_ = 0.0f;
    d5ea:	str	r3, [r0, #88]	; 0x58
    formant_frequency_ = 0.0f;
    d5ec:	str	r3, [r0, #92]	; 0x5c
    carrier_shape_ = 0.0f;
    d5ee:	str	r3, [r0, #96]	; 0x60
    mode_ = 0.0f;
    d5f0:	str	r3, [r0, #100]	; 0x64
    set_f<FREQUENCY_DIRTY>(0.01f);
    Reset();
  }
  
  void Reset() {
    state_ = 0.0f;
    d5f2:	str	r3, [r0, #112]	; 0x70
    d5f4:	str	r3, [r0, #124]	; 0x7c
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    d5f6:	str	r1, [r0, #104]	; 0x68
    d5f8:	str	r1, [r0, #116]	; 0x74
    gi_ = 1.0f / (1.0f + g_);
    d5fa:	str	r2, [r0, #108]	; 0x6c
    d5fc:	str	r2, [r0, #120]	; 0x78
    d5fe:	bx	lr
    d600:	.word	0x3d00ba22
    d604:	.word	0x3f783320

0000d608 <plaits::GrainEngine::Reset()>:
  z_oscillator_.Init();
  dc_blocker_[0].Init();
  dc_blocker_[1].Init();
}

void GrainEngine::Reset() {
    d608:	bx	lr
    d60a:	nop

0000d60c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    d60c:	vmov.f32	s15, #34	; 0x41100000  9.0
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float root = parameters.note;
    d610:	vldr	s13, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d614:	vldr	s14, [pc, #156]	; d6b4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa8>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    d618:	vsub.f32	s15, s13, s15
void GrainEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    d61c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d620:	vcmpe.f32	s15, s14
    d624:	vpush	{d8-d15}
    d628:	vmrs	APSR_nzcv, fpscr
    d62c:	sub	sp, #20
  const float root = parameters.note;
    d62e:	vstr	s13, [sp, #8]
void GrainEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    d632:	str	r2, [sp, #4]
    d634:	ldr.w	r9, [sp, #120]	; 0x78
    d638:	bmi.n	d650 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44>
    d63a:	vldr	s14, [pc, #124]	; d6b8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xac>
    d63e:	vcmpe.f32	s15, s14
    d642:	vmrs	APSR_nzcv, fpscr
    d646:	ble.w	ebf6 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x15ea>
    d64a:	movs	r2, #0
    d64c:	movs	r4, #255	; 0xff
    d64e:	b.n	d654 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48>
    d650:	movs	r2, #0
    d652:	mov	r4, r2
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    d654:	vmov.f32	s15, #56	; 0x41c00000  24.0
    d658:	vldr	s13, [r1, #8]
    d65c:	vldr	s14, [pc, #92]	; d6bc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb0>
    d660:	vmov.f32	s11, #34	; 0x41100000  9.0

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    d664:	ldr.w	fp, [pc, #88]	; d6c0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb4>
    d668:	vfma.f32	s15, s13, s14
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d66c:	ldr.w	sl, [pc, #84]	; d6c4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb8>
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d670:	vldr	s13, [pc, #64]	; d6b4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa8>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    d674:	add.w	r4, fp, r4, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d678:	add.w	r2, sl, r2, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    d67c:	vldr	s12, [pc, #80]	; d6d0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc4>
    d680:	vldr	s14, [r4]
    d684:	vldr	s23, [r2]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    d688:	vsub.f32	s15, s15, s11
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    d68c:	vmul.f32	s14, s14, s23

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d690:	vcmpe.f32	s15, s13
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    d694:	vmul.f32	s23, s14, s12

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    d698:	vmrs	APSR_nzcv, fpscr
    d69c:	bmi.n	d6dc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd0>
    d69e:	vldr	s14, [pc, #24]	; d6b8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xac>
    d6a2:	vcmpe.f32	s15, s14
    d6a6:	vmrs	APSR_nzcv, fpscr
    d6aa:	ble.w	ebce <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x15c2>
    d6ae:	movs	r2, #0
    d6b0:	movs	r4, #255	; 0xff
    d6b2:	b.n	d6e0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd4>
    d6b4:	.word	0xc3000000
    d6b8:	.word	0x42fe0000
    d6bc:	.word	0x42a80000
    d6c0:	.word	0x20000554
    d6c4:	.word	0x20000958
    d6c8:	.word	0x42400000
    d6cc:	.word	0x43000000
    d6d0:	.word	0x39962fc9
    d6d4:	.word	0x00000000
    d6d8:	.word	0x3ea8f5c3
    d6dc:	movs	r2, #0
    d6de:	mov	r4, r2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    d6e0:	vmov.f32	s15, #184	; 0xc1c00000 -24.0
  const float root = parameters.note;
  const float f0 = NoteToFrequency(root);
  
  const float f1 = NoteToFrequency(24.0f + 84.0f * parameters.timbre);
  const float ratio = SemitonesToRatio(-24.0f + 48.0f * parameters.harmonics);
    d6e4:	vldr	s13, [r1, #16]
    d6e8:	vldr	s14, [pc, #-36]	; d6c8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbc>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d6ec:	add.w	r2, sl, r2, lsl #2

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    d6f0:	add.w	r4, fp, r4, lsl #2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    d6f4:	vldr	s10, [pc, #-44]	; d6cc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc0>
    d6f8:	vfma.f32	s15, s13, s14
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    d6fc:	vldr	s28, [r2]
    d700:	vldr	s14, [r4]
  const float carrier_bleed = parameters.harmonics < 0.5f
      ? 1.0f - 2.0f * parameters.harmonics
      : 0.0f;
    d704:	vmov.f32	s12, #96	; 0x3f000000  0.5
    d708:	vldr	s11, [pc, #-60]	; d6d0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc4>
    d70c:	vmul.f32	s14, s14, s28
    d710:	vcmpe.f32	s13, s12
    d714:	vadd.f32	s15, s15, s10
    d718:	vmul.f32	s28, s14, s11
    d71c:	vmrs	APSR_nzcv, fpscr
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    d720:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d724:	vcvt.f32.s32	s11, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    d728:	vmov	r2, s14
    d72c:	add.w	r2, fp, r2, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    d730:	vsub.f32	s15, s15, s11
    d734:	vldr	s14, [r2]
    d738:	vcvt.s32.f32	s15, s15, #8
    d73c:	vmov	r2, s15
    d740:	add.w	r2, sl, r2, lsl #2
    d744:	vldr	s15, [r2]
    d748:	vmul.f32	s15, s15, s14
    d74c:	vstr	s15, [sp, #12]
    d750:	bpl.w	eb84 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1578>
    d754:	vmov.f32	s14, #0	; 0x40000000  2.0
    d758:	vmov.f32	s15, #112	; 0x3f800000  1.0
    d75c:	vfms.f32	s15, s13, s14
    d760:	vsub.f32	s14, s14, s15
    d764:	vmul.f32	s15, s14, s15
    d768:	vstr	s15, [sp]
  const float carrier_bleed_fixed = carrier_bleed * (2.0f - carrier_bleed);
  const float carrier_shape = 0.33f + (parameters.morph - 0.33f) * \
      max(1.0f - f0 * 24.0f, 0.0f);
    d76c:	vmov.f32	s6, #112	; 0x3f800000  1.0
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
	return __b;
      return __a;
    d770:	vldr	s18, [pc, #-160]	; d6d4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc8>
    d774:	vmov.f32	s14, #56	; 0x41c00000  24.0
  const float ratio = SemitonesToRatio(-24.0f + 48.0f * parameters.harmonics);
  const float carrier_bleed = parameters.harmonics < 0.5f
      ? 1.0f - 2.0f * parameters.harmonics
      : 0.0f;
  const float carrier_bleed_fixed = carrier_bleed * (2.0f - carrier_bleed);
  const float carrier_shape = 0.33f + (parameters.morph - 0.33f) * \
    d778:	vldr	s31, [pc, #-164]	; d6d8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcc>
      float formant_frequency,
      float carrier_shape,
      float carrier_bleed,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    d77c:	vmov.f32	s15, #64	; 0x3e000000  0.125
    d780:	vldr	s13, [r1, #12]
      max(1.0f - f0 * 24.0f, 0.0f);
    d784:	vmov.f32	s12, s6
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    d788:	vldr	s2, [r0, #28]
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
    d78c:	vmov.f32	s0, #80	; 0x3e800000  0.250
    d790:	vldr	s3, [r0, #36]	; 0x24
  const float ratio = SemitonesToRatio(-24.0f + 48.0f * parameters.harmonics);
  const float carrier_bleed = parameters.harmonics < 0.5f
      ? 1.0f - 2.0f * parameters.harmonics
      : 0.0f;
  const float carrier_bleed_fixed = carrier_bleed * (2.0f - carrier_bleed);
  const float carrier_shape = 0.33f + (parameters.morph - 0.33f) * \
    d794:	vsub.f32	s13, s13, s31
    d798:	vldr	s1, [r0, #32]
      max(1.0f - f0 * 24.0f, 0.0f);
    d79c:	vfms.f32	s12, s23, s14
    d7a0:	vldr	s9, [r0, #40]	; 0x28
    stmlib::ParameterInterpolator carrier_bleed_modulation(
        &carrier_bleed_,
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    d7a4:	vldr	s5, [r0, #24]
    
    while (size--) {
    d7a8:	add.w	r7, r9, #4294967295
    d7ac:	vmov.f32	s14, s12
    increment_ = (new_value - *state) / static_cast<float>(size);
    d7b0:	vmov	s12, r9
    d7b4:	vcvt.f32.u32	s24, s12
    d7b8:	vldr	s12, [sp]
    d7bc:	vcmpe.f32	s14, s18
    d7c0:	vsub.f32	s12, s12, s9
    d7c4:	vmrs	APSR_nzcv, fpscr
      float formant_frequency,
      float carrier_shape,
      float carrier_bleed,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    d7c8:	vcmpe.f32	s23, s15
    d7cc:	vdiv.f32	s21, s12, s24
    d7d0:	it	mi
    d7d2:	vmovmi.f32	s14, s18
    d7d6:	vmrs	APSR_nzcv, fpscr
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
    d7da:	vcmpe.f32	s28, s0
    d7de:	vfma.f32	s31, s13, s14
      float formant_frequency,
      float carrier_shape,
      float carrier_bleed,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    d7e2:	it	lt
    d7e4:	vmovlt.f32	s15, s23
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
    d7e8:	vmrs	APSR_nzcv, fpscr
    d7ec:	vsub.f32	s15, s15, s2
    d7f0:	ite	lt
    d7f2:	vmovlt.f32	s14, s28
    d7f6:	vmovge.f32	s14, s0
    d7fa:	vsub.f32	s13, s31, s3
    d7fe:	vdiv.f32	s25, s15, s24
    d802:	vsub.f32	s15, s14, s1
    d806:	vdiv.f32	s20, s13, s24
    d80a:	vdiv.f32	s26, s15, s24
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    d80e:	cmp.w	r9, #0
    d812:	beq.w	daa0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x494>
    d816:	ldr	r2, [pc, #972]	; (dbe4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5d8>)
    d818:	mov	lr, r7
    d81a:	ldr.w	r8, [sp, #4]
    d81e:	adds	r4, r2, #4
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    d820:	vldr	s17, [pc, #964]	; dbe8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5dc>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    d824:	vldr	s30, [pc, #964]	; dbec <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e0>
    d828:	vmov.f32	s22, #8	; 0x40400000  3.0
    d82c:	vldr	s29, [pc, #960]	; dbf0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e4>
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    d830:	vmov.f32	s19, #96	; 0x3f000000  0.5
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    d834:	vmov.f32	s27, #224	; 0xbf000000 -0.5
  }

  inline float Next() {
    value_ += increment_;
    d838:	vadd.f32	s2, s2, s25
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      carrier_phase_ += f0;
    d83c:	vldr	s13, [r0, #16]
    d840:	vadd.f32	s1, s1, s26
    d844:	vadd.f32	s13, s2, s13
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
    d848:	vcmpe.f32	s13, s6
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      carrier_phase_ += f0;
    d84c:	vstr	s13, [r0, #16]
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
    d850:	vmrs	APSR_nzcv, fpscr
    d854:	blt.w	e8b0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12a4>
        carrier_phase_ -= 1.0f;
    d858:	vsub.f32	s13, s13, s6
        reset_time = carrier_phase_ / f0;
        float before = Grainlet(
    d85c:	vldr	s14, [r0, #20]
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    d860:	vmov.f32	s11, s3
    return value_;
  }

  inline float subsample(float t) {
    return value_ + increment_ * t;
    d864:	vmov.f32	s10, s9
      carrier_phase_ += f0;
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
        carrier_phase_ -= 1.0f;
        reset_time = carrier_phase_ / f0;
    d868:	vdiv.f32	s15, s13, s2
    
      carrier_phase_ += f0;
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
        carrier_phase_ -= 1.0f;
    d86c:	vstr	s13, [r0, #16]
        reset_time = carrier_phase_ / f0;
        float before = Grainlet(
            1.0f,
            formant_phase_ + (1.0f - reset_time) * f1,
    d870:	vsub.f32	s8, s6, s15
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    d874:	vfma.f32	s11, s20, s8
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
        carrier_phase_ -= 1.0f;
        reset_time = carrier_phase_ / f0;
        float before = Grainlet(
    d878:	vfma.f32	s14, s1, s8
    d87c:	vfma.f32	s10, s21, s8
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    d880:	vmul.f32	s11, s11, s22
    MAKE_INTEGRAL_FRACTIONAL(shape);
    d884:	vcvt.s32.f32	s7, s11
    float t = 1.0f - shape_fractional;
    d888:	vcvt.f32.s32	s12, s7
    
    if (shape_integral == 0) {
    d88c:	vmov	r5, s7
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    d890:	vsub.f32	s12, s11, s12
    d894:	vsub.f32	s12, s6, s12
    
    if (shape_integral == 0) {
    d898:	cmp	r5, #0
    d89a:	bne.w	e4dc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xed0>
      phase = phase * (1.0f + t * t * t * 15.0f);
    d89e:	vmul.f32	s11, s12, s12
    d8a2:	vmov.f32	s7, #46	; 0x41700000  15.0
    d8a6:	vmul.f32	s12, s11, s12
    d8aa:	vmov.f32	s11, s6
    d8ae:	vfma.f32	s11, s12, s7
      if (phase >= 1.0f) {
    d8b2:	vcmpe.f32	s11, s6
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    
    if (shape_integral == 0) {
      phase = phase * (1.0f + t * t * t * 15.0f);
    d8b6:	vmov.f32	s12, s11
      if (phase >= 1.0f) {
    d8ba:	vmrs	APSR_nzcv, fpscr
    d8be:	blt.w	e75c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1150>
    d8c2:	movw	r6, #3076	; 0xc04
    d8c6:	vldr	s11, [pc, #812]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    d8ca:	mov.w	r5, #3072	; 0xc00
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    d8ce:	vcvt.s32.f32	s12, s14
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d8d2:	add	r5, r2
    d8d4:	vadd.f32	s7, s21, s9
  float b = table[index_integral + 1];
    d8d8:	add	r6, r2
    d8da:	vadd.f32	s3, s20, s3

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d8de:	vldr	s4, [r5]
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    d8e2:	vcvt.f32.s32	s9, s12
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d8e6:	vldr	s12, [r6]
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    d8ea:	vmul.f32	s16, s3, s22
    d8ee:	vsub.f32	s14, s14, s9
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d8f2:	vsub.f32	s12, s12, s4
  index *= size;
    d8f6:	vmul.f32	s14, s14, s17
    d8fa:	vfma.f32	s4, s12, s11
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    d8fe:	vcvt.s32.f32	s12, s16
  MAKE_INTEGRAL_FRACTIONAL(index)
    d902:	vcvt.s32.f32	s9, s14
    d906:	vmov	r5, s12
  float a = table[index_integral];
    d90a:	vmov	r6, s9
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d90e:	vcvt.f32.s32	s9, s9
    d912:	vadd.f32	s4, s4, s6
    d916:	lsls	r6, r6, #2
    d918:	vsub.f32	s9, s14, s9
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    d91c:	vmov	s14, r5
    d920:	add.w	ip, r2, r6
  float b = table[index_integral + 1];
    d924:	add	r6, r4
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d926:	vmul.f32	s4, s4, s0

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d92a:	vldr	s12, [ip]
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    d92e:	vcvt.f32.s32	s14, s14
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d932:	vldr	s11, [r6]
    d936:	vsub.f32	s11, s11, s12
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    d93a:	vsub.f32	s14, s16, s14
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d93e:	vfma.f32	s12, s9, s11
    d942:	vadd.f32	s9, s10, s6
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    d946:	vsub.f32	s14, s6, s14
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d94a:	vadd.f32	s12, s12, s10
    d94e:	vmul.f32	s12, s12, s4
    d952:	vdiv.f32	s16, s12, s9
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    
    if (shape_integral == 0) {
    d956:	cmp	r5, #0
    d958:	bne.w	e65e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1052>
      phase = phase * (1.0f + t * t * t * 15.0f);
    d95c:	vmul.f32	s12, s14, s14
    d960:	vmov.f32	s11, #46	; 0x41700000  15.0
    d964:	vmov.f32	s10, s6
    d968:	vmul.f32	s12, s12, s14
    d96c:	vfma.f32	s10, s12, s11
    d970:	vmul.f32	s12, s10, s18
      if (phase >= 1.0f) {
    d974:	vcmpe.f32	s12, s6
    d978:	vmrs	APSR_nzcv, fpscr
    d97c:	blt.w	e7b0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11a4>
    d980:	movw	ip, #3076	; 0xc04
    d984:	vldr	s11, [pc, #620]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    d988:	mov.w	r6, #3072	; 0xc00
    d98c:	add	r6, r2
  float b = table[index_integral + 1];
    d98e:	add	ip, r2

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    d990:	vldr	s10, [r2]
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    d994:	vadd.f32	s4, s7, s6
    d998:	vldr	s12, [r6]
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d99c:	vldr	s9, [ip]
    d9a0:	vsub.f32	s9, s9, s12
    d9a4:	vfma.f32	s12, s9, s11
    d9a8:	vldr	s11, [r2, #4]
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    d9ac:	vmov.f32	s9, s7
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d9b0:	vsub.f32	s11, s11, s10
    d9b4:	vfma.f32	s10, s11, s18
    d9b8:	vadd.f32	s12, s12, s6
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    d9bc:	vmul.f32	s11, s15, s19
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d9c0:	vmul.f32	s12, s12, s0
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    d9c4:	vmul.f32	s11, s11, s15
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d9c8:	vadd.f32	s10, s10, s7
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    d9cc:	vmul.f32	s15, s1, s15
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d9d0:	vmul.f32	s10, s12, s10
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    d9d4:	vmul.f32	s12, s8, s27
        formant_phase_ = reset_time * f1;
    d9d8:	vstr	s15, [r0, #20]
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d9dc:	vdiv.f32	s7, s10, s4
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    d9e0:	vmul.f32	s8, s12, s8
    d9e4:	vmov.f32	s12, s18
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    d9e8:	vsub.f32	s16, s7, s16
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    d9ec:	vfma.f32	s5, s16, s11
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    d9f0:	vfma.f32	s12, s16, s8
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    
    if (shape_integral == 0) {
    d9f4:	cmp	r5, #0
    d9f6:	bne.w	e428 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe1c>
      phase = phase * (1.0f + t * t * t * 15.0f);
    d9fa:	vmul.f32	s11, s14, s14
    d9fe:	vmov.f32	s10, #46	; 0x41700000  15.0
    da02:	vmul.f32	s14, s11, s14
    da06:	vmov.f32	s11, s6
    da0a:	vfma.f32	s11, s14, s10
    da0e:	vmul.f32	s13, s11, s13
      if (phase >= 1.0f) {
    da12:	vcmpe.f32	s13, s6
    da16:	vmrs	APSR_nzcv, fpscr
    da1a:	blt.w	ea06 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x13fa>
    da1e:	movw	r6, #3076	; 0xc04
    da22:	vldr	s13, [pc, #464]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    da26:	mov.w	r5, #3072	; 0xc00
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    da2a:	vcvt.s32.f32	s10, s15
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    da2e:	add	r5, r2
  float b = table[index_integral + 1];
    da30:	add	r6, r2
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    da32:	add.w	lr, lr, #4294967295

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    da36:	vldr	s14, [r5]
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    da3a:	vcvt.f32.s32	s10, s10
      
      next_sample += Grainlet(
          carrier_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
    da3e:	vldr	s11, [r6]
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    da42:	cmp.w	lr, #4294967295
      
      next_sample += Grainlet(
          carrier_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
    da46:	vsub.f32	s11, s11, s14
    da4a:	vsub.f32	s15, s15, s10
    da4e:	vfma.f32	s14, s11, s13
  index *= size;
    da52:	vmul.f32	s15, s15, s17
  MAKE_INTEGRAL_FRACTIONAL(index)
    da56:	vcvt.s32.f32	s11, s15
    da5a:	vadd.f32	s13, s14, s6
  float a = table[index_integral];
    da5e:	vmov	r5, s11
    da62:	vcvt.f32.s32	s11, s11
    da66:	mov.w	r5, r5, lsl #2
    da6a:	vmul.f32	s13, s13, s0
    da6e:	vsub.f32	s15, s15, s11
    da72:	add.w	r6, r2, r5
  float b = table[index_integral + 1];
    da76:	add	r5, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    da78:	vldr	s14, [r6]
    da7c:	vldr	s11, [r5]
      *out++ = this_sample;
    da80:	vstmia	r8!, {s5}
      
      next_sample += Grainlet(
          carrier_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
    da84:	vsub.f32	s11, s11, s14
    da88:	vfma.f32	s14, s15, s11
    da8c:	vadd.f32	s14, s14, s9
    da90:	vmul.f32	s14, s14, s13
    da94:	vdiv.f32	s5, s14, s4
    da98:	vadd.f32	s5, s5, s12
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    da9c:	bne.w	d838 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22c>
      float formant_frequency,
      float carrier_shape,
      float carrier_bleed,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    daa0:	vmov.f32	s15, #64	; 0x3e000000  0.125
  
  grainlet_[0].Render(f0, f1, carrier_shape, carrier_bleed_fixed, out, size);
  grainlet_[1].Render(f0, f1 * ratio, carrier_shape, carrier_bleed_fixed, aux, size);
    daa4:	vldr	s14, [sp, #12]
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
    daa8:	vmov.f32	s13, #80	; 0x3e800000  0.250
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    daac:	vldr	s16, [r0, #56]	; 0x38
    dab0:	vmul.f32	s28, s14, s28
    dab4:	vldr	s17, [r0, #60]	; 0x3c
      float formant_frequency,
      float carrier_shape,
      float carrier_bleed,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    dab8:	vcmpe.f32	s23, s15
    dabc:	vldr	s8, [r0, #64]	; 0x40
    dac0:	vldr	s0, [r0, #68]	; 0x44
    increment_ = (new_value - *state) / static_cast<float>(size);
    dac4:	vldr	s14, [sp]
    dac8:	vsub.f32	s31, s31, s8
    dacc:	vmrs	APSR_nzcv, fpscr
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
      *out++ = this_sample;
    }
    
    next_sample_ = next_sample;
    dad0:	vstr	s5, [r0, #24]
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
      formant_frequency = kMaxFrequency;
    dad4:	vcmp.f32	s28, s13
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    dad8:	vstr	s9, [r0, #40]	; 0x28
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    dadc:	vsub.f32	s14, s14, s0
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    dae0:	vstr	s3, [r0, #36]	; 0x24
      float formant_frequency,
      float carrier_shape,
      float carrier_bleed,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    dae4:	it	lt
    dae6:	vmovlt.f32	s15, s23
    daea:	vstr	s1, [r0, #32]
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
      formant_frequency = kMaxFrequency;
    daee:	vmrs	APSR_nzcv, fpscr
    daf2:	vstr	s2, [r0, #28]
    stmlib::ParameterInterpolator carrier_bleed_modulation(
        &carrier_bleed_,
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    daf6:	vldr	s5, [r0, #52]	; 0x34
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    dafa:	vdiv.f32	s20, s31, s24
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
      formant_frequency = kMaxFrequency;
    dafe:	it	ge
    db00:	vmovge.f32	s28, s13
    db04:	vsub.f32	s15, s15, s16
    db08:	vdiv.f32	s21, s14, s24
    db0c:	vsub.f32	s28, s28, s17
    db10:	vdiv.f32	s25, s15, s24
    db14:	vdiv.f32	s26, s28, s24
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    db18:	cmp.w	r9, #0
    db1c:	beq.w	ddee <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e2>
    db20:	ldr	r2, [pc, #192]	; (dbe4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5d8>)
    db22:	mov	lr, r3
    db24:	mov	r6, r7
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    db26:	vldr	s18, [pc, #204]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    db2a:	adds	r4, r2, #4
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    db2c:	vldr	s1, [pc, #184]	; dbe8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5dc>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    db30:	vldr	s29, [pc, #184]	; dbec <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e0>
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    db34:	vmov.f32	s2, s13
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    db38:	vldr	s28, [pc, #180]	; dbf0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e4>
      const float f1 = formant_frequency_modulation.Next();
    
      carrier_phase_ += f0;
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
    db3c:	vmov.f32	s6, #112	; 0x3f800000  1.0
    db40:	vmov.f32	s22, #8	; 0x40400000  3.0
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    db44:	vmov.f32	s19, #96	; 0x3f000000  0.5
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    db48:	vmov.f32	s27, #224	; 0xbf000000 -0.5
  }

  inline float Next() {
    value_ += increment_;
    db4c:	vadd.f32	s16, s16, s25
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      carrier_phase_ += f0;
    db50:	vldr	s14, [r0, #44]	; 0x2c
    db54:	vadd.f32	s17, s17, s26
    db58:	vadd.f32	s14, s16, s14
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
    db5c:	vcmpe.f32	s14, s6
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      carrier_phase_ += f0;
    db60:	vstr	s14, [r0, #44]	; 0x2c
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
    db64:	vmrs	APSR_nzcv, fpscr
    db68:	blt.w	e868 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x125c>
        carrier_phase_ -= 1.0f;
    db6c:	vsub.f32	s14, s14, s6
        reset_time = carrier_phase_ / f0;
        float before = Grainlet(
    db70:	vldr	s12, [r0, #48]	; 0x30
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    db74:	vmov.f32	s13, s8
    return value_;
  }

  inline float subsample(float t) {
    return value_ + increment_ * t;
    db78:	vmov.f32	s11, s0
      carrier_phase_ += f0;
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
        carrier_phase_ -= 1.0f;
        reset_time = carrier_phase_ / f0;
    db7c:	vdiv.f32	s15, s14, s16
    
      carrier_phase_ += f0;
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
        carrier_phase_ -= 1.0f;
    db80:	vstr	s14, [r0, #44]	; 0x2c
        reset_time = carrier_phase_ / f0;
        float before = Grainlet(
            1.0f,
            formant_phase_ + (1.0f - reset_time) * f1,
    db84:	vsub.f32	s10, s6, s15
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    db88:	vfma.f32	s13, s20, s10
      reset = carrier_phase_ >= 1.0f;
      
      if (reset) {
        carrier_phase_ -= 1.0f;
        reset_time = carrier_phase_ / f0;
        float before = Grainlet(
    db8c:	vfma.f32	s12, s17, s10
    db90:	vfma.f32	s11, s21, s10
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    db94:	vmul.f32	s13, s13, s22
    MAKE_INTEGRAL_FRACTIONAL(shape);
    db98:	vcvt.s32.f32	s9, s13
    float t = 1.0f - shape_fractional;
    db9c:	vcvt.f32.s32	s7, s9
    
    if (shape_integral == 0) {
    dba0:	vmov	r5, s9
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    dba4:	vsub.f32	s13, s13, s7
    dba8:	vsub.f32	s13, s6, s13
    
    if (shape_integral == 0) {
    dbac:	cmp	r5, #0
    dbae:	bne.w	e6f6 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x10ea>
      phase = phase * (1.0f + t * t * t * 15.0f);
    dbb2:	vmul.f32	s9, s13, s13
    dbb6:	vmov.f32	s7, #46	; 0x41700000  15.0
    dbba:	vmul.f32	s13, s9, s13
    dbbe:	vmov.f32	s9, s6
    dbc2:	vfma.f32	s9, s13, s7
      if (phase >= 1.0f) {
    dbc6:	vcmpe.f32	s9, s6
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    
    if (shape_integral == 0) {
      phase = phase * (1.0f + t * t * t * 15.0f);
    dbca:	vmov.f32	s13, s9
      if (phase >= 1.0f) {
    dbce:	vmrs	APSR_nzcv, fpscr
    dbd2:	blt.w	eb02 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x14f6>
    dbd6:	movw	ip, #3076	; 0xc04
    dbda:	vldr	s4, [pc, #24]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    dbde:	mov.w	r5, #3072	; 0xc00
    dbe2:	b.n	dc10 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x604>
    dbe4:	.word	0x20002b10
    dbe8:	.word	0x44800000
    dbec:	.word	0x3eff7cee
    dbf0:	.word	0x3a83126f
    dbf4:	.word	0x00000000
    dbf8:	.word	0x3e99999a
    dbfc:	.word	0x413957d7
    dc00:	.word	0x40490fdb
    dc04:	.word	0x42c00000
    dc08:	.word	0xc3000000
    dc0c:	.word	0x39962fc9
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    dc10:	vcvt.s32.f32	s3, s12
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dc14:	add	r5, r2
  float b = table[index_integral + 1];
    dc16:	add	ip, r2
    dc18:	vadd.f32	s8, s20, s8
    dc1c:	vadd.f32	s9, s21, s0

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dc20:	vldr	s7, [r5]
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    dc24:	vcvt.f32.s32	s3, s3
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc28:	vldr	s13, [ip]
    dc2c:	vsub.f32	s13, s13, s7
    dc30:	vsub.f32	s12, s12, s3
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    dc34:	vmul.f32	s3, s8, s22
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc38:	vfma.f32	s7, s13, s4
  index *= size;
    dc3c:	vmul.f32	s12, s12, s1
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    dc40:	vcvt.s32.f32	s13, s3
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc44:	vadd.f32	s4, s11, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    dc48:	vcvt.s32.f32	s0, s12
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    dc4c:	vmov	r5, s13
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc50:	vadd.f32	s7, s7, s6
  float a = table[index_integral];
    dc54:	vmov	ip, s0
    dc58:	vcvt.f32.s32	s0, s0
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    dc5c:	vmov	s30, r5
    dc60:	mov.w	ip, ip, lsl #2
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc64:	vmul.f32	s7, s7, s2
    dc68:	vsub.f32	s12, s12, s0
    dc6c:	add.w	r8, r2, ip
  float b = table[index_integral + 1];
    dc70:	add	ip, r4
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    dc72:	vcvt.f32.s32	s30, s30

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dc76:	vldr	s13, [r8]
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc7a:	vldr	s0, [ip]
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    dc7e:	vsub.f32	s3, s3, s30
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc82:	vsub.f32	s0, s0, s13
    dc86:	vfma.f32	s13, s12, s0
  }
  
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    dc8a:	vsub.f32	s12, s6, s3
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dc8e:	vadd.f32	s13, s13, s11
    dc92:	vmul.f32	s13, s13, s7
    dc96:	vdiv.f32	s11, s13, s4
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    
    if (shape_integral == 0) {
    dc9a:	cmp	r5, #0
    dc9c:	bne.w	e6a8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x109c>
      phase = phase * (1.0f + t * t * t * 15.0f);
    dca0:	vmul.f32	s13, s12, s12
    dca4:	vmov.f32	s7, #46	; 0x41700000  15.0
    dca8:	vmov.f32	s4, s6
    dcac:	vmul.f32	s13, s13, s12
    dcb0:	vfma.f32	s4, s13, s7
    dcb4:	vmul.f32	s13, s4, s18
      if (phase >= 1.0f) {
    dcb8:	vcmpe.f32	s13, s6
    dcbc:	vmrs	APSR_nzcv, fpscr
    dcc0:	blt.w	e806 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11fa>
    dcc4:	movw	ip, #3076	; 0xc04
    dcc8:	vldr	s7, [pc, #-216]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    dccc:	mov.w	r8, #3072	; 0xc00
    dcd0:	add	r8, r2
  float b = table[index_integral + 1];
    dcd2:	add	ip, r2

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dcd4:	vldr	s4, [r2]
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    dcd8:	vmov.f32	s13, s12
    dcdc:	vldr	s3, [r8]
    dce0:	vmov.f32	s0, s9
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dce4:	vldr	s30, [ip]
    dce8:	vldr	s12, [r2, #4]
    dcec:	vsub.f32	s30, s30, s3
    dcf0:	vsub.f32	s12, s12, s4
    dcf4:	vfma.f32	s3, s30, s7
    dcf8:	vfma.f32	s4, s12, s18
      float formant_phase,
      float shape,
      float bleed) {
    float carrier = Carrier(carrier_phase, shape);
    float formant = Sine(formant_phase);
    return carrier * (formant + bleed) / (1.0f + bleed);
    dcfc:	vadd.f32	s12, s9, s6
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dd00:	vmov.f32	s7, s3
    dd04:	vmov.f32	s30, s4
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    dd08:	vmul.f32	s4, s10, s27
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dd0c:	vadd.f32	s7, s7, s6
    dd10:	vadd.f32	s9, s30, s9
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    dd14:	vmul.f32	s10, s4, s10
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dd18:	vmul.f32	s7, s7, s2
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    dd1c:	vmul.f32	s3, s15, s19
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dd20:	vmul.f32	s9, s7, s9
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    dd24:	vmul.f32	s3, s3, s15
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    dd28:	vmul.f32	s15, s17, s15
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dd2c:	vdiv.f32	s7, s9, s12
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    dd30:	vstr	s15, [r0, #48]	; 0x30
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    dd34:	vmov.f32	s9, s18
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
    dd38:	vsub.f32	s11, s7, s11
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    dd3c:	vfma.f32	s9, s11, s10
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            carrier_bleed_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    dd40:	vfma.f32	s5, s11, s3
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    dd44:	vmov.f32	s11, s9
  inline float Carrier(float phase, float shape) {
    shape *= 3.0f;
    MAKE_INTEGRAL_FRACTIONAL(shape);
    float t = 1.0f - shape_fractional;
    
    if (shape_integral == 0) {
    dd48:	cmp	r5, #0
    dd4a:	bne.w	e3e0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xdd4>
      phase = phase * (1.0f + t * t * t * 15.0f);
    dd4e:	vmul.f32	s10, s13, s13
    dd52:	vmov.f32	s9, #46	; 0x41700000  15.0
    dd56:	vmul.f32	s13, s10, s13
    dd5a:	vmov.f32	s10, s6
    dd5e:	vfma.f32	s10, s13, s9
    dd62:	vmul.f32	s14, s10, s14
      if (phase >= 1.0f) {
    dd66:	vcmpe.f32	s14, s6
    dd6a:	vmrs	APSR_nzcv, fpscr
    dd6e:	blt.w	e4ac <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xea0>
    dd72:	movw	ip, #3076	; 0xc04
    dd76:	vldr	s13, [pc, #-388]	; dbf4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e8>
    dd7a:	mov.w	r5, #3072	; 0xc00
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    dd7e:	vcvt.s32.f32	s9, s15
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dd82:	add	r5, r2
  float b = table[index_integral + 1];
    dd84:	add	ip, r2
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    dd86:	subs	r6, #1

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dd88:	vldr	s14, [r5]
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    dd8c:	vcvt.f32.s32	s9, s9
      
      next_sample += Grainlet(
          carrier_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
    dd90:	vldr	s10, [ip]
    dd94:	vsub.f32	s10, s10, s14
    dd98:	vsub.f32	s15, s15, s9
    dd9c:	vfma.f32	s14, s10, s13
  index *= size;
    dda0:	vmul.f32	s15, s15, s1
  MAKE_INTEGRAL_FRACTIONAL(index)
    dda4:	vcvt.s32.f32	s10, s15
    dda8:	vadd.f32	s13, s14, s6
  float a = table[index_integral];
    ddac:	vmov	r5, s10
    ddb0:	vcvt.f32.s32	s10, s10
    ddb4:	lsls	r5, r5, #2
    ddb6:	vmul.f32	s13, s13, s2
    ddba:	vsub.f32	s15, s15, s10
    ddbe:	add.w	ip, r2, r5
  float b = table[index_integral + 1];
    ddc2:	add	r5, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    ddc4:	vldr	s14, [ip]
    ddc8:	vldr	s10, [r5]
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    ddcc:	adds	r5, r6, #1
      next_sample += Grainlet(
          carrier_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
      *out++ = this_sample;
    ddce:	vstmia	lr!, {s5}
      
      next_sample += Grainlet(
          carrier_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
    ddd2:	vsub.f32	s10, s10, s14
    ddd6:	vfma.f32	s14, s15, s10
    ddda:	vadd.f32	s14, s14, s0
    ddde:	vmul.f32	s14, s14, s13
    dde2:	vdiv.f32	s5, s14, s12
    dde6:	vadd.f32	s5, s5, s11
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    ddea:	bne.w	db4c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x540>
  dc_blocker_[0].set_f<FREQUENCY_DIRTY>(0.3f * f0);
    ddee:	vldr	s7, [pc, #-504]	; dbf8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5ec>
    ddf2:	vmov.f32	s13, #112	; 0x3f800000  1.0
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
    ddf6:	vldr	s14, [pc, #-508]	; dbfc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5f0>
    ddfa:	vmul.f32	s15, s23, s7
    ddfe:	vldr	s7, [pc, #-512]	; dc00 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5f4>
          carrier_shape_modulation.Next(),
          carrier_bleed_modulation.Next());
      *out++ = this_sample;
    }
    
    next_sample_ = next_sample;
    de02:	vstr	s5, [r0, #52]	; 0x34
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    de06:	vstr	s0, [r0, #68]	; 0x44
    de0a:	vmul.f32	s14, s15, s14
    de0e:	vstr	s8, [r0, #64]	; 0x40
    de12:	vstr	s17, [r0, #60]	; 0x3c
    de16:	vstr	s16, [r0, #56]	; 0x38
    de1a:	vfma.f32	s7, s15, s14
    de1e:	vmul.f32	s7, s7, s15
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    gi_ = 1.0f / (1.0f + g_);
    de22:	vadd.f32	s15, s7, s13
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    de26:	vstr	s7, [r0, #104]	; 0x68
    gi_ = 1.0f / (1.0f + g_);
    de2a:	vdiv.f32	s3, s13, s15
    de2e:	vstr	s3, [r0, #108]	; 0x6c
  for (size_t i = 0; i < size; ++i) {
    de32:	cmp.w	r9, #0
    de36:	beq.n	de7e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x872>
    de38:	ldr	r2, [sp, #4]
    de3a:	mov	r4, r3
    de3c:	vmov.f32	s11, s3
    de40:	vmov.f32	s13, s7
    de44:	add.w	r5, r2, r9, lsl #2
    de48:	b.n	de52 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x846>
    de4a:	vldr	s13, [r0, #104]	; 0x68
    de4e:	vldr	s11, [r0, #108]	; 0x6c
    out[i] = dc_blocker_[0].Process<FILTER_MODE_HIGH_PASS>(out[i] + aux[i]);
    de52:	vldmia	r4!, {s15}
    de56:	vldr	s12, [r2]
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    de5a:	vldr	s14, [r0, #112]	; 0x70
    de5e:	vadd.f32	s15, s15, s12
    de62:	vfma.f32	s14, s15, s13
    state_ = g_ * (in - lp) + lp;
    de66:	vfms.f32	s15, s14, s11
    de6a:	vmul.f32	s13, s15, s13
    de6e:	vfma.f32	s13, s14, s11
    de72:	vstr	s13, [r0, #112]	; 0x70
    de76:	vstmia	r2!, {s15}
      max(1.0f - f0 * 24.0f, 0.0f);
  
  grainlet_[0].Render(f0, f1, carrier_shape, carrier_bleed_fixed, out, size);
  grainlet_[1].Render(f0, f1 * ratio, carrier_shape, carrier_bleed_fixed, aux, size);
  dc_blocker_[0].set_f<FREQUENCY_DIRTY>(0.3f * f0);
  for (size_t i = 0; i < size; ++i) {
    de7a:	cmp	r5, r2
    de7c:	bne.n	de4a <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x83e>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    de7e:	vldr	s15, [pc, #-636]	; dc04 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5f8>
    de82:	vmov.f32	s13, #34	; 0x41100000  9.0
    de86:	vldr	s12, [r1, #8]
    de8a:	vldr	s11, [sp, #8]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    de8e:	vldr	s14, [pc, #-648]	; dc08 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5fc>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    de92:	vfma.f32	s11, s12, s15
    de96:	vsub.f32	s15, s11, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    de9a:	vcmpe.f32	s15, s14
    de9e:	vmrs	APSR_nzcv, fpscr
    dea2:	bpl.w	eb90 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1584>
    dea6:	movs	r2, #0
    dea8:	mov	r4, r2

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    deaa:	add.w	fp, fp, r4, lsl #2
      float formant_frequency,
      float carrier_shape,
      float mode,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
    deae:	vmov.f32	s11, #64	; 0x3e000000  0.125
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    deb2:	add.w	sl, sl, r2, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    deb6:	vldr	s10, [pc, #-684]	; dc0c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x600>
    deba:	vldr	s14, [fp]
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
    debe:	vmov.f32	s12, #80	; 0x3e800000  0.250
    dec2:	vldr	s15, [sl]
      float carrier_shape,
      float mode,
      float* out,
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
      carrier_frequency = kMaxFrequency * 0.5f;
    dec6:	vcmp.f32	s23, s11
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    deca:	vldr	s4, [r0, #92]	; 0x5c
    dece:	vmul.f32	s15, s14, s15
    ded2:	vldr	s5, [r0, #88]	; 0x58
    ded6:	vmrs	APSR_nzcv, fpscr

  const float cutoff = NoteToFrequency(root + 96.0f * parameters.timbre);
  z_oscillator_.Render(
      f0,
      cutoff,
      parameters.morph,
    deda:	vldr	s13, [r1, #12]
    dede:	vldr	s9, [r0, #96]	; 0x60
    dee2:	vmul.f32	s15, s15, s10
      parameters.harmonics,
    dee6:	vldr	s14, [r1, #16]
    deea:	it	ge
    deec:	vmovge.f32	s23, s11
    def0:	vldr	s8, [r0, #100]	; 0x64
    increment_ = (new_value - *state) / static_cast<float>(size);
    def4:	vsub.f32	s13, s13, s9
    stmlib::ParameterInterpolator mode_modulation(
        &mode_,
        mode,
        size);

    float next_sample = next_sample_;
    def8:	vldr	s20, [r0, #84]	; 0x54
      size_t size) {
    if (carrier_frequency >= kMaxFrequency * 0.5f) {
      carrier_frequency = kMaxFrequency * 0.5f;
    }
    if (formant_frequency >= kMaxFrequency) {
      formant_frequency = kMaxFrequency;
    defc:	vcmp.f32	s15, s12
    df00:	vsub.f32	s23, s23, s5
    df04:	vsub.f32	s14, s14, s8
    df08:	vmrs	APSR_nzcv, fpscr
    df0c:	vdiv.f32	s17, s23, s24
    df10:	it	ge
    df12:	vmovge.f32	s15, s12
    df16:	vdiv.f32	s0, s13, s24
    df1a:	vsub.f32	s15, s15, s4
    df1e:	vdiv.f32	s16, s14, s24
    df22:	vdiv.f32	s18, s15, s24
        mode,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    df26:	cmp.w	r9, #0
    df2a:	beq.w	ec1e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1612>
    df2e:	ldr	r2, [pc, #40]	; (df58 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x94c>)
    df30:	mov	r6, r3
        carrier_bleed,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    df32:	mov	r5, r7
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    df34:	vldr	s2, [pc, #48]	; df68 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x95c>
    df38:	adds	r4, r2, #4
    df3a:	mov	lr, r2
  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    df3c:	vldr	s1, [pc, #28]	; df5c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x950>
    
      discontinuity_phase_ += 2.0f * f0;
      carrier_phase_ += f0;
      reset = discontinuity_phase_ >= 1.0f;
      
      if (reset) {
    df40:	vmov.f32	s11, #112	; 0x3f800000  1.0
  float b = table[index_integral + 1];
    df44:	mov	ip, r4
    df46:	vmov.f32	s10, #96	; 0x3f000000  0.5
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
    df4a:	vldr	s6, [pc, #20]	; df60 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x954>
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
    df4e:	vldr	s19, [pc, #20]	; df64 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x958>
    df52:	vmov.f32	s12, s20
    df56:	b.n	e03c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa30>
    df58:	.word	0x20002b10
    df5c:	.word	0x3eaa7efa
    df60:	.word	0x44800000
    df64:	.word	0x3f2a7efa
    df68:	.word	0x00000000
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    df6c:	vmov.f32	s15, #120	; 0x3fc00000  1.5
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
    df70:	vmov.f32	s23, #112	; 0x3f800000  1.0
      phase_shift = 0.25f + mode * 1.50f;
    df74:	vfma.f32	s13, s8, s15
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = 0.001f;
    }
    
    float discontinuity = Sine(f + phase_shift);
    df78:	vadd.f32	s13, s13, s21
    float contour;
    if (shape < 0.5f) {
    df7c:	vcmpe.f32	s9, s10
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    df80:	vcvt.s32.f32	s15, s13
    df84:	vmrs	APSR_nzcv, fpscr
    df88:	vcvt.f32.s32	s15, s15
    df8c:	vsub.f32	s15, s13, s15
  index *= size;
    df90:	vmul.f32	s15, s15, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    df94:	vcvt.s32.f32	s13, s15
  float a = table[index_integral];
    df98:	vmov	r1, s13
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    df9c:	vcvt.f32.s32	s13, s13

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dfa0:	mov.w	r1, r1, lsl #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    dfa4:	vsub.f32	s15, s15, s13

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dfa8:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    dfac:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    dfae:	vldr	s13, [r8]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    dfb2:	vldr	s21, [r1]
    dfb6:	vsub.f32	s21, s21, s13
    dfba:	vfma.f32	s13, s15, s21
    dfbe:	bpl.w	e39e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd92>
      shape *= 2.0f;
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    dfc2:	vmov.f32	s15, #80	; 0x3e800000  0.250
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
      if (c >= 0.5f) {
    dfc6:	vcmpe.f32	s14, s10
    }
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
    dfca:	vadd.f32	s21, s9, s9
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    dfce:	vadd.f32	s14, s14, s15
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
      if (c >= 0.5f) {
    dfd2:	vmrs	APSR_nzcv, fpscr
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    dfd6:	vcvt.s32.f32	s15, s14
        ramp_down *= shape;
    dfda:	it	ge
    dfdc:	vmulge.f32	s22, s22, s21
    dfe0:	vcvt.f32.s32	s15, s15
    dfe4:	vsub.f32	s14, s14, s15
  index *= size;
    dfe8:	vmul.f32	s14, s14, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    dfec:	vcvt.s32.f32	s15, s14
  float a = table[index_integral];
    dff0:	vmov	r1, s15
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    dff4:	vcvt.f32.s32	s15, s15
    dff8:	lsls	r1, r1, #2
    dffa:	vsub.f32	s14, s14, s15
    dffe:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    e002:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e004:	vldr	s15, [r8]
    e008:	vldr	s24, [r1]
    e00c:	vsub.f32	s24, s24, s15
    e010:	vfma.f32	s15, s14, s24
    e014:	vmov.f32	s14, s11
    e018:	vsub.f32	s15, s15, s11
    e01c:	vfma.f32	s14, s21, s15
      next_sample += Z(
          carrier_phase_,
          discontinuity_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          mode_modulation.Next());
    e020:	vadd.f32	s15, s13, s23
        mode,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    e024:	subs	r5, #1
          carrier_phase_,
          discontinuity_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          mode_modulation.Next());
      *out++ = this_sample;
    e026:	vstmia	r6!, {s12}
      next_sample += Z(
          carrier_phase_,
          discontinuity_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          mode_modulation.Next());
    e02a:	vmov.f32	s12, s20
        mode,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    e02e:	adds	r1, r5, #1
      next_sample += Z(
          carrier_phase_,
          discontinuity_phase_,
          formant_phase_,
          carrier_shape_modulation.Next(),
          mode_modulation.Next());
    e030:	vfnms.f32	s23, s15, s22
    e034:	vfma.f32	s12, s23, s14
        mode,
        size);

    float next_sample = next_sample_;
    
    while (size--) {
    e038:	beq.w	ea36 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x142a>
  }

  inline float Next() {
    value_ += increment_;
    e03c:	vadd.f32	s5, s5, s17
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      discontinuity_phase_ += 2.0f * f0;
    e040:	vldr	s15, [r0, #76]	; 0x4c
      carrier_phase_ += f0;
    e044:	vldr	s14, [r0, #72]	; 0x48
    e048:	vadd.f32	s4, s4, s18
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      discontinuity_phase_ += 2.0f * f0;
    e04c:	vadd.f32	s20, s5, s5
      carrier_phase_ += f0;
    e050:	vadd.f32	s14, s5, s14
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      discontinuity_phase_ += 2.0f * f0;
    e054:	vadd.f32	s15, s20, s15
      carrier_phase_ += f0;
    e058:	vstr	s14, [r0, #72]	; 0x48
      reset = discontinuity_phase_ >= 1.0f;
      
      if (reset) {
    e05c:	vcmpe.f32	s15, s11
      next_sample = 0.0f;
    
      const float f0 = carrier_frequency_modulation.Next();
      const float f1 = formant_frequency_modulation.Next();
    
      discontinuity_phase_ += 2.0f * f0;
    e060:	vstr	s15, [r0, #76]	; 0x4c
      carrier_phase_ += f0;
      reset = discontinuity_phase_ >= 1.0f;
      
      if (reset) {
    e064:	vmrs	APSR_nzcv, fpscr
    e068:	blt.w	e83a <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x122e>
        discontinuity_phase_ -= 1.0f;
        reset_time = discontinuity_phase_ / (2.0f * f0);
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
    e06c:	vcmpe.f32	s14, s11
      discontinuity_phase_ += 2.0f * f0;
      carrier_phase_ += f0;
      reset = discontinuity_phase_ >= 1.0f;
      
      if (reset) {
        discontinuity_phase_ -= 1.0f;
    e070:	vsub.f32	s15, s15, s11
        reset_time = discontinuity_phase_ / (2.0f * f0);
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
    e074:	vmrs	APSR_nzcv, fpscr
      discontinuity_phase_ += 2.0f * f0;
      carrier_phase_ += f0;
      reset = discontinuity_phase_ >= 1.0f;
      
      if (reset) {
        discontinuity_phase_ -= 1.0f;
    e078:	vstr	s15, [r0, #76]	; 0x4c
        reset_time = discontinuity_phase_ / (2.0f * f0);
    e07c:	vdiv.f32	s13, s15, s20
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
    e080:	blt.w	e96c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1360>
    e084:	vmov.f32	s27, #112	; 0x3f800000  1.0
        float carrier_phase_after = carrier_phase_ >= 1.0f ? 0.0f : 0.5f;
    e088:	vldr	s24, [pc, #-292]	; df68 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x95c>
    e08c:	ldr	r1, [pc, #996]	; (e474 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe68>)
        float before = Z(
            carrier_phase_before,
            1.0f,
            formant_phase_ + (1.0f - reset_time) * f1,
    e08e:	vsub.f32	s20, s11, s13
    return value_;
  }

  inline float subsample(float t) {
    return value_ + increment_ * t;
    e092:	vmov.f32	s29, s8
        discontinuity_phase_ -= 1.0f;
        reset_time = discontinuity_phase_ / (2.0f * f0);
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
        float carrier_phase_after = carrier_phase_ >= 1.0f ? 0.0f : 0.5f;
        float before = Z(
    e096:	vldr	s22, [r0, #80]	; 0x50
    e09a:	vldr	s26, [r1]
    e09e:	vmov.f32	s28, s9
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e0a2:	vldr	s25, [r1, #4]
        discontinuity_phase_ -= 1.0f;
        reset_time = discontinuity_phase_ / (2.0f * f0);
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
        float carrier_phase_after = carrier_phase_ >= 1.0f ? 0.0f : 0.5f;
        float before = Z(
    e0a6:	vfma.f32	s22, s4, s20
    e0aa:	vfma.f32	s29, s16, s20
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e0ae:	vsub.f32	s21, s25, s26
    e0b2:	vfma.f32	s28, s0, s20
    e0b6:	vfma.f32	s26, s21, s2
        discontinuity_phase_ -= 1.0f;
        reset_time = discontinuity_phase_ / (2.0f * f0);
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
        float carrier_phase_after = carrier_phase_ >= 1.0f ? 0.0f : 0.5f;
        float before = Z(
    e0ba:	vmov.f32	s23, s22
  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e0be:	vcmpe.f32	s29, s1
    e0c2:	vmrs	APSR_nzcv, fpscr
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e0c6:	vadd.f32	s26, s26, s11
    e0ca:	vmul.f32	s26, s26, s10
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e0ce:	bpl.w	e564 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf58>
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    e0d2:	vmov.f32	s21, #120	; 0x3fc00000  1.5
    e0d6:	vmov.f32	s22, #80	; 0x3e800000  0.250
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
    e0da:	vmov.f32	s25, #112	; 0x3f800000  1.0
      phase_shift = 0.25f + mode * 1.50f;
    e0de:	vfma.f32	s22, s29, s21
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = 0.001f;
    }
    
    float discontinuity = Sine(f + phase_shift);
    e0e2:	vadd.f32	s22, s23, s22
    float contour;
    if (shape < 0.5f) {
    e0e6:	vcmpe.f32	s28, s10
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e0ea:	vcvt.s32.f32	s21, s22
    e0ee:	vmrs	APSR_nzcv, fpscr
    e0f2:	vcvt.f32.s32	s21, s21
    e0f6:	vsub.f32	s21, s22, s21
  index *= size;
    e0fa:	vmul.f32	s21, s21, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e0fe:	vcvt.s32.f32	s22, s21
  float a = table[index_integral];
    e102:	vmov	r1, s22
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e106:	vcvt.f32.s32	s22, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e10a:	mov.w	r1, r1, lsl #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e10e:	vsub.f32	s21, s21, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e112:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    e116:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e118:	vldr	s23, [r8]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e11c:	vldr	s22, [r1]
    e120:	vsub.f32	s22, s22, s23
    e124:	vfma.f32	s23, s21, s22
    e128:	vmov.f32	s21, s23
    e12c:	bpl.w	e620 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1014>
      shape *= 2.0f;
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    e130:	vmov.f32	s22, #80	; 0x3e800000  0.250
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
      if (c >= 0.5f) {
    e134:	vcmpe.f32	s27, s10
    }
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
    e138:	vadd.f32	s28, s28, s28
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    e13c:	vadd.f32	s27, s27, s22
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
      if (c >= 0.5f) {
    e140:	vmrs	APSR_nzcv, fpscr
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e144:	vcvt.s32.f32	s22, s27
        ramp_down *= shape;
    e148:	it	ge
    e14a:	vmulge.f32	s26, s26, s28
    e14e:	vcvt.f32.s32	s22, s22
    e152:	vsub.f32	s27, s27, s22
  index *= size;
    e156:	vmul.f32	s27, s27, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e15a:	vcvt.s32.f32	s22, s27
  float a = table[index_integral];
    e15e:	vmov	r1, s22
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    e162:	vcvt.f32.s32	s22, s22
    e166:	lsls	r1, r1, #2
    e168:	vsub.f32	s27, s27, s22
    e16c:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    e170:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e172:	vldr	s22, [r8]
    e176:	vldr	s23, [r1]
    e17a:	vsub.f32	s23, s23, s22
    e17e:	vfma.f32	s22, s27, s23
    e182:	vmov.f32	s23, s11
    e186:	vsub.f32	s22, s22, s11
    e18a:	vfma.f32	s23, s28, s22
    e18e:	vmov.f32	s22, s23
    e192:	ldr	r1, [pc, #740]	; (e478 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe6c>)
    } else {
      contour = Sine(c + shape * 0.5f);
    }
    return (ramp_down * (offset + discontinuity) - offset) * contour;
    e194:	vadd.f32	s27, s21, s25
    e198:	vadd.f32	s8, s16, s8
    e19c:	vldr	s23, [r1]
    e1a0:	vadd.f32	s9, s9, s0
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e1a4:	vldr	s21, [r1, #4]
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    } else {
      contour = Sine(c + shape * 0.5f);
    }
    return (ramp_down * (offset + discontinuity) - offset) * contour;
    e1a8:	vfnms.f32	s25, s27, s26
  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e1ac:	vcmpe.f32	s8, s1
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e1b0:	vsub.f32	s21, s21, s23
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e1b4:	vmrs	APSR_nzcv, fpscr
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e1b8:	vfma.f32	s23, s21, s2
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    } else {
      contour = Sine(c + shape * 0.5f);
    }
    return (ramp_down * (offset + discontinuity) - offset) * contour;
    e1bc:	vmul.f32	s25, s25, s22
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e1c0:	vadd.f32	s23, s23, s11
    e1c4:	vmul.f32	s23, s23, s10
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e1c8:	bpl.w	e5c2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfb6>
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    e1cc:	vmov.f32	s21, #120	; 0x3fc00000  1.5
    e1d0:	vmov.f32	s22, #80	; 0x3e800000  0.250
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
    e1d4:	vmov.f32	s26, #112	; 0x3f800000  1.0
      phase_shift = 0.25f + mode * 1.50f;
    e1d8:	vfma.f32	s22, s8, s21
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = 0.001f;
    }
    
    float discontinuity = Sine(f + phase_shift);
    e1dc:	vadd.f32	s22, s22, s2
    float contour;
    if (shape < 0.5f) {
    e1e0:	vcmpe.f32	s9, s10
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e1e4:	vcvt.s32.f32	s21, s22
    e1e8:	vmrs	APSR_nzcv, fpscr
    e1ec:	vcvt.f32.s32	s21, s21
    e1f0:	vsub.f32	s21, s22, s21
  index *= size;
    e1f4:	vmul.f32	s21, s21, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e1f8:	vcvt.s32.f32	s22, s21
  float a = table[index_integral];
    e1fc:	vmov	r1, s22
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e200:	vcvt.f32.s32	s22, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e204:	mov.w	r1, r1, lsl #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e208:	vsub.f32	s21, s21, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e20c:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    e210:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e212:	vldr	s27, [r8]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e216:	vldr	s22, [r1]
    e21a:	vsub.f32	s22, s22, s27
    e21e:	vfma.f32	s27, s21, s22
    e222:	vmov.f32	s21, s27
    e226:	bpl.w	e522 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf16>
      shape *= 2.0f;
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    e22a:	vmov.f32	s22, #80	; 0x3e800000  0.250
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
      if (c >= 0.5f) {
    e22e:	vcmpe.f32	s24, s10
    }
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
    e232:	vadd.f32	s27, s9, s9
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    e236:	vadd.f32	s24, s24, s22
    
    float discontinuity = Sine(f + phase_shift);
    float contour;
    if (shape < 0.5f) {
      shape *= 2.0f;
      if (c >= 0.5f) {
    e23a:	vmrs	APSR_nzcv, fpscr
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e23e:	vcvt.s32.f32	s22, s24
        ramp_down *= shape;
    e242:	it	ge
    e244:	vmulge.f32	s23, s23, s27
    e248:	vcvt.f32.s32	s22, s22
    e24c:	vsub.f32	s24, s24, s22
  index *= size;
    e250:	vmul.f32	s24, s24, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e254:	vcvt.s32.f32	s22, s24
  float a = table[index_integral];
    e258:	vmov	r1, s22
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    e25c:	vcvt.f32.s32	s22, s22
    e260:	lsls	r1, r1, #2
    e262:	vsub.f32	s24, s24, s22
    e266:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    e26a:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e26c:	vldr	s22, [r8]
    e270:	vldr	s28, [r1]
    e274:	vsub.f32	s28, s28, s22
    e278:	vfma.f32	s22, s24, s28
    e27c:	vmov.f32	s24, s11
    e280:	vsub.f32	s22, s22, s11
    e284:	vfma.f32	s24, s27, s22
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
    e288:	vadd.f32	s21, s21, s26
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    e28c:	vmov.f32	s22, #224	; 0xbf000000 -0.5
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    e290:	vmul.f32	s27, s13, s10
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
    e294:	vfnms.f32	s26, s21, s23
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    e298:	vmul.f32	s22, s20, s22
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    e29c:	vmul.f32	s23, s27, s13
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    e2a0:	vmul.f32	s21, s4, s13
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    e2a4:	vmul.f32	s20, s22, s20
    e2a8:	vmov.f32	s13, s2
            0.0f,
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
    e2ac:	vfnms.f32	s25, s26, s24
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
    e2b0:	vstr	s21, [r0, #80]	; 0x50
        
        if (carrier_phase_ > 1.0f) {
    e2b4:	vcmpe.f32	s14, s11
    e2b8:	vmrs	APSR_nzcv, fpscr
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    e2bc:	vfma.f32	s13, s25, s20
            0.0f,
            carrier_shape_modulation.subsample(1.0f),
            mode_modulation.subsample(1.0f));

        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
    e2c0:	vfma.f32	s12, s25, s23
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
    e2c4:	vmov.f32	s20, s13
        formant_phase_ = reset_time * f1;
        
        if (carrier_phase_ > 1.0f) {
    e2c8:	ble.w	e966 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x135a>
          carrier_phase_ = discontinuity_phase_ * 0.5f;
    e2cc:	vmul.f32	s14, s15, s10
    e2d0:	vmov.f32	s15, s14
    e2d4:	vstr	s14, [r0, #72]	; 0x48
        if (formant_phase_ >= 1.0f) {
          formant_phase_ -= 1.0f;
        }
      }
      
      if (carrier_phase_ >= 1.0f) {
    e2d8:	vcmpe.f32	s14, s11
    e2dc:	vmrs	APSR_nzcv, fpscr
    e2e0:	blt.n	e2ea <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcde>
        carrier_phase_ -= 1.0f;
    e2e2:	vsub.f32	s14, s14, s11
    e2e6:	vstr	s14, [r0, #72]	; 0x48
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e2ea:	vmov.f32	s13, #80	; 0x3e800000  0.250
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e2ee:	vcmpe.f32	s8, s1
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e2f2:	vadd.f32	s15, s15, s13
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e2f6:	vmrs	APSR_nzcv, fpscr
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e2fa:	vcvt.s32.f32	s22, s15
    e2fe:	vcvt.f32.s32	s22, s22
    e302:	vsub.f32	s15, s15, s22
  index *= size;
    e306:	vmul.f32	s15, s15, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e30a:	vcvt.s32.f32	s22, s15
  float a = table[index_integral];
    e30e:	vmov	r1, s22
  inline float Sine(float phase) {
    return stmlib::InterpolateWrap(lut_sine, phase, 1024.0f);
  }

  inline float Z(float c, float d, float f, float shape, float mode) {
    float ramp_down = 0.5f * (1.0f + Sine(0.5f * d + 0.25f));
    e312:	vcvt.f32.s32	s22, s22
    e316:	mov.w	r1, r1, lsl #2
    e31a:	vsub.f32	s15, s15, s22
    e31e:	add.w	r8, r2, r1
  float b = table[index_integral + 1];
    e322:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e324:	vldr	s22, [r8]
    e328:	vldr	s23, [r1]
    e32c:	vsub.f32	s23, s23, s22
    e330:	vfma.f32	s22, s15, s23
    e334:	vadd.f32	s22, s22, s11
    e338:	vmul.f32	s22, s22, s10
    
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
    e33c:	bmi.w	df6c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x960>
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
    e340:	vcmpe.f32	s8, s19
    e344:	vmrs	APSR_nzcv, fpscr
    e348:	bpl.w	e8f8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12ec>
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e34c:	vldr	s23, [pc, #300]	; e47c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe70>
    e350:	vmov.f32	s15, #104	; 0x3f400000  0.750
    e354:	vldr	s13, [pc, #296]	; e480 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe74>
    e358:	vsub.f32	s23, s8, s23
    e35c:	vfms.f32	s13, s23, s15
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e360:	vcvt.s32.f32	s15, s13
    e364:	vcvt.f32.s32	s15, s15
    e368:	vsub.f32	s15, s13, s15
  index *= size;
    e36c:	vmul.f32	s15, s15, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e370:	vcvt.s32.f32	s23, s15
  float a = table[index_integral];
    e374:	vmov	r1, s23
      offset = -Sine(phase_shift);
    e378:	vcvt.f32.s32	s23, s23
    e37c:	lsls	r1, r1, #2
    e37e:	vsub.f32	s15, s15, s23
    e382:	add.w	r8, r1, lr
  float b = table[index_integral + 1];
    e386:	add	r1, ip

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e388:	vldr	s23, [r8]
    e38c:	vldr	s24, [r1]
    e390:	vsub.f32	s24, s24, s23
    e394:	vfma.f32	s23, s15, s24
    e398:	vneg.f32	s23, s23
    e39c:	b.n	df78 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x96c>
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    } else {
      contour = Sine(c + shape * 0.5f);
    e39e:	vfma.f32	s14, s9, s10
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e3a2:	vcvt.s32.f32	s15, s14
    e3a6:	vcvt.f32.s32	s15, s15
    e3aa:	vsub.f32	s14, s14, s15
  index *= size;
    e3ae:	vmul.f32	s14, s14, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e3b2:	vcvt.s32.f32	s15, s14
  float a = table[index_integral];
    e3b6:	vmov	r1, s15
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e3ba:	vcvt.f32.s32	s15, s15

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e3be:	lsls	r1, r1, #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e3c0:	vsub.f32	s14, s14, s15

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e3c4:	add.w	r8, r1, lr
  float b = table[index_integral + 1];
    e3c8:	add	r1, ip

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e3ca:	vldr	s15, [r8]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e3ce:	vldr	s21, [r1]
    e3d2:	vsub.f32	s21, s21, s15
    e3d6:	vfma.f32	s15, s14, s21
    e3da:	vmov.f32	s14, s15
    e3de:	b.n	e020 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa14>
      phase = phase * (1.0f + t * t * t * 15.0f);
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
    e3e0:	cmp	r5, #1
    e3e2:	beq.n	e488 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe7c>
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
    e3e4:	vsub.f32	s13, s6, s13
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e3e8:	vmov.f32	s7, #45	; 0x41680000  14.5
      if (phase >= 0.75f) phase = 0.75f;
    e3ec:	vmov.f32	s9, #104	; 0x3f400000  0.750
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e3f0:	vmul.f32	s10, s13, s13
    e3f4:	vmul.f32	s13, s10, s13
    e3f8:	vmov.f32	s10, s19
    e3fc:	vfma.f32	s10, s13, s7
    e400:	vmov.f32	s13, s10
    e404:	vmov.f32	s10, s2
    e408:	vfma.f32	s10, s13, s14
      if (phase >= 0.75f) phase = 0.75f;
    e40c:	vcmpe.f32	s10, s9
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e410:	vmov.f32	s14, s10
      if (phase >= 0.75f) phase = 0.75f;
    e414:	vmrs	APSR_nzcv, fpscr
    e418:	blt.n	e4b4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xea8>
    e41a:	movw	ip, #3076	; 0xc04
    e41e:	mov.w	r5, #3072	; 0xc00
    e422:	vldr	s13, [pc, #96]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e426:	b.n	dd7e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x772>
      phase = phase * (1.0f + t * t * t * 15.0f);
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
    e428:	cmp	r5, #1
    e42a:	beq.w	e9ca <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x13be>
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
    e42e:	vsub.f32	s14, s6, s14
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e432:	vmov.f32	s8, #45	; 0x41680000  14.5
      if (phase >= 0.75f) phase = 0.75f;
    e436:	vmov.f32	s10, #104	; 0x3f400000  0.750
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e43a:	vmul.f32	s11, s14, s14
    e43e:	vmul.f32	s14, s11, s14
    e442:	vmov.f32	s11, s19
    e446:	vfma.f32	s11, s14, s8
    e44a:	vmov.f32	s14, s11
    e44e:	vmov.f32	s11, s0
    e452:	vfma.f32	s11, s14, s13
      if (phase >= 0.75f) phase = 0.75f;
    e456:	vcmpe.f32	s11, s10
    e45a:	vmrs	APSR_nzcv, fpscr
    e45e:	blt.w	e9a2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1396>
    e462:	movw	r6, #3076	; 0xc04
    e466:	mov.w	r5, #3072	; 0xc00
    e46a:	vldr	s13, [pc, #24]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e46e:	b.w	da2a <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41e>
    e472:	nop
    e474:	.word	0x20003710
    e478:	.word	0x20002f10
    e47c:	.word	0x3ea8f5c3
    e480:	.word	0x3f3fdf3b
    e484:	.word	0x00000000
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    e488:	vmul.f32	s10, s13, s29
    e48c:	vmov.f32	s9, s28
    e490:	vmul.f32	s10, s10, s13
    e494:	vfma.f32	s9, s10, s13
      if (phase < breakpoint) {
    e498:	vcmpe.f32	s9, s14
    e49c:	vmrs	APSR_nzcv, fpscr
    e4a0:	ble.w	eae4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x14d8>
        phase *= (0.5f / breakpoint);
    e4a4:	vdiv.f32	s13, s19, s9
    e4a8:	vmul.f32	s14, s13, s14
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    e4ac:	vmov.f32	s13, #104	; 0x3f400000  0.750
    e4b0:	vadd.f32	s14, s14, s13
    e4b4:	vcvt.s32.f32	s13, s14
    e4b8:	vcvt.f32.s32	s13, s13
    e4bc:	vsub.f32	s14, s14, s13
    e4c0:	vmul.f32	s14, s14, s1
    e4c4:	vcvt.s32.f32	s10, s14
    e4c8:	vmov	r5, s10
    e4cc:	vcvt.f32.s32	s13, s10
    e4d0:	lsls	r5, r5, #2
    e4d2:	vsub.f32	s13, s14, s13
    e4d6:	add.w	ip, r5, #4
    e4da:	b.n	dd7e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x772>
      phase = phase * (1.0f + t * t * t * 15.0f);
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
    e4dc:	vmov	r5, s7
    e4e0:	cmp	r5, #1
    e4e2:	beq.w	e73c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1130>
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
    e4e6:	vsub.f32	s12, s6, s12
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e4ea:	vmov.f32	s4, #45	; 0x41680000  14.5
      if (phase >= 0.75f) phase = 0.75f;
    e4ee:	vmov.f32	s11, #104	; 0x3f400000  0.750
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e4f2:	vmul.f32	s7, s12, s12
    e4f6:	vmul.f32	s12, s7, s12
    e4fa:	vmov.f32	s7, s19
    e4fe:	vfma.f32	s7, s12, s4
    e502:	vadd.f32	s12, s7, s0
      if (phase >= 0.75f) phase = 0.75f;
    e506:	vcmpe.f32	s12, s11
    e50a:	vmrs	APSR_nzcv, fpscr
    e50e:	blt.w	e764 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1158>
    e512:	movw	r6, #3076	; 0xc04
    e516:	mov.w	r5, #3072	; 0xc00
    e51a:	vldr	s11, [pc, #-152]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e51e:	b.w	d8ce <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c2>
    e522:	vfma.f32	s24, s9, s10
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e526:	vcvt.s32.f32	s22, s24
    e52a:	vcvt.f32.s32	s22, s22
    e52e:	vsub.f32	s24, s24, s22
  index *= size;
    e532:	vmul.f32	s24, s24, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e536:	vcvt.s32.f32	s22, s24
  float a = table[index_integral];
    e53a:	vmov	r1, s22
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e53e:	vcvt.f32.s32	s22, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e542:	lsls	r1, r1, #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e544:	vsub.f32	s24, s24, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e548:	add.w	r8, r1, lr
  float b = table[index_integral + 1];
    e54c:	add	r1, ip

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e54e:	vldr	s27, [r8]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e552:	vldr	s22, [r1]
    e556:	vsub.f32	s22, s22, s27
    e55a:	vfma.f32	s27, s24, s22
    e55e:	vmov.f32	s24, s27
    e562:	b.n	e288 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc7c>
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
    e564:	vcmpe.f32	s29, s19
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e568:	vldr	s25, [pc, #-240]	; e47c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe70>
    e56c:	vmov.f32	s21, #104	; 0x3f400000  0.750
    e570:	vldr	s22, [pc, #-244]	; e480 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe74>
    e574:	vsub.f32	s29, s29, s25
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
    e578:	vmrs	APSR_nzcv, fpscr
    e57c:	bpl.w	e97c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1370>
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e580:	vfms.f32	s22, s29, s21
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e584:	vcvt.s32.f32	s21, s22
    e588:	vcvt.f32.s32	s21, s21
    e58c:	vsub.f32	s21, s22, s21
  index *= size;
    e590:	vmul.f32	s21, s21, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e594:	vcvt.s32.f32	s25, s21
  float a = table[index_integral];
    e598:	vmov	r1, s25
      offset = -Sine(phase_shift);
    e59c:	vcvt.f32.s32	s25, s25
    e5a0:	lsls	r1, r1, #2
    e5a2:	vsub.f32	s21, s21, s25
    e5a6:	add.w	r8, r1, lr
  float b = table[index_integral + 1];
    e5aa:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e5ac:	vldr	s25, [r8]
    e5b0:	vldr	s29, [r1]
    e5b4:	vsub.f32	s29, s29, s25
    e5b8:	vfma.f32	s25, s21, s29
    e5bc:	vneg.f32	s25, s25
    e5c0:	b.n	e0e2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xad6>
    float offset;
    float phase_shift;
    if (mode < 0.333f) {
      offset = 1.0f;
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
    e5c2:	vcmpe.f32	s8, s19
    e5c6:	vmrs	APSR_nzcv, fpscr
    e5ca:	bpl.w	e988 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x137c>
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e5ce:	vldr	s26, [pc, #-340]	; e47c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe70>
    e5d2:	vmov.f32	s21, #104	; 0x3f400000  0.750
    e5d6:	vldr	s22, [pc, #-344]	; e480 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe74>
    e5da:	vsub.f32	s26, s8, s26
    e5de:	vfms.f32	s22, s26, s21
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e5e2:	vcvt.s32.f32	s21, s22
    e5e6:	vcvt.f32.s32	s21, s21
    e5ea:	vsub.f32	s21, s22, s21
  index *= size;
    e5ee:	vmul.f32	s21, s21, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e5f2:	vcvt.s32.f32	s26, s21
  float a = table[index_integral];
    e5f6:	vmov	r1, s26
      offset = -Sine(phase_shift);
    e5fa:	vcvt.f32.s32	s26, s26
    e5fe:	lsls	r1, r1, #2
    e600:	vsub.f32	s21, s21, s26
    e604:	add.w	r8, r1, lr
  float b = table[index_integral + 1];
    e608:	add	r1, r4

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e60a:	vldr	s26, [r8]
    e60e:	vldr	s27, [r1]
    e612:	vsub.f32	s27, s27, s26
    e616:	vfma.f32	s26, s21, s27
    e61a:	vneg.f32	s26, s26
    e61e:	b.n	e1dc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbd0>
      if (c >= 0.5f) {
        ramp_down *= shape;
      }
      contour = 1.0f + (Sine(c + 0.25f) - 1.0f) * shape;
    } else {
      contour = Sine(c + shape * 0.5f);
    e620:	vfma.f32	s27, s28, s10
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
    e624:	vcvt.s32.f32	s22, s27
    e628:	vcvt.f32.s32	s22, s22
    e62c:	vsub.f32	s27, s27, s22
  index *= size;
    e630:	vmul.f32	s27, s27, s6
  MAKE_INTEGRAL_FRACTIONAL(index)
    e634:	vcvt.s32.f32	s22, s27
  float a = table[index_integral];
    e638:	vmov	r1, s22
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e63c:	vcvt.f32.s32	s22, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e640:	lsls	r1, r1, #2
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e642:	vsub.f32	s27, s27, s22

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e646:	add.w	r8, r1, lr
  float b = table[index_integral + 1];
    e64a:	add	r1, ip

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    e64c:	vldr	s22, [r8]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
    e650:	vldr	s23, [r1]
    e654:	vsub.f32	s23, s23, s22
    e658:	vfma.f32	s22, s27, s23
    e65c:	b.n	e192 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb86>
      phase = phase * (1.0f + t * t * t * 15.0f);
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
    e65e:	cmp	r5, #1
    e660:	beq.w	e78c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1180>
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
    e664:	vsub.f32	s12, s6, s14
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e668:	vmov.f32	s10, #45	; 0x41680000  14.5
      if (phase >= 0.75f) phase = 0.75f;
    e66c:	vmov.f32	s11, #104	; 0x3f400000  0.750
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e670:	vmul.f32	s9, s12, s12
    e674:	vmul.f32	s12, s9, s12
    e678:	vmov.f32	s9, s19
    e67c:	vfma.f32	s9, s12, s10
    e680:	vmov.f32	s10, s0
    e684:	vfma.f32	s10, s9, s18
      if (phase >= 0.75f) phase = 0.75f;
    e688:	vcmpe.f32	s10, s11
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e68c:	vmov.f32	s12, s10
      if (phase >= 0.75f) phase = 0.75f;
    e690:	vmrs	APSR_nzcv, fpscr
    e694:	blt.w	e7b8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11ac>
    e698:	movw	ip, #3076	; 0xc04
    e69c:	mov.w	r6, #3072	; 0xc00
    e6a0:	vldr	s11, [pc, #-544]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e6a4:	b.w	d98c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x380>
      phase = phase * (1.0f + t * t * t * 15.0f);
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
    e6a8:	cmp	r5, #1
    e6aa:	beq.w	e7e2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11d6>
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
    e6ae:	vsub.f32	s13, s6, s12
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e6b2:	vmov.f32	s3, #45	; 0x41680000  14.5
      if (phase >= 0.75f) phase = 0.75f;
    e6b6:	vmov.f32	s4, #104	; 0x3f400000  0.750
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e6ba:	vmul.f32	s7, s13, s13
    e6be:	vmul.f32	s13, s7, s13
    e6c2:	vmov.f32	s7, s19
    e6c6:	vfma.f32	s7, s13, s3
    e6ca:	vmov.f32	s13, s7
    e6ce:	vmov.f32	s7, s2
    e6d2:	vfma.f32	s7, s13, s18
      if (phase >= 0.75f) phase = 0.75f;
    e6d6:	vcmpe.f32	s7, s4
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e6da:	vmov.f32	s13, s7
      if (phase >= 0.75f) phase = 0.75f;
    e6de:	vmrs	APSR_nzcv, fpscr
    e6e2:	blt.w	e80e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1202>
    e6e6:	movw	ip, #3076	; 0xc04
    e6ea:	mov.w	r8, #3072	; 0xc00
    e6ee:	vldr	s7, [pc, #-620]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e6f2:	b.w	dcd0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6c4>
      phase = phase * (1.0f + t * t * t * 15.0f);
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
    e6f6:	vmov	r5, s9
    e6fa:	cmp	r5, #1
    e6fc:	beq.w	e914 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1308>
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
    e700:	vsub.f32	s13, s6, s13
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e704:	vmov.f32	s4, #45	; 0x41680000  14.5
      if (phase >= 0.75f) phase = 0.75f;
    e708:	vmov.f32	s7, #104	; 0x3f400000  0.750
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    } else {
      t = 1.0f - t;
      phase = 0.25f + phase * (0.5f + t * t * t * 14.5f);
    e70c:	vmul.f32	s9, s13, s13
    e710:	vmul.f32	s13, s9, s13
    e714:	vmov.f32	s9, s19
    e718:	vfma.f32	s9, s13, s4
    e71c:	vadd.f32	s13, s9, s2
      if (phase >= 0.75f) phase = 0.75f;
    e720:	vcmpe.f32	s13, s7
    e724:	vmrs	APSR_nzcv, fpscr
    e728:	blt.w	e93c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1330>
    e72c:	movw	ip, #3076	; 0xc04
    e730:	mov.w	r5, #3072	; 0xc00
    e734:	vldr	s4, [pc, #-692]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e738:	b.w	dc10 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x604>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    e73c:	vmul.f32	s11, s12, s30
    e740:	vmov.f32	s7, s29
    e744:	vmul.f32	s11, s11, s12
    e748:	vfma.f32	s7, s12, s11
      if (phase < breakpoint) {
    e74c:	vcmpe.f32	s7, s6
    e750:	vmrs	APSR_nzcv, fpscr
    e754:	ble.w	eb1c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1510>
        phase *= (0.5f / breakpoint);
    e758:	vdiv.f32	s12, s19, s7
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    e75c:	vmov.f32	s11, #104	; 0x3f400000  0.750
    e760:	vadd.f32	s12, s12, s11
    e764:	vcvt.s32.f32	s11, s12
    e768:	vcvt.f32.s32	s11, s11
    e76c:	vsub.f32	s11, s12, s11
    e770:	vmul.f32	s11, s11, s17
    e774:	vcvt.s32.f32	s12, s11
    e778:	vmov	r5, s12
    e77c:	vcvt.f32.s32	s7, s12
    e780:	lsls	r5, r5, #2
    e782:	vsub.f32	s11, s11, s7
    e786:	adds	r6, r5, #4
    e788:	b.w	d8ce <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c2>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    e78c:	vmul.f32	s12, s14, s30
    e790:	vmov.f32	s11, s29
    e794:	vmul.f32	s12, s12, s14
    e798:	vfma.f32	s11, s14, s12
      if (phase < breakpoint) {
    e79c:	vcmpe.f32	s11, #0.0
    e7a0:	vmrs	APSR_nzcv, fpscr
    e7a4:	ble.w	eb48 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x153c>
        phase *= (0.5f / breakpoint);
    e7a8:	vdiv.f32	s12, s19, s11
    e7ac:	vmul.f32	s12, s12, s18
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    e7b0:	vmov.f32	s11, #104	; 0x3f400000  0.750
    e7b4:	vadd.f32	s12, s12, s11
    e7b8:	vcvt.s32.f32	s11, s12
    e7bc:	vcvt.f32.s32	s11, s11
    e7c0:	vsub.f32	s11, s12, s11
    e7c4:	vmul.f32	s11, s11, s17
    e7c8:	vcvt.s32.f32	s12, s11
    e7cc:	vmov	r6, s12
    e7d0:	vcvt.f32.s32	s10, s12
    e7d4:	lsls	r6, r6, #2
    e7d6:	vsub.f32	s11, s11, s10
    e7da:	add.w	ip, r6, #4
    e7de:	b.w	d98c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x380>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    e7e2:	vmul.f32	s13, s12, s29
    e7e6:	vmov.f32	s7, s28
    e7ea:	vmul.f32	s13, s13, s12
    e7ee:	vfma.f32	s7, s12, s13
      if (phase < breakpoint) {
    e7f2:	vcmpe.f32	s7, #0.0
    e7f6:	vmrs	APSR_nzcv, fpscr
    e7fa:	ble.w	eb66 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x155a>
        phase *= (0.5f / breakpoint);
    e7fe:	vdiv.f32	s13, s19, s7
    e802:	vmul.f32	s13, s13, s18
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    e806:	vmov.f32	s7, #104	; 0x3f400000  0.750
    e80a:	vadd.f32	s13, s13, s7
    e80e:	vcvt.s32.f32	s7, s13
    e812:	vcvt.f32.s32	s7, s7
    e816:	vsub.f32	s7, s13, s7
    e81a:	vmul.f32	s7, s7, s1
    e81e:	vcvt.s32.f32	s13, s7
    e822:	vmov	ip, s13
    e826:	vcvt.f32.s32	s4, s13
    e82a:	mov.w	r8, ip, lsl #2
    e82e:	vsub.f32	s7, s7, s4
    e832:	add.w	ip, r8, #4
    e836:	b.w	dcd0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6c4>
        
        if (carrier_phase_ > 1.0f) {
          carrier_phase_ = discontinuity_phase_ * 0.5f;
        }
      } else {
        formant_phase_ += f1;
    e83a:	vldr	s13, [r0, #80]	; 0x50
    e83e:	vadd.f32	s21, s4, s13
        if (formant_phase_ >= 1.0f) {
    e842:	vcmpe.f32	s21, s11
    e846:	vmrs	APSR_nzcv, fpscr
    e84a:	blt.w	eaa2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1496>
          formant_phase_ -= 1.0f;
    e84e:	vsub.f32	s21, s21, s11
    while (size--) {
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    e852:	vldr	s20, [pc, #-976]	; e484 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xe78>
    e856:	vmul.f32	s15, s15, s10
          carrier_phase_ = discontinuity_phase_ * 0.5f;
        }
      } else {
        formant_phase_ += f1;
        if (formant_phase_ >= 1.0f) {
          formant_phase_ -= 1.0f;
    e85a:	vadd.f32	s8, s16, s8
    e85e:	vadd.f32	s9, s9, s0
    e862:	vstr	s21, [r0, #80]	; 0x50
    e866:	b.n	e2d8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xccc>
        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
      } else {
        formant_phase_ += f1;
    e868:	vldr	s15, [r0, #48]	; 0x30
    e86c:	vadd.f32	s8, s20, s8
    e870:	vadd.f32	s15, s17, s15
        if (formant_phase_ >= 1.0f) {
    e874:	vcmpe.f32	s15, s6
    e878:	vmrs	APSR_nzcv, fpscr
    e87c:	blt.w	eab8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x14ac>
    e880:	vadd.f32	s0, s21, s0
    while (size--) {
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    e884:	vldr	s11, [pc, #928]	; ec28 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x161c>
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
      } else {
        formant_phase_ += f1;
        if (formant_phase_ >= 1.0f) {
          formant_phase_ -= 1.0f;
    e888:	vsub.f32	s15, s15, s6
    e88c:	vmul.f32	s13, s8, s22
    e890:	vadd.f32	s12, s0, s6
    e894:	vstr	s15, [r0, #48]	; 0x30
    e898:	vcvt.s32.f32	s10, s13
    e89c:	vmov	r5, s10
    e8a0:	vcvt.f32.s32	s10, s10
    e8a4:	vsub.f32	s13, s13, s10
    e8a8:	vsub.f32	s13, s6, s13
    e8ac:	b.w	dd48 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x73c>
        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
      } else {
        formant_phase_ += f1;
    e8b0:	vldr	s15, [r0, #20]
    e8b4:	vadd.f32	s3, s20, s3
    e8b8:	vadd.f32	s15, s1, s15
        if (formant_phase_ >= 1.0f) {
    e8bc:	vcmpe.f32	s15, s6
    e8c0:	vmrs	APSR_nzcv, fpscr
    e8c4:	blt.w	ea8c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1480>
    e8c8:	vadd.f32	s9, s21, s9
    while (size--) {
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    e8cc:	vldr	s12, [pc, #856]	; ec28 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x161c>
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
      } else {
        formant_phase_ += f1;
        if (formant_phase_ >= 1.0f) {
          formant_phase_ -= 1.0f;
    e8d0:	vsub.f32	s15, s15, s6
    e8d4:	vmul.f32	s14, s3, s22
    e8d8:	vadd.f32	s4, s9, s6
    e8dc:	vstr	s15, [r0, #20]
    e8e0:	vcvt.s32.f32	s11, s14
    e8e4:	vmov	r5, s11
    e8e8:	vcvt.f32.s32	s11, s11
    e8ec:	vsub.f32	s14, s14, s11
    e8f0:	vsub.f32	s14, s6, s14
    e8f4:	b.w	d9f4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e8>
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = -Sine(phase_shift);
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e8f8:	vldr	s24, [pc, #816]	; ec2c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1620>
    e8fc:	vmov.f32	s15, #104	; 0x3f400000  0.750
    e900:	vldr	s13, [pc, #812]	; ec30 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1624>
    e904:	vsub.f32	s24, s8, s24
      offset = 0.001f;
    e908:	vldr	s23, [pc, #808]	; ec34 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1628>
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = -Sine(phase_shift);
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e90c:	vfms.f32	s13, s24, s15
    e910:	b.w	df78 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x96c>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    e914:	vmul.f32	s9, s13, s29
    e918:	vmov.f32	s7, s28
    e91c:	vmul.f32	s9, s9, s13
    e920:	vfma.f32	s7, s13, s9
      if (phase < breakpoint) {
    e924:	vcmpe.f32	s7, s6
    e928:	vmrs	APSR_nzcv, fpscr
    e92c:	ble.w	eb36 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x152a>
        phase *= (0.5f / breakpoint);
    e930:	vdiv.f32	s13, s19, s7
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    e934:	vmov.f32	s9, #104	; 0x3f400000  0.750
    e938:	vadd.f32	s13, s13, s9
    e93c:	vcvt.s32.f32	s4, s13
    e940:	vcvt.f32.s32	s4, s4
    e944:	vsub.f32	s4, s13, s4
    e948:	vmul.f32	s9, s4, s1
    e94c:	vcvt.s32.f32	s13, s9
    e950:	vmov	r5, s13
    e954:	vcvt.f32.s32	s4, s13
    e958:	lsls	r5, r5, #2
    e95a:	vsub.f32	s4, s9, s4
    e95e:	add.w	ip, r5, #4
    e962:	b.w	dc10 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x604>
    e966:	vmul.f32	s15, s15, s10
    e96a:	b.n	e2d8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xccc>
      
      if (reset) {
        discontinuity_phase_ -= 1.0f;
        reset_time = discontinuity_phase_ / (2.0f * f0);
        
        float carrier_phase_before = carrier_phase_ >= 1.0f ? 1.0f : 0.5f;
    e96c:	vmov.f32	s27, #96	; 0x3f000000  0.5
        float carrier_phase_after = carrier_phase_ >= 1.0f ? 0.0f : 0.5f;
    e970:	bge.w	e088 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa7c>
    e974:	vmov.f32	s24, s27
    e978:	b.w	e08c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa80>
    } else if (mode < 0.666f) {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = -Sine(phase_shift);
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = 0.001f;
    e97c:	vldr	s25, [pc, #692]	; ec34 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1628>
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = -Sine(phase_shift);
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e980:	vfms.f32	s22, s29, s21
    e984:	b.w	e0e2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xad6>
    e988:	vldr	s27, [pc, #672]	; ec2c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1620>
    e98c:	vmov.f32	s21, #104	; 0x3f400000  0.750
    e990:	vldr	s22, [pc, #668]	; ec30 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1624>
    e994:	vsub.f32	s27, s8, s27
      offset = 0.001f;
    e998:	vldr	s26, [pc, #664]	; ec34 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1628>
      phase_shift = 0.25f + mode * 1.50f;
    } else if (mode < 0.666f) {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
      offset = -Sine(phase_shift);
    } else {
      phase_shift = 0.7495f - (mode - 0.33f) * 0.75f;
    e99c:	vfms.f32	s22, s27, s21
    e9a0:	b.n	e1dc <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbd0>
    e9a2:	vcvt.s32.f32	s13, s11
    e9a6:	vcvt.f32.s32	s13, s13
    e9aa:	vsub.f32	s14, s11, s13
    e9ae:	vmul.f32	s14, s14, s17
    e9b2:	vcvt.s32.f32	s11, s14
    e9b6:	vmov	r5, s11
    e9ba:	vcvt.f32.s32	s13, s11
    e9be:	lsls	r5, r5, #2
    e9c0:	vsub.f32	s13, s14, s13
    e9c4:	adds	r6, r5, #4
    e9c6:	b.w	da2a <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41e>
      if (phase >= 1.0f) {
        phase = 1.0f;
      }
      phase += 0.75f;
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
    e9ca:	vmul.f32	s11, s14, s30
    e9ce:	vmov.f32	s10, s29
    e9d2:	vmul.f32	s11, s11, s14
    e9d6:	vfma.f32	s10, s11, s14
      if (phase < breakpoint) {
    e9da:	vcmpe.f32	s10, s13
    e9de:	vmrs	APSR_nzcv, fpscr
    e9e2:	ble.n	eace <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x14c2>
        phase *= (0.5f / breakpoint);
    e9e4:	vdiv.f32	s14, s19, s10
    e9e8:	vmul.f32	s13, s14, s13
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
      }
      phase += 0.75f;
    e9ec:	vmov.f32	s14, #104	; 0x3f400000  0.750
    e9f0:	vadd.f32	s13, s13, s14
    e9f4:	vcvt.s32.f32	s14, s13
    e9f8:	vcvt.f32.s32	s14, s14
    e9fc:	vsub.f32	s13, s13, s14
    ea00:	vmul.f32	s14, s13, s17
    ea04:	b.n	e9b2 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x13a6>
    ea06:	vmov.f32	s14, #104	; 0x3f400000  0.750
    ea0a:	vadd.f32	s13, s13, s14
    ea0e:	vcvt.s32.f32	s14, s13
    ea12:	vcvt.f32.s32	s14, s14
    ea16:	vsub.f32	s13, s13, s14
    ea1a:	vmul.f32	s13, s13, s17
    ea1e:	vcvt.s32.f32	s14, s13
    ea22:	vmov	r5, s14
    ea26:	vcvt.f32.s32	s11, s14
    ea2a:	lsls	r5, r5, #2
    ea2c:	vsub.f32	s13, s13, s11
    ea30:	adds	r6, r5, #4
    ea32:	b.w	da2a <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41e>
          carrier_shape_modulation.Next(),
          mode_modulation.Next());
      *out++ = this_sample;
    }
    
    next_sample_ = next_sample;
    ea36:	vstr	s12, [r0, #84]	; 0x54
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    ea3a:	vstr	s8, [r0, #100]	; 0x64
    ea3e:	vstr	s9, [r0, #96]	; 0x60
    ea42:	vstr	s4, [r0, #92]	; 0x5c
    ea46:	vstr	s5, [r0, #88]	; 0x58
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    ea4a:	vstr	s7, [r0, #116]	; 0x74
    gi_ = 1.0f / (1.0f + g_);
    ea4e:	vstr	s3, [r0, #120]	; 0x78
    ea52:	b.n	ea5c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1450>
    ea54:	vldr	s7, [r0, #116]	; 0x74
    ea58:	vldr	s3, [r0, #120]	; 0x78
  }
  
  template<FilterMode mode>
  inline void Process(float* in_out, size_t size) {
    while (size--) {
      *in_out = Process<mode>(*in_out);
    ea5c:	vldr	s15, [r3]
    }
  }
  
  template<FilterMode mode>
  inline void Process(float* in_out, size_t size) {
    while (size--) {
    ea60:	subs	r7, #1
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    ea62:	vldr	s14, [r0, #124]	; 0x7c
    }
  }
  
  template<FilterMode mode>
  inline void Process(float* in_out, size_t size) {
    while (size--) {
    ea66:	adds	r2, r7, #1
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    ea68:	vfma.f32	s14, s15, s7
    state_ = g_ * (in - lp) + lp;
    ea6c:	vfms.f32	s15, s14, s3
    ea70:	vmul.f32	s7, s15, s7
    ea74:	vfma.f32	s7, s14, s3
    ea78:	vstr	s7, [r0, #124]	; 0x7c
  }
  
  template<FilterMode mode>
  inline void Process(float* in_out, size_t size) {
    while (size--) {
      *in_out = Process<mode>(*in_out);
    ea7c:	vstmia	r3!, {s15}
    }
  }
  
  template<FilterMode mode>
  inline void Process(float* in_out, size_t size) {
    while (size--) {
    ea80:	bne.n	ea54 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1448>
      aux,
      size);
  
  dc_blocker_[1].set_f<FREQUENCY_DIRTY>(0.3f * f0);
  dc_blocker_[1].Process<FILTER_MODE_HIGH_PASS>(aux, size);
}
    ea82:	add	sp, #20
    ea84:	vpop	{d8-d15}
    ea88:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea8c:	vadd.f32	s9, s21, s9
        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
      } else {
        formant_phase_ += f1;
    ea90:	vstr	s15, [r0, #20]
    while (size--) {
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    ea94:	vldr	s12, [pc, #400]	; ec28 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x161c>
    ea98:	vmul.f32	s14, s3, s22
    ea9c:	vadd.f32	s4, s9, s6
    eaa0:	b.n	e8e0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12d4>
        
        if (carrier_phase_ > 1.0f) {
          carrier_phase_ = discontinuity_phase_ * 0.5f;
        }
      } else {
        formant_phase_ += f1;
    eaa2:	vstr	s21, [r0, #80]	; 0x50
    eaa6:	vmul.f32	s15, s15, s10
    eaaa:	vadd.f32	s8, s16, s8
    while (size--) {
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    eaae:	vldr	s20, [pc, #376]	; ec28 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x161c>
        
        if (carrier_phase_ > 1.0f) {
          carrier_phase_ = discontinuity_phase_ * 0.5f;
        }
      } else {
        formant_phase_ += f1;
    eab2:	vadd.f32	s9, s9, s0
    eab6:	b.n	e2d8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xccc>
    eab8:	vadd.f32	s0, s21, s0
        float discontinuity = after - before;
        this_sample += discontinuity * stmlib::ThisBlepSample(reset_time);
        next_sample += discontinuity * stmlib::NextBlepSample(reset_time);
        formant_phase_ = reset_time * f1;
      } else {
        formant_phase_ += f1;
    eabc:	vstr	s15, [r0, #48]	; 0x30
    while (size--) {
      bool reset = false;
      float reset_time = 0.0f;

      float this_sample = next_sample;
      next_sample = 0.0f;
    eac0:	vldr	s11, [pc, #356]	; ec28 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x161c>
    eac4:	vmul.f32	s13, s8, s22
    eac8:	vadd.f32	s12, s0, s6
    eacc:	b.n	e898 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x128c>
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eace:	vsub.f32	s13, s13, s10
    ead2:	vsub.f32	s11, s6, s10
    ead6:	vmul.f32	s14, s13, s19
    eada:	vdiv.f32	s13, s14, s11
    eade:	vadd.f32	s13, s13, s19
    eae2:	b.n	e9ec <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x13e0>
    eae4:	vsub.f32	s14, s14, s9
    eae8:	vsub.f32	s10, s6, s9
    eaec:	vmul.f32	s13, s14, s19
    eaf0:	vdiv.f32	s14, s13, s10
      }
      phase += 0.75f;
    eaf4:	vmov.f32	s13, #104	; 0x3f400000  0.750
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eaf8:	vadd.f32	s14, s14, s19
      }
      phase += 0.75f;
    eafc:	vadd.f32	s14, s14, s13
    eb00:	b.n	e4b4 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xea8>
    eb02:	vmov.f32	s9, #104	; 0x3f400000  0.750
    eb06:	vadd.f32	s13, s13, s9
    eb0a:	vcvt.s32.f32	s9, s13
    eb0e:	vcvt.f32.s32	s9, s9
    eb12:	vsub.f32	s13, s13, s9
    eb16:	vmul.f32	s9, s13, s1
    eb1a:	b.n	e94c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1340>
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eb1c:	vsub.f32	s11, s6, s7
    eb20:	vmul.f32	s7, s11, s19
    eb24:	vdiv.f32	s12, s7, s11
      }
      phase += 0.75f;
    eb28:	vmov.f32	s11, #104	; 0x3f400000  0.750
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eb2c:	vadd.f32	s12, s12, s19
      }
      phase += 0.75f;
    eb30:	vadd.f32	s12, s12, s11
    eb34:	b.n	e764 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1158>
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eb36:	vsub.f32	s9, s6, s7
    eb3a:	vmul.f32	s7, s9, s19
    eb3e:	vdiv.f32	s13, s7, s9
    eb42:	vadd.f32	s13, s13, s19
    eb46:	b.n	e934 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1328>
    eb48:	vsub.f32	s10, s18, s11
    eb4c:	vsub.f32	s11, s6, s11
    eb50:	vmul.f32	s10, s10, s19
    eb54:	vdiv.f32	s12, s10, s11
      }
      phase += 0.75f;
    eb58:	vmov.f32	s11, #104	; 0x3f400000  0.750
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eb5c:	vadd.f32	s12, s12, s19
      }
      phase += 0.75f;
    eb60:	vadd.f32	s12, s12, s11
    eb64:	b.n	e7b8 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11ac>
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eb66:	vsub.f32	s4, s18, s7
    eb6a:	vsub.f32	s7, s6, s7
    eb6e:	vmul.f32	s4, s4, s19
    eb72:	vdiv.f32	s13, s4, s7
      }
      phase += 0.75f;
    eb76:	vmov.f32	s7, #104	; 0x3f400000  0.750
    } else if (shape_integral == 1) {
      float breakpoint = 0.001f + 0.499f * t * t * t;
      if (phase < breakpoint) {
        phase *= (0.5f / breakpoint);
      } else {
        phase = 0.5f + (phase - breakpoint) * 0.5f / (1.0f - breakpoint);
    eb7a:	vadd.f32	s13, s13, s19
      }
      phase += 0.75f;
    eb7e:	vadd.f32	s13, s13, s7
    eb82:	b.n	e80e <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1202>
    eb84:	vldr	s15, [pc, #160]	; ec28 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x161c>
    eb88:	vstr	s15, [sp]
    eb8c:	b.w	d76c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x160>

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    eb90:	vldr	s14, [pc, #164]	; ec38 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x162c>
    eb94:	vcmpe.f32	s15, s14
    eb98:	vmrs	APSR_nzcv, fpscr
    eb9c:	ble.n	eba6 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x159a>
    eb9e:	movs	r2, #0
    eba0:	movs	r4, #255	; 0xff
    eba2:	b.w	deaa <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x89e>
    eba6:	vldr	s14, [pc, #148]	; ec3c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1630>
    ebaa:	vadd.f32	s15, s15, s14
    ebae:	vcvt.s32.f32	s14, s15
    ebb2:	vmov	r4, s14
    ebb6:	vcvt.f32.s32	s14, s14
    ebba:	vsub.f32	s15, s15, s14
    ebbe:	vmov.f32	s14, s15
    ebc2:	vcvt.s32.f32	s14, s14, #8
    ebc6:	vmov	r2, s14
    ebca:	b.w	deaa <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x89e>
    ebce:	vldr	s14, [pc, #108]	; ec3c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1630>
    ebd2:	vadd.f32	s15, s15, s14
    ebd6:	vcvt.s32.f32	s14, s15
    ebda:	vmov	r4, s14
    ebde:	vcvt.f32.s32	s14, s14
    ebe2:	vsub.f32	s15, s15, s14
    ebe6:	vmov.f32	s14, s15
    ebea:	vcvt.s32.f32	s14, s14, #8
    ebee:	vmov	r2, s14
    ebf2:	b.w	d6e0 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd4>
    ebf6:	vldr	s14, [pc, #68]	; ec3c <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1630>
    ebfa:	vadd.f32	s15, s15, s14
    ebfe:	vcvt.s32.f32	s14, s15
    ec02:	vmov	r4, s14
    ec06:	vcvt.f32.s32	s14, s14
    ec0a:	vsub.f32	s15, s15, s14
    ec0e:	vmov.f32	s14, s15
    ec12:	vcvt.s32.f32	s14, s14, #8
    ec16:	vmov	r2, s14
    ec1a:	b.w	d654 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48>
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    ec1e:	vstr	s7, [r0, #116]	; 0x74
    gi_ = 1.0f / (1.0f + g_);
    ec22:	vstr	s3, [r0, #120]	; 0x78
    ec26:	b.n	ea82 <plaits::GrainEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1476>
    ec28:	.word	0x00000000
    ec2c:	.word	0x3ea8f5c3
    ec30:	.word	0x3f3fdf3b
    ec34:	.word	0x3a83126f
    ec38:	.word	0x42fe0000
    ec3c:	.word	0x43000000

0000ec40 <plaits::SwarmEngine::Init(stmlib::BufferAllocator*)>:
 public:
  SwarmVoice() { }
  ~SwarmVoice() { }
  
  void Init(float rank) {
    rank_ = rank;
    ec40:	vmov.f32	s14, #8	; 0x40400000  3.0
  GrainEnvelope() { }
  ~GrainEnvelope() { }
  
  void Init() {
    from_ = 0.0f;
    interval_ = 1.0f;
    ec44:	mov.w	r1, #1065353216	; 0x3f800000
using namespace std;
using namespace stmlib;

void SwarmEngine::Init(BufferAllocator* allocator) {
  const float n = (kNumSwarmVoices - 1) / 2;
  for (int i = 0; i < kNumSwarmVoices; ++i) {
    ec48:	movs	r2, #0
 public:
  GrainEnvelope() { }
  ~GrainEnvelope() { }
  
  void Init() {
    from_ = 0.0f;
    ec4a:	movs	r3, #0
namespace plaits {

using namespace std;
using namespace stmlib;

void SwarmEngine::Init(BufferAllocator* allocator) {
    ec4c:	push	{r4, r5}
    interval_ = 1.0f;
    phase_ = 1.0f;
    fm_ = 0.0f;
    amplitude_ = 0.5f;
    ec4e:	mov.w	r5, #1056964608	; 0x3f000000
  ~AdditiveSawOscillator() { }

  inline void Init() {
    phase_ = 0.0f;
    next_sample_ = 0.0f;
    frequency_ = 0.01f;
    ec52:	ldr	r4, [pc, #80]	; (eca4 <plaits::SwarmEngine::Init(stmlib::BufferAllocator*)+0x64>)
 public:
  SwarmVoice() { }
  ~SwarmVoice() { }
  
  void Init(float rank) {
    rank_ = rank;
    ec54:	vmov	s15, r2
  const float n = (kNumSwarmVoices - 1) / 2;
  for (int i = 0; i < kNumSwarmVoices; ++i) {
    ec58:	adds	r2, #1
 public:
  GrainEnvelope() { }
  ~GrainEnvelope() { }
  
  void Init() {
    from_ = 0.0f;
    ec5a:	str	r3, [r0, #20]
    ec5c:	adds	r0, #64	; 0x40
 public:
  SwarmVoice() { }
  ~SwarmVoice() { }
  
  void Init(float rank) {
    rank_ = rank;
    ec5e:	vcvt.f32.s32	s15, s15
    ec62:	cmp	r2, #8
  GrainEnvelope() { }
  ~GrainEnvelope() { }
  
  void Init() {
    from_ = 0.0f;
    interval_ = 1.0f;
    ec64:	str.w	r1, [r0, #-40]
    phase_ = 1.0f;
    ec68:	str.w	r1, [r0, #-36]
 public:
  SwarmVoice() { }
  ~SwarmVoice() { }
  
  void Init(float rank) {
    rank_ = rank;
    ec6c:	vsub.f32	s15, s15, s14
  
  void Init() {
    from_ = 0.0f;
    interval_ = 1.0f;
    phase_ = 1.0f;
    fm_ = 0.0f;
    ec70:	str.w	r3, [r0, #-32]
    amplitude_ = 0.5f;
    ec74:	str.w	r5, [r0, #-28]
    previous_size_ratio_ = 0.0f;
    ec78:	str.w	r3, [r0, #-24]
 public:
  SwarmVoice() { }
  ~SwarmVoice() { }
  
  void Init(float rank) {
    rank_ = rank;
    ec7c:	vdiv.f32	s13, s15, s14
 public:
  AdditiveSawOscillator() { }
  ~AdditiveSawOscillator() { }

  inline void Init() {
    phase_ = 0.0f;
    ec80:	str.w	r3, [r0, #-16]
    next_sample_ = 0.0f;
    ec84:	str.w	r3, [r0, #-12]
    frequency_ = 0.01f;
    ec88:	str.w	r4, [r0, #-8]
    gain_ = 0.0f;
    ec8c:	str.w	r3, [r0, #-4]
 public:
  FastSineOscillator() { }
  ~FastSineOscillator() { }

  void Init() {
    x_ = 1.0f;
    ec90:	str	r1, [r0, #0]
    y_ = 0.0f;
    ec92:	str	r3, [r0, #4]
    epsilon_ = 0.0f;
    ec94:	str	r3, [r0, #8]
    amplitude_ = 0.0f;
    ec96:	str	r3, [r0, #12]
 public:
  SwarmVoice() { }
  ~SwarmVoice() { }
  
  void Init(float rank) {
    rank_ = rank;
    ec98:	vstr	s13, [r0, #-48]	; 0xffffffd0
    ec9c:	bne.n	ec54 <plaits::SwarmEngine::Init(stmlib::BufferAllocator*)+0x14>
    float rank = (static_cast<float>(i) - n) / n;
    swarm_voice_[i].Init(rank);
  }
}
    ec9e:	pop	{r4, r5}
    eca0:	bx	lr
    eca2:	nop
    eca4:	.word	0x3c23d70a

0000eca8 <plaits::SwarmEngine::Reset()>:

void SwarmEngine::Reset() { }
    eca8:	bx	lr
    ecaa:	nop

0000ecac <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    ecac:	vmov.f32	s13, #34	; 0x41100000  9.0
    ecb0:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    ecb4:	vldr	s14, [pc, #856]	; f010 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x364>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    ecb8:	vsub.f32	s15, s15, s13
void SwarmEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    ecbc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    ecc0:	vcmpe.f32	s15, s14
    ecc4:	mov	r9, r3
    ecc6:	vpush	{d8-d13}
    ecca:	vmrs	APSR_nzcv, fpscr
    ecce:	sub	sp, #12
    ecd0:	ldr	r7, [sp, #96]	; 0x60
    ecd2:	bmi.n	ecea <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e>
    ecd4:	vldr	s14, [pc, #828]	; f014 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x368>
    ecd8:	vcmpe.f32	s15, s14
    ecdc:	vmrs	APSR_nzcv, fpscr
    ece0:	ble.w	f2f0 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x644>
    ece4:	movs	r3, #0
    ece6:	movs	r4, #255	; 0xff
    ece8:	b.n	ecee <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42>
    ecea:	movs	r3, #0
    ecec:	mov	r4, r3
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    ecee:	vmov.f32	s15, #162	; 0xc1100000 -9.0
    ecf2:	vldr	s12, [r1, #8]
    ecf6:	vldr	s13, [pc, #800]	; f018 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
    ecfa:	vmov	s14, r7

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    ecfe:	ldr.w	ip, [pc, #860]	; f05c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b0>
    ed02:	vfma.f32	s15, s12, s13
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    ed06:	ldr.w	r8, [pc, #856]	; f060 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b4>
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    ed0a:	vldr	s13, [pc, #772]	; f010 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x364>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    ed0e:	add.w	r4, ip, r4, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    ed12:	add.w	r3, r8, r3, lsl #2
    ed16:	vcvt.f32.u32	s2, s14
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    ed1a:	vldr	s14, [r4]
    ed1e:	vldr	s0, [r3]
    ed22:	vldr	s12, [pc, #760]	; f01c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x370>

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    ed26:	vcmpe.f32	s15, s13
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    ed2a:	vmul.f32	s14, s14, s0

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    ed2e:	vmrs	APSR_nzcv, fpscr
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    ed32:	vmul.f32	s0, s14, s12

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    ed36:	bmi.n	ed4e <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa2>
    ed38:	vldr	s14, [pc, #728]	; f014 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x368>
    ed3c:	vcmpe.f32	s15, s14
    ed40:	vmrs	APSR_nzcv, fpscr
    ed44:	ble.w	f2ca <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x61e>
    ed48:	movs	r3, #0
    ed4a:	movs	r4, #255	; 0xff
    ed4c:	b.n	ed52 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa6>
    ed4e:	movs	r3, #0
    ed50:	mov	r4, r3

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    ed52:	vmov.f32	s14, #112	; 0x3f800000  1.0
    ed56:	vldr	s12, [r1, #12]
    ed5a:	vldr	s9, [pc, #708]	; f020 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x374>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    ed5e:	add.w	r4, ip, r4, lsl #2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    ed62:	vldr	s15, [pc, #704]	; f024 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x378>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    ed66:	add.w	r3, r8, r3, lsl #2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    ed6a:	vsub.f32	s12, s14, s12
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
    ed6e:	vldr	s13, [r4]
    ed72:	vldr	s14, [r3]
      (1.0f - parameters.morph) * 84.0f);
  
  const bool burst_mode = !(parameters.trigger & TRIGGER_UNPATCHED);
  const bool start_burst = parameters.trigger & TRIGGER_RISING_EDGE;

  fill(&out[0], &out[size], 0.0f);
    ed76:	lsls	r5, r7, #2
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
    ed78:	vldr	s10, [pc, #672]	; f01c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x370>
  const float spread = parameters.harmonics * parameters.harmonics * \
      parameters.harmonics;
  float size_ratio = 0.25f * SemitonesToRatio(
      (1.0f - parameters.morph) * 84.0f);
    ed7c:	vmov.f32	s11, #80	; 0x3e800000  0.250
    ed80:	vfma.f32	s15, s12, s9
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
    ed84:	vldr	s16, [pc, #672]	; f028 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37c>
    ed88:	vmul.f32	s14, s13, s14
  const float spread = parameters.harmonics * parameters.harmonics * \
      parameters.harmonics;
  float size_ratio = 0.25f * SemitonesToRatio(
      (1.0f - parameters.morph) * 84.0f);
  
  const bool burst_mode = !(parameters.trigger & TRIGGER_UNPATCHED);
    ed8c:	ldrb	r3, [r1, #0]
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
  const float spread = parameters.harmonics * parameters.harmonics * \
    ed8e:	vldr	s12, [r1, #16]
      (1.0f - parameters.morph) * 84.0f);
  
  const bool burst_mode = !(parameters.trigger & TRIGGER_UNPATCHED);
  const bool start_burst = parameters.trigger & TRIGGER_RISING_EDGE;

  fill(&out[0], &out[size], 0.0f);
    ed92:	adds	r4, r2, r5
    ed94:	and.w	sl, r3, #2
    ed98:	and.w	r3, r3, #1
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
    ed9c:	vmul.f32	s14, s14, s10
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    eda0:	cmp	r2, r4
    eda2:	uxtb.w	r1, sl
  const float spread = parameters.harmonics * parameters.harmonics * \
      parameters.harmonics;
    eda6:	vmul.f32	s1, s12, s12
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    edaa:	vcvt.s32.f32	s13, s15
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
    edae:	vmul.f32	s16, s14, s16
    edb2:	str	r1, [sp, #4]
  const float spread = parameters.harmonics * parameters.harmonics * \
      parameters.harmonics;
    edb4:	vmul.f32	s1, s1, s12

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    edb8:	vcvt.f32.s32	s14, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    edbc:	vmov	r1, s13
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  const float control_rate = static_cast<float>(size);
  const float density = NoteToFrequency(parameters.timbre * 120.0f) * \
      0.025f * control_rate;
    edc0:	vmul.f32	s16, s16, s2
    edc4:	add.w	r1, ip, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    edc8:	vsub.f32	s15, s15, s14
  const float spread = parameters.harmonics * parameters.harmonics * \
      parameters.harmonics;
  float size_ratio = 0.25f * SemitonesToRatio(
      (1.0f - parameters.morph) * 84.0f);
    edcc:	vldr	s3, [r1]
    edd0:	vcvt.s32.f32	s15, s15, #8
    edd4:	vmov	r1, s15
    edd8:	add.w	r1, r8, r1, lsl #2
    eddc:	vldr	s15, [r1]
    ede0:	vmul.f32	s15, s15, s3
    ede4:	vmul.f32	s3, s15, s11
    ede8:	beq.n	edf6 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x14a>
    edea:	mov	r1, r2
	*__first = __tmp;
    edec:	movs	r6, #0
    edee:	str.w	r6, [r1], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    edf2:	cmp	r4, r1
    edf4:	bne.n	edee <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x142>
  
  const bool burst_mode = !(parameters.trigger & TRIGGER_UNPATCHED);
  const bool start_burst = parameters.trigger & TRIGGER_RISING_EDGE;

  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
    edf6:	add.w	r4, r9, r5
    edfa:	cmp	r9, r4
    edfc:	beq.n	ee0a <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x15e>
    edfe:	mov	r1, r9
	*__first = __tmp;
    ee00:	movs	r5, #0
    ee02:	str.w	r5, [r1], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    ee06:	cmp	r1, r4
    ee08:	bne.n	ee02 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x156>
    ee0a:	ldr	r1, [pc, #544]	; (f02c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x380>)
      phase_ = 0.5f;
      fm_ = 16.0f;
      randomize = true;
    } else {
      phase_ += rate * fm_;
      if (phase_ >= 1.0f) {
    ee0c:	vmov.f32	s8, #112	; 0x3f800000  1.0
    ee10:	add.w	lr, r7, #4294967295
    ee14:	mov.w	sl, #0
    ee18:	add.w	fp, r0, #512	; 0x200
    ee1c:	ldr	r1, [r1, #0]
      }
    }
    
    if (randomize) {
      from_ += interval_;
      interval_ = stmlib::Random::GetFloat() - from_;
    ee1e:	vldr	s17, [pc, #528]	; f030 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x384>
      // Randomize the duration of the grain.
      if (burst_mode) {
        fm_ *= 0.8f + 0.2f * stmlib::Random::GetFloat();
    ee22:	vldr	s19, [pc, #528]	; f034 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x388>
    ee26:	vldr	s18, [pc, #528]	; f038 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x38c>
  
  inline float amplitude(float size_ratio) {
    float target_amplitude = 1.0f;
    if (size_ratio >= 1.0f) {
      float phase = (phase_ - 0.5f) * size_ratio;
      CONSTRAIN(phase, -1.0f, 1.0f);
    ee2a:	vldr	s4, [pc, #584]	; f074 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>
    ee2e:	vldr	s20, [pc, #524]	; f03c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x390>
    previous_size_ratio_ = 0.0f;
  }
  
  inline void Step(float rate, bool burst_mode, bool start_burst) {
    bool randomize = false;
    if (start_burst) {
    ee32:	cmp	r3, #0
    ee34:	beq.w	f202 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x556>
      phase_ = 0.5f;
    ee38:	mov.w	r5, #1056964608	; 0x3f000000
      fm_ = 16.0f;
    ee3c:	mov.w	r4, #1098907648	; 0x41800000
  }
  
  inline void Step(float rate, bool burst_mode, bool start_burst) {
    bool randomize = false;
    if (start_burst) {
      phase_ = 0.5f;
    ee40:	str	r5, [r0, #28]
      fm_ = 16.0f;
    ee42:	str	r4, [r0, #32]
    ee44:	ldr	r5, [pc, #504]	; (f040 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x394>)
    ee46:	ldr	r4, [pc, #508]	; (f044 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x398>)
    ee48:	mul.w	r1, r5, r1
        randomize = true;
      }
    }
    
    if (randomize) {
      from_ += interval_;
    ee4c:	vldr	s14, [r0, #20]
    ee50:	vldr	s15, [r0, #24]
    ee54:	add	r4, r1
      interval_ = stmlib::Random::GetFloat() - from_;
      // Randomize the duration of the grain.
      if (burst_mode) {
    ee56:	ldr	r1, [sp, #4]
        randomize = true;
      }
    }
    
    if (randomize) {
      from_ += interval_;
    ee58:	vadd.f32	s15, s14, s15
      interval_ = stmlib::Random::GetFloat() - from_;
    ee5c:	vmov	s14, r4
    ee60:	vcvt.f32.u32	s14, s14
        randomize = true;
      }
    }
    
    if (randomize) {
      from_ += interval_;
    ee64:	vstr	s15, [r0, #20]
      interval_ = stmlib::Random::GetFloat() - from_;
    ee68:	vfnms.f32	s15, s14, s17
    ee6c:	vstr	s15, [r0, #24]
      // Randomize the duration of the grain.
      if (burst_mode) {
    ee70:	cmp	r1, #0
    ee72:	beq.w	f230 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x584>
    ee76:	mul.w	r4, r5, r4
    ee7a:	ldr	r1, [pc, #456]	; (f044 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x398>)
        fm_ *= 0.8f + 0.2f * stmlib::Random::GetFloat();
      } else {
        fm_ = 0.5f + 1.5f * stmlib::Random::GetFloat();
    ee7c:	vmov.f32	s13, #120	; 0x3fc00000  1.5
    ee80:	mov.w	sl, #1
    ee84:	add	r1, r4
    ee86:	vmov.f32	s15, #96	; 0x3f000000  0.5
    ee8a:	vmov	s14, r1
    ee8e:	vcvt.f32.u32	s14, s14
    ee92:	vmul.f32	s14, s14, s17
    ee96:	vfma.f32	s15, s14, s13
    ee9a:	vstr	s15, [r0, #32]
    }
  }
  
  inline float amplitude(float size_ratio) {
    float target_amplitude = 1.0f;
    if (size_ratio >= 1.0f) {
    ee9e:	vcmpe.f32	s3, s8
    eea2:	vmrs	APSR_nzcv, fpscr
    eea6:	blt.w	f22a <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x57e>
      float phase = (phase_ - 0.5f) * size_ratio;
    eeaa:	vmov.f32	s13, #96	; 0x3f000000  0.5
    eeae:	vldr	s15, [r0, #28]
      CONSTRAIN(phase, -1.0f, 1.0f);
    eeb2:	vmov.f32	s14, #240	; 0xbf800000 -1.0
  }
  
  inline float amplitude(float size_ratio) {
    float target_amplitude = 1.0f;
    if (size_ratio >= 1.0f) {
      float phase = (phase_ - 0.5f) * size_ratio;
    eeb6:	vsub.f32	s15, s15, s13
    eeba:	vmul.f32	s15, s15, s3
      CONSTRAIN(phase, -1.0f, 1.0f);
    eebe:	vcmpe.f32	s15, s14
    eec2:	vmrs	APSR_nzcv, fpscr
    eec6:	bmi.n	eed4 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x228>
    eec8:	vcmpe.f32	s15, s8
    eecc:	vmrs	APSR_nzcv, fpscr
    eed0:	ble.w	f292 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e6>
    eed4:	movw	r6, #3076	; 0xc04
    eed8:	mov.w	r5, #3072	; 0xc00
    eedc:	vldr	s13, [pc, #404]	; f074 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    eee0:	ldr	r4, [pc, #356]	; (f048 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x39c>)
      float e = stmlib::InterpolateWrap(
          lut_sine, 0.5f * phase + 1.25f, 1024.0f);
      target_amplitude = 0.5f * (e + 1.0f);
    eee2:	vmov.f32	s14, #96	; 0x3f000000  0.5
    eee6:	add	r5, r4
  float b = table[index_integral + 1];
    eee8:	add	r4, r6

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    eeea:	vldr	s15, [r5]
    eeee:	vldr	s12, [r4]
    eef2:	vsub.f32	s12, s12, s15
    eef6:	vfma.f32	s15, s12, s13
    eefa:	vadd.f32	s15, s15, s8
    eefe:	vmul.f32	s15, s15, s14
    }
    
    if ((size_ratio >= 1.0f) ^ (previous_size_ratio_ >= 1.0f)) {
    ef02:	vcmpe.f32	s3, s8
    ef06:	vldr	s14, [r0, #40]	; 0x28
    ef0a:	vmrs	APSR_nzcv, fpscr
    ef0e:	vcmpe.f32	s14, s8
    ef12:	ite	ge
    ef14:	movge	r5, #1
    ef16:	movlt	r5, #0
    ef18:	vmrs	APSR_nzcv, fpscr
    ef1c:	ite	ge
    ef1e:	movge	r4, #1
    ef20:	movlt	r4, #0
    ef22:	cmp	r5, r4
    ef24:	beq.w	f25e <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5b2>
    ef28:	vldr	s13, [pc, #288]	; f04c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a0>
    ef2c:	vldr	s14, [pc, #288]	; f050 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a4>
      filter_coefficient_ = 0.5f;
    }
    filter_coefficient_ *= 0.95f;
    
    previous_size_ratio_ = size_ratio;
    ONE_POLE(amplitude_, target_amplitude, 0.5f - filter_coefficient_);
    ef30:	vldr	s7, [r0, #36]	; 0x24
  
  inline float frequency(float size_ratio) const {
    // We approximate two overlapping grains of frequencies f1 and f2
    // By a continuous tone ramping from f1 to f2. This allows a continuous
    // transition between the "grain cloud" and "swarm of glissandi" textures.
    if (size_ratio < 1.0f) {
    ef34:	vcmpe.f32	s3, s8
      float* sine,
      size_t size) {
    envelope_.Step(density, burst_mode, start_burst);
    
    const float scale = 1.0f / kNumSwarmVoices;
    const float amplitude = envelope_.amplitude(size_ratio) * scale;
    ef38:	vmov.f32	s12, #64	; 0x3e000000  0.125
    }
    
    if ((size_ratio >= 1.0f) ^ (previous_size_ratio_ >= 1.0f)) {
      filter_coefficient_ = 0.5f;
    }
    filter_coefficient_ *= 0.95f;
    ef3c:	vstr	s14, [r0, #44]	; 0x2c
    
    previous_size_ratio_ = size_ratio;
    ONE_POLE(amplitude_, target_amplitude, 0.5f - filter_coefficient_);
    ef40:	vsub.f32	s15, s15, s7
    if ((size_ratio >= 1.0f) ^ (previous_size_ratio_ >= 1.0f)) {
      filter_coefficient_ = 0.5f;
    }
    filter_coefficient_ *= 0.95f;
    
    previous_size_ratio_ = size_ratio;
    ef44:	vstr	s3, [r0, #40]	; 0x28
  
  inline float frequency(float size_ratio) const {
    // We approximate two overlapping grains of frequencies f1 and f2
    // By a continuous tone ramping from f1 to f2. This allows a continuous
    // transition between the "grain cloud" and "swarm of glissandi" textures.
    if (size_ratio < 1.0f) {
    ef48:	vmrs	APSR_nzcv, fpscr
      filter_coefficient_ = 0.5f;
    }
    filter_coefficient_ *= 0.95f;
    
    previous_size_ratio_ = size_ratio;
    ONE_POLE(amplitude_, target_amplitude, 0.5f - filter_coefficient_);
    ef4c:	vfma.f32	s7, s15, s13
    ef50:	vstr	s7, [r0, #36]	; 0x24
      float* sine,
      size_t size) {
    envelope_.Step(density, burst_mode, start_burst);
    
    const float scale = 1.0f / kNumSwarmVoices;
    const float amplitude = envelope_.amplitude(size_ratio) * scale;
    ef54:	vmul.f32	s7, s7, s12
  
  inline float frequency(float size_ratio) const {
    // We approximate two overlapping grains of frequencies f1 and f2
    // By a continuous tone ramping from f1 to f2. This allows a continuous
    // transition between the "grain cloud" and "swarm of glissandi" textures.
    if (size_ratio < 1.0f) {
    ef58:	bmi.w	f274 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5c8>
      return 2.0f * (from_ + interval_ * phase_) - 1.0f;
    } else {
      return from_;
    ef5c:	vldr	s6, [r0, #20]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    ef60:	vldr	s15, [pc, #240]	; f054 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a8>

    const float expo_amount = envelope_.frequency(size_ratio);
    f0 *= stmlib::SemitonesToRatio(48.0f * expo_amount * spread * rank_);
    
    const float linear_amount = rank_ * (rank_ + 0.01f) * spread * 0.25f;
    f0 *= 1.0f + linear_amount;
    ef64:	vmov.f32	s5, #80	; 0x3e800000  0.250
    
    const float scale = 1.0f / kNumSwarmVoices;
    const float amplitude = envelope_.amplitude(size_ratio) * scale;

    const float expo_amount = envelope_.frequency(size_ratio);
    f0 *= stmlib::SemitonesToRatio(48.0f * expo_amount * spread * rank_);
    ef68:	vldr	s12, [r0, #16]
    ef6c:	vmul.f32	s6, s6, s15
    ef70:	vldr	s13, [pc, #176]	; f024 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x378>
    
    const float linear_amount = rank_ * (rank_ + 0.01f) * spread * 0.25f;
    f0 *= 1.0f + linear_amount;
    ef74:	vldr	s11, [pc, #224]	; f058 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ac>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    ef78:	vldr	s10, [r0, #56]	; 0x38
    ef7c:	vmul.f32	s6, s6, s1
    ef80:	vldr	s9, [r0, #60]	; 0x3c
    ef84:	vadd.f32	s11, s12, s11
      frequency = kMaxFrequency;
    }
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);
    stmlib::ParameterInterpolator gain(&gain_, level, size);

    float next_sample = next_sample_;
    ef88:	vldr	s14, [r0, #52]	; 0x34
    increment_ = (new_value - *state) / static_cast<float>(size);
    ef8c:	vsub.f32	s22, s7, s9
    float phase = phase_;
    ef90:	vldr	s15, [r0, #48]	; 0x30
    ef94:	vfma.f32	s13, s6, s12

    const float expo_amount = envelope_.frequency(size_ratio);
    f0 *= stmlib::SemitonesToRatio(48.0f * expo_amount * spread * rank_);
    
    const float linear_amount = rank_ * (rank_ + 0.01f) * spread * 0.25f;
    f0 *= 1.0f + linear_amount;
    ef98:	vmul.f32	s12, s11, s12
    ef9c:	vdiv.f32	s21, s22, s2
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    efa0:	vcvt.s32.f32	s6, s13
    efa4:	vmul.f32	s11, s12, s1

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    efa8:	vcvt.f32.s32	s12, s6

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    efac:	vmov	r4, s6
    efb0:	vmov.f32	s6, s8
    efb4:	add.w	r4, ip, r4, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    efb8:	vsub.f32	s13, s13, s12
    efbc:	vfma.f32	s6, s11, s5
    efc0:	vldr	s11, [r4]
    efc4:	vcvt.s32.f32	s13, s13, #8
    efc8:	vmov	r4, s13
    efcc:	add.w	r4, r8, r4, lsl #2
    efd0:	vldr	s13, [r4]
    efd4:	vmul.f32	s13, s13, s11
    efd8:	vmul.f32	s13, s13, s0
    efdc:	vmul.f32	s6, s13, s6
  inline void Render(
      float frequency,
      float level,
      float* out,
      size_t size) {
    if (frequency >= kMaxFrequency) {
    efe0:	vcmpe.f32	s6, s5
    efe4:	vmrs	APSR_nzcv, fpscr
    efe8:	it	lt
    efea:	vmovlt.f32	s5, s6
    efee:	vsub.f32	s5, s5, s10
    eff2:	vdiv.f32	s22, s5, s2
    stmlib::ParameterInterpolator gain(&gain_, level, size);

    float next_sample = next_sample_;
    float phase = phase_;

    while (size--) {
    eff6:	cmp	r7, #0
    eff8:	beq.n	f0d6 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42a>
    effa:	mov	r5, r2
    effc:	mov	r4, lr
      phase += frequency;
  
      if (phase >= 1.0f) {
        phase -= 1.0f;
        float t = phase / frequency;
        this_sample -= stmlib::ThisBlepSample(t);
    effe:	vmov.f32	s26, #96	; 0x3f000000  0.5
        next_sample -= stmlib::NextBlepSample(t);
    f002:	vmov.f32	s25, #224	; 0xbf000000 -0.5
      }

      next_sample += phase;
      *out++ += (2.0f * this_sample - 1.0f) * gain.Next();
    f006:	vmov.f32	s24, #0	; 0x40000000  2.0
    f00a:	vmov.f32	s23, #240	; 0xbf800000 -1.0
    f00e:	b.n	f0be <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x412>
    f010:	.word	0xc3000000
    f014:	.word	0x42fe0000
    f018:	.word	0x42f00000
    f01c:	.word	0x39962fc9
    f020:	.word	0x42a80000
    f024:	.word	0x43000000
    f028:	.word	0x3ccccccd
    f02c:	.word	0x20020470
    f030:	.word	0x2f800000
    f034:	.word	0x3e4ccccd
    f038:	.word	0x3f4ccccd
    f03c:	.word	0x44800000
    f040:	.word	0x0019660d
    f044:	.word	0x3c6ef35f
    f048:	.word	0x20002b10
    f04c:	.word	0x3cccccd0
    f050:	.word	0x3ef33333
    f054:	.word	0x42400000
    f058:	.word	0x3c23d70a
    f05c:	.word	0x20000554
    f060:	.word	0x20000958
    f064:	.word	0x40490fdb
    f068:	.word	0x3ea3d70a
    f06c:	.word	0x3f7851ec
    f070:	.word	0x3fb537c9
    f074:	.word	0x00000000
      const float frequency = fm.Next();

      phase += frequency;
  
      if (phase >= 1.0f) {
        phase -= 1.0f;
    f078:	vsub.f32	s15, s15, s8
        float t = phase / frequency;
    f07c:	vdiv.f32	s13, s15, s10
    f080:	vsub.f32	s12, s8, s13
        this_sample -= stmlib::ThisBlepSample(t);
    f084:	vmul.f32	s5, s13, s26
        next_sample -= stmlib::NextBlepSample(t);
    f088:	vmul.f32	s11, s12, s25
      phase += frequency;
  
      if (phase >= 1.0f) {
        phase -= 1.0f;
        float t = phase / frequency;
        this_sample -= stmlib::ThisBlepSample(t);
    f08c:	vfms.f32	s14, s13, s5
        next_sample -= stmlib::NextBlepSample(t);
    f090:	vmov.f32	s13, s4
    f094:	vfms.f32	s13, s12, s11
    f098:	vmov.f32	s11, s13
      }

      next_sample += phase;
      *out++ += (2.0f * this_sample - 1.0f) * gain.Next();
    f09c:	vmov.f32	s12, s23
    f0a0:	vldmia	r5!, {s13}
  }

  inline float Next() {
    value_ += increment_;
    f0a4:	vadd.f32	s9, s9, s21
    stmlib::ParameterInterpolator gain(&gain_, level, size);

    float next_sample = next_sample_;
    float phase = phase_;

    while (size--) {
    f0a8:	subs	r4, #1
        this_sample -= stmlib::ThisBlepSample(t);
        next_sample -= stmlib::NextBlepSample(t);
      }

      next_sample += phase;
      *out++ += (2.0f * this_sample - 1.0f) * gain.Next();
    f0aa:	vfma.f32	s12, s14, s24
    stmlib::ParameterInterpolator gain(&gain_, level, size);

    float next_sample = next_sample_;
    float phase = phase_;

    while (size--) {
    f0ae:	adds	r6, r4, #1
        float t = phase / frequency;
        this_sample -= stmlib::ThisBlepSample(t);
        next_sample -= stmlib::NextBlepSample(t);
      }

      next_sample += phase;
    f0b0:	vadd.f32	s14, s11, s15
      *out++ += (2.0f * this_sample - 1.0f) * gain.Next();
    f0b4:	vfma.f32	s13, s12, s9
    f0b8:	vstr	s13, [r5, #-4]
    stmlib::ParameterInterpolator gain(&gain_, level, size);

    float next_sample = next_sample_;
    float phase = phase_;

    while (size--) {
    f0bc:	beq.n	f0d6 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42a>
    f0be:	vadd.f32	s10, s10, s22
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();

      phase += frequency;
    f0c2:	vadd.f32	s15, s15, s10
  
      if (phase >= 1.0f) {
    f0c6:	vcmpe.f32	s15, s8
    f0ca:	vmrs	APSR_nzcv, fpscr
    f0ce:	bge.n	f078 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3cc>
    float next_sample = next_sample_;
    float phase = phase_;

    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
    f0d0:	vldr	s11, [pc, #-96]	; f074 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>
    f0d4:	b.n	f09c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f0>
  
 private:
  template<bool additive>
  void RenderInternal(
      float frequency, float amplitude, float* out, size_t size) {
    if (frequency >= 0.25f) {
    f0d6:	vmov.f32	s13, #80	; 0x3e800000  0.250
      }

      next_sample += phase;
      *out++ += (2.0f * this_sample - 1.0f) * gain.Next();
    }
    phase_ = phase;
    f0da:	vstr	s15, [r0, #48]	; 0x30
    next_sample_ = next_sample;
    f0de:	vstr	s14, [r0, #52]	; 0x34
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    f0e2:	vstr	s9, [r0, #60]	; 0x3c
    f0e6:	vcmpe.f32	s6, s13
    f0ea:	vstr	s10, [r0, #56]	; 0x38
    f0ee:	vmrs	APSR_nzcv, fpscr
    f0f2:	bge.w	f1f8 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x54c>
    f0f6:	vldr	s15, [pc, #-148]	; f064 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b8>
    f0fa:	vmov.f32	s13, #0	; 0x40000000  2.0
    f0fe:	vldr	s12, [pc, #-152]	; f068 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3bc>
      frequency = 0.25f;
      amplitude = 0.0f;
    } else {
      amplitude *= 1.0f - frequency * 4.0f;
    f102:	vmov.f32	s14, #16	; 0x40800000  4.0
    f106:	vmul.f32	s15, s6, s15
    f10a:	vmov.f32	s11, s8
    f10e:	vmul.f32	s12, s15, s12
    f112:	vfms.f32	s11, s6, s14
    f116:	vfms.f32	s13, s15, s12
    f11a:	vmul.f32	s7, s11, s7
    f11e:	vmul.f32	s13, s13, s15
    }
    
    stmlib::ParameterInterpolator epsilon(&epsilon_, Fast2Sin(frequency), size);
    stmlib::ParameterInterpolator am(&amplitude_, amplitude, size);
    float x = x_;
    float y = y_;
    f122:	vldr	s12, [r0, #68]	; 0x44
    
    const float norm = x * x + y * y;
    if (norm <= 0.5f || norm >= 2.0f) {
    f126:	vmov.f32	s5, #96	; 0x3f000000  0.5
      amplitude *= 1.0f - frequency * 4.0f;
    }
    
    stmlib::ParameterInterpolator epsilon(&epsilon_, Fast2Sin(frequency), size);
    stmlib::ParameterInterpolator am(&amplitude_, amplitude, size);
    float x = x_;
    f12a:	vldr	s15, [r0, #64]	; 0x40
    float y = y_;
    
    const float norm = x * x + y * y;
    f12e:	vmul.f32	s6, s12, s12
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    f132:	vldr	s14, [r0, #72]	; 0x48
    f136:	vldr	s11, [r0, #76]	; 0x4c
    increment_ = (new_value - *state) / static_cast<float>(size);
    f13a:	vsub.f32	s13, s13, s14
    f13e:	vfma.f32	s6, s15, s15
    f142:	vsub.f32	s7, s7, s11
    f146:	vdiv.f32	s10, s13, s2
    if (norm <= 0.5f || norm >= 2.0f) {
    f14a:	vcmpe.f32	s6, s5
    f14e:	vdiv.f32	s9, s7, s2
    f152:	vmrs	APSR_nzcv, fpscr
    f156:	bls.n	f166 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4ba>
    f158:	vmov.f32	s13, #0	; 0x40000000  2.0
    f15c:	vcmpe.f32	s6, s13
    f160:	vmrs	APSR_nzcv, fpscr
    f164:	blt.n	f19e <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4f2>

template<typename To, typename From>
To unsafe_bit_cast(From from) {
    unsafe_bit_cast_t<To, From> u;
    u.from = from;
    return u.to;
    f166:	vmov	r4, s6
  y = x;
  i = unsafe_bit_cast<uint32_t, float>(y);
  i = 0x5f3759df - (i >> 1);
  y = unsafe_bit_cast<float, uint32_t>(i);
  x2 = x * 0.5f;
  y = y * (threehalfs - (x2 * y * y));
    f16a:	vmov.f32	s7, #96	; 0x3f000000  0.5
    f16e:	vmov.f32	s13, #120	; 0x3fc00000  1.5

template<typename To, typename From>
To unsafe_bit_cast(From from) {
    unsafe_bit_cast_t<To, From> u;
    u.from = from;
    return u.to;
    f172:	lsrs	r4, r4, #1
  y = x;
  i = unsafe_bit_cast<uint32_t, float>(y);
  i = 0x5f3759df - (i >> 1);
  y = unsafe_bit_cast<float, uint32_t>(i);
  x2 = x * 0.5f;
  y = y * (threehalfs - (x2 * y * y));
    f174:	vmul.f32	s6, s6, s7

template<typename To, typename From>
To unsafe_bit_cast(From from) {
    unsafe_bit_cast_t<To, From> u;
    u.from = from;
    return u.to;
    f178:	rsb	r4, r4, #1593835520	; 0x5f000000
    f17c:	add.w	r4, r4, #3620864	; 0x374000
    f180:	add.w	r4, r4, #6592	; 0x19c0
    f184:	adds	r4, #31
  y = x;
  i = unsafe_bit_cast<uint32_t, float>(y);
  i = 0x5f3759df - (i >> 1);
  y = unsafe_bit_cast<float, uint32_t>(i);
  x2 = x * 0.5f;
  y = y * (threehalfs - (x2 * y * y));
    f186:	vmov	s7, r4
    f18a:	vmul.f32	s6, s6, s7
    f18e:	vfms.f32	s13, s7, s6
    f192:	vmul.f32	s13, s13, s7
      const float scale = stmlib::fast_rsqrt_carmack(norm);
      x *= scale;
    f196:	vmul.f32	s15, s15, s13
      y *= scale;
    f19a:	vmul.f32	s12, s12, s13
    }
    
    while (size--) {
    f19e:	cbz	r7, f1c6 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x51a>
    f1a0:	mov	r5, r9
    f1a2:	mov	r4, lr
  }

  inline float Next() {
    value_ += increment_;
    f1a4:	vadd.f32	s14, s14, s10
      const float e = epsilon.Next();
      x += e * y;
      y -= e * x;
      if (additive) {
        *out++ += am.Next() * x;
    f1a8:	vldmia	r5!, {s13}
    f1ac:	vadd.f32	s11, s11, s9
      const float scale = stmlib::fast_rsqrt_carmack(norm);
      x *= scale;
      y *= scale;
    }
    
    while (size--) {
    f1b0:	subs	r4, #1
      const float e = epsilon.Next();
      x += e * y;
    f1b2:	vfma.f32	s15, s14, s12
      const float scale = stmlib::fast_rsqrt_carmack(norm);
      x *= scale;
      y *= scale;
    }
    
    while (size--) {
    f1b6:	adds	r6, r4, #1
      const float e = epsilon.Next();
      x += e * y;
      y -= e * x;
      if (additive) {
        *out++ += am.Next() * x;
    f1b8:	vfma.f32	s13, s15, s11
    }
    
    while (size--) {
      const float e = epsilon.Next();
      x += e * y;
      y -= e * x;
    f1bc:	vfms.f32	s12, s14, s15
      if (additive) {
        *out++ += am.Next() * x;
    f1c0:	vstr	s13, [r5, #-4]
      const float scale = stmlib::fast_rsqrt_carmack(norm);
      x *= scale;
      y *= scale;
    }
    
    while (size--) {
    f1c4:	bne.n	f1a4 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4f8>
        *out++ += am.Next() * x;
      } else {
        *out++ = x;
      }
    }
    x_ = x;
    f1c6:	vstr	s15, [r0, #64]	; 0x40
    f1ca:	adds	r0, #64	; 0x40
    y_ = y;
    f1cc:	vstr	s12, [r0, #4]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    f1d0:	vstr	s11, [r0, #12]
    f1d4:	vstr	s14, [r0, #8]
  
  for (int i = 0; i < kNumSwarmVoices; ++i) {
    f1d8:	cmp	fp, r0
        spread,
        size_ratio,
        out,
        aux,
        size);
    size_ratio *= 0.97f;
    f1da:	vldr	s15, [pc, #-368]	; f06c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
    f1de:	vmul.f32	s3, s3, s15
  const bool start_burst = parameters.trigger & TRIGGER_RISING_EDGE;

  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  for (int i = 0; i < kNumSwarmVoices; ++i) {
    f1e2:	bne.w	ee32 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x186>
    f1e6:	cmp.w	sl, #0
    f1ea:	bne.w	f316 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x66a>
        out,
        aux,
        size);
    size_ratio *= 0.97f;
  }
}
    f1ee:	add	sp, #12
    f1f0:	vpop	{d8-d13}
    f1f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  
 private:
  template<bool additive>
  void RenderInternal(
      float frequency, float amplitude, float* out, size_t size) {
    if (frequency >= 0.25f) {
    f1f8:	vldr	s13, [pc, #-396]	; f070 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c4>
      frequency = 0.25f;
      amplitude = 0.0f;
    f1fc:	vldr	s7, [pc, #-396]	; f074 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>
    f200:	b.n	f122 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x476>
    if (start_burst) {
      phase_ = 0.5f;
      fm_ = 16.0f;
      randomize = true;
    } else {
      phase_ += rate * fm_;
    f202:	vldr	s14, [r0, #32]
    f206:	vldr	s15, [r0, #28]
    f20a:	vfma.f32	s15, s16, s14
      if (phase_ >= 1.0f) {
    f20e:	vcmpe.f32	s15, s8
    f212:	vmrs	APSR_nzcv, fpscr
    f216:	blt.n	f2c4 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x618>
        phase_ -= static_cast<float>(static_cast<int>(phase_));
    f218:	vcvt.s32.f32	s14, s15
    f21c:	vcvt.f32.s32	s14, s14
    f220:	vsub.f32	s15, s15, s14
    f224:	vstr	s15, [r0, #28]
    f228:	b.n	ee44 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x198>
      return from_;
    }
  }
  
  inline float amplitude(float size_ratio) {
    float target_amplitude = 1.0f;
    f22a:	vmov.f32	s15, #112	; 0x3f800000  1.0
    f22e:	b.n	ef02 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x256>
    f230:	mul.w	r4, r5, r4
    f234:	ldr	r1, [pc, #228]	; (f31c <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x670>)
    if (randomize) {
      from_ += interval_;
      interval_ = stmlib::Random::GetFloat() - from_;
      // Randomize the duration of the grain.
      if (burst_mode) {
        fm_ *= 0.8f + 0.2f * stmlib::Random::GetFloat();
    f236:	vmov.f32	s13, s18
    f23a:	vldr	s14, [r0, #32]
    f23e:	add	r1, r4
    f240:	mov.w	sl, #1
    f244:	vmov	s15, r1
    f248:	vcvt.f32.u32	s15, s15
    f24c:	vmul.f32	s15, s15, s17
    f250:	vfma.f32	s13, s15, s19
    f254:	vmul.f32	s15, s14, s13
    f258:	vstr	s15, [r0, #32]
    f25c:	b.n	ee9e <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f2>
    f25e:	vldr	s13, [r0, #44]	; 0x2c
    f262:	vmov.f32	s12, #96	; 0x3f000000  0.5
    f266:	vldr	s14, [pc, #184]	; f320 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x674>
    f26a:	vmul.f32	s14, s13, s14
    f26e:	vsub.f32	s13, s12, s14
    f272:	b.n	ef30 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x284>
  inline float frequency(float size_ratio) const {
    // We approximate two overlapping grains of frequencies f1 and f2
    // By a continuous tone ramping from f1 to f2. This allows a continuous
    // transition between the "grain cloud" and "swarm of glissandi" textures.
    if (size_ratio < 1.0f) {
      return 2.0f * (from_ + interval_ * phase_) - 1.0f;
    f274:	vldr	s12, [r0, #24]
    f278:	vmov.f32	s14, #0	; 0x40000000  2.0
    f27c:	vldr	s13, [r0, #28]
    f280:	vmov.f32	s6, #240	; 0xbf800000 -1.0
    f284:	vldr	s15, [r0, #20]
    f288:	vfma.f32	s15, s12, s13
    f28c:	vfma.f32	s6, s15, s14
    f290:	b.n	ef60 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b4>
    f292:	vmov.f32	s14, #116	; 0x3fa00000  1.250
    f296:	vfma.f32	s14, s15, s13
    f29a:	vmov.f32	s15, s14
    f29e:	vcvt.s32.f32	s14, s14
    f2a2:	vcvt.f32.s32	s14, s14
    f2a6:	vsub.f32	s15, s15, s14
    f2aa:	vmul.f32	s15, s15, s20
    f2ae:	vcvt.s32.f32	s14, s15
    f2b2:	vmov	r4, s14
    f2b6:	vcvt.f32.s32	s13, s14
    f2ba:	lsls	r5, r4, #2
    f2bc:	vsub.f32	s13, s15, s13
    f2c0:	adds	r6, r5, #4
    f2c2:	b.n	eee0 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x234>
    if (start_burst) {
      phase_ = 0.5f;
      fm_ = 16.0f;
      randomize = true;
    } else {
      phase_ += rate * fm_;
    f2c4:	vstr	s15, [r0, #28]
    f2c8:	b.n	ee9e <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f2>
    f2ca:	vldr	s14, [pc, #88]	; f324 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x678>
    f2ce:	vadd.f32	s15, s15, s14
    f2d2:	vcvt.s32.f32	s14, s15
    f2d6:	vmov	r4, s14
    f2da:	vcvt.f32.s32	s14, s14
    f2de:	vsub.f32	s15, s15, s14
    f2e2:	vmov.f32	s14, s15
    f2e6:	vcvt.s32.f32	s14, s14, #8
    f2ea:	vmov	r3, s14
    f2ee:	b.n	ed52 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa6>
    f2f0:	vldr	s14, [pc, #48]	; f324 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x678>
    f2f4:	vadd.f32	s15, s15, s14
    f2f8:	vcvt.s32.f32	s14, s15
    f2fc:	vmov	r4, s14
    f300:	vcvt.f32.s32	s14, s14
    f304:	vsub.f32	s15, s15, s14
    f308:	vmov.f32	s14, s15
    f30c:	vcvt.s32.f32	s14, s14, #8
    f310:	vmov	r3, s14
    f314:	b.n	ecee <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42>
    f316:	ldr	r3, [pc, #16]	; (f328 <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x67c>)
    f318:	str	r1, [r3, #0]
    f31a:	b.n	f1ee <plaits::SwarmEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x542>
    f31c:	.word	0x3c6ef35f
    f320:	.word	0x3f733333
    f324:	.word	0x43000000
    f328:	.word	0x20020470

0000f32c <plaits::FMEngine::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace stmlib;

void FMEngine::Init(BufferAllocator* allocator) {
  carrier_phase_ = 0;
    f32c:	movs	r2, #0
  modulator_phase_ = 0;
  sub_phase_ = 0;

  previous_carrier_frequency_ = a0;
  previous_modulator_frequency_ = a0;
  previous_amount_ = 0.0f;
    f32e:	movs	r3, #0
void FMEngine::Init(BufferAllocator* allocator) {
  carrier_phase_ = 0;
  modulator_phase_ = 0;
  sub_phase_ = 0;

  previous_carrier_frequency_ = a0;
    f330:	ldr	r1, [pc, #16]	; (f344 <plaits::FMEngine::Init(stmlib::BufferAllocator*)+0x18>)
namespace plaits {

using namespace stmlib;

void FMEngine::Init(BufferAllocator* allocator) {
  carrier_phase_ = 0;
    f332:	str	r2, [r0, #16]
  modulator_phase_ = 0;
    f334:	str	r2, [r0, #20]
  sub_phase_ = 0;
    f336:	str	r2, [r0, #24]

  previous_carrier_frequency_ = a0;
    f338:	str	r1, [r0, #28]
  previous_modulator_frequency_ = a0;
    f33a:	str	r1, [r0, #32]
  previous_amount_ = 0.0f;
    f33c:	str	r3, [r0, #36]	; 0x24
  previous_feedback_ = 0.0f;
    f33e:	str	r3, [r0, #40]	; 0x28
  previous_sample_ = 0.0f;
    f340:	str	r3, [r0, #44]	; 0x2c
    f342:	bx	lr
    f344:	.word	0x3a962fc9

0000f348 <plaits::FMEngine::Reset()>:
}

void FMEngine::Reset() {
    f348:	bx	lr
    f34a:	nop

0000f34c <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
    f34c:	vldr	s10, [pc, #952]	; f708 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3bc>
    float* aux,
    size_t size,
    bool* already_enveloped) {
  
  // 4x oversampling
  const float note = parameters.note - 24.0f;
    f350:	vmov.f32	s12, #56	; 0x41c00000  24.0
    f354:	vldr	s13, [r1, #16]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    f358:	vmov.f32	s14, #34	; 0x41100000  9.0
    f35c:	vldr	s15, [r1, #4]
    f360:	vmul.f32	s13, s13, s10
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    f364:	vldr	s9, [pc, #864]	; f6c8 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37c>
    f368:	vsub.f32	s15, s15, s12
  MAKE_INTEGRAL_FRACTIONAL(index)
    f36c:	vcvt.s32.f32	s12, s13
void FMEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    f370:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f374:	vpush	{d8-d13}
    f378:	sub	sp, #28
  float a = table[index_integral];
    f37a:	ldr	r4, [pc, #848]	; (f6cc <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x380>)
    f37c:	mov	r8, r0
    f37e:	str	r3, [sp, #12]
    f380:	vmov	r3, s12
  const float ratio = Interpolate(
      lut_fm_frequency_quantizer,
      parameters.harmonics,
      128.0f);
  
  float modulator_note = note + ratio;
    f384:	vcvt.f32.s32	s12, s12
void FMEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    f388:	str	r2, [sp, #8]
    f38a:	lsls	r3, r3, #2
    f38c:	ldr	r5, [sp, #112]	; 0x70
    f38e:	adds	r2, r3, r4
  const float ratio = Interpolate(
      lut_fm_frequency_quantizer,
      parameters.harmonics,
      128.0f);
  
  float modulator_note = note + ratio;
    f390:	vsub.f32	s12, s13, s12
    f394:	vldr	s11, [r2, #4]
    f398:	vldr	s13, [r2]
    f39c:	vsub.f32	s11, s11, s13
    f3a0:	vfma.f32	s13, s12, s11
    f3a4:	vadd.f32	s13, s13, s15
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    f3a8:	vsub.f32	s14, s13, s14
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    f3ac:	vcmpe.f32	s14, s9
    f3b0:	vmrs	APSR_nzcv, fpscr
    f3b4:	bmi.n	f3cc <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x80>
    f3b6:	vldr	s12, [pc, #792]	; f6d0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x384>
    f3ba:	vcmpe.f32	s14, s12
    f3be:	vmrs	APSR_nzcv, fpscr
    f3c2:	ble.w	f7ae <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x462>
    f3c6:	movs	r2, #0
    f3c8:	movs	r3, #255	; 0xff
    f3ca:	b.n	f3d0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x84>
    f3cc:	movs	r2, #0
    f3ce:	mov	r3, r2

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    f3d0:	ldr	r4, [pc, #768]	; (f6d4 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x388>)
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    f3d2:	ldr	r0, [pc, #772]	; (f6d8 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x38c>)

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    f3d4:	add.w	r3, r4, r3, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    f3d8:	vldr	s11, [pc, #768]	; f6dc <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x390>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    f3dc:	add.w	r2, r0, r2, lsl #2
    f3e0:	vldr	s12, [r3]
    f3e4:	vldr	s14, [r2]
    f3e8:	vmul.f32	s14, s12, s14
    f3ec:	vmul.f32	s14, s14, s11
  float target_modulator_frequency = NoteToFrequency(modulator_note);
  CONSTRAIN(target_modulator_frequency, 0.0f, 0.5f);
    f3f0:	vcmpe.f32	s14, #0.0
    f3f4:	vmrs	APSR_nzcv, fpscr
    f3f8:	bmi.w	f7d6 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48a>
    f3fc:	vmov.f32	s12, #96	; 0x3f000000  0.5
    f400:	vcmp.f32	s14, s12
    f404:	vmrs	APSR_nzcv, fpscr
    f408:	it	gt
    f40a:	vmovgt.f32	s14, s12

  // Reduce the maximum FM index for high pitched notes, to prevent aliasing.
  float hf_taming = 1.0f - (modulator_note - 72.0f) * 0.025f;
    f40e:	vmov.f32	s12, #112	; 0x3f800000  1.0
    f412:	vldr	s10, [pc, #716]	; f6e0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x394>
    f416:	vldr	s11, [pc, #716]	; f6e4 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x398>
    f41a:	vsub.f32	s13, s13, s10
    f41e:	vmov.f32	s10, s12
    f422:	vfms.f32	s10, s13, s11
  CONSTRAIN(hf_taming, 0.0f, 1.0f);
    f426:	vcmpe.f32	s10, #0.0
    f42a:	vmrs	APSR_nzcv, fpscr
    f42e:	bmi.w	f7d0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x484>
    f432:	vcmpe.f32	s10, s12
    f436:	vmrs	APSR_nzcv, fpscr
    f43a:	ble.w	f7dc <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x490>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    f43e:	vmov.f32	s11, #34	; 0x41100000  9.0
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    f442:	vldr	s13, [pc, #644]	; f6c8 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37c>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    f446:	vsub.f32	s15, s15, s11
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    f44a:	vcmpe.f32	s15, s13
    f44e:	vmrs	APSR_nzcv, fpscr
    f452:	bmi.n	f46a <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e>
    f454:	vldr	s13, [pc, #632]	; f6d0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x384>
    f458:	vcmpe.f32	s15, s13
    f45c:	vmrs	APSR_nzcv, fpscr
    f460:	ble.w	f788 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x43c>
    f464:	movs	r3, #0
    f466:	movs	r2, #255	; 0xff
    f468:	b.n	f46e <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x122>
    f46a:	movs	r3, #0
    f46c:	mov	r2, r3
      &previous_carrier_frequency_, NoteToFrequency(note), size);
  ParameterInterpolator modulator_frequency(
      &previous_modulator_frequency_, target_modulator_frequency, size);
  ParameterInterpolator amount_modulation(
      &previous_amount_,
      2.0f * parameters.timbre * parameters.timbre * hf_taming,
    f46e:	vldr	s10, [r1, #8]

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    f472:	add.w	r4, r4, r2, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    f476:	add.w	r3, r0, r3, lsl #2
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
    f47a:	vmov.f32	s8, #0	; 0x40000000  2.0
    f47e:	vmov.f32	s15, #240	; 0xbf800000 -1.0
    f482:	vldr	s7, [r1, #12]
    f486:	vadd.f32	s13, s10, s10
    f48a:	vldr	s6, [r3]
    f48e:	vldr	s9, [r4]
    f492:	vmov	s11, r5
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    f496:	vldr	s18, [r8, #28]
    increment_ = (new_value - *state) / static_cast<float>(size);
    f49a:	vfma.f32	s15, s7, s8
    f49e:	vmul.f32	s9, s9, s6
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    f4a2:	vldr	s6, [r8, #36]	; 0x24
    increment_ = (new_value - *state) / static_cast<float>(size);
    f4a6:	vmov.f32	s8, s18
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    f4aa:	vldr	s19, [r8, #32]
    increment_ = (new_value - *state) / static_cast<float>(size);
    f4ae:	vmul.f32	s10, s13, s10
    f4b2:	vldr	s13, [pc, #552]	; f6dc <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x390>
    f4b6:	vcvt.f32.u32	s11, s11
};

class Downsampler {
 public:
  Downsampler(float* state) {
    head_ = *state;
    f4ba:	vldr	s7, [r8, #52]	; 0x34
    f4be:	vfnms.f32	s8, s9, s13
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    f4c2:	vldr	s13, [r8, #40]	; 0x28
    increment_ = (new_value - *state) / static_cast<float>(size);
    f4c6:	vsub.f32	s14, s14, s19
      &previous_feedback_, 2.0f * parameters.morph - 1.0f, size);
  
  Downsampler carrier_downsampler(&carrier_fir_);
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    f4ca:	add.w	sl, r5, #4294967295
    f4ce:	vsub.f32	s15, s15, s13
};

class Downsampler {
 public:
  Downsampler(float* state) {
    head_ = *state;
    f4d2:	vldr	s5, [r8, #48]	; 0x30
    f4d6:	vdiv.f32	s23, s14, s11
    f4da:	vmov.f32	s9, s8
    f4de:	vmov.f32	s8, s6
    f4e2:	vdiv.f32	s21, s15, s11
    f4e6:	vfnms.f32	s8, s10, s12
    f4ea:	vdiv.f32	s24, s9, s11
    f4ee:	vdiv.f32	s22, s8, s11
      &previous_feedback_, 2.0f * parameters.morph - 1.0f, size);
  
  Downsampler carrier_downsampler(&carrier_fir_);
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    f4f2:	cmp	r5, #0
    f4f4:	beq.w	f758 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40c>
    f4f8:	ldr.w	r3, [r8, #16]
    f4fc:	ldr.w	r7, [r8, #20]
    f500:	str	r3, [sp, #4]
    f502:	ldr.w	r9, [pc, #512]	; f704 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b8>
    f506:	ldr.w	r3, [r8, #24]
    f50a:	ldr	r2, [pc, #476]	; (f6e8 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x39c>)
    const float amount = amount_modulation.Next();
    const float feedback = feedback_modulation.Next();
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    f50c:	vldr	s20, [pc, #476]	; f6ec <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a0>
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f510:	vldr	s10, [pc, #476]	; f6f0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a4>
    f514:	vldr	s11, [pc, #476]	; f6f4 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a8>
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
      float modulator = SinePM(
          modulator_phase_, modulator_fb * previous_sample_);
      float carrier = SinePM(carrier_phase_, amount * modulator);
      float sub = SinePM(sub_phase_, amount * carrier * 0.25f);
      ONE_POLE(previous_sample_, carrier, 0.05f);
    f518:	vldr	s17, [pc, #476]	; f6f8 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ac>
    f51c:	str	r3, [sp, #0]
  }

  inline float Next() {
    value_ += increment_;
    f51e:	vadd.f32	s13, s13, s21
    f522:	vadd.f32	s6, s6, s22
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    const float amount = amount_modulation.Next();
    const float feedback = feedback_modulation.Next();
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    f526:	vcmpe.f32	s13, #0.0
    f52a:	vmrs	APSR_nzcv, fpscr
    f52e:	bmi.w	f77a <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42e>
    f532:	vldr	s1, [pc, #472]	; f70c <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
    f536:	vadd.f32	s18, s18, s24
    f53a:	ldr	r3, [sp, #4]
    f53c:	vadd.f32	s19, s19, s23
    f540:	ldr	r1, [sp, #0]
    f542:	vmov.f32	s3, s7
    f546:	vldr	s7, [pc, #452]	; f70c <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    f54a:	vmul.f32	s15, s18, s20
    f54e:	vldr	s14, [r8, #44]	; 0x2c
    f552:	vmov.f32	s4, s5
    f556:	ldr.w	ip, [pc, #428]	; f704 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b8>
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
      modulator_phase_ += static_cast<uint32_t>(4294967296.0f * \
           _modulator_frequency * (1.0f + previous_sample_ * phase_feedback));
    f55a:	vmov.f32	s16, #112	; 0x3f800000  1.0
    f55e:	vldr	s8, [pc, #412]	; f6fc <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b0>
  while (size--) {
    const float amount = amount_modulation.Next();
    const float feedback = feedback_modulation.Next();
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    f562:	vcvt.u32.f32	s15, s15
    f566:	vldr	s9, [pc, #408]	; f700 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b4>
    f56a:	vmov.f32	s5, s7
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
    f56e:	movs	r0, #0
    f570:	vmul.f32	s0, s19, s20
  while (size--) {
    const float amount = amount_modulation.Next();
    const float feedback = feedback_modulation.Next();
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    f574:	vmov	r6, s15
    for (size_t j = 0; j < kOversampling; ++j) {
      modulator_phase_ += static_cast<uint32_t>(4294967296.0f * \
           _modulator_frequency * (1.0f + previous_sample_ * phase_feedback));
      carrier_phase_ += carrier_increment;
      sub_phase_ += carrier_increment >> 1;
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
    f578:	vmov.f32	s2, #80	; 0x3e800000  0.250
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f57c:	vmov.f32	s12, #16	; 0x40800000  4.0
    f580:	mov.w	lr, r6, lsr #1
    f584:	adds	r3, r6, r3
    f586:	add	r1, lr
    f588:	mov	r5, r3
    f58a:	str	r3, [sp, #20]
    f58c:	mov	r4, r1
    f58e:	str	r1, [sp, #16]
        4294967296.0f * carrier_frequency.Next());
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
      modulator_phase_ += static_cast<uint32_t>(4294967296.0f * \
           _modulator_frequency * (1.0f + previous_sample_ * phase_feedback));
    f590:	vmov.f32	s15, s16
      carrier_phase_ += carrier_increment;
      sub_phase_ += carrier_increment >> 1;
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
    f594:	vcmpe.f32	s13, #0.0
        4294967296.0f * carrier_frequency.Next());
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
      modulator_phase_ += static_cast<uint32_t>(4294967296.0f * \
           _modulator_frequency * (1.0f + previous_sample_ * phase_feedback));
    f598:	vfma.f32	s15, s1, s14
      carrier_phase_ += carrier_increment;
      sub_phase_ += carrier_increment >> 1;
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
    f59c:	vmrs	APSR_nzcv, fpscr
        4294967296.0f * carrier_frequency.Next());
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
      modulator_phase_ += static_cast<uint32_t>(4294967296.0f * \
           _modulator_frequency * (1.0f + previous_sample_ * phase_feedback));
    f5a0:	vmul.f32	s15, s15, s0
    f5a4:	vcvt.u32.f32	s15, s15
    f5a8:	vmov	r3, s15
    f5ac:	add	r7, r3
      carrier_phase_ += carrier_increment;
      sub_phase_ += carrier_increment >> 1;
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
    f5ae:	ble.w	f6c0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x374>
    f5b2:	vmul.f32	s15, s13, s2
    f5b6:	vmul.f32	s15, s15, s13
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f5ba:	vmov.f32	s25, s12
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
    f5be:	adds	r0, #1
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f5c0:	vmov.f32	s27, s12
    f5c4:	mvns	r1, r0
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
    f5c6:	cmp	r0, #4
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f5c8:	vfma.f32	s25, s15, s14
    f5cc:	and.w	r1, r1, #3
    f5d0:	add.w	r1, r9, r1, lsl #2
    f5d4:	vmul.f32	s15, s25, s10
    f5d8:	vcvt.u32.f32	s15, s15
    f5dc:	vmov	r3, s15
    f5e0:	add.w	r3, r7, r3, lsl #3
  uint32_t integral = phase >> 22;
    f5e4:	mov.w	fp, r3, lsr #22
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f5e8:	mov.w	r3, r3, lsl #10
    f5ec:	vmov	s15, r3
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
    f5f0:	add.w	r3, r2, fp, lsl #2
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f5f4:	vcvt.f32.u32	s15, s15
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
    f5f8:	vldr	s25, [r3]
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f5fc:	vldr	s26, [r3, #4]
    f600:	vmul.f32	s15, s15, s11
    f604:	vsub.f32	s26, s26, s25
    f608:	vfma.f32	s25, s15, s26
    f60c:	vmov.f32	s15, s12
    f610:	vfma.f32	s15, s6, s25
    f614:	vmul.f32	s15, s15, s10
    f618:	vcvt.u32.f32	s15, s15
    f61c:	vmov	r3, s15
    f620:	add.w	r3, r5, r3, lsl #3
    f624:	add	r5, r6
  uint32_t integral = phase >> 22;
    f626:	mov.w	fp, r3, lsr #22
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f62a:	mov.w	r3, r3, lsl #10
    f62e:	vmov	s15, r3

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
    f632:	add.w	r3, r2, fp, lsl #2
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f636:	vcvt.f32.u32	s15, s15

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
    f63a:	vldr	s25, [r3]
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f63e:	vldr	s26, [r3, #4]
    f642:	vmul.f32	s15, s15, s11
    f646:	vsub.f32	s26, s26, s25
    f64a:	vfma.f32	s25, s15, s26
    f64e:	vmov.f32	s15, s25
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f652:	vmul.f32	s25, s6, s25
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
      float modulator = SinePM(
          modulator_phase_, modulator_fb * previous_sample_);
      float carrier = SinePM(carrier_phase_, amount * modulator);
      float sub = SinePM(sub_phase_, amount * carrier * 0.25f);
      ONE_POLE(previous_sample_, carrier, 0.05f);
    f656:	vsub.f32	s26, s15, s14
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f65a:	vfma.f32	s27, s25, s2
  }
  ~Downsampler() {
    *state_ = head_;
  }
  inline void Accumulate(int i, float sample) {
    head_ += sample * fir_coefficient[3 - (i & 3)];
    f65e:	vfma.f32	s3, s15, s9
    tail_ += sample * fir_coefficient[i & 3];
    f662:	vfma.f32	s7, s15, s8
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
      float modulator = SinePM(
          modulator_phase_, modulator_fb * previous_sample_);
      float carrier = SinePM(carrier_phase_, amount * modulator);
      float sub = SinePM(sub_phase_, amount * carrier * 0.25f);
      ONE_POLE(previous_sample_, carrier, 0.05f);
    f666:	vfma.f32	s14, s26, s17
void FMEngine::Reset() {
  
}

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
    f66a:	vmul.f32	s15, s27, s10
    f66e:	vcvt.u32.f32	s15, s15
    f672:	vmov	r3, s15
    f676:	add.w	r3, r4, r3, lsl #3
    f67a:	add	r4, lr
  uint32_t integral = phase >> 22;
    f67c:	mov.w	fp, r3, lsr #22
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f680:	mov.w	r3, r3, lsl #10
    f684:	vmov	s15, r3

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
    f688:	add.w	r3, r2, fp, lsl #2
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f68c:	vcvt.f32.u32	s15, s15

inline float FMEngine::SinePM(uint32_t phase, float fm) const {
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
    f690:	vldr	s25, [r3]
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f694:	vldr	s26, [r3, #4]
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
      float modulator = SinePM(
          modulator_phase_, modulator_fb * previous_sample_);
      float carrier = SinePM(carrier_phase_, amount * modulator);
      float sub = SinePM(sub_phase_, amount * carrier * 0.25f);
      ONE_POLE(previous_sample_, carrier, 0.05f);
    f698:	vstr	s14, [r8, #44]	; 0x2c
  phase += (static_cast<uint32_t>((fm + 4.0f) * 536870912.0f)) << 3;
  uint32_t integral = phase >> 22;
  float fractional = static_cast<float>(phase << 10) / 4294967296.0f;
  float a = lut_sine[integral];
  float b = lut_sine[integral + 1];
  return a + (b - a) * fractional;
    f69c:	vmul.f32	s15, s15, s11
    f6a0:	vsub.f32	s26, s26, s25
    f6a4:	vfma.f32	s25, s15, s26
  }
  ~Downsampler() {
    *state_ = head_;
  }
  inline void Accumulate(int i, float sample) {
    head_ += sample * fir_coefficient[3 - (i & 3)];
    f6a8:	vfma.f32	s4, s25, s9
    tail_ += sample * fir_coefficient[i & 3];
    f6ac:	vfma.f32	s5, s25, s8
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    const uint32_t carrier_increment = static_cast<uint32_t>(
        4294967296.0f * carrier_frequency.Next());
    float _modulator_frequency = modulator_frequency.Next();

    for (size_t j = 0; j < kOversampling; ++j) {
    f6b0:	beq.n	f710 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c4>
    f6b2:	add.w	ip, ip, #4
    f6b6:	vldr	s9, [r1]
    f6ba:	vldr	s8, [ip]
    f6be:	b.n	f590 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x244>
      modulator_phase_ += static_cast<uint32_t>(4294967296.0f * \
           _modulator_frequency * (1.0f + previous_sample_ * phase_feedback));
      carrier_phase_ += carrier_increment;
      sub_phase_ += carrier_increment >> 1;
      float modulator_fb = feedback > 0.0f ? 0.25f * feedback * feedback : 0.0f;
    f6c0:	vldr	s15, [pc, #72]	; f70c <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
    f6c4:	b.n	f5ba <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x26e>
    f6c6:	nop
    f6c8:	.word	0xc3000000
    f6cc:	.word	0x20000e60
    f6d0:	.word	0x42fe0000
    f6d4:	.word	0x20000554
    f6d8:	.word	0x20000958
    f6dc:	.word	0x39962fc9
    f6e0:	.word	0x42900000
    f6e4:	.word	0x3ccccccd
    f6e8:	.word	0x20002b10
    f6ec:	.word	0x4f800000
    f6f0:	.word	0x4e000000
    f6f4:	.word	0x2f800000
    f6f8:	.word	0x3d4ccccd
    f6fc:	.word	0x3cc81528
    f700:	.word	0x3e5ca50a
    f704:	.word	0x2001fa08
    f708:	.word	0x43000000
    f70c:	.word	0x00000000
    f710:	ldr	r0, [sp, #20]
    f712:	add.w	r3, r6, r6, lsl #1
      ONE_POLE(previous_sample_, carrier, 0.05f);
      carrier_downsampler.Accumulate(j, carrier);
      sub_downsampler.Accumulate(j, sub);
    }
    
    *out++ = carrier_downsampler.Read();
    f716:	ldr	r1, [sp, #8]
      &previous_feedback_, 2.0f * parameters.morph - 1.0f, size);
  
  Downsampler carrier_downsampler(&carrier_fir_);
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    f718:	add.w	sl, sl, #4294967295
    f71c:	add	r3, r0
    f71e:	ldr	r0, [sp, #0]
      ONE_POLE(previous_sample_, carrier, 0.05f);
      carrier_downsampler.Accumulate(j, carrier);
      sub_downsampler.Accumulate(j, sub);
    }
    
    *out++ = carrier_downsampler.Read();
    f720:	vstmia	r1!, {s3}
      &previous_feedback_, 2.0f * parameters.morph - 1.0f, size);
  
  Downsampler carrier_downsampler(&carrier_fir_);
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    f724:	cmp.w	sl, #4294967295
    f728:	add.w	r0, r0, lr, lsl #2
      ONE_POLE(previous_sample_, carrier, 0.05f);
      carrier_downsampler.Accumulate(j, carrier);
      sub_downsampler.Accumulate(j, sub);
    }
    
    *out++ = carrier_downsampler.Read();
    f72c:	str	r1, [sp, #8]
    f72e:	ldr	r1, [sp, #4]
    f730:	str	r0, [sp, #0]
    f732:	add.w	r1, r1, r6, lsl #2
    *aux++ = sub_downsampler.Read();
    f736:	ldr	r0, [sp, #12]
    f738:	str	r1, [sp, #4]
    f73a:	add.w	r1, lr, lr, lsl #1
    f73e:	vstmia	r0!, {s4}
    f742:	str	r0, [sp, #12]
    f744:	ldr	r0, [sp, #16]
    f746:	add	r0, r1
      &previous_feedback_, 2.0f * parameters.morph - 1.0f, size);
  
  Downsampler carrier_downsampler(&carrier_fir_);
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    f748:	bne.w	f51e <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1d2>
    f74c:	str.w	r7, [r8, #20]
    f750:	str.w	r3, [r8, #16]
    f754:	str.w	r0, [r8, #24]
    head_ = *state;
    tail_ = 0.0f;
    state_ = state;
  }
  ~Downsampler() {
    *state_ = head_;
    f758:	vstr	s5, [r8, #48]	; 0x30
    f75c:	vstr	s7, [r8, #52]	; 0x34
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
    f760:	vstr	s13, [r8, #40]	; 0x28
    f764:	vstr	s6, [r8, #36]	; 0x24
    f768:	vstr	s19, [r8, #32]
    f76c:	vstr	s18, [r8, #28]
    }
    
    *out++ = carrier_downsampler.Read();
    *aux++ = sub_downsampler.Read();
  }
}
    f770:	add	sp, #28
    f772:	vpop	{d8-d13}
    f776:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  Downsampler sub_downsampler(&sub_fir_);
  
  while (size--) {
    const float amount = amount_modulation.Next();
    const float feedback = feedback_modulation.Next();
    float phase_feedback = feedback < 0.0f ? 0.5f * feedback * feedback : 0.0f;
    f77a:	vmov.f32	s1, #96	; 0x3f000000  0.5
    f77e:	vmul.f32	s1, s13, s1
    f782:	vmul.f32	s1, s1, s13
    f786:	b.n	f536 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1ea>
    f788:	vldr	s13, [pc, #-132]	; f708 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3bc>
    f78c:	vadd.f32	s15, s15, s13
    f790:	vcvt.s32.f32	s13, s15
    f794:	vmov	r2, s13
    f798:	vcvt.f32.s32	s13, s13
    f79c:	vsub.f32	s15, s15, s13
    f7a0:	vmov.f32	s13, s15
    f7a4:	vcvt.s32.f32	s13, s13, #8
    f7a8:	vmov	r3, s13
    f7ac:	b.n	f46e <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x122>
    f7ae:	vadd.f32	s14, s14, s10
    f7b2:	vcvt.s32.f32	s12, s14
    f7b6:	vmov	r3, s12
    f7ba:	vcvt.f32.s32	s12, s12
    f7be:	vsub.f32	s14, s14, s12
    f7c2:	vmov.f32	s12, s14
    f7c6:	vcvt.s32.f32	s12, s12, #8
    f7ca:	vmov	r2, s12
    f7ce:	b.n	f3d0 <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x84>
    f7d0:	vldr	s12, [pc, #-200]	; f70c <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
    f7d4:	b.n	f43e <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf2>
      parameters.harmonics,
      128.0f);
  
  float modulator_note = note + ratio;
  float target_modulator_frequency = NoteToFrequency(modulator_note);
  CONSTRAIN(target_modulator_frequency, 0.0f, 0.5f);
    f7d6:	vldr	s14, [pc, #-204]	; f70c <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c0>
    f7da:	b.n	f40e <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc2>
    f7dc:	vmul.f32	s12, s10, s10
    f7e0:	b.n	f43e <plaits::FMEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf2>
    f7e2:	nop

0000f7e4 <plaits::StringEngine::Init(stmlib::BufferAllocator*)>:
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    f7e4:	ldr	r2, [r1, #8]
    f7e6:	cmp.w	r2, #512	; 0x200
namespace plaits {

using namespace std;
using namespace stmlib;

void StringEngine::Init(BufferAllocator* allocator) {
    f7ea:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f7ee:	mov	r6, r1
    f7f0:	mov	r7, r0
    f7f2:	bcc.n	f866 <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x82>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    f7f4:	ldr	r3, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    f7f6:	sub.w	r2, r2, #512	; 0x200
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    f7fa:	add.w	r1, r3, #512	; 0x200
      free_ -= size_bytes;
    f7fe:	str	r2, [r6, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    f800:	str	r1, [r6, #0]
    f802:	add.w	r5, r7, #16
    f806:	add.w	r4, r7, #304	; 0x130
    f80a:	add.w	r9, r7, #316	; 0x13c
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  for (int i = 0; i < kNumStrings; ++i) {
    voice_[i].Init(allocator);
    f0_[i] = 0.01f;
    f80e:	ldr.w	r8, [pc, #92]	; f86c <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x88>

using namespace std;
using namespace stmlib;

void StringEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
    f812:	str.w	r3, [r7, #328]	; 0x148
  for (int i = 0; i < kNumStrings; ++i) {
    voice_[i].Init(allocator);
    f816:	mov	r0, r5
    f818:	mov	r1, r6
    f81a:	bl	127cc <plaits::StringVoice::Init(stmlib::BufferAllocator*)>
    f0_[i] = 0.01f;
    f81e:	str.w	r8, [r4], #4
using namespace std;
using namespace stmlib;

void StringEngine::Init(BufferAllocator* allocator) {
  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
  for (int i = 0; i < kNumStrings; ++i) {
    f822:	cmp	r4, r9
    f824:	add.w	r5, r5, #96	; 0x60
    f828:	bne.n	f816 <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x32>
    voice_[i].Init(allocator);
    f0_[i] = 0.01f;
  }
  active_string_ = kNumStrings - 1;
    f82a:	movs	r3, #2
    f82c:	str.w	r3, [r7, #324]	; 0x144
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
    f830:	ldr	r2, [r6, #8]
    f832:	cmp	r2, #63	; 0x3f
    f834:	bls.n	f85c <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x78>
      T* start = static_cast<T*>(static_cast<void*>(next_));
    f836:	ldr	r3, [r6, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
    f838:	subs	r2, #64	; 0x40
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    f83a:	add.w	r1, r3, #64	; 0x40
      free_ -= size_bytes;
    f83e:	str	r2, [r6, #8]
    line_ = buffer;
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    f840:	mov	r2, r1
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
    f842:	str	r1, [r6, #0]
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
    f844:	str.w	r3, [r7, #320]	; 0x140
	*__first = __tmp;
    f848:	movs	r1, #0
    f84a:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    f84e:	cmp	r3, r2
    f850:	bne.n	f84a <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x66>
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
    f852:	movs	r3, #0
    f854:	str.w	r3, [r7, #316]	; 0x13c
  f0_delay_.Init(allocator->Allocate<float>(16));
}
    f858:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
    f85c:	movs	r3, #0
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    f85e:	movs	r2, #64	; 0x40
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
    f860:	str.w	r3, [r7, #320]	; 0x140
    f864:	b.n	f848 <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x64>
      free_ -= size_bytes;
      return start;
    } else {
      return NULL;
    f866:	movs	r3, #0
    f868:	b.n	f802 <plaits::StringEngine::Init(stmlib::BufferAllocator*)+0x1e>
    f86a:	nop
    f86c:	.word	0x3c23d70a

0000f870 <plaits::StringEngine::Reset()>:
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    f870:	ldr.w	r3, [r0, #320]	; 0x140
	*__first = __tmp;
    f874:	movs	r1, #0

void StringEngine::Reset() {
    f876:	push	{r4, lr}
    f878:	add.w	r2, r3, #64	; 0x40
    f87c:	mov	r4, r0
    f87e:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    f882:	cmp	r2, r3
    f884:	bne.n	f87e <plaits::StringEngine::Reset()+0xe>
    write_ptr_ = 0;
    f886:	movs	r3, #0
  f0_delay_.Reset();
  for (int i = 0; i < kNumStrings; ++i) {
    voice_[i].Reset();
    f888:	add.w	r0, r4, #16
    f88c:	str.w	r3, [r4, #316]	; 0x13c
    f890:	bl	127fc <plaits::StringVoice::Reset()>
    f894:	add.w	r0, r4, #112	; 0x70
    f898:	bl	127fc <plaits::StringVoice::Reset()>
    f89c:	add.w	r0, r4, #208	; 0xd0
  }
}
    f8a0:	ldmia.w	sp!, {r4, lr}
}

void StringEngine::Reset() {
  f0_delay_.Reset();
  for (int i = 0; i < kNumStrings; ++i) {
    voice_[i].Reset();
    f8a4:	b.w	127fc <plaits::StringVoice::Reset()>

0000f8a8 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
void StringEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    f8a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f8ac:	mov	r7, r2
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    f8ae:	ldrb	r2, [r1, #0]
void StringEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    f8b0:	sub	sp, #20
    f8b2:	mov	r8, r3
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    f8b4:	lsls	r3, r2, #31
void StringEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    f8b6:	mov	r5, r0
    f8b8:	mov	r4, r1
    f8ba:	ldr.w	r9, [sp, #56]	; 0x38
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    f8be:	ldr.w	r0, [r0, #316]	; 0x13c
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    f8c2:	bmi.n	f906 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5e>
    f8c4:	add.w	lr, r0, #15
    f8c8:	ldr.w	r3, [r5, #324]	; 0x144
    f8cc:	ldr.w	r6, [r5, #320]	; 0x140
    f8d0:	and.w	lr, lr, #15
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    f8d4:	vmov.f32	s13, #34	; 0x41100000  9.0
    f8d8:	vldr	s15, [r4, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    f8dc:	vldr	s14, [pc, #384]	; fa60 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b8>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    f8e0:	vsub.f32	s15, s15, s13
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    f8e4:	vcmpe.f32	s15, s14
    f8e8:	vmrs	APSR_nzcv, fpscr
    f8ec:	bmi.n	f95c <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb4>
    f8ee:	vldr	s14, [pc, #372]	; fa64 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1bc>
    f8f2:	vcmpe.f32	s15, s14
    f8f6:	vmrs	APSR_nzcv, fpscr
    f8fa:	ble.w	fa38 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x190>
    f8fe:	movs	r1, #0
    f900:	mov.w	fp, #255	; 0xff
    f904:	b.n	f960 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb8>
    f906:	add.w	r3, r0, #14
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    f90a:	add.w	lr, r0, #15
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    f90e:	ldr.w	r6, [r5, #320]	; 0x140
    f912:	and.w	r3, r3, #15
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    f916:	and.w	lr, lr, #15
    // 8 in original firmware version.
    // 05.01.18: mic.w: problem with microbrute.
    f0_[active_string_] = f0_delay_.Read(14);
    f91a:	ldr.w	ip, [r5, #324]	; 0x144
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    f91e:	add.w	r3, r6, r3, lsl #2
    f922:	vldr	s13, [pc, #324]	; fa68 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1c0>
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    f926:	add.w	sl, r6, lr, lsl #2
    active_string_ = (active_string_ + 1) % kNumStrings;
    f92a:	add.w	r1, ip, #1
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    f92e:	vldr	s15, [r3]
    size_t size,
    bool* already_enveloped) {
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    // 8 in original firmware version.
    // 05.01.18: mic.w: problem with microbrute.
    f0_[active_string_] = f0_delay_.Read(14);
    f932:	add.w	ip, r5, ip, lsl #2
    f936:	vldr	s14, [sl]
    active_string_ = (active_string_ + 1) % kNumStrings;
    f93a:	ldr	r3, [pc, #304]	; (fa6c <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1c4>)
    size_t size,
    bool* already_enveloped) {
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    // 8 in original firmware version.
    // 05.01.18: mic.w: problem with microbrute.
    f0_[active_string_] = f0_delay_.Read(14);
    f93c:	vsub.f32	s14, s14, s15
    active_string_ = (active_string_ + 1) % kNumStrings;
    f940:	smull	sl, r3, r3, r1
    size_t size,
    bool* already_enveloped) {
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    // 8 in original firmware version.
    // 05.01.18: mic.w: problem with microbrute.
    f0_[active_string_] = f0_delay_.Read(14);
    f944:	vfma.f32	s15, s14, s13
    active_string_ = (active_string_ + 1) % kNumStrings;
    f948:	sub.w	r3, r3, r1, asr #31
    f94c:	add.w	r3, r3, r3, lsl #1
    f950:	subs	r3, r1, r3
    size_t size,
    bool* already_enveloped) {
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    // 8 in original firmware version.
    // 05.01.18: mic.w: problem with microbrute.
    f0_[active_string_] = f0_delay_.Read(14);
    f952:	vstr	s15, [ip, #304]	; 0x130
    active_string_ = (active_string_ + 1) % kNumStrings;
    f956:	str.w	r3, [r5, #324]	; 0x144
    f95a:	b.n	f8d4 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c>
    f95c:	movs	r1, #0
    f95e:	mov	fp, r1

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    f960:	ldr.w	sl, [pc, #276]	; fa78 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1d0>
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    f964:	add.w	r6, r6, r0, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    f968:	ldr.w	ip, [pc, #272]	; fa7c <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1d4>
  }
  
  const float f0 = NoteToFrequency(parameters.note);
  f0_[active_string_] = f0;
    f96c:	add.w	r3, r5, r3, lsl #2

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    f970:	add.w	sl, sl, fp, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    f974:	vldr	s13, [pc, #248]	; fa70 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1c8>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    f978:	add.w	ip, ip, r1, lsl #2
    f97c:	vldr	s14, [sl]
  f0_delay_.Write(f0);
  
  fill(&out[0], &out[size], 0.0f);
    f980:	mov.w	r1, r9, lsl #2
    f984:	vldr	s15, [ip]
    f988:	adds	r0, r7, r1
    f98a:	vmul.f32	s15, s14, s15
    f98e:	cmp	r7, r0
    f990:	vmul.f32	s15, s15, s13
    f0_[active_string_] = f0_delay_.Read(14);
    active_string_ = (active_string_ + 1) % kNumStrings;
  }
  
  const float f0 = NoteToFrequency(parameters.note);
  f0_[active_string_] = f0;
    f994:	vstr	s15, [r3, #304]	; 0x130
    f998:	vstr	s15, [r6]
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
    f99c:	str.w	lr, [r5, #316]	; 0x13c
    f9a0:	beq.n	f9ae <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x106>
    f9a2:	mov	r3, r7
	*__first = __tmp;
    f9a4:	movs	r6, #0
    f9a6:	str.w	r6, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    f9aa:	cmp	r0, r3
    f9ac:	bne.n	f9a6 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xfe>
  f0_delay_.Write(f0);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
    f9ae:	add	r1, r8
    f9b0:	cmp	r8, r1
    f9b2:	beq.n	f9c0 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x118>
    f9b4:	mov	r3, r8
	*__first = __tmp;
    f9b6:	movs	r0, #0
    f9b8:	str.w	r0, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
    f9bc:	cmp	r1, r3
    f9be:	bne.n	f9b8 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x110>
  
  for (int i = 0; i < kNumStrings; ++i) {
    voice_[i].Render(
    f9c0:	and.w	r3, r2, #2
    f9c4:	add.w	fp, r5, #304	; 0x130
    f9c8:	add.w	sl, r5, #16
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  if (parameters.trigger & TRIGGER_RISING_EDGE) {
    f9cc:	movs	r6, #0
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  for (int i = 0; i < kNumStrings; ++i) {
    voice_[i].Render(
    f9ce:	and.w	r1, r3, #255	; 0xff
    f9d2:	cbz	r3, f9e0 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x138>
    f9d4:	ldr.w	r1, [r5, #324]	; 0x144
    f9d8:	subs	r1, r1, r6
    f9da:	clz	r1, r1
    f9de:	lsrs	r1, r1, #5
    f9e0:	ands.w	r2, r2, #1
    f9e4:	beq.n	f9f2 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x14a>
    f9e6:	ldr.w	r2, [r5, #324]	; 0x144
    f9ea:	subs	r2, r2, r6
    f9ec:	clz	r2, r2
    f9f0:	lsrs	r2, r2, #5
        parameters.trigger & TRIGGER_UNPATCHED && i == active_string_,
        parameters.trigger & TRIGGER_RISING_EDGE && i == active_string_,
        parameters.accent,
        f0_[i],
        parameters.harmonics,
        parameters.timbre * parameters.timbre,
    f9f2:	vldr	s3, [r4, #8]
  f0_delay_.Write(f0);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  for (int i = 0; i < kNumStrings; ++i) {
    f9f6:	adds	r6, #1
    voice_[i].Render(
    f9f8:	vldmia	fp!, {s1}
        parameters.timbre * parameters.timbre,
        parameters.morph,
        temp_buffer_,
        out,
        aux,
        size);
    f9fc:	mov	r0, sl
    f9fe:	ldr.w	r3, [r5, #328]	; 0x148
    fa02:	vmul.f32	s3, s3, s3
    fa06:	vldr	s4, [r4, #12]
    fa0a:	add.w	sl, sl, #96	; 0x60
    fa0e:	vldr	s2, [r4, #16]
    fa12:	vldr	s0, [r4, #20]
    fa16:	stmia.w	sp, {r7, r8, r9}
    fa1a:	bl	12804 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)>
  f0_delay_.Write(f0);
  
  fill(&out[0], &out[size], 0.0f);
  fill(&aux[0], &aux[size], 0.0f);
  
  for (int i = 0; i < kNumStrings; ++i) {
    fa1e:	cmp	r6, #3
    fa20:	beq.n	fa32 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x18a>
    fa22:	ldrb	r2, [r4, #0]
    voice_[i].Render(
    fa24:	and.w	r3, r2, #2
    fa28:	and.w	r1, r3, #255	; 0xff
    fa2c:	cmp	r3, #0
    fa2e:	beq.n	f9e0 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x138>
    fa30:	b.n	f9d4 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x12c>
        temp_buffer_,
        out,
        aux,
        size);
  }
}
    fa32:	add	sp, #20
    fa34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa38:	vldr	s14, [pc, #56]	; fa74 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1cc>
    fa3c:	vadd.f32	s15, s15, s14
    fa40:	vcvt.s32.f32	s14, s15
    fa44:	vmov	fp, s14
    fa48:	vcvt.f32.s32	s14, s14
    fa4c:	vsub.f32	s15, s15, s14
    fa50:	vmov.f32	s14, s15
    fa54:	vcvt.s32.f32	s14, s14, #8
    fa58:	vmov	r1, s14
    fa5c:	b.n	f960 <plaits::StringEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb8>
    fa5e:	nop
    fa60:	.word	0xc3000000
    fa64:	.word	0x42fe0000
    fa68:	.word	0x00000000
    fa6c:	.word	0x55555556
    fa70:	.word	0x39962fc9
    fa74:	.word	0x43000000
    fa78:	.word	0x20000554
    fa7c:	.word	0x20000958

0000fa80 <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace std;
using namespace stmlib;

void SnareDrumEngine::Init(BufferAllocator* allocator) {
    fa80:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  static const int kNumModes = 5;

  void Init() {
    pulse_remaining_samples_ = 0;
    pulse_ = 0.0f;
    fa84:	movs	r4, #0
  ~AnalogSnareDrum() { }

  static const int kNumModes = 5;

  void Init() {
    pulse_remaining_samples_ = 0;
    fa86:	movs	r5, #0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    fa88:	ldr.w	r9, [pc, #176]	; fb3c <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xbc>
    fa8c:	mov	r3, r0
    fa8e:	add.w	r8, r0, #100	; 0x64
    pulse_ = 0.0f;
    pulse_height_ = 0.0f;
    pulse_lp_ = 0.0f;
    noise_envelope_ = 0.0f;
    sustain_gain_ = 0.0f;
    fa92:	mov	r1, r0
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    fa94:	mov	r2, r4
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    fa96:	ldr.w	ip, [pc, #168]	; fb40 <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xc0>
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fa9a:	ldr.w	lr, [pc, #168]	; fb44 <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xc4>
  ~AnalogSnareDrum() { }

  static const int kNumModes = 5;

  void Init() {
    pulse_remaining_samples_ = 0;
    fa9e:	str	r5, [r0, #16]
    pulse_ = 0.0f;
    faa0:	str	r4, [r0, #20]
    pulse_height_ = 0.0f;
    faa2:	str	r4, [r0, #24]
    pulse_lp_ = 0.0f;
    faa4:	str	r4, [r0, #28]
    noise_envelope_ = 0.0f;
    faa6:	str	r4, [r0, #32]
    sustain_gain_ = 0.0f;
    faa8:	str	r4, [r0, #36]	; 0x24

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    faaa:	str.w	r9, [r3, #40]	; 0x28
    faae:	adds	r3, #20
    r_ = 1.0f / resonance;
    fab0:	str.w	ip, [r3, #24]
    fab4:	adds	r1, #12
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fab6:	str.w	lr, [r3, #28]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    faba:	movs	r4, #0
    fabc:	str	r2, [r3, #36]	; 0x24
    fabe:	str	r2, [r3, #32]

    for (int i = 0; i < kNumModes; ++i) {
    fac0:	cmp	r3, r8
 public:
  SineOscillator() { }
  ~SineOscillator() { }

  void Init() {
    phase_ = 0.0f;
    fac2:	str.w	r2, [r1, #148]	; 0x94
    frequency_ = 0.0f;
    fac6:	str.w	r2, [r1, #152]	; 0x98
    amplitude_ = 0.0f;
    faca:	str.w	r2, [r1, #156]	; 0x9c

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    face:	ldr	r5, [pc, #108]	; (fb3c <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xbc>)
    r_ = 1.0f / resonance;
    fad0:	ldr	r7, [pc, #108]	; (fb40 <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xc0>)
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fad2:	ldr	r6, [pc, #112]	; (fb44 <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xc4>)
    fad4:	bne.n	faaa <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0x2a>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    gi_ = 1.0f / (1.0f + g_);
    fad6:	ldr	r3, [pc, #112]	; (fb48 <plaits::SnareDrumEngine::Init(stmlib::BufferAllocator*)+0xc8>)
    phase_[0] = 0.0f;
    phase_[1] = 0.0f;
    drum_amplitude_ = 0.0f;
    snare_amplitude_ = 0.0f;
    fm_ = 0.0f;
    hold_counter_ = 0;
    fad8:	movs	r2, #0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    fada:	str.w	r5, [r0, #140]	; 0x8c
    r_ = 1.0f / resonance;
    fade:	str.w	r7, [r0, #144]	; 0x90
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fae2:	str.w	r6, [r0, #148]	; 0x94
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    fae6:	str.w	r4, [r0, #156]	; 0x9c
    faea:	str.w	r4, [r0, #152]	; 0x98
 public:
  SyntheticSnareDrum() { }
  ~SyntheticSnareDrum() { }

  void Init() {
    phase_[0] = 0.0f;
    faee:	str.w	r4, [r0, #220]	; 0xdc
    phase_[1] = 0.0f;
    faf2:	str.w	r4, [r0, #224]	; 0xe0
    drum_amplitude_ = 0.0f;
    faf6:	str.w	r4, [r0, #228]	; 0xe4
    snare_amplitude_ = 0.0f;
    fafa:	str.w	r4, [r0, #232]	; 0xe8
    fm_ = 0.0f;
    fafe:	str.w	r4, [r0, #236]	; 0xec
    hold_counter_ = 0;
    sustain_gain_ = 0.0f;
    fb02:	str.w	r4, [r0, #240]	; 0xf0
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    fb06:	str.w	r5, [r0, #248]	; 0xf8
    set_f<FREQUENCY_DIRTY>(0.01f);
    Reset();
  }
  
  void Reset() {
    state_ = 0.0f;
    fb0a:	str.w	r4, [r0, #256]	; 0x100
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    fb0e:	str.w	r5, [r0, #260]	; 0x104
    set_f<FREQUENCY_DIRTY>(0.01f);
    Reset();
  }
  
  void Reset() {
    state_ = 0.0f;
    fb12:	str.w	r4, [r0, #268]	; 0x10c

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    fb16:	str.w	r5, [r0, #272]	; 0x110
    r_ = 1.0f / resonance;
    fb1a:	str.w	r7, [r0, #276]	; 0x114
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fb1e:	str.w	r6, [r0, #280]	; 0x118
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
    fb22:	str.w	r4, [r0, #288]	; 0x120
    fb26:	str.w	r4, [r0, #284]	; 0x11c
    phase_[0] = 0.0f;
    phase_[1] = 0.0f;
    drum_amplitude_ = 0.0f;
    snare_amplitude_ = 0.0f;
    fm_ = 0.0f;
    hold_counter_ = 0;
    fb2a:	str.w	r2, [r0, #244]	; 0xf4
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    gi_ = 1.0f / (1.0f + g_);
    fb2e:	str.w	r3, [r0, #252]	; 0xfc
    fb32:	str.w	r3, [r0, #264]	; 0x108
    fb36:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    fb3a:	nop
    fb3c:	.word	0x3d00ba22
    fb40:	.word	0x3c23d70a
    fb44:	.word	0x3f7faaca
    fb48:	.word	0x3f783320

0000fb4c <plaits::SnareDrumEngine::Reset()>:
  analog_snare_drum_.Init();
  synthetic_snare_drum_.Init();
}

void SnareDrumEngine::Reset() {
    fb4c:	bx	lr
    fb4e:	nop

0000fb50 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    fb50:	vmov.f32	s13, #34	; 0x41100000  9.0
    fb54:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    fb58:	vldr	s14, [pc, #604]	; fdb8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x268>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
    fb5c:	vsub.f32	s15, s15, s13
void SnareDrumEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
    fb60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
    fb64:	vcmpe.f32	s15, s14
    fb68:	mov	r5, r2
    fb6a:	vpush	{d8-d15}
    fb6e:	vmrs	APSR_nzcv, fpscr
    fb72:	sub	sp, #68	; 0x44
    fb74:	str	r1, [sp, #8]
    fb76:	str	r3, [sp, #16]
    fb78:	bmi.w	10804 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcb4>
    fb7c:	vldr	s14, [pc, #572]	; fdbc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x26c>
    fb80:	vcmpe.f32	s15, s14
    fb84:	vmrs	APSR_nzcv, fpscr
    fb88:	ble.w	fd90 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x240>
    fb8c:	movs	r3, #0
    fb8e:	movs	r2, #255	; 0xff
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
    fb90:	ldr	r4, [sp, #8]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    fb92:	vmov.f32	s10, #36	; 0x41200000  10.0
    fb96:	vmov.f32	s11, #112	; 0x3f800000  1.0
    fb9a:	vldr	s14, [pc, #548]	; fdc0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x270>
      parameters.harmonics,
    fb9e:	vldr	s8, [r4, #16]
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
    fba2:	mov	r1, r4
    fba4:	vldr	s7, [r4, #12]
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    fba8:	vmov.f32	s13, #0	; 0x40000000  2.0
    fbac:	vfma.f32	s14, s8, s10
    fbb0:	vldr	s15, [pc, #528]	; fdc4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x274>
    fbb4:	vsub.f32	s12, s7, s11
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fbb8:	ldr	r4, [pc, #524]	; (fdc8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x278>)

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    fbba:	vmov.f32	s6, s11
    fbbe:	vldr	s9, [pc, #524]	; fdcc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x27c>
    fbc2:	vmov.f32	s10, s15
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fbc6:	add.w	r3, r4, r3, lsl #2

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    fbca:	ldr	r4, [pc, #516]	; (fdd0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x280>)
    fbcc:	vsub.f32	s13, s13, s8

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    fbd0:	vfma.f32	s6, s7, s12
    
    snappy = snappy * 1.1f - 0.05f;
    fbd4:	vldr	s3, [pc, #508]	; fdd4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x284>
    fbd8:	vfms.f32	s10, s7, s14
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    fbdc:	add.w	r2, r4, r2, lsl #2
    fbe0:	vldr	s12, [pc, #500]	; fdd8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x288>
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    fbe4:	vmul.f32	s13, s13, s8
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
    fbe8:	vldr	s5, [r3]
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  analog_snare_drum_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
    fbec:	mov	r4, r1
    
    snappy = snappy * 1.1f - 0.05f;
    fbee:	vfma.f32	s3, s8, s12
    fbf2:	vldr	s12, [r2]
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    fbf6:	vldr	s8, [pc, #484]	; fddc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x28c>
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    fbfa:	vmov.f32	s0, s11

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    fbfe:	vmul.f32	s6, s6, s7
    fc02:	ldrb	r3, [r1, #0]
    fc04:	vmov.f32	s14, s10
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fc08:	vldr	s4, [pc, #468]	; fde0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x290>
    fc0c:	vmul.f32	s10, s12, s5
    fc10:	mov	r1, r3

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
    fc12:	vfma.f32	s15, s6, s9
    fc16:	and.w	r7, r3, #2
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    fc1a:	vcvt.s32.f32	s12, s14
    fc1e:	str	r3, [sp, #12]
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    fc20:	vmul.f32	s8, s13, s8

  return lut_pitch_ratio_high[pitch_integral] * \
    fc24:	ldr	r3, [pc, #424]	; (fdd0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x280>)
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    fc26:	vcmpe.f32	s3, #0.0
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    fc2a:	vldr	s1, [pc, #440]	; fde4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x294>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fc2e:	vcvt.f32.s32	s9, s12

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    fc32:	vmov	r2, s12
      float* out,
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    fc36:	vldr	s2, [pc, #432]	; fde8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x298>
    fc3a:	uxtb	r7, r7
extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)
    fc3c:	vcvt.s32.f32	s13, s15

  return lut_pitch_ratio_high[pitch_integral] * \
    fc40:	add.w	r3, r3, r2, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fc44:	vsub.f32	s14, s14, s9
    fc48:	and.w	r2, r1, #1
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    fc4c:	vldr	s12, [r3]
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    fc50:	vmrs	APSR_nzcv, fpscr
    fc54:	vcvt.f32.s32	s9, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    fc58:	vmov	r1, s13
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fc5c:	vmul.f32	s14, s14, s4

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    fc60:	ldr	r3, [pc, #364]	; (fdd0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x280>)
    fc62:	vldr	s5, [pc, #392]	; fdec <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x29c>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fc66:	vsub.f32	s15, s15, s9

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
    fc6a:	add.w	r3, r3, r1, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
    fc6e:	vcvt.s32.f32	s14, s14
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
    fc72:	vldr	s6, [r4, #20]
      float* out,
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    fc76:	vldr	s9, [r3]
    fc7a:	vmul.f32	s5, s10, s5
    fc7e:	vmul.f32	s15, s15, s4
    fc82:	ldr	r3, [pc, #324]	; (fdc8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x278>)
    fc84:	vmov	r1, s14
      f0,
      parameters.timbre,
    fc88:	vldr	s10, [r4, #8]
    fc8c:	vcvt.s32.f32	s15, s15
    fc90:	add.w	r3, r3, r1, lsl #2
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    fc94:	vldr	s14, [r3]
    fc98:	vmov	r1, s15
    fc9c:	ldr	r3, [pc, #296]	; (fdc8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x278>)
    fc9e:	vnmul.f32	s14, s12, s14
    fca2:	add.w	r3, r3, r1, lsl #2
      float* out,
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    fca6:	vldr	s15, [r3]
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    fcaa:	vfma.f32	s0, s14, s1
      float* out,
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    const int kTriggerPulseDuration = 1.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.1e-3 * kSampleRate;
    const float q = 2000.0f * stmlib::SemitonesToRatio(decay_xt * 84.0f);
    fcae:	vmul.f32	s15, s15, s9
    fcb2:	vmul.f32	s9, s15, s2
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    fcb6:	bmi.w	1083a <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcea>
    fcba:	vcmp.f32	s3, s11
    fcbe:	vmrs	APSR_nzcv, fpscr
    fcc2:	it	gt
    fcc4:	vmovgt.f32	s3, s11
    
    if (trigger) {
    fcc8:	cbz	r2, fce4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x194>
      pulse_remaining_samples_ = kTriggerPulseDuration;
      pulse_height_ = 3.0f + 7.0f * accent;
    fcca:	vmov.f32	s14, #28	; 0x40e00000  7.0
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    
    if (trigger) {
      pulse_remaining_samples_ = kTriggerPulseDuration;
    fcce:	movs	r2, #48	; 0x30
      pulse_height_ = 3.0f + 7.0f * accent;
    fcd0:	vmov.f32	s15, #8	; 0x40400000  3.0
      noise_envelope_ = 2.0f;
    fcd4:	mov.w	r3, #1073741824	; 0x40000000
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    
    if (trigger) {
      pulse_remaining_samples_ = kTriggerPulseDuration;
    fcd8:	str	r2, [r0, #16]
      pulse_height_ = 3.0f + 7.0f * accent;
      noise_envelope_ = 2.0f;
    fcda:	str	r3, [r0, #32]
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    
    if (trigger) {
      pulse_remaining_samples_ = kTriggerPulseDuration;
      pulse_height_ = 3.0f + 7.0f * accent;
    fcdc:	vfma.f32	s15, s6, s14
    fce0:	vstr	s15, [r0, #24]
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    fce4:	vmov.f32	s14, #112	; 0x3f800000  1.0
    fce8:	ldr	r4, [pc, #260]	; (fdf0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a0>)
    
    for (int i = 0; i < kNumModes; ++i) {
      f[i] = std::min(f0 * kModeFrequencies[i], 0.499f);
      resonator_[i].set_f_q<stmlib::FREQUENCY_FAST>(
          f[i],
          1.0f + f[i] * (i == 0 ? q : q * 0.25f));
    fcea:	vmov.f32	s1, #80	; 0x3e800000  0.250
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
    fcee:	add	r1, sp, #24
    fcf0:	mov	r3, r0
    fcf2:	movs	r2, #0
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    fcf4:	vmov.f32	s12, s14
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    fcf8:	vldr	s2, [pc, #264]	; fe04 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b4>
    fcfc:	vldr	s18, [pc, #264]	; fe08 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b8>
    fd00:	vldr	s17, [pc, #264]	; fe0c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
    fd04:	vldr	s16, [pc, #264]	; fe10 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c0>
    
    float f[kNumModes];
    float gain[kNumModes];
    
    for (int i = 0; i < kNumModes; ++i) {
      f[i] = std::min(f0 * kModeFrequencies[i], 0.499f);
    fd08:	vmul.f32	s14, s5, s14
    fd0c:	vldr	s13, [pc, #228]	; fdf4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a4>
	return __b;
    fd10:	vldr	s11, [pc, #240]	; fe04 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b4>
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
    fd14:	vldr	s15, [pc, #224]	; fdf8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2a8>
    fd18:	vcmpe.f32	s14, s2
    fd1c:	vmrs	APSR_nzcv, fpscr
    fd20:	bgt.n	fd42 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f2>
    fd22:	vmul.f32	s15, s14, s14
    fd26:	vmov.f32	s13, s17
    fd2a:	vmov.f32	s4, s16
	return __b;
      return __a;
    fd2e:	vmov.f32	s11, s14
    fd32:	vfma.f32	s13, s15, s18
    fd36:	vfma.f32	s4, s15, s13
    fd3a:	vmul.f32	s13, s4, s14
    fd3e:	vmul.f32	s15, s13, s13
    fd42:	vstmia	r1!, {s11}
      resonator_[i].set_f_q<stmlib::FREQUENCY_FAST>(
          f[i],
          1.0f + f[i] * (i == 0 ? q : q * 0.25f));
    fd46:	cmp	r2, #0
    fd48:	beq.w	10868 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd18>
    fd4c:	vmul.f32	s14, s9, s1
    fd50:	vmov.f32	s4, s12
        5.62f};
    
    float f[kNumModes];
    float gain[kNumModes];
    
    for (int i = 0; i < kNumModes; ++i) {
    fd54:	adds	r2, #1

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    fd56:	vstr	s13, [r3, #40]	; 0x28
    fd5a:	adds	r3, #20
    fd5c:	cmp	r2, #5
    r_ = 1.0f / resonance;
    fd5e:	vfma.f32	s4, s11, s14
    fd62:	vmov.f32	s14, s4
    fd66:	vmov.f32	s4, #112	; 0x3f800000  1.0
    fd6a:	vdiv.f32	s11, s12, s14
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fd6e:	vmov.f32	s14, s12
    fd72:	vfma.f32	s14, s11, s13
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    fd76:	vstr	s11, [r3, #24]
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fd7a:	vadd.f32	s15, s14, s15
    fd7e:	vdiv.f32	s14, s12, s15
    fd82:	vstr	s14, [r3, #28]
    fd86:	beq.n	fe14 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c4>
    fd88:	adds	r4, #4
    fd8a:	vldr	s14, [r4]
    fd8e:	b.n	fd08 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b8>
    fd90:	vldr	s14, [pc, #48]	; fdc4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x274>
    fd94:	vadd.f32	s15, s15, s14
    fd98:	vcvt.s32.f32	s14, s15
    fd9c:	vmov	r2, s14
    fda0:	vcvt.f32.s32	s14, s14
    fda4:	vsub.f32	s15, s15, s14
    fda8:	vmov.f32	s14, s15
    fdac:	vcvt.s32.f32	s14, s14, #8
    fdb0:	vmov	r3, s14
    fdb4:	b.n	fb90 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40>
    fdb6:	nop
    fdb8:	.word	0xc3000000
    fdbc:	.word	0x42fe0000
    fdc0:	.word	0x42480000
    fdc4:	.word	0x43000000
    fdc8:	.word	0x20000958
    fdcc:	.word	0x42a80000
    fdd0:	.word	0x20000554
    fdd4:	.word	0xbd4ccccd
    fdd8:	.word	0x3f8ccccd
    fddc:	.word	0x3dcccccd
    fde0:	.word	0x43800000
    fde4:	.word	0x3aded289
    fde8:	.word	0x44fa0000
    fdec:	.word	0x39962fc9
    fdf0:	.word	0x2001fa2c
    fdf4:	.word	0x40919638
    fdf8:	.word	0x41a59707
    fdfc:	.word	0x3f2aaab0
    fe00:	.word	0x3e19999a
    fe04:	.word	0x3eff7cee
    fe08:	.word	0x425f2649
    fe0c:	.word	0x4121ba8f
    fe10:	.word	0x40490fdb
      resonator_[i].set_f_q<stmlib::FREQUENCY_FAST>(
          f[i],
          1.0f + f[i] * (i == 0 ? q : q * 0.25f));
    }
    
    if (tone < 0.666667f) {
    fe14:	vldr	s15, [pc, #-28]	; fdfc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
    fe18:	vcmpe.f32	s10, s15
    fe1c:	vmrs	APSR_nzcv, fpscr
    fe20:	bpl.w	107bc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc6c>
      // 808-style (2 modes)
      tone *= 1.5f;
    fe24:	vmov.f32	s15, #120	; 0x3fc00000  1.5
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
      gain[1] = 2.0f * tone + 0.15f;
    fe28:	vldr	s14, [pc, #-44]	; fe00 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b0>
    }
    
    if (tone < 0.666667f) {
      // 808-style (2 modes)
      tone *= 1.5f;
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
    fe2c:	vmov.f32	s13, #18	; 0x40900000  4.5
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    fe30:	movs	r3, #0
      gain[1] = 2.0f * tone + 0.15f;
    fe32:	vmov.f32	s12, #0	; 0x40000000  2.0
          1.0f + f[i] * (i == 0 ? q : q * 0.25f));
    }
    
    if (tone < 0.666667f) {
      // 808-style (2 modes)
      tone *= 1.5f;
    fe36:	vmul.f32	s10, s10, s15
    fe3a:	str	r3, [sp, #52]	; 0x34
    fe3c:	str	r3, [sp, #56]	; 0x38
    fe3e:	str	r3, [sp, #60]	; 0x3c
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
    fe40:	vsub.f32	s4, s4, s10
      gain[1] = 2.0f * tone + 0.15f;
    fe44:	vfma.f32	s14, s10, s12
    }
    
    if (tone < 0.666667f) {
      // 808-style (2 modes)
      tone *= 1.5f;
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
    fe48:	vmul.f32	s4, s4, s4
    fe4c:	vfma.f32	s15, s4, s13
      gain[1] = 2.0f * tone + 0.15f;
    fe50:	vstr	s14, [sp, #48]	; 0x30
    }
    
    if (tone < 0.666667f) {
      // 808-style (2 modes)
      tone *= 1.5f;
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
    fe54:	vstr	s15, [sp, #44]	; 0x2c
        gain[i] = tone;
        tone *= tone;
      }
    }

    float f_noise = f0 * 16.0f;
    fe58:	vmov.f32	s15, #48	; 0x41800000  16.0
    fe5c:	vmul.f32	s15, s5, s15
    CONSTRAIN(f_noise, 0.0f, 0.499f);
    fe60:	vcmpe.f32	s15, #0.0
    fe64:	vmrs	APSR_nzcv, fpscr
    fe68:	bmi.w	1082a <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcda>
    fe6c:	vldr	s14, [pc, #-108]	; fe04 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b4>
    fe70:	vcmpe.f32	s15, s14
    fe74:	vmrs	APSR_nzcv, fpscr
    fe78:	bgt.w	1080c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcbc>
    fe7c:	vmov.f32	s12, #112	; 0x3f800000  1.0
    fe80:	vldr	s13, [pc, #-124]	; fe08 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b8>
    fe84:	vmov.f32	s9, #120	; 0x3fc00000  1.5
    fe88:	vldr	s11, [pc, #-128]	; fe0c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2bc>
    fe8c:	vmul.f32	s10, s15, s15
    fe90:	vldr	s14, [pc, #-132]	; fe10 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c0>
    fe94:	vmov.f32	s4, s12
    fe98:	vfma.f32	s11, s10, s13
    fe9c:	vfma.f32	s4, s15, s9
    fea0:	vfma.f32	s14, s10, s11
    fea4:	vdiv.f32	s13, s12, s4
    fea8:	vmul.f32	s15, s14, s15
    feac:	vmov.f32	s11, s12
    feb0:	vfma.f32	s11, s15, s13
    feb4:	vfma.f32	s11, s15, s15
    feb8:	vdiv.f32	s14, s12, s11
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    febc:	vldr	s9, [r0, #36]	; 0x24

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    fec0:	vstr	s15, [r0, #140]	; 0x8c
    increment_ = (new_value - *state) / static_cast<float>(size);
    fec4:	vldr	s12, [sp, #168]	; 0xa8
    r_ = 1.0f / resonance;
    fec8:	vstr	s13, [r0, #144]	; 0x90
    fecc:	vmov.f32	s15, s9
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
    fed0:	vmov	r3, s12
    fed4:	vcvt.f32.u32	s20, s12
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
    fed8:	vstr	s14, [r0, #148]	; 0x94
    fedc:	add.w	r8, r3, #4294967295
    fee0:	vfnms.f32	s15, s6, s7
    fee4:	vdiv.f32	s16, s15, s20
    fee8:	cmp	r3, #0
    feea:	beq.w	100ec <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x59c>
    feee:	ldr	r3, [pc, #976]	; (102c0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x770>)
    fef0:	mov	r9, r8
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
        pulse_ = pulse;
      } else {
        pulse_ *= 1.0f - 1.0f / kPulseDecayTime;
    fef2:	vldr	s19, [pc, #976]	; 102c4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x774>
      }
      shell = stmlib::SoftClip(shell);
      
      // C56 / R194 / Q48 / C54 / R188 / D54
      float noise = 2.0f * stmlib::Random::GetFloat() - 1.0f;
      if (noise < 0.0f) noise = 0.0f;
    fef6:	mov	fp, r5
    fef8:	ldr.w	lr, [r3]
      
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
        float excitation = i == 0
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
    fefc:	vldr	s10, [pc, #968]	; 102c8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x778>
    ff00:	vmov.f32	s1, #112	; 0x3f800000  1.0
    ff04:	vldr	s21, [pc, #964]	; 102cc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x77c>
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
    ff08:	vldr	s2, [pc, #964]	; 102d0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x780>
                  excitation) + excitation * exciter_leak);
      }
      shell = stmlib::SoftClip(shell);
      
      // C56 / R194 / Q48 / C54 / R188 / D54
      float noise = 2.0f * stmlib::Random::GetFloat() - 1.0f;
    ff0c:	vldr	s18, [pc, #964]	; 102d4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x784>
    ff10:	vsub.f32	s1, s1, s3
      if (noise < 0.0f) noise = 0.0f;
    ff14:	vldr	s17, [pc, #960]	; 102d8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x788>
    ff18:	str	r3, [sp, #4]
    ff1a:	str.w	r8, [sp, #20]
        size);
    
    while (size--) {
      // Q45 / Q46
      float pulse = 0.0f;
      if (pulse_remaining_samples_) {
    ff1e:	ldr	r3, [r0, #16]
    ff20:	cmp	r3, #0
    ff22:	beq.w	1071a <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbca>
        --pulse_remaining_samples_;
    ff26:	subs	r3, #1
    ff28:	str	r3, [r0, #16]
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
    ff2a:	cmp	r3, #0
    ff2c:	beq.w	10724 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbd4>
    ff30:	vldr	s11, [r0, #24]
      }
      
      float sustain_gain_value = sustain_gain.Next();
      
      // R189 / C57 / R190 + C58 / C59 / R197 / R196 / IC14
      ONE_POLE(pulse_lp_, pulse, 0.75f);
    ff34:	vldr	s15, [r0, #28]
    ff38:	vmov.f32	s14, #104	; 0x3f400000  0.750
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
    ff3c:	ldr.w	ip, [pc, #988]	; 1031c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7cc>
  }

  inline float Next() {
    value_ += increment_;
    ff40:	vadd.f32	s9, s9, s16
    ff44:	vsub.f32	s13, s11, s15
    ff48:	add	r5, sp, #44	; 0x2c
  }
  
  inline float Next(float frequency) {
    if (frequency >= 0.5f) {
    ff4a:	vmov.f32	s7, #96	; 0x3f000000  0.5
  float b = table[index_integral + 1];
    ff4e:	add.w	sl, ip, #4
      frequency = 0.5f;
    }
    
    phase_ += frequency;
    if (phase_ >= 1.0f) {
    ff52:	vmov.f32	s6, #112	; 0x3f800000  1.0
    ff56:	add	r4, sp, #24
    ff58:	vfma.f32	s15, s13, s14
    ff5c:	mov	r1, r0
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
        float excitation = i == 0
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
        shell += gain[i] * (sustain
    ff5e:	vmov.f32	s4, #80	; 0x3e800000  0.250
      }
      
      float sustain_gain_value = sustain_gain.Next();
      
      // R189 / C57 / R190 + C58 / C59 / R197 / R196 / IC14
      ONE_POLE(pulse_lp_, pulse, 0.75f);
    ff62:	mov	r3, r0
      
      float shell = 0.0f;
    ff64:	vldr	s13, [pc, #880]	; 102d8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x788>
      for (int i = 0; i < kNumModes; ++i) {
    ff68:	movs	r2, #0
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
        pulse_ = pulse;
      } else {
        pulse_ *= 1.0f - 1.0f / kPulseDecayTime;
    ff6a:	vstr	s11, [r0, #20]
      }
      
      float sustain_gain_value = sustain_gain.Next();
      
      // R189 / C57 / R190 + C58 / C59 / R197 / R196 / IC14
      ONE_POLE(pulse_lp_, pulse, 0.75f);
    ff6e:	vstr	s15, [r0, #28]
      
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
        float excitation = i == 0
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
    ff72:	cmp	r2, #0
    ff74:	beq.w	10858 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xd08>
    ff78:	vmul.f32	s25, s11, s10
        shell += gain[i] * (sustain
    ff7c:	vldmia	r5!, {s12}
    ff80:	cmp	r7, #0
    ff82:	bne.w	1060c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xabc>
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    ff86:	vmov.f32	s14, s25
    ff8a:	vldr	s22, [r3, #52]	; 0x34
    ff8e:	vldr	s15, [r3, #44]	; 0x2c
    ff92:	vldr	s24, [r3, #40]	; 0x28
    ff96:	vfms.f32	s14, s15, s22
    ff9a:	vldr	s23, [r3, #56]	; 0x38
    ff9e:	vmov.f32	s15, s14
    ffa2:	vldr	s14, [r3, #48]	; 0x30
    ffa6:	vfms.f32	s15, s22, s24
    ffaa:	vsub.f32	s15, s15, s23
    ffae:	vmul.f32	s15, s15, s14
    bp = g_ * hp + state_1_;
    ffb2:	vmov.f32	s14, s22
    ffb6:	vfma.f32	s14, s24, s15
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    ffba:	vfma.f32	s23, s24, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    ffbe:	vmov.f32	s22, s14
    ffc2:	vfma.f32	s22, s24, s15
    ffc6:	vmov.f32	s15, s14
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    ffca:	vfma.f32	s23, s24, s14
    ffce:	vfma.f32	s15, s8, s25
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    ffd2:	vstr	s22, [r3, #52]	; 0x34
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
    ffd6:	vstr	s23, [r3, #56]	; 0x38
      
      // R189 / C57 / R190 + C58 / C59 / R197 / R196 / IC14
      ONE_POLE(pulse_lp_, pulse, 0.75f);
      
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
    ffda:	adds	r2, #1
    ffdc:	adds	r3, #20
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
        shell += gain[i] * (sustain
            ? oscillator_[i].Next(f[i]) * sustain_gain_value * 0.25f
            : resonator_[i].Process<stmlib::FILTER_MODE_BAND_PASS>(
                  excitation) + excitation * exciter_leak);
    ffde:	vfma.f32	s13, s12, s15
    ffe2:	adds	r1, #12
      
      // R189 / C57 / R190 + C58 / C59 / R197 / R196 / IC14
      ONE_POLE(pulse_lp_, pulse, 0.75f);
      
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
    ffe4:	cmp	r2, #5
    ffe6:	add.w	r4, r4, #4
    ffea:	bne.n	ff72 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x422>
inline float SoftLimit(float x) {
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
    ffec:	vmov.f32	s15, #136	; 0xc0400000 -3.0
    fff0:	vcmpe.f32	s13, s15
    fff4:	vmrs	APSR_nzcv, fpscr
    fff8:	bmi.w	10692 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb42>
    return -1.0f;
  } else if (x > 3.0f) {
    fffc:	vmov.f32	s15, #8	; 0x40400000  3.0
   10000:	vcmpe.f32	s13, s15
   10004:	vmrs	APSR_nzcv, fpscr
   10008:	bgt.w	1074c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbfc>
inline float Crossfade(float a, float b, float fade) {
  return a + (b - a) * fade;
}

inline float SoftLimit(float x) {
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
   1000c:	vmov.f32	s14, #59	; 0x41d80000  27.0
   10010:	vmov.f32	s12, #34	; 0x41100000  9.0
   10014:	vmov.f32	s15, s14
   10018:	vmul.f32	s12, s13, s12
   1001c:	vfma.f32	s15, s13, s13
   10020:	vfma.f32	s14, s13, s12
   10024:	vmul.f32	s13, s15, s13
   10028:	vdiv.f32	s7, s13, s14
   1002c:	ldr	r3, [pc, #684]	; (102dc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x78c>)
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   1002e:	add.w	r9, r9, #4294967295
      shell = stmlib::SoftClip(shell);
      
      // C56 / R194 / Q48 / C54 / R188 / D54
      float noise = 2.0f * stmlib::Random::GetFloat() - 1.0f;
      if (noise < 0.0f) noise = 0.0f;
      noise_envelope_ *= noise_envelope_decay;
   10032:	vldr	s13, [r0, #32]
   10036:	mul.w	r3, r3, lr
   1003a:	ldr.w	lr, [pc, #740]	; 10320 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d0>
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   1003e:	vldr	s12, [r0, #152]	; 0x98
   10042:	add	lr, r3
                  excitation) + excitation * exciter_leak);
      }
      shell = stmlib::SoftClip(shell);
      
      // C56 / R194 / Q48 / C54 / R188 / D54
      float noise = 2.0f * stmlib::Random::GetFloat() - 1.0f;
   10044:	vmov.f32	s23, #0	; 0x40000000  2.0
   10048:	vmov.f32	s11, #240	; 0xbf800000 -1.0
   1004c:	vldr	s15, [r0, #144]	; 0x90
   10050:	vmov	s14, lr
      if (noise < 0.0f) noise = 0.0f;
      noise_envelope_ *= noise_envelope_decay;
   10054:	vmul.f32	s13, s0, s13
   10058:	vnmul.f32	s15, s15, s12
   1005c:	vldr	s4, [r0, #140]	; 0x8c
                  excitation) + excitation * exciter_leak);
      }
      shell = stmlib::SoftClip(shell);
      
      // C56 / R194 / Q48 / C54 / R188 / D54
      float noise = 2.0f * stmlib::Random::GetFloat() - 1.0f;
   10060:	vcvt.f32.u32	s22, s14
   10064:	vldr	s6, [r0, #156]	; 0x9c
      if (noise < 0.0f) noise = 0.0f;
      noise_envelope_ *= noise_envelope_decay;
   10068:	vstr	s13, [r0, #32]
   1006c:	vldr	s14, [r0, #148]	; 0x94
                  excitation) + excitation * exciter_leak);
      }
      shell = stmlib::SoftClip(shell);
      
      // C56 / R194 / Q48 / C54 / R188 / D54
      float noise = 2.0f * stmlib::Random::GetFloat() - 1.0f;
   10070:	vmul.f32	s22, s22, s18
   10074:	vfma.f32	s11, s22, s23
      if (noise < 0.0f) noise = 0.0f;
   10078:	vcmp.f32	s11, #0.0
   1007c:	vmrs	APSR_nzcv, fpscr
   10080:	it	mi
   10082:	vmovmi.f32	s11, s17
   10086:	cmp	r7, #0
   10088:	it	ne
   1008a:	vmovne.f32	s13, s9
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   1008e:	cmp.w	r9, #4294967295
   10092:	vmul.f32	s13, s3, s13
   10096:	vadd.f32	s13, s13, s13
   1009a:	vfma.f32	s15, s13, s11
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   1009e:	vmov.f32	s13, s6
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   100a2:	vfms.f32	s15, s12, s4
   100a6:	vsub.f32	s15, s15, s6
   100aa:	vmul.f32	s15, s15, s14
    bp = g_ * hp + state_1_;
   100ae:	vmov.f32	s14, s12
   100b2:	vfma.f32	s14, s4, s15
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   100b6:	vfma.f32	s13, s4, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   100ba:	vmov.f32	s11, s14

      // C66 / R201 / C67 / R202 / R203 / Q49
      noise = noise_filter_.Process<stmlib::FILTER_MODE_BAND_PASS>(noise);
      
      // IC13
      *out++ = noise + shell * (1.0f - snappy);
   100be:	vmov.f32	s12, s14
   100c2:	vfma.f32	s11, s4, s15
   100c6:	vfma.f32	s12, s7, s1
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   100ca:	vmov.f32	s15, s13
   100ce:	vfma.f32	s15, s4, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   100d2:	vstr	s11, [r0, #152]	; 0x98
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   100d6:	vstr	s15, [r0, #156]	; 0x9c
   100da:	vstmia	fp!, {s12}
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   100de:	bne.w	ff1e <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ce>
   100e2:	ldr	r3, [sp, #4]
   100e4:	ldr.w	r8, [sp, #20]
   100e8:	str.w	lr, [r3]
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
   100ec:	ldr	r2, [sp, #8]

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   100ee:	vmov.f32	s8, #112	; 0x3f800000  1.0
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   100f2:	vstr	s9, [r0, #36]	; 0x24
   100f6:	vmov.f32	s14, #40	; 0x41400000  12.0
   100fa:	vldr	s12, [r2, #12]
   100fe:	vmov.f32	s4, #28	; 0x40e00000  7.0
   10102:	vmov.f32	s10, s8
  synthetic_snare_drum_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
   10106:	vldr	s2, [r2, #8]
   1010a:	vsub.f32	s15, s12, s8
   1010e:	vldr	s13, [pc, #464]	; 102e0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x790>
      float decay,
      float snappy,
      float* out,
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    fm_amount *= fm_amount;
   10112:	vmul.f32	s2, s2, s2
   10116:	vldr	s1, [pc, #460]	; 102e4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x794>
   1011a:	vnmul.f32	s13, s12, s13
      parameters.morph,
      parameters.harmonics,
   1011e:	vldr	s9, [r2, #16]
   10122:	vfma.f32	s10, s12, s15
   10126:	vldr	s15, [pc, #448]	; 102e8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x798>
   1012a:	vnmul.f32	s14, s14, s2
           -decay_xt * 72.0f - fm_amount * 12.0f + snappy * 7.0f);
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
    const float fm_decay = 1.0f - 1.0f / (0.007f * kSampleRate);
    
    snappy = snappy * 1.1f - 0.05f;
   1012e:	vldr	s11, [pc, #444]	; 102ec <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x79c>
   10132:	vfms.f32	s13, s9, s4
   10136:	vldr	s0, [pc, #440]	; 102f0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a0>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   1013a:	vldr	s7, [pc, #440]	; 102f4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a4>
    fm_amount *= fm_amount;
    const float drum_decay = 1.0f - 1.0f / (0.015f * kSampleRate) * \
        stmlib::SemitonesToRatio(
           -decay_xt * 72.0f - fm_amount * 12.0f + snappy * 7.0f);
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
   1013e:	vmov.f32	s22, s8
    const float fm_decay = 1.0f - 1.0f / (0.007f * kSampleRate);
    
    snappy = snappy * 1.1f - 0.05f;
   10142:	vfma.f32	s0, s9, s11

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10146:	ldr	r3, [pc, #432]	; (102f8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a8>)
      size);
  
  synthetic_snare_drum_.Render(
      parameters.trigger & TRIGGER_UNPATCHED,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
   10148:	vldr	s11, [r2, #20]
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    fm_amount *= fm_amount;
    const float drum_decay = 1.0f - 1.0f / (0.015f * kSampleRate) * \
        stmlib::SemitonesToRatio(
           -decay_xt * 72.0f - fm_amount * 12.0f + snappy * 7.0f);
   1014c:	vmov.f32	s21, s8

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   10150:	vnmul.f32	s10, s12, s10
   10154:	ldr	r4, [sp, #12]
   10156:	vldr	s6, [pc, #420]	; 102fc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7ac>
   1015a:	vadd.f32	s13, s13, s15
   1015e:	and.w	r1, r4, #2
   10162:	vfma.f32	s14, s10, s1
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
   10166:	vldr	s3, [pc, #408]	; 10300 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b0>
    const float fm_decay = 1.0f - 1.0f / (0.007f * kSampleRate);
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
   1016a:	vcmpe.f32	s0, #0.0
   1016e:	uxtb	r1, r1
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   10170:	vcvt.s32.f32	s10, s13
   10174:	and.w	r4, r4, #1
   10178:	vmrs	APSR_nzcv, fpscr

  return lut_pitch_ratio_high[pitch_integral] * \
   1017c:	vmov	r2, s10

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   10180:	vfma.f32	s14, s9, s4
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10184:	vcvt.f32.s32	s9, s10

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10188:	add.w	r3, r3, r2, lsl #2
    fm_amount *= fm_amount;
    const float drum_decay = 1.0f - 1.0f / (0.015f * kSampleRate) * \
        stmlib::SemitonesToRatio(
           -decay_xt * 72.0f - fm_amount * 12.0f + snappy * 7.0f);
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
   1018c:	vldr	s10, [r3]
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10190:	vsub.f32	s13, s13, s9

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10194:	ldr	r3, [pc, #352]	; (102f8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7a8>)

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   10196:	vadd.f32	s15, s14, s15
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   1019a:	vmul.f32	s13, s13, s7
extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   1019e:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   101a2:	vcvt.s32.f32	s13, s13
   101a6:	vcvt.f32.s32	s9, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   101aa:	vmov	r2, s14
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   101ae:	vmov	r5, s13

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   101b2:	add.w	r2, r3, r2, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   101b6:	ldr	r3, [pc, #332]	; (10304 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b4>)
   101b8:	vsub.f32	s15, s15, s9
   101bc:	add.w	r3, r3, r5, lsl #2
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    fm_amount *= fm_amount;
    const float drum_decay = 1.0f - 1.0f / (0.015f * kSampleRate) * \
        stmlib::SemitonesToRatio(
           -decay_xt * 72.0f - fm_amount * 12.0f + snappy * 7.0f);
   101c0:	vldr	s14, [r2]
   101c4:	vmul.f32	s15, s15, s7
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
   101c8:	vldr	s13, [r3]
   101cc:	ldr	r3, [pc, #308]	; (10304 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b4>)
   101ce:	vnmul.f32	s13, s10, s13
   101d2:	vcvt.s32.f32	s15, s15
   101d6:	vfma.f32	s22, s13, s3
   101da:	vmov	r2, s15
   101de:	add.w	r3, r3, r2, lsl #2
      size_t size) {
    const float decay_xt = decay * (1.0f + decay * (decay - 1.0f));
    fm_amount *= fm_amount;
    const float drum_decay = 1.0f - 1.0f / (0.015f * kSampleRate) * \
        stmlib::SemitonesToRatio(
           -decay_xt * 72.0f - fm_amount * 12.0f + snappy * 7.0f);
   101e2:	vldr	s15, [r3]
   101e6:	vnmul.f32	s15, s14, s15
   101ea:	vfma.f32	s21, s15, s6
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
    const float fm_decay = 1.0f - 1.0f / (0.007f * kSampleRate);
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
   101ee:	bmi.w	1081c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xccc>
   101f2:	vcmpe.f32	s0, s8
   101f6:	vmrs	APSR_nzcv, fpscr
   101fa:	ble.w	10842 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcf2>
   101fe:	vmov.f32	s0, s8
   10202:	vldr	s6, [pc, #260]	; 10308 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7b8>
   10206:	vldr	s16, [pc, #208]	; 102d8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x788>
    
    const float drum_level = stmlib::Sqrt(1.0f - snappy);
    const float snare_level = stmlib::Sqrt(snappy);
    
    const float snare_f_min = std::min(10.0f * f0, 0.5f);
   1020a:	vmov.f32	s15, #36	; 0x41200000  10.0
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   1020e:	vmov.f32	s14, #96	; 0x3f000000  0.5
    return sqrtf(x);
  }
#else
  inline float Sqrt(float x) {
    float result;
    __asm ("vsqrt.f32 %0, %1" : "=w" (result) : "w" (x) );
   10212:	vsqrt.f32	s16, s16
   10216:	vmul.f32	s15, s5, s15
   1021a:	vsqrt.f32	s0, s0
   1021e:	vcmpe.f32	s15, s14
   10222:	vmrs	APSR_nzcv, fpscr
   10226:	bgt.w	1075c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc0c>
   1022a:	vmul.f32	s9, s15, s15
   1022e:	vldr	s8, [pc, #220]	; 1030c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7bc>
   10232:	vldr	s14, [pc, #220]	; 10310 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c0>
   10236:	vmov.f32	s13, #112	; 0x3f800000  1.0
   1023a:	vldr	s10, [pc, #216]	; 10314 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c4>
   1023e:	vfma.f32	s14, s9, s8
   10242:	vfma.f32	s10, s9, s14
   10246:	vmul.f32	s10, s10, s15
   1024a:	vadd.f32	s15, s10, s13
   1024e:	vdiv.f32	s7, s13, s15
    const float snare_f_max = std::min(35.0f * f0, 0.5f);
   10252:	vldr	s13, [pc, #196]	; 10318 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c8>
   10256:	vmov.f32	s15, #96	; 0x3f000000  0.5
   1025a:	vmul.f32	s14, s5, s13
   1025e:	vcmpe.f32	s14, s15
   10262:	vmrs	APSR_nzcv, fpscr
   10266:	bgt.w	10752 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc02>
   1026a:	vmul.f32	s9, s14, s14
   1026e:	vldr	s8, [pc, #156]	; 1030c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7bc>
   10272:	vldr	s15, [pc, #156]	; 10310 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c0>
   10276:	vldr	s13, [pc, #156]	; 10314 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c4>
   1027a:	vfma.f32	s15, s9, s8
   1027e:	vfma.f32	s13, s9, s15
   10282:	vmul.f32	s13, s13, s14
   10286:	vmul.f32	s4, s13, s13
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   1028a:	vmov.f32	s8, #112	; 0x3f800000  1.0
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
   1028e:	vstr	s10, [r0, #260]	; 0x104

    snare_hp_.set_f<stmlib::FREQUENCY_FAST>(snare_f_min);
    snare_lp_.set_f_q<stmlib::FREQUENCY_FAST>(snare_f_max,
        0.5f + 2.0f * snappy);
    drum_lp_.set_f<stmlib::FREQUENCY_FAST>(3.0f * f0);
   10292:	vmov.f32	s15, #8	; 0x40400000  3.0
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   10296:	vldr	s10, [pc, #120]	; 10310 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c0>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    gi_ = 1.0f / (1.0f + g_);
   1029a:	vstr	s7, [r0, #264]	; 0x108
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   1029e:	vmov.f32	s9, s8

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   102a2:	vstr	s13, [r0, #272]	; 0x110
   102a6:	vmul.f32	s14, s5, s15
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   102aa:	vldr	s3, [pc, #96]	; 1030c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7bc>
   102ae:	vldr	s15, [pc, #100]	; 10314 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c4>
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   102b2:	vfma.f32	s9, s6, s13
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   102b6:	vstr	s6, [r0, #276]	; 0x114
      // The usual tangent approximation uses 3.1755e-01 and 2.033e-01, but
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
   102ba:	vmul.f32	s7, s14, s14
   102be:	b.n	10338 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e8>
   102c0:	.word	0x20020470
   102c4:	.word	0x3f4aaaab
   102c8:	.word	0x3cd4fdf4
   102cc:	.word	0x3bc49ba6
   102d0:	.word	0x44800000
   102d4:	.word	0x2f800000
   102d8:	.word	0x00000000
   102dc:	.word	0x0019660d
   102e0:	.word	0x42700000
   102e4:	.word	0x42900000
   102e8:	.word	0x43000000
   102ec:	.word	0x3f8ccccd
   102f0:	.word	0xbd4ccccd
   102f4:	.word	0x43800000
   102f8:	.word	0x20000554
   102fc:	.word	0x3ab60b61
   10300:	.word	0x3b088889
   10304:	.word	0x20000958
   10308:	.word	0x3ecccccd
   1030c:	.word	0x425f2649
   10310:	.word	0x4121ba8f
   10314:	.word	0x40490fdb
   10318:	.word	0x420c0000
   1031c:	.word	0x20002b10
   10320:	.word	0x3c6ef35f
   10324:	.word	0x3cf5c28f
   10328:	.word	0x3d23d70a
   1032c:	.word	0x473b8000
   10330:	.word	0x3f333333
   10334:	.word	0x3e99999a
      return f * (M_PI_F + f2 * (a + b * f2));
   10338:	vmov.f32	s13, s10
   1033c:	vfma.f32	s13, s7, s3
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10340:	vadd.f32	s10, s9, s4
   10344:	vdiv.f32	s9, s8, s10
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   10348:	vfma.f32	s15, s7, s13
   1034c:	vmul.f32	s15, s15, s14
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    gi_ = 1.0f / (1.0f + g_);
   10350:	vadd.f32	s14, s15, s8
  
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
   10354:	vstr	s15, [r0, #248]	; 0xf8
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10358:	vstr	s9, [r0, #280]	; 0x118
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f(float f) {
    g_ = tan<approximation>(f);
    gi_ = 1.0f / (1.0f + g_);
   1035c:	vdiv.f32	s15, s8, s14
   10360:	vstr	s15, [r0, #252]	; 0xfc
    
    if (trigger) {
   10364:	cbz	r4, 103a4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x854>
      snare_amplitude_ = drum_amplitude_ = 0.3f + 0.7f * accent;
      fm_ = 1.0f;
      phase_[0] = phase_[1] = 0.0f;
      hold_counter_ = static_cast<int>((0.04f + decay * 0.03f) * kSampleRate);
   10366:	vldr	s14, [pc, #-68]	; 10324 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d4>
    drum_lp_.set_f<stmlib::FREQUENCY_FAST>(3.0f * f0);
    
    if (trigger) {
      snare_amplitude_ = drum_amplitude_ = 0.3f + 0.7f * accent;
      fm_ = 1.0f;
      phase_[0] = phase_[1] = 0.0f;
   1036a:	movs	r3, #0
      hold_counter_ = static_cast<int>((0.04f + decay * 0.03f) * kSampleRate);
   1036c:	vldr	s15, [pc, #-72]	; 10328 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7d8>
   10370:	vldr	s13, [pc, #-72]	; 1032c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7dc>
   10374:	vfma.f32	s15, s12, s14
    snare_lp_.set_f_q<stmlib::FREQUENCY_FAST>(snare_f_max,
        0.5f + 2.0f * snappy);
    drum_lp_.set_f<stmlib::FREQUENCY_FAST>(3.0f * f0);
    
    if (trigger) {
      snare_amplitude_ = drum_amplitude_ = 0.3f + 0.7f * accent;
   10378:	vldr	s10, [pc, #-76]	; 10330 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e0>
   1037c:	vldr	s14, [pc, #-76]	; 10334 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7e4>
      fm_ = 1.0f;
   10380:	vstr	s8, [r0, #236]	; 0xec
    snare_lp_.set_f_q<stmlib::FREQUENCY_FAST>(snare_f_max,
        0.5f + 2.0f * snappy);
    drum_lp_.set_f<stmlib::FREQUENCY_FAST>(3.0f * f0);
    
    if (trigger) {
      snare_amplitude_ = drum_amplitude_ = 0.3f + 0.7f * accent;
   10384:	vfma.f32	s14, s11, s10
      fm_ = 1.0f;
      phase_[0] = phase_[1] = 0.0f;
   10388:	str.w	r3, [r0, #224]	; 0xe0
   1038c:	str.w	r3, [r0, #220]	; 0xdc
      hold_counter_ = static_cast<int>((0.04f + decay * 0.03f) * kSampleRate);
   10390:	vmul.f32	s15, s15, s13
   10394:	vcvt.s32.f32	s15, s15
    snare_lp_.set_f_q<stmlib::FREQUENCY_FAST>(snare_f_max,
        0.5f + 2.0f * snappy);
    drum_lp_.set_f<stmlib::FREQUENCY_FAST>(3.0f * f0);
    
    if (trigger) {
      snare_amplitude_ = drum_amplitude_ = 0.3f + 0.7f * accent;
   10398:	vstr	s14, [r0, #228]	; 0xe4
   1039c:	vstr	s14, [r0, #232]	; 0xe8
      fm_ = 1.0f;
      phase_[0] = phase_[1] = 0.0f;
      hold_counter_ = static_cast<int>((0.04f + decay * 0.03f) * kSampleRate);
   103a0:	vstr	s15, [r0, #244]	; 0xf4
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   103a4:	vldr	s4, [r0, #240]	; 0xf0
    
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    while (size--) {
   103a8:	ldr	r3, [sp, #168]	; 0xa8
    increment_ = (new_value - *state) / static_cast<float>(size);
   103aa:	vmov.f32	s15, s4
   103ae:	vfnms.f32	s15, s11, s12
   103b2:	vdiv.f32	s18, s15, s20
   103b6:	cmp	r3, #0
   103b8:	beq.w	105fe <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xaae>
   103bc:	ldr	r3, [pc, #936]	; (10768 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc18>)
      if (sustain) {
        snare_amplitude_ = sustain_gain.Next();
        drum_amplitude_ = snare_amplitude_;
        fm_ = 0.0f;
   103be:	movs	r4, #0
        // The envelope for the drum has a very long tail.
        // The envelope for the snare has a "hold" stage which lasts between
        // 40 and 70 ms
        drum_amplitude_ *= (drum_amplitude_ > 0.03f || !(size & 1))
            ? drum_decay
            : 1.0f;
   103c0:	vldr	s20, [pc, #936]	; 1076c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc1c>
   103c4:	str	r3, [sp, #4]
        if (hold_counter_) {
          --hold_counter_;
        } else {
          snare_amplitude_ *= snare_decay;
        }
        fm_ *= fm_decay;
   103c6:	vldr	s19, [pc, #936]	; 10770 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc20>
   103ca:	vmov.f32	s15, #64	; 0x3e000000  0.125
   103ce:	ldr	r3, [r3, #0]
   103d0:	vmov.f32	s3, #32	; 0x41000000  8.0
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
      phase_[1] += f * 1.47f;
   103d4:	vldr	s17, [pc, #924]	; 10774 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc24>
        // The envelope for the drum has a very long tail.
        // The envelope for the snare has a "hold" stage which lasts between
        // 40 and 70 ms
        drum_amplitude_ *= (drum_amplitude_ > 0.03f || !(size & 1))
            ? drum_decay
            : 1.0f;
   103d8:	vmov.f32	s8, #112	; 0x3f800000  1.0
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
      phase_[1] += f * 1.47f;
      if (reset_noise_amount > 0.1f) {
   103dc:	vldr	s1, [pc, #920]	; 10778 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc28>
   103e0:	vsub.f32	s15, s15, s5
   103e4:	ldr	r5, [sp, #16]
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
   103e6:	vmov.f32	s7, #96	; 0x3f000000  0.5
   103ea:	vmul.f32	s3, s15, s3
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    while (size--) {
      if (sustain) {
   103ee:	cmp	r1, #0
   103f0:	beq.w	106c0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb70>
      // The 909 circuit has a funny kind of oscillator coupling - the signal
      // leaving Q40's collector and resetting all oscillators allow some
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
   103f4:	vcmpe.f32	s3, #0.0
        size);
    while (size--) {
      if (sustain) {
        snare_amplitude_ = sustain_gain.Next();
        drum_amplitude_ = snare_amplitude_;
        fm_ = 0.0f;
   103f8:	vldr	s15, [pc, #956]	; 107b8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc68>
  }

  inline float Next() {
    value_ += increment_;
   103fc:	vadd.f32	s4, s4, s18
   10400:	str.w	r4, [r0, #236]	; 0xec
   10404:	vmov.f32	s9, s15
      // The 909 circuit has a funny kind of oscillator coupling - the signal
      // leaving Q40's collector and resetting all oscillators allow some
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
   10408:	vmrs	APSR_nzcv, fpscr
        &sustain_gain_,
        accent * decay,
        size);
    while (size--) {
      if (sustain) {
        snare_amplitude_ = sustain_gain.Next();
   1040c:	vstr	s4, [r0, #232]	; 0xe8
   10410:	vmov.f32	s31, s4
        drum_amplitude_ = snare_amplitude_;
   10414:	vstr	s4, [r0, #228]	; 0xe4
      // The 909 circuit has a funny kind of oscillator coupling - the signal
      // leaving Q40's collector and resetting all oscillators allow some
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
   10418:	bmi.w	10714 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbc4>
   1041c:	vcmpe.f32	s3, s8
   10420:	vmrs	APSR_nzcv, fpscr
   10424:	ble.w	10746 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbf6>
   10428:	vmov.f32	s10, #112	; 0x3f800000  1.0
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
   1042c:	vmov.f32	s14, s8
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
   10430:	vldr	s13, [r0, #224]	; 0xe0
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
   10434:	vmov.f32	s12, #240	; 0xbf800000 -1.0
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
   10438:	vmul.f32	s10, s2, s10
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
   1043c:	vfma.f32	s14, s2, s15
   10440:	vmov.f32	s15, s14
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
   10444:	vldr	s14, [r0, #220]	; 0xdc
   10448:	vcmpe.f32	s14, s7
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
   1044c:	vmul.f32	s15, s15, s5
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
   10450:	vmrs	APSR_nzcv, fpscr
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
   10454:	vcmpe.f32	s13, s7
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
      phase_[1] += f * 1.47f;
   10458:	vfma.f32	s13, s15, s17
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
   1045c:	ite	le
   1045e:	vmovle.f32	s11, s8
   10462:	vmovgt.f32	s11, s12
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
   10466:	vmrs	APSR_nzcv, fpscr
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
      phase_[1] += f * 1.47f;
      if (reset_noise_amount > 0.1f) {
   1046a:	vcmpe.f32	s10, s1
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
   1046e:	vadd.f32	s15, s14, s15
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
      reset_noise_amount *= reset_noise_amount;
      reset_noise_amount *= fm_amount;
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
   10472:	it	le
   10474:	vmovle.f32	s12, s8
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
      phase_[1] += f * 1.47f;
      if (reset_noise_amount > 0.1f) {
   10478:	vmrs	APSR_nzcv, fpscr
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
      phase_[1] += f * 1.47f;
   1047c:	vstr	s13, [r0, #224]	; 0xe0
      reset_noise += phase_[0] > 0.5f ? -1.0f : 1.0f;
      reset_noise += phase_[1] > 0.5f ? -1.0f : 1.0f;
      reset_noise *= reset_noise_amount * 0.025f;

      float f = f0 * (1.0f + fm_amount * (4.0f * fm_));
      phase_[0] += f;
   10480:	vstr	s15, [r0, #220]	; 0xdc
      phase_[1] += f * 1.47f;
      if (reset_noise_amount > 0.1f) {
   10484:	ble.w	10698 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb48>
        if (phase_[0] >= 1.0f + reset_noise) {
   10488:	vldr	s14, [pc, #752]	; 1077c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc2c>
   1048c:	vadd.f32	s12, s12, s11
   10490:	vmul.f32	s10, s10, s14
   10494:	vmov.f32	s14, s8
   10498:	vfma.f32	s14, s12, s10
   1049c:	vcmpe.f32	s15, s14
   104a0:	vmrs	APSR_nzcv, fpscr
   104a4:	blt.n	104ae <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x95e>
          phase_[0] = 1.0f - phase_[0];
   104a6:	vsub.f32	s15, s8, s15
   104aa:	vstr	s15, [r0, #220]	; 0xdc
        }
        if (phase_[1] >= 1.0f + reset_noise) {
   104ae:	vcmpe.f32	s13, s14
   104b2:	vmrs	APSR_nzcv, fpscr
   104b6:	blt.n	104c0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
          phase_[1] = 1.0f - phase_[1];
   104b8:	vsub.f32	s13, s8, s13
   104bc:	vstr	s13, [r0, #224]	; 0xe0
          phase_[1] -= 1.0f;
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
   104c0:	vldr	s14, [r0, #220]	; 0xdc
    snare_hp_.Init();
    snare_lp_.Init();
  }
  
  inline float DistortedSine(float phase) {
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.3f;
   104c4:	vcmpe.f32	s14, s7
   104c8:	vmrs	APSR_nzcv, fpscr
   104cc:	bpl.w	10680 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb30>
   104d0:	vmov.f32	s12, #16	; 0x40800000  4.0
   104d4:	vldr	s15, [pc, #680]	; 10780 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc30>
   104d8:	vfma.f32	s15, s14, s12
          phase_[1] -= 1.0f;
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
   104dc:	vabs.f32	s12, s15
   104e0:	vldr	s11, [pc, #672]	; 10784 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc34>
   104e4:	vadd.f32	s15, s15, s15
   104e8:	vldr	s14, [pc, #668]	; 10788 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc38>
    snare_hp_.Init();
    snare_lp_.Init();
  }
  
  inline float DistortedSine(float phase) {
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.3f;
   104ec:	vcmpe.f32	s13, s7
          phase_[1] -= 1.0f;
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
   104f0:	vadd.f32	s12, s12, s8
    snare_hp_.Init();
    snare_lp_.Init();
  }
  
  inline float DistortedSine(float phase) {
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.3f;
   104f4:	vmrs	APSR_nzcv, fpscr
          phase_[1] -= 1.0f;
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
   104f8:	vdiv.f32	s10, s15, s12
   104fc:	vfma.f32	s14, s10, s11
    snare_hp_.Init();
    snare_lp_.Init();
  }
  
  inline float DistortedSine(float phase) {
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.3f;
   10500:	bpl.w	1066e <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb1e>
   10504:	vmov.f32	s12, #16	; 0x40800000  4.0
   10508:	vldr	s15, [pc, #628]	; 10780 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc30>
   1050c:	vfma.f32	s15, s13, s12
   10510:	ldr	r2, [pc, #632]	; (1078c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc3c>)
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
      drum += DistortedSine(phase_[1]) * 0.25f;
   10512:	vabs.f32	s13, s15
   10516:	vadd.f32	s15, s15, s15
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   1051a:	vldr	s25, [r0, #284]	; 0x11c
   1051e:	mul.w	r2, r2, r3
   10522:	ldr	r3, [pc, #620]	; (10790 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc40>)
   10524:	vadd.f32	s13, s13, s8
   10528:	vldr	s24, [r0, #276]	; 0x114
   1052c:	add	r3, r2
   1052e:	vldr	s6, [pc, #612]	; 10794 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc44>
   10532:	vnmul.f32	s24, s24, s25
   10536:	vldr	s26, [r0, #272]	; 0x110
   1053a:	vmov	s12, r3
   1053e:	vdiv.f32	s30, s15, s13
   10542:	vldr	s10, [r0, #288]	; 0x120
    
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    while (size--) {
   10546:	add.w	r8, r8, #4294967295
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
      drum += DistortedSine(phase_[1]) * 0.25f;
      drum *= drum_amplitude_ * drum_level;
   1054a:	vldr	s13, [r0, #228]	; 0xe4
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
   1054e:	vldr	s15, [r0, #248]	; 0xf8
    
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    while (size--) {
   10552:	cmp.w	r8, #4294967295
   10556:	vldr	s11, [r0, #260]	; 0x104
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   1055a:	vcvt.f32.u32	s28, s12
   1055e:	vldr	s12, [r0, #280]	; 0x118
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
      drum += DistortedSine(phase_[1]) * 0.25f;
   10562:	vmov.f32	s29, #80	; 0x3e800000  0.250
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
   10566:	vldr	s27, [r0, #268]	; 0x10c
      drum *= drum_amplitude_ * drum_level;
   1056a:	vmul.f32	s13, s16, s13
   1056e:	vldr	s23, [r0, #264]	; 0x108
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10572:	vfma.f32	s24, s28, s6
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
   10576:	vldr	s28, [r0, #256]	; 0x100
   1057a:	vldr	s6, [r0, #252]	; 0xfc
      float noise = stmlib::Random::GetFloat();
      float snare = snare_lp_.Process<stmlib::FILTER_MODE_LOW_PASS>(noise);
      snare = snare_hp_.Process<stmlib::FILTER_MODE_HIGH_PASS>(snare);
      snare = (snare + 0.1f) * (snare_amplitude_ + fm_) * snare_level;
      
      *out++ = snare + drum;  // It's a snare, it's a drum, it's a snare drum.
   1057e:	vadd.f32	s9, s9, s31
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10582:	vfms.f32	s24, s25, s26
        }
      }
      
      float drum = -0.1f;
      drum += DistortedSine(phase_[0]) * 0.60f;
      drum += DistortedSine(phase_[1]) * 0.25f;
   10586:	vfma.f32	s14, s30, s29
   1058a:	vsub.f32	s24, s24, s10
      drum *= drum_amplitude_ * drum_level;
   1058e:	vmul.f32	s14, s13, s14
   10592:	vmul.f32	s12, s24, s12
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
   10596:	vmov.f32	s13, s10
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
   1059a:	vfma.f32	s28, s14, s15
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
   1059e:	vfma.f32	s25, s26, s12
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    state_ = g_ * (in - lp) + lp;
   105a2:	vfms.f32	s14, s28, s6
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
   105a6:	vfma.f32	s13, s26, s25
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   105aa:	vmov.f32	s10, s25
   105ae:	vfma.f32	s10, s26, s12
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    state_ = g_ * (in - lp) + lp;
   105b2:	vmul.f32	s15, s14, s15
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
   105b6:	vfma.f32	s27, s13, s11
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   105ba:	vmov.f32	s12, s13
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    state_ = g_ * (in - lp) + lp;
   105be:	vfma.f32	s15, s28, s6
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   105c2:	vfma.f32	s12, s26, s25
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   105c6:	vstr	s10, [r0, #284]	; 0x11c
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    state_ = g_ * (in - lp) + lp;
   105ca:	vfms.f32	s13, s27, s23
   105ce:	vstr	s15, [r0, #256]	; 0x100
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   105d2:	vstr	s12, [r0, #288]	; 0x120
      float noise = stmlib::Random::GetFloat();
      float snare = snare_lp_.Process<stmlib::FILTER_MODE_LOW_PASS>(noise);
      snare = snare_hp_.Process<stmlib::FILTER_MODE_HIGH_PASS>(snare);
      snare = (snare + 0.1f) * (snare_amplitude_ + fm_) * snare_level;
      
      *out++ = snare + drum;  // It's a snare, it's a drum, it's a snare drum.
   105d6:	vadd.f32	s15, s13, s1
  
  template<FilterMode mode>
  inline float Process(float in) {
    float lp;
    lp = (g_ * in + state_) * gi_;
    state_ = g_ * (in - lp) + lp;
   105da:	vmul.f32	s13, s11, s13
   105de:	vmul.f32	s9, s9, s15
   105e2:	vfma.f32	s13, s27, s23
   105e6:	vmul.f32	s9, s9, s0
   105ea:	vfma.f32	s9, s28, s6
   105ee:	vstr	s13, [r0, #268]	; 0x10c
   105f2:	vstmia	r5!, {s9}
    
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    while (size--) {
   105f6:	bne.w	103ee <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x89e>
   105fa:	ldr	r2, [sp, #4]
   105fc:	str	r3, [r2, #0]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   105fe:	vstr	s4, [r0, #240]	; 0xf0
      parameters.timbre,
      parameters.morph,
      parameters.harmonics,
      aux,
      size);
}
   10602:	add	sp, #68	; 0x44
   10604:	vpop	{d8-d15}
   10608:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (int i = 0; i < kNumModes; ++i) {
        float excitation = i == 0
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
        shell += gain[i] * (sustain
            ? oscillator_[i].Next(f[i]) * sustain_gain_value * 0.25f
   1060c:	vldr	s15, [r4]
  inline float Next(float frequency) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    }
    
    phase_ += frequency;
   10610:	vldr	s14, [r1, #160]	; 0xa0
    amplitude_ = 0.0f;
  }
  
  inline float Next(float frequency) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
   10614:	vcmp.f32	s15, s7
   10618:	vmrs	APSR_nzcv, fpscr
   1061c:	it	ge
   1061e:	vmovge.f32	s15, s7
    }
    
    phase_ += frequency;
   10622:	vadd.f32	s15, s15, s14
    if (phase_ >= 1.0f) {
   10626:	vcmpe.f32	s15, s6
   1062a:	vmrs	APSR_nzcv, fpscr
      phase_ -= 1.0f;
   1062e:	it	ge
   10630:	vsubge.f32	s15, s15, s6
   10634:	vstr	s15, [r1, #160]	; 0xa0
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
   10638:	vmul.f32	s15, s15, s2
  MAKE_INTEGRAL_FRACTIONAL(index)
   1063c:	vcvt.s32.f32	s14, s15
  float a = table[index_integral];
   10640:	vmov	r6, s14
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
        float excitation = i == 0
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
        shell += gain[i] * (sustain
   10644:	vcvt.f32.s32	s14, s14
   10648:	lsls	r6, r6, #2
   1064a:	vsub.f32	s15, s15, s14
   1064e:	add.w	r8, r6, ip
  float b = table[index_integral + 1];
   10652:	add	r6, sl
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   10654:	vldr	s14, [r8]
   10658:	vldr	s22, [r6]
   1065c:	vsub.f32	s22, s22, s14
   10660:	vfma.f32	s14, s15, s22
   10664:	vmul.f32	s15, s14, s9
   10668:	vmul.f32	s15, s15, s4
   1066c:	b.n	ffda <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x48a>
    snare_hp_.Init();
    snare_lp_.Init();
  }
  
  inline float DistortedSine(float phase) {
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.3f;
   1066e:	vsub.f32	s13, s8, s13
   10672:	vldr	s15, [pc, #268]	; 10780 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc30>
   10676:	vmov.f32	s12, #16	; 0x40800000  4.0
   1067a:	vfma.f32	s15, s13, s12
   1067e:	b.n	10510 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9c0>
   10680:	vsub.f32	s14, s8, s14
   10684:	vldr	s15, [pc, #248]	; 10780 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc30>
   10688:	vmov.f32	s12, #16	; 0x40800000  4.0
   1068c:	vfma.f32	s15, s14, s12
   10690:	b.n	104dc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x98c>
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
    return -1.0f;
   10692:	vmov.f32	s7, #240	; 0xbf800000 -1.0
   10696:	b.n	1002c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4dc>
        }
        if (phase_[1] >= 1.0f + reset_noise) {
          phase_[1] = 1.0f - phase_[1];
        }
      } else {
        if (phase_[0] >= 1.0f) {
   10698:	vcmpe.f32	s15, s8
   1069c:	vmrs	APSR_nzcv, fpscr
   106a0:	blt.n	106aa <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb5a>
          phase_[0] -= 1.0f;
   106a2:	vsub.f32	s15, s15, s8
   106a6:	vstr	s15, [r0, #220]	; 0xdc
        }
        if (phase_[1] >= 1.0f) {
   106aa:	vcmpe.f32	s13, s8
   106ae:	vmrs	APSR_nzcv, fpscr
   106b2:	blt.w	104c0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
          phase_[1] -= 1.0f;
   106b6:	vsub.f32	s13, s13, s8
   106ba:	vstr	s13, [r0, #224]	; 0xe0
   106be:	b.n	104c0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x970>
      } else {
        // Compute all D envelopes.
        // The envelope for the drum has a very long tail.
        // The envelope for the snare has a "hold" stage which lasts between
        // 40 and 70 ms
        drum_amplitude_ *= (drum_amplitude_ > 0.03f || !(size & 1))
   106c0:	vldr	s15, [r0, #228]	; 0xe4
            ? drum_decay
            : 1.0f;
   106c4:	vcmpe.f32	s15, s20
   106c8:	vmrs	APSR_nzcv, fpscr
   106cc:	bgt.n	10740 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbf0>
   106ce:	tst.w	r8, #1
   106d2:	ite	ne
   106d4:	vmovne.f32	s14, s8
   106d8:	vmoveq.f32	s14, s21
   106dc:	vmul.f32	s15, s15, s14
        if (hold_counter_) {
   106e0:	ldr.w	r2, [r0, #244]	; 0xf4
        // The envelope for the drum has a very long tail.
        // The envelope for the snare has a "hold" stage which lasts between
        // 40 and 70 ms
        drum_amplitude_ *= (drum_amplitude_ > 0.03f || !(size & 1))
            ? drum_decay
            : 1.0f;
   106e4:	vstr	s15, [r0, #228]	; 0xe4
        if (hold_counter_) {
   106e8:	cbz	r2, 10732 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbe2>
          --hold_counter_;
   106ea:	subs	r2, #1
   106ec:	vldr	s31, [r0, #232]	; 0xe8
   106f0:	str.w	r2, [r0, #244]	; 0xf4
      // The 909 circuit has a funny kind of oscillator coupling - the signal
      // leaving Q40's collector and resetting all oscillators allow some
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
   106f4:	vcmpe.f32	s3, #0.0
        if (hold_counter_) {
          --hold_counter_;
        } else {
          snare_amplitude_ *= snare_decay;
        }
        fm_ *= fm_decay;
   106f8:	vldr	s9, [r0, #236]	; 0xec
   106fc:	vmov.f32	s15, #16	; 0x40800000  4.0
   10700:	vmul.f32	s9, s9, s19
      // The 909 circuit has a funny kind of oscillator coupling - the signal
      // leaving Q40's collector and resetting all oscillators allow some
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
   10704:	vmrs	APSR_nzcv, fpscr
   10708:	vmul.f32	s15, s9, s15
        if (hold_counter_) {
          --hold_counter_;
        } else {
          snare_amplitude_ *= snare_decay;
        }
        fm_ *= fm_decay;
   1070c:	vstr	s9, [r0, #236]	; 0xec
      // The 909 circuit has a funny kind of oscillator coupling - the signal
      // leaving Q40's collector and resetting all oscillators allow some
      // intermodulation.
      float reset_noise = 0.0f;
      float reset_noise_amount = (0.125f - f0) * 8.0f;
      CONSTRAIN(reset_noise_amount, 0.0f, 1.0f);
   10710:	bpl.w	1041c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8cc>
   10714:	vldr	s10, [pc, #160]	; 107b8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc68>
   10718:	b.n	1042c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8dc>
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
        pulse_ = pulse;
      } else {
        pulse_ *= 1.0f - 1.0f / kPulseDecayTime;
   1071a:	vldr	s11, [r0, #20]
   1071e:	vmul.f32	s11, s11, s19
   10722:	b.n	ff34 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e4>
    while (size--) {
      // Q45 / Q46
      float pulse = 0.0f;
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
   10724:	vmov.f32	s15, #112	; 0x3f800000  1.0
   10728:	vldr	s11, [r0, #24]
   1072c:	vsub.f32	s11, s11, s15
   10730:	b.n	ff34 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e4>
            ? drum_decay
            : 1.0f;
        if (hold_counter_) {
          --hold_counter_;
        } else {
          snare_amplitude_ *= snare_decay;
   10732:	vldr	s31, [r0, #232]	; 0xe8
   10736:	vmul.f32	s31, s31, s22
   1073a:	vstr	s31, [r0, #232]	; 0xe8
   1073e:	b.n	106f4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xba4>
        // The envelope for the drum has a very long tail.
        // The envelope for the snare has a "hold" stage which lasts between
        // 40 and 70 ms
        drum_amplitude_ *= (drum_amplitude_ > 0.03f || !(size & 1))
            ? drum_decay
            : 1.0f;
   10740:	vmov.f32	s14, s21
   10744:	b.n	106dc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb8c>
   10746:	vmul.f32	s10, s3, s3
   1074a:	b.n	1042c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8dc>
  } else if (x > 3.0f) {
    return 1.0f;
   1074c:	vmov.f32	s7, #112	; 0x3f800000  1.0
   10750:	b.n	1002c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4dc>
   10752:	vldr	s4, [pc, #68]	; 10798 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc48>
   10756:	vldr	s13, [pc, #68]	; 1079c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc4c>
   1075a:	b.n	1028a <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x73a>
   1075c:	vldr	s7, [pc, #64]	; 107a0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc50>
   10760:	vldr	s10, [pc, #56]	; 1079c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc4c>
   10764:	b.n	10252 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x702>
   10766:	nop
   10768:	.word	0x20020470
   1076c:	.word	0x3cf5c28f
   10770:	.word	0x3f7f3cf4
   10774:	.word	0x3fbc28f6
   10778:	.word	0x3dcccccd
   1077c:	.word	0x3ccccccd
   10780:	.word	0xbfa66666
   10784:	.word	0x3f19999a
   10788:	.word	0xbdcccccd
   1078c:	.word	0x0019660d
   10790:	.word	0x3c6ef35f
   10794:	.word	0x2f800000
   10798:	.word	0x41a7a3bf
   1079c:	.word	0x40927c2d
   107a0:	.word	0x3e3796f0
   107a4:	.word	0x3f333333
   107a8:	.word	0x4009999a
   107ac:	.word	0x3d288df7
   107b0:	.word	0x3f126945
   107b4:	.word	0x40919638
   107b8:	.word	0x00000000
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
      gain[1] = 2.0f * tone + 0.15f;
      std::fill(&gain[2], &gain[kNumModes], 0.0f);
    } else {
      // What the 808 could have been if there were extra modes!
      tone = (tone - 0.666667f) * 3.0f;
   107bc:	vsub.f32	s10, s10, s15
      gain[0] = 1.5f - tone * 0.5f;
      gain[1] = 2.15f - tone * 0.7f;
   107c0:	vldr	s11, [pc, #-32]	; 107a4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc54>
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
      gain[1] = 2.0f * tone + 0.15f;
      std::fill(&gain[2], &gain[kNumModes], 0.0f);
    } else {
      // What the 808 could have been if there were extra modes!
      tone = (tone - 0.666667f) * 3.0f;
   107c4:	vmov.f32	s15, #8	; 0x40400000  3.0
      gain[0] = 1.5f - tone * 0.5f;
      gain[1] = 2.15f - tone * 0.7f;
   107c8:	vldr	s14, [pc, #-36]	; 107a8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc58>
      gain[1] = 2.0f * tone + 0.15f;
      std::fill(&gain[2], &gain[kNumModes], 0.0f);
    } else {
      // What the 808 could have been if there were extra modes!
      tone = (tone - 0.666667f) * 3.0f;
      gain[0] = 1.5f - tone * 0.5f;
   107cc:	vmov.f32	s9, #96	; 0x3f000000  0.5
   107d0:	vmov.f32	s13, #120	; 0x3fc00000  1.5
      gain[0] = 1.5f + (1.0f - tone) * (1.0f - tone) * 4.5f;
      gain[1] = 2.0f * tone + 0.15f;
      std::fill(&gain[2], &gain[kNumModes], 0.0f);
    } else {
      // What the 808 could have been if there were extra modes!
      tone = (tone - 0.666667f) * 3.0f;
   107d4:	vmul.f32	s15, s10, s15
      gain[0] = 1.5f - tone * 0.5f;
   107d8:	vneg.f32	s12, s15
      gain[1] = 2.15f - tone * 0.7f;
      for (int i = 2; i < kNumModes; ++i) {
        gain[i] = tone;
   107dc:	vstr	s15, [sp, #52]	; 0x34
        tone *= tone;
   107e0:	vmul.f32	s15, s15, s15
      gain[1] = 2.0f * tone + 0.15f;
      std::fill(&gain[2], &gain[kNumModes], 0.0f);
    } else {
      // What the 808 could have been if there were extra modes!
      tone = (tone - 0.666667f) * 3.0f;
      gain[0] = 1.5f - tone * 0.5f;
   107e4:	vfma.f32	s13, s12, s9
      gain[1] = 2.15f - tone * 0.7f;
   107e8:	vfma.f32	s14, s12, s11
      for (int i = 2; i < kNumModes; ++i) {
        gain[i] = tone;
   107ec:	vstr	s15, [sp, #56]	; 0x38
   107f0:	vmul.f32	s15, s15, s15
   107f4:	vstr	s15, [sp, #60]	; 0x3c
      gain[1] = 2.0f * tone + 0.15f;
      std::fill(&gain[2], &gain[kNumModes], 0.0f);
    } else {
      // What the 808 could have been if there were extra modes!
      tone = (tone - 0.666667f) * 3.0f;
      gain[0] = 1.5f - tone * 0.5f;
   107f8:	vstr	s13, [sp, #44]	; 0x2c
      gain[1] = 2.15f - tone * 0.7f;
   107fc:	vstr	s14, [sp, #48]	; 0x30
   10800:	b.w	fe58 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x308>

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   10804:	movs	r3, #0
   10806:	mov	r2, r3
   10808:	b.w	fb90 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40>
        tone *= tone;
      }
    }

    float f_noise = f0 * 16.0f;
    CONSTRAIN(f_noise, 0.0f, 0.499f);
   1080c:	vldr	s14, [pc, #-100]	; 107ac <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc5c>
   10810:	vldr	s13, [pc, #-100]	; 107b0 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc60>
   10814:	vldr	s15, [pc, #-100]	; 107b4 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc64>
   10818:	b.w	febc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
    const float snare_decay = 1.0f - 1.0f / (0.01f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f - snappy * 7.0f);
    const float fm_decay = 1.0f - 1.0f / (0.007f * kSampleRate);
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
   1081c:	vmov.f32	s16, s8
   10820:	vldr	s0, [pc, #-108]	; 107b8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc68>
   10824:	vmov.f32	s6, #0	; 0x40000000  2.0
   10828:	b.n	1020a <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6ba>
   1082a:	vmov.f32	s14, #112	; 0x3f800000  1.0
   1082e:	vldr	s15, [pc, #-120]	; 107b8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc68>
   10832:	vmov.f32	s13, s14
   10836:	b.w	febc <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
    const float noise_envelope_decay = 1.0f - 0.0017f * \
        stmlib::SemitonesToRatio(-decay * (50.0f + snappy * 10.0f));
    const float exciter_leak = snappy * (2.0f - snappy) * 0.1f;
    
    snappy = snappy * 1.1f - 0.05f;
    CONSTRAIN(snappy, 0.0f, 1.0f);
   1083a:	vldr	s3, [pc, #-132]	; 107b8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc68>
   1083e:	b.w	fcc8 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x178>
   10842:	vmov.f32	s14, #0	; 0x40000000  2.0
   10846:	vmov.f32	s15, #96	; 0x3f000000  0.5
   1084a:	vsub.f32	s16, s8, s0
   1084e:	vfma.f32	s15, s0, s14
   10852:	vdiv.f32	s6, s8, s15
   10856:	b.n	1020a <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6ba>
      
      float shell = 0.0f;
      for (int i = 0; i < kNumModes; ++i) {
        float excitation = i == 0
            ? (pulse - pulse_lp_) + 0.006f * pulse
            : 0.026f * pulse;
   10858:	vldr	s25, [r0, #28]
   1085c:	vsub.f32	s25, s11, s25
   10860:	vfma.f32	s25, s11, s21
   10864:	b.w	ff7c <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42c>
    
    for (int i = 0; i < kNumModes; ++i) {
      f[i] = std::min(f0 * kModeFrequencies[i], 0.499f);
      resonator_[i].set_f_q<stmlib::FREQUENCY_FAST>(
          f[i],
          1.0f + f[i] * (i == 0 ? q : q * 0.25f));
   10868:	vmov.f32	s14, s9
   1086c:	b.w	fd50 <plaits::SnareDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x200>

00010870 <plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)>:

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   10870:	ldr	r1, [pc, #128]	; (108f4 <plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)+0x84>)
  ~AnalogBassDrum() { }

  void Init() {
    pulse_remaining_samples_ = 0;
    fm_pulse_remaining_samples_ = 0;
    pulse_ = 0.0f;
   10872:	movs	r3, #0
 public:
  AnalogBassDrum() { }
  ~AnalogBassDrum() { }

  void Init() {
    pulse_remaining_samples_ = 0;
   10874:	movs	r2, #0
   10876:	str	r1, [r0, #56]	; 0x38
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10878:	ldr	r1, [pc, #124]	; (108f8 <plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)+0x88>)
   1087a:	str	r2, [r0, #16]
    fm_pulse_remaining_samples_ = 0;
   1087c:	str	r2, [r0, #20]
    f0_ = 0.0f;
    fm_ = 0.0f;
    fm_lp_ = 0.0f;
    body_env_lp_ = 0.0f;
    body_env_ = 0.0f;
    body_env_pulse_width_ = 0;
   1087e:	str.w	r2, [r0, #168]	; 0xa8
    fm_pulse_width_ = 0;
   10882:	str.w	r2, [r0, #172]	; 0xac
    pulse_ = 0.0f;
   10886:	str	r3, [r0, #24]
    pulse_height_ = 0.0f;
   10888:	str	r3, [r0, #28]
    pulse_lp_ = 0.0f;
   1088a:	str	r3, [r0, #32]
    fm_pulse_lp_ = 0.0f;
   1088c:	str	r3, [r0, #36]	; 0x24
    retrig_pulse_ = 0.0f;
   1088e:	str	r3, [r0, #40]	; 0x28
    lp_out_ = 0.0f;
   10890:	str	r3, [r0, #44]	; 0x2c
    tone_lp_ = 0.0f;
   10892:	str	r3, [r0, #48]	; 0x30
    sustain_gain_ = 0.0f;
   10894:	str	r3, [r0, #52]	; 0x34
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   10896:	str	r3, [r0, #72]	; 0x48
   10898:	str	r3, [r0, #68]	; 0x44
 public:
  SineOscillator() { }
  ~SineOscillator() { }

  void Init() {
    phase_ = 0.0f;
   1089a:	str	r3, [r0, #76]	; 0x4c
    frequency_ = 0.0f;
   1089c:	str	r3, [r0, #80]	; 0x50
    amplitude_ = 0.0f;
   1089e:	str	r3, [r0, #84]	; 0x54
 public:
  SyntheticBassDrum() { }
  ~SyntheticBassDrum() { }

  void Init() {
    phase_ = 0.0f;
   108a0:	str	r3, [r0, #92]	; 0x5c
    phase_noise_ = 0.0f;
   108a2:	str	r3, [r0, #96]	; 0x60
    f0_ = 0.0f;
   108a4:	str	r3, [r0, #88]	; 0x58
    fm_ = 0.0f;
   108a6:	str	r3, [r0, #100]	; 0x64
    fm_lp_ = 0.0f;
   108a8:	str	r3, [r0, #104]	; 0x68
    body_env_lp_ = 0.0f;
   108aa:	str	r3, [r0, #112]	; 0x70
    body_env_ = 0.0f;
   108ac:	str	r3, [r0, #108]	; 0x6c
    body_env_pulse_width_ = 0;
    fm_pulse_width_ = 0;
    tone_lp_ = 0.0f;
   108ae:	str.w	r3, [r0, #128]	; 0x80
    sustain_gain_ = 0.0f;
   108b2:	str	r3, [r0, #124]	; 0x7c
 public:
  SyntheticBassDrumClick() { }
  ~SyntheticBassDrumClick() { }
  
  void Init() {
    lp_ = 0.0f;
   108b4:	str.w	r3, [r0, #132]	; 0x84
    hp_ = 0.0f;
   108b8:	str.w	r3, [r0, #136]	; 0x88
namespace plaits {

using namespace std;
using namespace stmlib;

void BassDrumEngine::Init(BufferAllocator* allocator) {
   108bc:	push	{r4, r5, r6, r7}
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   108be:	mov.w	r4, #1056964608	; 0x3f000000
   108c2:	ldr	r7, [pc, #56]	; (108fc <plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)+0x8c>)
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   108c4:	ldr	r6, [pc, #56]	; (10900 <plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)+0x90>)

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   108c6:	ldr	r5, [pc, #60]	; (10904 <plaits::BassDrumEngine::Init(stmlib::BufferAllocator*)+0x94>)
    r_ = 1.0f / resonance;
   108c8:	str	r7, [r0, #60]	; 0x3c
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   108ca:	str	r6, [r0, #64]	; 0x40
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   108cc:	str.w	r3, [r0, #156]	; 0x9c

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   108d0:	str.w	r5, [r0, #140]	; 0x8c
    r_ = 1.0f / resonance;
   108d4:	str.w	r4, [r0, #144]	; 0x90
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   108d8:	str.w	r3, [r0, #152]	; 0x98
 public:
  SyntheticBassDrumAttackNoise() { }
  ~SyntheticBassDrumAttackNoise() { }
  
  void Init() {
    lp_ = 0.0f;
   108dc:	str.w	r3, [r0, #160]	; 0xa0
    hp_ = 0.0f;
   108e0:	str.w	r3, [r0, #164]	; 0xa4
 public:
  Overdrive() { }
  ~Overdrive() { }
  
  void Init() {
    pre_gain_ = 0.0f;
   108e4:	str.w	r3, [r0, #176]	; 0xb0
    post_gain_ = 0.0f;
   108e8:	str.w	r3, [r0, #180]	; 0xb4
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   108ec:	str.w	r1, [r0, #148]	; 0x94
  analog_bass_drum_.Init();
  synthetic_bass_drum_.Init();
  overdrive_.Init();
}
   108f0:	pop	{r4, r5, r6, r7}
   108f2:	bx	lr
   108f4:	.word	0x3d00ba22
   108f8:	.word	0x3f473f01
   108fc:	.word	0x3c23d70a
   10900:	.word	0x3f7faaca
   10904:	.word	0x3eadc061

00010908 <plaits::BassDrumEngine::Reset()>:

void BassDrumEngine::Reset() {
   10908:	bx	lr
   1090a:	nop

0001090c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   1090c:	vmov.f32	s13, #34	; 0x41100000  9.0
   10910:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   10914:	vldr	s14, [pc, #956]	; 10cd4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c8>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   10918:	vsub.f32	s15, s15, s13
void BassDrumEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
   1091c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   10920:	vcmpe.f32	s15, s14
   10924:	vpush	{d8-d15}
   10928:	vmrs	APSR_nzcv, fpscr
   1092c:	sub	sp, #20
   1092e:	bmi.n	10946 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a>
   10930:	vldr	s14, [pc, #932]	; 10cd8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3cc>
   10934:	vcmpe.f32	s15, s14
   10938:	vmrs	APSR_nzcv, fpscr
   1093c:	ble.w	1156c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc60>
   10940:	movs	r4, #0
   10942:	movs	r5, #255	; 0xff
   10944:	b.n	1094a <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e>
   10946:	movs	r4, #0
   10948:	mov	r5, r4
  const float f0 = NoteToFrequency(parameters.note);
  
  const float attack_fm_amount = min(parameters.harmonics * 4.0f, 1.0f);
   1094a:	vmov.f32	s8, #16	; 0x40800000  4.0
   1094e:	vldr	s13, [r1, #16]
   10952:	vmov.f32	s9, #112	; 0x3f800000  1.0

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10956:	ldr.w	sl, [pc, #980]	; 10d2c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x420>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   1095a:	ldr	r6, [pc, #896]	; (10cdc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d0>)
   1095c:	vmul.f32	s8, s13, s8

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10960:	add.w	r5, sl, r5, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10964:	add.w	r4, r6, r4, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   10968:	vldr	s12, [pc, #884]	; 10ce0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d4>
   1096c:	vldr	s15, [r5]
	return __b;
      return __a;
   10970:	vcmpe.f32	s8, s9
   10974:	vldr	s10, [r4]
  const float self_fm_amount = max(min(parameters.harmonics * 4.0f - 1.0f, 1.0f), 0.0f);
   10978:	vsub.f32	s14, s8, s9
   1097c:	vmul.f32	s15, s15, s10
   10980:	vmrs	APSR_nzcv, fpscr
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   10984:	vcmpe.f32	s14, s9
   10988:	vmul.f32	s10, s15, s12
	return __b;
      return __a;
   1098c:	it	gt
   1098e:	vmovgt.f32	s8, s9
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   10992:	vmrs	APSR_nzcv, fpscr
   10996:	ble.w	11594 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc88>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   1099a:	vldr	s15, [pc, #840]	; 10ce4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d8>
  const float drive = max(parameters.harmonics * 2.0f - 1.0f, 0.0f) * \
   1099e:	vmov.f32	s5, #0	; 0x40000000  2.0
  analog_bass_drum_.Render(
      sustain,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
   109a2:	vldr	s12, [r1, #8]
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  const float attack_fm_amount = min(parameters.harmonics * 4.0f, 1.0f);
  const float self_fm_amount = max(min(parameters.harmonics * 4.0f - 1.0f, 1.0f), 0.0f);
  const float drive = max(parameters.harmonics * 2.0f - 1.0f, 0.0f) * \
   109a6:	vmov.f32	s17, #240	; 0xbf800000 -1.0
   109aa:	vmov.f32	s6, s15
   109ae:	vldr	s14, [pc, #824]	; 10ce8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3dc>
      sustain,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
      f0,
      parameters.timbre,
      parameters.morph,
   109b2:	vldr	s11, [r1, #12]
  const float f0 = NoteToFrequency(parameters.note);
  
  const float attack_fm_amount = min(parameters.harmonics * 4.0f, 1.0f);
  const float self_fm_amount = max(min(parameters.harmonics * 4.0f - 1.0f, 1.0f), 0.0f);
  const float drive = max(parameters.harmonics * 2.0f - 1.0f, 0.0f) * \
      max(1.0f - 16.0f * f0, 0.0f);
   109b6:	vmov.f32	s4, #112	; 0x3f800000  1.0
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  const float attack_fm_amount = min(parameters.harmonics * 4.0f, 1.0f);
  const float self_fm_amount = max(min(parameters.harmonics * 4.0f - 1.0f, 1.0f), 0.0f);
  const float drive = max(parameters.harmonics * 2.0f - 1.0f, 0.0f) * \
   109ba:	vfma.f32	s17, s13, s5
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   109be:	vldr	s1, [pc, #812]	; 10cec <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e0>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   109c2:	vfma.f32	s6, s12, s14
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
	return __b;
      return __a;
   109c6:	vldr	s3, [pc, #872]	; 10d30 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x424>
      max(1.0f - 16.0f * f0, 0.0f);
   109ca:	vmov.f32	s7, #48	; 0x41800000  16.0
  
  const bool sustain = parameters.trigger & TRIGGER_UNPATCHED;
   109ce:	ldrb	r4, [r1, #0]
  const float f0 = NoteToFrequency(parameters.note);
  
  const float attack_fm_amount = min(parameters.harmonics * 4.0f, 1.0f);
  const float self_fm_amount = max(min(parameters.harmonics * 4.0f - 1.0f, 1.0f), 0.0f);
  const float drive = max(parameters.harmonics * 2.0f - 1.0f, 0.0f) * \
      max(1.0f - 16.0f * f0, 0.0f);
   109d0:	vmov.f32	s13, s4
    const float scale = 0.001f / f0;
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
        1.0f);
    const float exciter_leak = 0.08f * (tone + 0.25f);
   109d4:	vldr	s18, [pc, #792]	; 10cf0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e4>
   109d8:	vneg.f32	s21, s10
  
  const bool sustain = parameters.trigger & TRIGGER_UNPATCHED;
   109dc:	mov	r6, r4
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   109de:	vmov.f32	s19, #16	; 0x40800000  4.0
   109e2:	str	r4, [sp, #4]
   109e4:	vcmpe.f32	s17, s3
   109e8:	and.w	r4, r4, #2
   109ec:	vmov.f32	s14, s6
   109f0:	vldr	s6, [pc, #768]	; 10cf4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e8>
  const float f0 = NoteToFrequency(parameters.note);
  
  const float attack_fm_amount = min(parameters.harmonics * 4.0f, 1.0f);
  const float self_fm_amount = max(min(parameters.harmonics * 4.0f - 1.0f, 1.0f), 0.0f);
  const float drive = max(parameters.harmonics * 2.0f - 1.0f, 0.0f) * \
      max(1.0f - 16.0f * f0, 0.0f);
   109f4:	vfma.f32	s13, s21, s7
   109f8:	uxtb	r4, r4
   109fa:	vfma.f32	s15, s11, s6
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   109fe:	vcvt.s32.f32	s5, s14
   10a02:	vmul.f32	s19, s10, s19
   10a06:	vmrs	APSR_nzcv, fpscr

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10a0a:	vcvt.f32.s32	s2, s5

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10a0e:	vmov	r5, s5
   10a12:	vcmpe.f32	s13, s3
    const int kFMPulseDuration = 6.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.2e-3 * kSampleRate;
    const float kPulseFilterTime = 0.1e-3 * kSampleRate;
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
   10a16:	vldr	s5, [pc, #736]	; 10cf8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3ec>
extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   10a1a:	vcvt.s32.f32	s7, s15

  return lut_pitch_ratio_high[pitch_integral] * \
   10a1e:	add.w	r5, sl, r5, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10a22:	vsub.f32	s14, s14, s2
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   10a26:	vldr	s0, [r5]
   10a2a:	it	mi
   10a2c:	vmovmi.f32	s17, s3

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10a30:	vmov	r5, s7
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10a34:	vcvt.f32.s32	s7, s7
   10a38:	vmul.f32	s14, s14, s1

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   10a3c:	add.w	r5, sl, r5, lsl #2
   10a40:	vmrs	APSR_nzcv, fpscr
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10a44:	vsub.f32	s15, s15, s7
    const float kPulseDecayTime = 0.2e-3 * kSampleRate;
    const float kPulseFilterTime = 0.1e-3 * kSampleRate;
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
   10a48:	vldr	s7, [pc, #688]	; 10cfc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f0>
   10a4c:	vcvt.s32.f32	s14, s14
   10a50:	vldr	s2, [r5]
   10a54:	ldr	r5, [pc, #644]	; (10cdc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d0>)
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
        1.0f);
    const float exciter_leak = 0.08f * (tone + 0.25f);
   10a56:	vmov.f32	s6, #80	; 0x3e800000  0.250
   10a5a:	vmul.f32	s15, s15, s1
   10a5e:	vmov	r7, s14
   10a62:	it	mi
   10a64:	vmovmi.f32	s13, s3
   10a68:	vadd.f32	s12, s12, s6
   10a6c:	add.w	r5, r5, r7, lsl #2
   10a70:	vcvt.s32.f32	s15, s15
   10a74:	vmul.f32	s17, s17, s13
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   10a78:	vldr	s14, [r5]
        1.0f);
    const float exciter_leak = 0.08f * (tone + 0.25f);
   10a7c:	vmul.f32	s6, s12, s18
   10a80:	vmov	r7, s15
   10a84:	ldr	r5, [pc, #596]	; (10cdc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3d0>)
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   10a86:	vmul.f32	s14, s14, s0
  const bool sustain = parameters.trigger & TRIGGER_UNPATCHED;
  
  analog_bass_drum_.Render(
      sustain,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
   10a8a:	vldr	s12, [r1, #20]
   10a8e:	add.w	r5, r5, r7, lsl #2
    const int kFMPulseDuration = 6.0e-3 * kSampleRate;
    const float kPulseDecayTime = 0.2e-3 * kSampleRate;
    const float kPulseFilterTime = 0.1e-3 * kSampleRate;
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
   10a92:	vdiv.f32	s18, s5, s10
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
   10a96:	vldr	s15, [r5]
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   10a9a:	vmul.f32	s14, s14, s19
    const float kPulseDecayTime = 0.2e-3 * kSampleRate;
    const float kPulseFilterTime = 0.1e-3 * kSampleRate;
    const float kRetrigPulseDuration = 0.05f * kSampleRate;
    
    const float scale = 0.001f / f0;
    const float q = 1500.0f * stmlib::SemitonesToRatio(decay * 80.0f);
   10a9e:	vmul.f32	s15, s15, s2
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
      return __a;
   10aa2:	vcmpe.f32	s14, s4
   10aa6:	vmul.f32	s2, s15, s7
   10aaa:	vmrs	APSR_nzcv, fpscr
   10aae:	it	le
   10ab0:	vmovle.f32	s4, s14
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
        1.0f);
    const float exciter_leak = 0.08f * (tone + 0.25f);
      

    if (trigger) {
   10ab4:	ands.w	r7, r6, #1
   10ab8:	beq.n	10ad8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1cc>
      pulse_remaining_samples_ = kTriggerPulseDuration;
      fm_pulse_remaining_samples_ = kFMPulseDuration;
      pulse_height_ = 3.0f + 7.0f * accent;
   10aba:	vmov.f32	s14, #28	; 0x40e00000  7.0
        1.0f);
    const float exciter_leak = 0.08f * (tone + 0.25f);
      

    if (trigger) {
      pulse_remaining_samples_ = kTriggerPulseDuration;
   10abe:	movs	r5, #48	; 0x30
      fm_pulse_remaining_samples_ = kFMPulseDuration;
      pulse_height_ = 3.0f + 7.0f * accent;
   10ac0:	vmov.f32	s15, #8	; 0x40400000  3.0
      lp_out_ = 0.0f;
   10ac4:	vstr	s3, [r0, #44]	; 0x2c
        1.0f);
    const float exciter_leak = 0.08f * (tone + 0.25f);
      

    if (trigger) {
      pulse_remaining_samples_ = kTriggerPulseDuration;
   10ac8:	str	r5, [r0, #16]
      fm_pulse_remaining_samples_ = kFMPulseDuration;
   10aca:	mov.w	r5, #288	; 0x120
      pulse_height_ = 3.0f + 7.0f * accent;
   10ace:	vfma.f32	s15, s12, s14
    const float exciter_leak = 0.08f * (tone + 0.25f);
      

    if (trigger) {
      pulse_remaining_samples_ = kTriggerPulseDuration;
      fm_pulse_remaining_samples_ = kFMPulseDuration;
   10ad2:	str	r5, [r0, #20]
      pulse_height_ = 3.0f + 7.0f * accent;
   10ad4:	vstr	s15, [r0, #28]
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
    increment_ = (new_value - *state) / static_cast<float>(size);
   10ad8:	vldr	s15, [sp, #120]	; 0x78
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   10adc:	vldr	s3, [r0, #52]	; 0x34
    increment_ = (new_value - *state) / static_cast<float>(size);
   10ae0:	vcvt.f32.u32	s1, s15
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   10ae4:	vmov	r5, s15
   10ae8:	vmov.f32	s15, s3
   10aec:	ldr	r6, [sp, #120]	; 0x78
   10aee:	subs	r5, #1
   10af0:	vfnms.f32	s15, s12, s11
   10af4:	vdiv.f32	s24, s15, s1
   10af8:	cmp	r6, #0
   10afa:	beq.w	10e3c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x530>
   10afe:	mov	ip, r2
   10b00:	mov	r6, r5
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
        pulse_ = pulse;
      } else {
        pulse_ *= 1.0f - 1.0f / kPulseDecayTime;
   10b02:	vldr	s23, [pc, #508]	; 10d00 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f4>
        pulse = pulse_;
      }
      if (sustain) {
   10b06:	vldr	s5, [pc, #552]	; 10d30 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x424>
   10b0a:	vldr	s22, [pc, #504]	; 10d04 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3f8>
        pulse = 0.0f;
      }
      
      // C40 / R163 / R162 / D83
      ONE_POLE(pulse_lp_, pulse, 1.0f / kPulseFilterTime);
   10b0e:	vldr	s11, [pc, #504]	; 10d08 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3fc>
  inline float Diode(float x) {
    if (x >= 0.0f) {
      return x;
    } else {
      x *= 2.0f;
      return 0.7f * x / (1.0f + fabsf(x));
   10b12:	vldr	s7, [pc, #504]	; 10d0c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x400>
        fm_pulse = 1.0f;
        // C39 / C52
        retrig_pulse_ = fm_pulse_remaining_samples_ ? 0.0f : -0.8f;
      } else {
        // C39 / R161
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
   10b16:	vldr	s20, [pc, #504]	; 10d10 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x404>
      float fm_pulse = 0.0f;
      if (fm_pulse_remaining_samples_) {
        --fm_pulse_remaining_samples_;
        fm_pulse = 1.0f;
        // C39 / C52
        retrig_pulse_ = fm_pulse_remaining_samples_ ? 0.0f : -0.8f;
   10b1a:	vldr	s16, [pc, #504]	; 10d14 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x408>
      float punch = 0.7f + Diode(10.0f * lp_out_ - 1.0f);

      // Q43 / R165
      float attack_fm = fm_pulse_lp_ * 1.7f * attack_fm_amount;
      float self_fm = punch * 0.08f * self_fm_amount;
      float f = f0 * (1.0f + attack_fm + self_fm);
   10b1e:	vldr	s0, [pc, #464]	; 10cf0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e4>
   10b22:	b.n	10cae <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3a2>
    
    while (size--) {
      // Q39 / Q40
      float pulse = 0.0f;
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
   10b24:	subs	r7, #1
   10b26:	str	r7, [r0, #16]
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
   10b28:	cmp	r7, #0
   10b2a:	beq.w	10e10 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x504>
   10b2e:	vldr	s14, [r0, #28]
        pulse_ = pulse;
      } else {
        pulse_ *= 1.0f - 1.0f / kPulseDecayTime;
   10b32:	vstr	s14, [r0, #24]
        pulse = pulse_;
      }
      if (sustain) {
   10b36:	cmp	r4, #0
   10b38:	bne.w	10cc8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3bc>
   10b3c:	vmul.f32	s15, s14, s22
        pulse = 0.0f;
      }
      
      // C40 / R163 / R162 / D83
      ONE_POLE(pulse_lp_, pulse, 1.0f / kPulseFilterTime);
   10b40:	vldr	s13, [r0, #32]
   10b44:	vsub.f32	s12, s14, s13
   10b48:	vfma.f32	s13, s12, s11
      pulse = Diode((pulse - pulse_lp_) + pulse * 0.044f);
   10b4c:	vsub.f32	s14, s14, s13
      if (sustain) {
        pulse = 0.0f;
      }
      
      // C40 / R163 / R162 / D83
      ONE_POLE(pulse_lp_, pulse, 1.0f / kPulseFilterTime);
   10b50:	vstr	s13, [r0, #32]
      pulse = Diode((pulse - pulse_lp_) + pulse * 0.044f);
   10b54:	vadd.f32	s15, s14, s15
    resonator_.Init();
    oscillator_.Init();
  }
  
  inline float Diode(float x) {
    if (x >= 0.0f) {
   10b58:	vcmpe.f32	s15, #0.0
   10b5c:	vmrs	APSR_nzcv, fpscr
   10b60:	blt.w	10df6 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4ea>
      ONE_POLE(pulse_lp_, pulse, 1.0f / kPulseFilterTime);
      pulse = Diode((pulse - pulse_lp_) + pulse * 0.044f);

      // Q41 / Q42
      float fm_pulse = 0.0f;
      if (fm_pulse_remaining_samples_) {
   10b64:	ldr	r7, [r0, #20]
   10b66:	cmp	r7, #0
   10b68:	beq.w	10d34 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x428>
        --fm_pulse_remaining_samples_;
   10b6c:	subs	r7, #1
        fm_pulse = 1.0f;
   10b6e:	vmov.f32	s14, #112	; 0x3f800000  1.0
        // C39 / C52
        retrig_pulse_ = fm_pulse_remaining_samples_ ? 0.0f : -0.8f;
   10b72:	cmp	r7, #0
      pulse = Diode((pulse - pulse_lp_) + pulse * 0.044f);

      // Q41 / Q42
      float fm_pulse = 0.0f;
      if (fm_pulse_remaining_samples_) {
        --fm_pulse_remaining_samples_;
   10b74:	str	r7, [r0, #20]
        fm_pulse = 1.0f;
        // C39 / C52
        retrig_pulse_ = fm_pulse_remaining_samples_ ? 0.0f : -0.8f;
   10b76:	ite	ne
   10b78:	vmovne.f32	s13, s5
   10b7c:	vmoveq.f32	s13, s16
   10b80:	vstr	s13, [r0, #40]	; 0x28
        fm_pulse = 0.0f;
      }
      ONE_POLE(fm_pulse_lp_, fm_pulse, 1.0f / kPulseFilterTime);

      // Q43 and R170 leakage
      float punch = 0.7f + Diode(10.0f * lp_out_ - 1.0f);
   10b84:	vmov.f32	s25, #36	; 0x41200000  10.0
      } else {
        // C39 / R161
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
      }
      if (sustain) {
        fm_pulse = 0.0f;
   10b88:	cmp	r4, #0
      }
      ONE_POLE(fm_pulse_lp_, fm_pulse, 1.0f / kPulseFilterTime);

      // Q43 and R170 leakage
      float punch = 0.7f + Diode(10.0f * lp_out_ - 1.0f);
   10b8a:	vmov.f32	s13, #240	; 0xbf800000 -1.0
   10b8e:	vldr	s26, [r0, #44]	; 0x2c
      } else {
        // C39 / R161
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
      }
      if (sustain) {
        fm_pulse = 0.0f;
   10b92:	it	ne
   10b94:	vmovne.f32	s14, s5
      }
      ONE_POLE(fm_pulse_lp_, fm_pulse, 1.0f / kPulseFilterTime);
   10b98:	vldr	s12, [r0, #36]	; 0x24

      // Q43 and R170 leakage
      float punch = 0.7f + Diode(10.0f * lp_out_ - 1.0f);
   10b9c:	vfma.f32	s13, s26, s25
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
      }
      if (sustain) {
        fm_pulse = 0.0f;
      }
      ONE_POLE(fm_pulse_lp_, fm_pulse, 1.0f / kPulseFilterTime);
   10ba0:	vsub.f32	s14, s14, s12
   10ba4:	vfma.f32	s12, s14, s11
    resonator_.Init();
    oscillator_.Init();
  }
  
  inline float Diode(float x) {
    if (x >= 0.0f) {
   10ba8:	vcmpe.f32	s13, #0.0
   10bac:	vmrs	APSR_nzcv, fpscr
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
      }
      if (sustain) {
        fm_pulse = 0.0f;
      }
      ONE_POLE(fm_pulse_lp_, fm_pulse, 1.0f / kPulseFilterTime);
   10bb0:	vstr	s12, [r0, #36]	; 0x24
    resonator_.Init();
    oscillator_.Init();
  }
  
  inline float Diode(float x) {
    if (x >= 0.0f) {
   10bb4:	blt.w	10ddc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4d0>
      float punch = 0.7f + Diode(10.0f * lp_out_ - 1.0f);

      // Q43 / R165
      float attack_fm = fm_pulse_lp_ * 1.7f * attack_fm_amount;
      float self_fm = punch * 0.08f * self_fm_amount;
      float f = f0 * (1.0f + attack_fm + self_fm);
   10bb8:	vldr	s25, [pc, #348]	; 10d18 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40c>
   10bbc:	vmov.f32	s14, #112	; 0x3f800000  1.0
   10bc0:	vadd.f32	s13, s13, s7
   10bc4:	vmul.f32	s12, s12, s25
   10bc8:	vmul.f32	s13, s13, s0
   10bcc:	vfma.f32	s14, s8, s12
   10bd0:	vfma.f32	s14, s13, s9
   10bd4:	vmul.f32	s14, s14, s10
      CONSTRAIN(f, 0.0f, 0.4f);
   10bd8:	vcmpe.f32	s14, #0.0
   10bdc:	vmrs	APSR_nzcv, fpscr
   10be0:	bmi.w	10dd0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4c4>
   10be4:	vldr	s13, [pc, #308]	; 10d1c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x410>
   10be8:	vcmpe.f32	s14, s13
   10bec:	vmrs	APSR_nzcv, fpscr
   10bf0:	bgt.w	10d46 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x43a>

      float resonator_out;
      if (sustain) {
   10bf4:	cmp	r4, #0
   10bf6:	bne.w	10e1e <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x512>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   10bfa:	vmov.f32	s26, #112	; 0x3f800000  1.0
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
   10bfe:	vldr	s12, [pc, #288]	; 10d20 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x414>
   10c02:	vldr	s27, [pc, #288]	; 10d24 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x418>
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c06:	vmov.f32	s28, s15
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
   10c0a:	vmul.f32	s12, s14, s12
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c0e:	vldr	s25, [r0, #40]	; 0x28
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   10c12:	vmov.f32	s29, s26
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c16:	vldr	s13, [pc, #272]	; 10d28 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x41c>
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
   10c1a:	vfma.f32	s27, s12, s14
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   10c1e:	vfma.f32	s29, s2, s14
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c22:	vfms.f32	s28, s25, s13
   10c26:	vldr	s13, [r0, #68]	; 0x44
   10c2a:	vldr	s25, [r0, #72]	; 0x48
      f = f < 0.497f ? f : 0.497f;
      return tanf(M_PI * f);
    } else if (approximation == FREQUENCY_DIRTY) {
      // Optimized for frequencies below 8kHz.
      const float a = 3.736e-01 * M_PI_POW_3;
      return f * (M_PI_F + a * f * f);
   10c2e:	vmul.f32	s14, s27, s14
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   10c32:	vdiv.f32	s12, s26, s29

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   10c36:	vstr	s14, [r0, #56]	; 0x38
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10c3a:	vmov.f32	s27, s26
   10c3e:	vfma.f32	s27, s14, s12
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   10c42:	vstr	s12, [r0, #60]	; 0x3c
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c46:	vnmul.f32	s12, s13, s12
   10c4a:	vfma.f32	s12, s18, s28
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10c4e:	vfma.f32	s27, s14, s14
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c52:	vfms.f32	s12, s14, s13
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10c56:	vdiv.f32	s28, s26, s27
  }
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   10c5a:	vsub.f32	s12, s12, s25
   10c5e:	vmul.f32	s12, s12, s28
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   10c62:	vstr	s28, [r0, #64]	; 0x40
  
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
   10c66:	vfma.f32	s13, s14, s12
    state_1_ = g_ * hp + bp;
   10c6a:	vmov.f32	s26, s13
    lp = g_ * bp + state_2_;
   10c6e:	vfma.f32	s25, s14, s13
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   10c72:	vfma.f32	s26, s14, s12
    } else if (mode_1 == FILTER_MODE_HIGH_PASS) {
      *out_1 = hp;
    }

    if (mode_2 == FILTER_MODE_LOW_PASS) {
      *out_2 = lp;
   10c76:	vstr	s25, [r0, #44]	; 0x2c
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   10c7a:	vmov.f32	s12, s26
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   10c7e:	vmov.f32	s26, s25
  template<FilterMode mode_1, FilterMode mode_2>
  inline void Process(float in, float* out_1, float* out_2) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   10c82:	vstr	s12, [r0, #68]	; 0x44
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   10c86:	vfma.f32	s26, s14, s13
   10c8a:	vstr	s26, [r0, #72]	; 0x48
            (pulse - retrig_pulse_ * 0.2f) * scale,
            &resonator_out,
            &lp_out_);
      }
      
      ONE_POLE(tone_lp_, pulse * exciter_leak + resonator_out, tone_f);
   10c8e:	vfma.f32	s13, s6, s15
   10c92:	vldr	s15, [r0, #48]	; 0x30
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   10c96:	subs	r6, #1
   10c98:	adds	r7, r6, #1
            (pulse - retrig_pulse_ * 0.2f) * scale,
            &resonator_out,
            &lp_out_);
      }
      
      ONE_POLE(tone_lp_, pulse * exciter_leak + resonator_out, tone_f);
   10c9a:	vsub.f32	s13, s13, s15
   10c9e:	vfma.f32	s15, s4, s13
   10ca2:	vstr	s15, [r0, #48]	; 0x30
      
      *out++ = tone_lp_;
   10ca6:	vstmia	ip!, {s15}
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   10caa:	beq.w	10e36 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x52a>
      // Q39 / Q40
      float pulse = 0.0f;
      if (pulse_remaining_samples_) {
   10cae:	ldr	r7, [r0, #16]
   10cb0:	cmp	r7, #0
   10cb2:	bne.w	10b24 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x218>
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
        pulse_ = pulse;
      } else {
        pulse_ *= 1.0f - 1.0f / kPulseDecayTime;
   10cb6:	vldr	s14, [r0, #24]
   10cba:	vmul.f32	s14, s14, s23
   10cbe:	vstr	s14, [r0, #24]
        pulse = pulse_;
      }
      if (sustain) {
   10cc2:	cmp	r4, #0
   10cc4:	beq.w	10b3c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x230>
   10cc8:	vldr	s14, [pc, #100]	; 10d30 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x424>
        pulse = 0.0f;
   10ccc:	vmov.f32	s15, s14
   10cd0:	b.n	10b40 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x234>
   10cd2:	nop
   10cd4:	.word	0xc3000000
   10cd8:	.word	0x42fe0000
   10cdc:	.word	0x20000958
   10ce0:	.word	0x39962fc9
   10ce4:	.word	0x43000000
   10ce8:	.word	0x42d80000
   10cec:	.word	0x43800000
   10cf0:	.word	0x3da3d70a
   10cf4:	.word	0x42a00000
   10cf8:	.word	0x3a83126f
   10cfc:	.word	0x44bb8000
   10d00:	.word	0x3f655555
   10d04:	.word	0x3d343958
   10d08:	.word	0x3e555555
   10d0c:	.word	0x3f333333
   10d10:	.word	0x3f7fe4b1
   10d14:	.word	0xbf4ccccd
   10d18:	.word	0x3fd9999a
   10d1c:	.word	0x3ecccccd
   10d20:	.word	0x413957d7
   10d24:	.word	0x40490fdb
   10d28:	.word	0x3e4ccccd
   10d2c:	.word	0x20000554
   10d30:	.word	0x00000000
        fm_pulse = 1.0f;
        // C39 / C52
        retrig_pulse_ = fm_pulse_remaining_samples_ ? 0.0f : -0.8f;
      } else {
        // C39 / R161
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
   10d34:	vldr	s13, [r0, #40]	; 0x28
      // C40 / R163 / R162 / D83
      ONE_POLE(pulse_lp_, pulse, 1.0f / kPulseFilterTime);
      pulse = Diode((pulse - pulse_lp_) + pulse * 0.044f);

      // Q41 / Q42
      float fm_pulse = 0.0f;
   10d38:	vldr	s14, [pc, #-12]	; 10d30 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x424>
        fm_pulse = 1.0f;
        // C39 / C52
        retrig_pulse_ = fm_pulse_remaining_samples_ ? 0.0f : -0.8f;
      } else {
        // C39 / R161
        retrig_pulse_ *= 1.0f - 1.0f / kRetrigPulseDuration;
   10d3c:	vmul.f32	s13, s13, s20
   10d40:	vstr	s13, [r0, #40]	; 0x28
   10d44:	b.n	10b84 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x278>

      // Q43 / R165
      float attack_fm = fm_pulse_lp_ * 1.7f * attack_fm_amount;
      float self_fm = punch * 0.08f * self_fm_amount;
      float f = f0 * (1.0f + attack_fm + self_fm);
      CONSTRAIN(f, 0.0f, 0.4f);
   10d46:	vmov.f32	s14, s13

      float resonator_out;
      if (sustain) {
   10d4a:	cmp	r4, #0
   10d4c:	beq.w	10bfa <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ee>
  }

  inline float Next() {
    value_ += increment_;
   10d50:	vadd.f32	s3, s3, s24
  inline void Next(float frequency, float amplitude, float* sin, float* cos) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    }
    
    phase_ += frequency;
   10d54:	vldr	s13, [r0, #76]	; 0x4c
    if (phase_ >= 1.0f) {
   10d58:	vmov.f32	s12, #112	; 0x3f800000  1.0
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   10d5c:	ldr.w	r9, [pc, #1000]	; 11148 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x83c>
  inline void Next(float frequency, float amplitude, float* sin, float* cos) {
    if (frequency >= 0.5f) {
      frequency = 0.5f;
    }
    
    phase_ += frequency;
   10d60:	vadd.f32	s14, s14, s13
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
   10d64:	vldr	s13, [pc, #944]	; 11118 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x80c>
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   10d68:	add.w	r8, r9, #1024	; 0x400
    if (phase_ >= 1.0f) {
   10d6c:	vcmpe.f32	s14, s12
   10d70:	vmrs	APSR_nzcv, fpscr
      phase_ -= 1.0f;
   10d74:	it	ge
   10d76:	vsubge.f32	s14, s14, s12
   10d7a:	vstr	s14, [r0, #76]	; 0x4c
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
   10d7e:	vmul.f32	s14, s14, s13
  MAKE_INTEGRAL_FRACTIONAL(index)
   10d82:	vcvt.s32.f32	s13, s14
  float a = table[index_integral];
   10d86:	vmov	r7, s13
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
   10d8a:	vcvt.f32.s32	s13, s13
  float a = table[index_integral];
   10d8e:	lsls	r7, r7, #2
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
   10d90:	vsub.f32	s14, s14, s13
  float a = table[index_integral];
  float b = table[index_integral + 1];
   10d94:	add.w	lr, r7, #4
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   10d98:	add.w	fp, r7, r8
   10d9c:	add	r7, r9
  float b = table[index_integral + 1];
   10d9e:	add	r8, lr
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   10da0:	vldr	s12, [fp]
  float b = table[index_integral + 1];
   10da4:	add	lr, r9
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   10da6:	vldr	s13, [r7]
    }
    
    *sin = amplitude * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
    *cos = amplitude * stmlib::Interpolate(lut_sine + 256, phase_, 1024.0f);
   10daa:	vldr	s26, [r8]
    phase_ += frequency;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    *sin = amplitude * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
   10dae:	vldr	s25, [lr]
    *cos = amplitude * stmlib::Interpolate(lut_sine + 256, phase_, 1024.0f);
   10db2:	vsub.f32	s26, s26, s12
    phase_ += frequency;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    *sin = amplitude * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
   10db6:	vsub.f32	s25, s25, s13
    *cos = amplitude * stmlib::Interpolate(lut_sine + 256, phase_, 1024.0f);
   10dba:	vfma.f32	s12, s14, s26
    phase_ += frequency;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    *sin = amplitude * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
   10dbe:	vfma.f32	s13, s14, s25
    *cos = amplitude * stmlib::Interpolate(lut_sine + 256, phase_, 1024.0f);
   10dc2:	vmul.f32	s12, s12, s3
    phase_ += frequency;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    *sin = amplitude * stmlib::Interpolate(lut_sine, phase_, 1024.0f);
   10dc6:	vmul.f32	s13, s13, s3
    *cos = amplitude * stmlib::Interpolate(lut_sine + 256, phase_, 1024.0f);
   10dca:	vstr	s12, [r0, #44]	; 0x2c
   10dce:	b.n	10c8e <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x382>

      // Q43 / R165
      float attack_fm = fm_pulse_lp_ * 1.7f * attack_fm_amount;
      float self_fm = punch * 0.08f * self_fm_amount;
      float f = f0 * (1.0f + attack_fm + self_fm);
      CONSTRAIN(f, 0.0f, 0.4f);
   10dd0:	vldr	s14, [pc, #840]	; 1111c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x810>

      float resonator_out;
      if (sustain) {
   10dd4:	cmp	r4, #0
   10dd6:	beq.w	10bfa <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ee>
   10dda:	b.n	10d50 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x444>
  
  inline float Diode(float x) {
    if (x >= 0.0f) {
      return x;
    } else {
      x *= 2.0f;
   10ddc:	vadd.f32	s13, s13, s13
      return 0.7f * x / (1.0f + fabsf(x));
   10de0:	vmov.f32	s26, #112	; 0x3f800000  1.0
   10de4:	vabs.f32	s14, s13
   10de8:	vmul.f32	s25, s13, s7
   10dec:	vadd.f32	s14, s14, s26
   10df0:	vdiv.f32	s13, s25, s14
   10df4:	b.n	10bb8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
  
  inline float Diode(float x) {
    if (x >= 0.0f) {
      return x;
    } else {
      x *= 2.0f;
   10df6:	vadd.f32	s15, s15, s15
      return 0.7f * x / (1.0f + fabsf(x));
   10dfa:	vmov.f32	s12, #112	; 0x3f800000  1.0
   10dfe:	vabs.f32	s13, s15
   10e02:	vmul.f32	s14, s15, s7
   10e06:	vadd.f32	s13, s13, s12
   10e0a:	vdiv.f32	s15, s14, s13
   10e0e:	b.n	10b64 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x258>
    while (size--) {
      // Q39 / Q40
      float pulse = 0.0f;
      if (pulse_remaining_samples_) {
        --pulse_remaining_samples_;
        pulse = pulse_remaining_samples_ ? pulse_height_ : pulse_height_ - 1.0f;
   10e10:	vmov.f32	s14, #112	; 0x3f800000  1.0
   10e14:	vldr	s15, [r0, #28]
   10e18:	vsub.f32	s14, s15, s14
   10e1c:	b.n	10b32 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x226>
    
    return stmlib::Interpolate(lut_sine, phase_, 1024.0f);
  }
  
  inline void Next(float frequency, float amplitude, float* sin, float* cos) {
    if (frequency >= 0.5f) {
   10e1e:	vmov.f32	s13, #96	; 0x3f000000  0.5
   10e22:	vadd.f32	s3, s3, s24
      frequency = 0.5f;
   10e26:	vcmp.f32	s14, s13
   10e2a:	vmrs	APSR_nzcv, fpscr
   10e2e:	it	ge
   10e30:	vmovge.f32	s14, s13
   10e34:	b.n	10d54 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x448>
   10e36:	ldr	r6, [sp, #4]
   10e38:	and.w	r7, r6, #1
      attack_fm_amount,
      self_fm_amount,
      out,
      size);

  overdrive_.Process(
   10e3c:	vmov.f32	s9, #96	; 0x3f000000  0.5
    const float drive_2 = drive * drive;
    const float pre_gain_a = drive * 0.5f;
    const float pre_gain_b = drive_2 * drive_2 * drive * 24.0f;
    const float pre_gain = pre_gain_a + (pre_gain_b - pre_gain_a) * drive_2;
    const float drive_squashed = drive * (2.0f - drive);
    const float post_gain = 1.0f / stmlib::SoftClip(
   10e40:	vldr	s12, [pc, #732]	; 11120 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x814>
  
  void Process(float drive, float* in_out, size_t size) {
    const float drive_2 = drive * drive;
    const float pre_gain_a = drive * 0.5f;
    const float pre_gain_b = drive_2 * drive_2 * drive * 24.0f;
    const float pre_gain = pre_gain_a + (pre_gain_b - pre_gain_a) * drive_2;
   10e44:	vmov.f32	s15, #56	; 0x41c00000  24.0
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   10e48:	vstr	s3, [r0, #52]	; 0x34
    const float drive_squashed = drive * (2.0f - drive);
    const float post_gain = 1.0f / stmlib::SoftClip(
   10e4c:	vmov.f32	s11, #0	; 0x40000000  2.0
   10e50:	vmov.f32	s13, s9
inline float SoftLimit(float x) {
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
   10e54:	vmov.f32	s7, #136	; 0xc0400000 -3.0
   10e58:	vfma.f32	s13, s17, s9
    pre_gain_ = 0.0f;
    post_gain_ = 0.0f;
  }
  
  void Process(float drive, float* in_out, size_t size) {
    const float drive_2 = drive * drive;
   10e5c:	vmul.f32	s8, s13, s13
    const float pre_gain_a = drive * 0.5f;
    const float pre_gain_b = drive_2 * drive_2 * drive * 24.0f;
    const float pre_gain = pre_gain_a + (pre_gain_b - pre_gain_a) * drive_2;
    const float drive_squashed = drive * (2.0f - drive);
    const float post_gain = 1.0f / stmlib::SoftClip(
   10e60:	vsub.f32	s11, s11, s13
  
  void Process(float drive, float* in_out, size_t size) {
    const float drive_2 = drive * drive;
    const float pre_gain_a = drive * 0.5f;
    const float pre_gain_b = drive_2 * drive_2 * drive * 24.0f;
    const float pre_gain = pre_gain_a + (pre_gain_b - pre_gain_a) * drive_2;
   10e64:	vmul.f32	s14, s8, s8
    const float drive_squashed = drive * (2.0f - drive);
    const float post_gain = 1.0f / stmlib::SoftClip(
   10e68:	vmul.f32	s11, s11, s13
  
  void Process(float drive, float* in_out, size_t size) {
    const float drive_2 = drive * drive;
    const float pre_gain_a = drive * 0.5f;
    const float pre_gain_b = drive_2 * drive_2 * drive * 24.0f;
    const float pre_gain = pre_gain_a + (pre_gain_b - pre_gain_a) * drive_2;
   10e6c:	vmul.f32	s14, s14, s13
   10e70:	vmul.f32	s15, s14, s15
   10e74:	vfms.f32	s15, s13, s9
   10e78:	vmul.f32	s15, s15, s8
   10e7c:	vfma.f32	s15, s13, s9
    const float drive_squashed = drive * (2.0f - drive);
    const float post_gain = 1.0f / stmlib::SoftClip(
   10e80:	vsub.f32	s14, s15, s12
   10e84:	vfma.f32	s12, s11, s14
   10e88:	vcmpe.f32	s12, s7
   10e8c:	vmov.f32	s14, s12
   10e90:	vmrs	APSR_nzcv, fpscr
   10e94:	bmi.n	10ed0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5c4>
    return -1.0f;
  } else if (x > 3.0f) {
   10e96:	vmov.f32	s13, #8	; 0x40400000  3.0
   10e9a:	vcmpe.f32	s12, s13
   10e9e:	vmrs	APSR_nzcv, fpscr
   10ea2:	bgt.w	115aa <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc9e>
   10ea6:	vmov.f32	s13, #59	; 0x41d80000  27.0
   10eaa:	vmov.f32	s11, #34	; 0x41100000  9.0
   10eae:	vmov.f32	s9, #112	; 0x3f800000  1.0
   10eb2:	vmov.f32	s12, s13
   10eb6:	vmul.f32	s11, s14, s11
   10eba:	vfma.f32	s12, s14, s14
   10ebe:	vfma.f32	s13, s14, s11
   10ec2:	vmul.f32	s14, s12, s14
   10ec6:	vdiv.f32	s12, s14, s13
   10eca:	vdiv.f32	s14, s9, s12
   10ece:	b.n	10ed4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5c8>
inline float SoftLimit(float x) {
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
   10ed0:	vmov.f32	s14, #240	; 0xbf800000 -1.0
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   10ed4:	vldr	s13, [r0, #176]	; 0xb0
   10ed8:	vldr	s12, [r0, #180]	; 0xb4
    increment_ = (new_value - *state) / static_cast<float>(size);
   10edc:	vsub.f32	s15, s15, s13
    stmlib::ParameterInterpolator post_gain_modulation(
        &post_gain_,
        post_gain,
        size);
    
    while (size--) {
   10ee0:	ldr	r6, [sp, #120]	; 0x78
   10ee2:	vsub.f32	s14, s14, s12
   10ee6:	vdiv.f32	s11, s15, s1
   10eea:	vdiv.f32	s9, s14, s1
   10eee:	cbz	r6, 10f5e <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x652>
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   10ef0:	mov	r6, r5
   10ef2:	vmov.f32	s8, #136	; 0xc0400000 -3.0
    return -1.0f;
  } else if (x > 3.0f) {
   10ef6:	vmov.f32	s5, #8	; 0x40400000  3.0
inline float Crossfade(float a, float b, float fade) {
  return a + (b - a) * fade;
}

inline float SoftLimit(float x) {
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
   10efa:	vmov.f32	s7, #59	; 0x41d80000  27.0
   10efe:	vmov.f32	s4, #34	; 0x41100000  9.0
   10f02:	b.n	10f34 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x628>
   10f04:	vmov.f32	s14, s7
   10f08:	vmul.f32	s6, s15, s4
   10f0c:	vmov.f32	s3, s7
   10f10:	vfma.f32	s14, s15, s15
   10f14:	vfma.f32	s3, s15, s6
   10f18:	vmul.f32	s15, s14, s15
   10f1c:	vdiv.f32	s14, s15, s3
   10f20:	subs	r6, #1
   10f22:	cmp.w	r6, #4294967295
  }

  inline float Next() {
    value_ += increment_;
   10f26:	vadd.f32	s12, s12, s9
      float pre = pre_gain_modulation.Next() * *in_out;
      *in_out++ = stmlib::SoftClip(pre) * post_gain_modulation.Next();
   10f2a:	vmul.f32	s14, s12, s14
   10f2e:	vstr	s14, [r2, #-4]
    stmlib::ParameterInterpolator post_gain_modulation(
        &post_gain_,
        post_gain,
        size);
    
    while (size--) {
   10f32:	beq.n	10f5e <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x652>
   10f34:	vadd.f32	s13, s13, s11
      float pre = pre_gain_modulation.Next() * *in_out;
   10f38:	vldmia	r2!, {s15}
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
    return -1.0f;
   10f3c:	vmov.f32	s14, #240	; 0xbf800000 -1.0
   10f40:	vmul.f32	s15, s13, s15
inline float SoftLimit(float x) {
  return x * (27.0f + x * x) / (27.0f + 9.0f * x * x);
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
   10f44:	vcmpe.f32	s15, s8
   10f48:	vmrs	APSR_nzcv, fpscr
   10f4c:	bmi.n	10f20 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x614>
    return -1.0f;
  } else if (x > 3.0f) {
   10f4e:	vcmpe.f32	s15, s5
   10f52:	vmrs	APSR_nzcv, fpscr
   10f56:	ble.n	10f04 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5f8>
    return 1.0f;
   10f58:	vmov.f32	s14, #112	; 0x3f800000  1.0
   10f5c:	b.n	10f20 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x614>
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   10f5e:	vstr	s12, [r0, #180]	; 0xb4
   10f62:	vstr	s13, [r0, #176]	; 0xb0
      size);

  synthetic_bass_drum_.Render(
      sustain,
      parameters.trigger & TRIGGER_RISING_EDGE,
      parameters.accent,
   10f66:	vldr	s11, [r1, #20]
      f0,
      parameters.timbre,
   10f6a:	vldr	s25, [r1, #8]
      parameters.morph,
   10f6e:	vldr	s13, [r1, #12]
  overdrive_.Process(
      0.5f + 0.5f * drive,
      out,
      size);

  synthetic_bass_drum_.Render(
   10f72:	cmp	r4, #0
   10f74:	beq.w	11552 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc46>
   10f78:	vldr	s7, [r1, #16]
   10f7c:	vmov.f32	s22, s7
      parameters.timbre,
      parameters.morph,
      sustain
          ? parameters.harmonics
          : 0.4f - 0.25f * parameters.morph * parameters.morph,
      min(parameters.harmonics * 2.0f, 1.0f),
   10f80:	vadd.f32	s22, s22, s22
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   10f84:	vmov.f32	s15, #112	; 0x3f800000  1.0
	return __b;
      return __a;
   10f88:	vcmpe.f32	s22, s15
      max(parameters.harmonics * 2.0f - 1.0f, 0.0f),
   10f8c:	vsub.f32	s14, s22, s15
   10f90:	vmrs	APSR_nzcv, fpscr
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   10f94:	vcmpe.f32	s14, #0.0
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
      return __a;
   10f98:	it	gt
   10f9a:	vmovgt.f32	s22, s15
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   10f9e:	vmrs	APSR_nzcv, fpscr
   10fa2:	bmi.w	115b0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xca4>
   10fa6:	vmul.f32	s14, s14, s14
   10faa:	vldr	s8, [pc, #376]	; 11124 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x818>
   10fae:	vmov.f32	s12, #16	; 0x40800000  4.0
   10fb2:	vldr	s9, [pc, #372]	; 11128 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x81c>
   10fb6:	vmov.f32	s6, s15
   10fba:	vfma.f32	s6, s14, s12
   10fbe:	vmul.f32	s14, s6, s8
   10fc2:	vmul.f32	s14, s14, s9
   10fc6:	vdiv.f32	s23, s15, s14
   10fca:	vsub.f32	s23, s15, s23

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   10fce:	vldr	s15, [pc, #348]	; 1112c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x820>
      float dirtiness,
      float fm_envelope_amount,
      float fm_envelope_decay,
      float* out,
      size_t size) {
    decay *= decay;
   10fd2:	vmul.f32	s13, s13, s13
   10fd6:	vldr	s14, [pc, #344]	; 11130 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x824>
    fm_envelope_decay *= fm_envelope_decay;
    
    stmlib::ParameterInterpolator f0_mod(&f0_, f0, size);
    
    dirtiness *= std::max(1.0f - 8.0f * f0, 0.0f);
   10fda:	vmov.f32	s9, #32	; 0x41000000  8.0
   10fde:	vmov.f32	s8, s15
   10fe2:	vldr	s12, [pc, #336]	; 11134 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x828>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   10fe6:	vldr	s5, [pc, #336]	; 11138 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   10fea:	vfms.f32	s15, s13, s12
	return __b;
      return __a;
   10fee:	vldr	s6, [pc, #300]	; 1111c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x810>
   10ff2:	vfma.f32	s8, s25, s14
   10ff6:	vmov.f32	s12, #112	; 0x3f800000  1.0
   10ffa:	vmov.f32	s3, s12
    
    const float fm_decay = 1.0f - \
        1.0f / (0.008f * (1.0f + fm_envelope_decay * 4.0f) * kSampleRate);

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
   10ffe:	vmov.f32	s30, s12
   11002:	vmov.f32	s14, s8
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   11006:	vcvt.s32.f32	s8, s8
    decay *= decay;
    fm_envelope_decay *= fm_envelope_decay;
    
    stmlib::ParameterInterpolator f0_mod(&f0_, f0, size);
    
    dirtiness *= std::max(1.0f - 8.0f * f0, 0.0f);
   1100a:	vfma.f32	s3, s21, s9
   1100e:	vcvt.s32.f32	s9, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11012:	vcvt.f32.s32	s4, s8

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   11016:	vmov	r2, s8
    
    const float fm_decay = 1.0f - \
        1.0f / (0.008f * (1.0f + fm_envelope_decay * 4.0f) * kSampleRate);

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
   1101a:	vldr	s8, [pc, #288]	; 1113c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x830>
   1101e:	vmov	r1, s9
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11022:	vcvt.f32.s32	s9, s9
   11026:	vsub.f32	s14, s14, s4

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   1102a:	add.w	r2, sl, r2, lsl #2
   1102e:	add.w	sl, sl, r1, lsl #2
   11032:	vcmpe.f32	s3, s6
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11036:	vsub.f32	s15, s15, s9
    const float transient_env_decay = 1.0f - 1.0f / (0.005f * kSampleRate);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   1103a:	vldr	s16, [r2]
   1103e:	vmul.f32	s14, s14, s5
   11042:	ldr	r2, [pc, #252]	; (11140 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x834>)
   11044:	vmrs	APSR_nzcv, fpscr
    
    const float fm_decay = 1.0f - \
        1.0f / (0.008f * (1.0f + fm_envelope_decay * 4.0f) * kSampleRate);

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
   11048:	vldr	s9, [sl]
   1104c:	vmul.f32	s15, s15, s5
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   11050:	vldr	s5, [r0, #88]	; 0x58
   11054:	vcvt.s32.f32	s14, s14
   11058:	it	mi
   1105a:	vmovmi.f32	s3, s6
   1105e:	vcvt.s32.f32	s15, s15
   11062:	vmov	r1, s14
    increment_ = (new_value - *state) / static_cast<float>(size);
   11066:	vsub.f32	s10, s10, s5
    decay *= decay;
    fm_envelope_decay *= fm_envelope_decay;
    
    stmlib::ParameterInterpolator f0_mod(&f0_, f0, size);
    
    dirtiness *= std::max(1.0f - 8.0f * f0, 0.0f);
   1106a:	vmul.f32	s3, s7, s3
   1106e:	add.w	r2, r2, r1, lsl #2
   11072:	vmov	r6, s15
   11076:	ldr	r1, [pc, #200]	; (11140 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x834>)
   11078:	vdiv.f32	s24, s10, s1

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
    const float transient_env_decay = 1.0f - 1.0f / (0.005f * kSampleRate);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   1107c:	vldr	s15, [r2]
   11080:	add.w	r1, r1, r6, lsl #2
    
    const float fm_decay = 1.0f - \
        1.0f / (0.008f * (1.0f + fm_envelope_decay * 4.0f) * kSampleRate);

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
   11084:	vldr	s14, [r1]
    const float transient_env_decay = 1.0f - 1.0f / (0.005f * kSampleRate);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   11088:	vmul.f32	s16, s15, s16
    
    const float fm_decay = 1.0f - \
        1.0f / (0.008f * (1.0f + fm_envelope_decay * 4.0f) * kSampleRate);

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
   1108c:	vnmul.f32	s15, s9, s14
    const float transient_env_decay = 1.0f - 1.0f / (0.005f * kSampleRate);
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
   11090:	vmul.f32	s16, s16, s19
    
    const float fm_decay = 1.0f - \
        1.0f / (0.008f * (1.0f + fm_envelope_decay * 4.0f) * kSampleRate);

    const float body_env_decay = 1.0f - 1.0f / (0.02f * kSampleRate) * \
        stmlib::SemitonesToRatio(-decay * 60.0f);
   11094:	vfma.f32	s30, s15, s8
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
      return __a;
   11098:	vcmpe.f32	s16, s12
   1109c:	vmrs	APSR_nzcv, fpscr
   110a0:	it	gt
   110a2:	vmovgt.f32	s16, s12
    const float tone_f = std::min(
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
        1.0f);
    const float transient_level = tone;
    
    if (trigger) {
   110a6:	cbz	r7, 110cc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x7c0>
      fm_ = 1.0f;
      body_env_ = transient_env_ = 0.3f + 0.7f * accent;
   110a8:	vldr	s14, [pc, #152]	; 11144 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x838>
      body_env_pulse_width_ = kSampleRate * 0.001f;
   110ac:	movs	r1, #48	; 0x30
        1.0f);
    const float transient_level = tone;
    
    if (trigger) {
      fm_ = 1.0f;
      body_env_ = transient_env_ = 0.3f + 0.7f * accent;
   110ae:	vldr	s15, [pc, #188]	; 1116c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x860>
      body_env_pulse_width_ = kSampleRate * 0.001f;
      fm_pulse_width_ = kSampleRate * 0.0013f;
   110b2:	movs	r2, #62	; 0x3e
        4.0f * f0 * stmlib::SemitonesToRatio(tone * 108.0f),
        1.0f);
    const float transient_level = tone;
    
    if (trigger) {
      fm_ = 1.0f;
   110b4:	vstr	s12, [r0, #100]	; 0x64
      body_env_ = transient_env_ = 0.3f + 0.7f * accent;
   110b8:	vfma.f32	s15, s11, s14
      body_env_pulse_width_ = kSampleRate * 0.001f;
   110bc:	str.w	r1, [r0, #168]	; 0xa8
      fm_pulse_width_ = kSampleRate * 0.0013f;
   110c0:	str.w	r2, [r0, #172]	; 0xac
        1.0f);
    const float transient_level = tone;
    
    if (trigger) {
      fm_ = 1.0f;
      body_env_ = transient_env_ = 0.3f + 0.7f * accent;
   110c4:	vstr	s15, [r0, #116]	; 0x74
   110c8:	vstr	s15, [r0, #108]	; 0x6c
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   110cc:	vldr	s2, [r0, #124]	; 0x7c
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   110d0:	ldr	r2, [sp, #120]	; 0x78
    increment_ = (new_value - *state) / static_cast<float>(size);
   110d2:	vmov.f32	s15, s2
   110d6:	vfnms.f32	s15, s11, s13
   110da:	vdiv.f32	s26, s15, s1
   110de:	cmp	r2, #0
   110e0:	beq.w	11540 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc34>
   110e4:	ldr.w	lr, [pc, #128]	; 11168 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x85c>
   110e8:	ldr	r6, [pc, #92]	; (11148 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x83c>)
   110ea:	ldr.w	r2, [lr]
   110ee:	adds	r7, r6, #4
      ONE_POLE(phase_noise_, stmlib::Random::GetFloat() - 0.5f, 0.002f);
   110f0:	vldr	s18, [pc, #88]	; 1114c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x840>
   110f4:	vldr	s21, [pc, #88]	; 11150 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x844>
          body_env_ *= body_env_decay;
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
   110f8:	vldr	s1, [pc, #88]	; 11154 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x848>
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
   110fc:	vldr	s20, [pc, #24]	; 11118 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x80c>
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
        ONE_POLE(fm_lp_, fm_, envelope_lp_f);
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
   11100:	vldr	s17, [pc, #24]	; 1111c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x810>
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
    ONE_POLE(hp_, lp_, 0.04f);
   11104:	vldr	s29, [pc, #80]	; 11158 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x84c>
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   11108:	vldr	s28, [pc, #80]	; 1115c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x850>
    ONE_POLE(hp_, lp_, 0.005f);
   1110c:	vldr	s27, [pc, #80]	; 11160 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x854>
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
  }
  
  inline float TransistorVCA(float s, float gain) {
    s = (s - 0.6f) * gain;
   11110:	vldr	s19, [pc, #80]	; 11164 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x858>
   11114:	b.n	11272 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x966>
   11116:	nop
   11118:	.word	0x44800000
   1111c:	.word	0x00000000
   11120:	.word	0x3ea8f5c3
   11124:	.word	0x3c03126f
   11128:	.word	0x473b8000
   1112c:	.word	0x43000000
   11130:	.word	0x42d80000
   11134:	.word	0x42700000
   11138:	.word	0x43800000
   1113c:	.word	0x3a888889
   11140:	.word	0x20000958
   11144:	.word	0x3f333333
   11148:	.word	0x20002b10
   1114c:	.word	0x2f800000
   11150:	.word	0x3b03126f
   11154:	.word	0x3dcccccd
   11158:	.word	0x3d23d70a
   1115c:	.word	0x3d4ccccd
   11160:	.word	0x3ba3d70a
   11164:	.word	0x3f19999a
   11168:	.word	0x20020470
   1116c:	.word	0x3e99999a
  }

  inline float Next() {
    value_ += increment_;
   11170:	vadd.f32	s5, s5, s24
      ONE_POLE(phase_noise_, stmlib::Random::GetFloat() - 0.5f, 0.002f);
      
      float mix = 0.0f;

      if (sustain) {
        phase_ += f0_mod.Next();
   11174:	vldr	s15, [r0, #92]	; 0x5c
        if (phase_ >= 1.0f) {
   11178:	vmov.f32	s13, #112	; 0x3f800000  1.0
      ONE_POLE(phase_noise_, stmlib::Random::GetFloat() - 0.5f, 0.002f);
      
      float mix = 0.0f;

      if (sustain) {
        phase_ += f0_mod.Next();
   1117c:	vadd.f32	s15, s5, s15
        if (phase_ >= 1.0f) {
   11180:	vcmpe.f32	s15, s13
   11184:	vmrs	APSR_nzcv, fpscr
          phase_ -= 1.0f;
   11188:	it	ge
   1118a:	vsubge.f32	s15, s15, s13
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
   1118e:	vmov.f32	s13, #96	; 0x3f000000  0.5
      float mix = 0.0f;

      if (sustain) {
        phase_ += f0_mod.Next();
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
   11192:	vstr	s15, [r0, #92]	; 0x5c
    click_.Init();
    noise_.Init();
  }
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
   11196:	vfma.f32	s15, s3, s14
    MAKE_INTEGRAL_FRACTIONAL(phase);
   1119a:	vcvt.s32.f32	s14, s15
   1119e:	vcvt.f32.s32	s14, s14
   111a2:	vsub.f32	s15, s15, s14
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
   111a6:	vcmpe.f32	s15, s13
   111aa:	vmrs	APSR_nzcv, fpscr
   111ae:	bmi.w	1152e <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc22>
   111b2:	vmov.f32	s13, #112	; 0x3f800000  1.0
   111b6:	vmov.f32	s12, #16	; 0x40800000  4.0
   111ba:	vmov.f32	s14, #240	; 0xbf800000 -1.0
   111be:	vsub.f32	s13, s13, s15
   111c2:	vfma.f32	s14, s13, s12
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
   111c6:	vmov.f32	s13, #104	; 0x3f400000  0.750
        phase_ += f0_mod.Next();
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
        }
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        mix -= TransistorVCA(body, sustain_gain.Next());
   111ca:	vldr	s12, [pc, #-96]	; 1116c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x860>
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
   111ce:	vabs.f32	s10, s14
   111d2:	vmov.f32	s9, #112	; 0x3f800000  1.0
    float clean_sine = stmlib::InterpolateWrap(
   111d6:	vadd.f32	s15, s15, s13
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
   111da:	vadd.f32	s14, s14, s14
   111de:	vadd.f32	s10, s10, s9
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
   111e2:	vcvt.s32.f32	s11, s15
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
  }
  
  inline float TransistorVCA(float s, float gain) {
    s = (s - 0.6f) * gain;
   111e6:	vsub.f32	s9, s9, s3
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
   111ea:	vdiv.f32	s13, s14, s10
   111ee:	vcvt.f32.s32	s14, s11
   111f2:	vadd.f32	s2, s2, s26
        phase_ += f0_mod.Next();
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
        }
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        mix -= TransistorVCA(body, sustain_gain.Next());
   111f6:	vmov.f32	s10, #0	; 0x40000000  2.0
   111fa:	vsub.f32	s15, s15, s14
   111fe:	vmov.f32	s14, #8	; 0x40400000  3.0
  index *= size;
   11202:	vmul.f32	s15, s15, s20
  MAKE_INTEGRAL_FRACTIONAL(index)
   11206:	vcvt.s32.f32	s11, s15
  float a = table[index_integral];
   1120a:	vmov	r1, s11
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
  }
  
  inline float TransistorVCA(float s, float gain) {
    s = (s - 0.6f) * gain;
   1120e:	vcvt.f32.s32	s11, s11
   11212:	lsls	r1, r1, #2
   11214:	vsub.f32	s15, s15, s11
   11218:	add.w	ip, r6, r1
  float b = table[index_integral + 1];
   1121c:	add	r1, r7

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   1121e:	vldr	s11, [ip]
   11222:	vldr	s8, [r1]
   11226:	vsub.f32	s8, s8, s11
   1122a:	vfma.f32	s11, s15, s8
   1122e:	vsub.f32	s11, s11, s13
   11232:	vfma.f32	s13, s9, s11
   11236:	vsub.f32	s13, s13, s19
   1123a:	vmul.f32	s15, s13, s2
        phase_ += f0_mod.Next();
        if (phase_ >= 1.0f) {
          phase_ -= 1.0f;
        }
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        mix -= TransistorVCA(body, sustain_gain.Next());
   1123e:	vabs.f32	s13, s15
   11242:	vmul.f32	s14, s15, s14
   11246:	vadd.f32	s10, s13, s10
   1124a:	vdiv.f32	s15, s14, s10
   1124e:	vfma.f32	s15, s2, s12
   11252:	vsub.f32	s15, s17, s15
      
        mix -= TransistorVCA(body, body_env_lp_);
        mix -= transient * transient_env_lp_ * transient_level;
      }

      ONE_POLE(tone_lp_, mix, tone_f);
   11256:	vldr	s14, [r0, #128]	; 0x80
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   1125a:	subs	r5, #1
      
        mix -= TransistorVCA(body, body_env_lp_);
        mix -= transient * transient_env_lp_ * transient_level;
      }

      ONE_POLE(tone_lp_, mix, tone_f);
   1125c:	vsub.f32	s15, s15, s14
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   11260:	adds	r1, r5, #1
      
        mix -= TransistorVCA(body, body_env_lp_);
        mix -= transient * transient_env_lp_ * transient_level;
      }

      ONE_POLE(tone_lp_, mix, tone_f);
   11262:	vfma.f32	s14, s16, s15
   11266:	vstr	s14, [r0, #128]	; 0x80
      *out++ = tone_lp_;
   1126a:	vstmia	r3!, {s14}
    stmlib::ParameterInterpolator sustain_gain(
        &sustain_gain_,
        accent * decay,
        size);
    
    while (size--) {
   1126e:	beq.w	1153c <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc30>
   11272:	ldr	r1, [pc, #836]	; (115b8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcac>)
      ONE_POLE(phase_noise_, stmlib::Random::GetFloat() - 0.5f, 0.002f);
   11274:	vmov.f32	s15, #224	; 0xbf000000 -0.5
   11278:	vldr	s14, [r0, #96]	; 0x60
   1127c:	mul.w	r1, r1, r2
   11280:	ldr	r2, [pc, #824]	; (115bc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcb0>)
   11282:	add	r2, r1
   11284:	vmov	s13, r2
   11288:	vcvt.f32.u32	s13, s13
   1128c:	vfma.f32	s15, s13, s18
   11290:	vsub.f32	s15, s15, s14
   11294:	vfma.f32	s14, s15, s21
   11298:	vstr	s14, [r0, #96]	; 0x60
      
      float mix = 0.0f;

      if (sustain) {
   1129c:	cmp	r4, #0
   1129e:	bne.w	11170 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x864>
          phase_ -= 1.0f;
        }
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        mix -= TransistorVCA(body, sustain_gain.Next());
      } else {
        if (fm_pulse_width_) {
   112a2:	ldr.w	r1, [r0, #172]	; 0xac
   112a6:	cmp	r1, #0
   112a8:	beq.w	114a0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xb94>
          --fm_pulse_width_;
   112ac:	subs	r1, #1
          phase_ = 0.25f;
   112ae:	mov.w	ip, #1048576000	; 0x3e800000
   112b2:	vldr	s11, [r0, #100]	; 0x64
        }
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        mix -= TransistorVCA(body, sustain_gain.Next());
      } else {
        if (fm_pulse_width_) {
          --fm_pulse_width_;
   112b6:	str.w	r1, [r0, #172]	; 0xac
          if (phase_ >= 1.0f) {
            phase_ -= 1.0f;
          }
        }
      
        if (body_env_pulse_width_) {
   112ba:	ldr.w	r1, [r0, #168]	; 0xa8
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        mix -= TransistorVCA(body, sustain_gain.Next());
      } else {
        if (fm_pulse_width_) {
          --fm_pulse_width_;
          phase_ = 0.25f;
   112be:	str.w	ip, [r0, #92]	; 0x5c
   112c2:	vldr	s15, [r0, #104]	; 0x68
          if (phase_ >= 1.0f) {
            phase_ -= 1.0f;
          }
        }
      
        if (body_env_pulse_width_) {
   112c6:	cmp	r1, #0
   112c8:	beq.w	11502 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xbf6>
          --body_env_pulse_width_;
   112cc:	subs	r1, #1
   112ce:	vldr	s12, [r0, #108]	; 0x6c
   112d2:	vldr	s13, [r0, #116]	; 0x74
   112d6:	str.w	r1, [r0, #168]	; 0xa8
    click_.Init();
    noise_.Init();
  }
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
   112da:	vldr	s9, [r0, #92]	; 0x5c
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
        ONE_POLE(fm_lp_, fm_, envelope_lp_f);
   112de:	vsub.f32	s10, s11, s15
          body_env_ *= body_env_decay;
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
   112e2:	vldr	s11, [r0, #112]	; 0x70
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
   112e6:	vmov.f32	s8, #96	; 0x3f000000  0.5
    click_.Init();
    noise_.Init();
  }
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
   112ea:	vfma.f32	s9, s3, s14
          body_env_ *= body_env_decay;
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
   112ee:	vsub.f32	s12, s12, s11
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
        ONE_POLE(fm_lp_, fm_, envelope_lp_f);
   112f2:	vfma.f32	s15, s10, s1
          body_env_ *= body_env_decay;
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
   112f6:	vfma.f32	s11, s12, s1
    click_.Init();
    noise_.Init();
  }
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
   112fa:	vmov.f32	s14, s9
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
   112fe:	vldr	s9, [r0, #120]	; 0x78
   11302:	vsub.f32	s13, s13, s9
        ONE_POLE(fm_lp_, fm_, envelope_lp_f);
   11306:	vstr	s15, [r0, #104]	; 0x68
          body_env_ *= body_env_decay;
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
   1130a:	vstr	s11, [r0, #112]	; 0x70
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
   1130e:	vfma.f32	s9, s13, s1
    noise_.Init();
  }
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
   11312:	vcvt.s32.f32	s13, s14
   11316:	vcvt.f32.s32	s13, s13
          transient_env_ *= transient_env_decay;
        }
      
        const float envelope_lp_f = 0.1f;
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
   1131a:	vstr	s9, [r0, #120]	; 0x78
    noise_.Init();
  }
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
   1131e:	vsub.f32	s14, s14, s13
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
   11322:	vcmpe.f32	s14, s8
   11326:	vmrs	APSR_nzcv, fpscr
   1132a:	bmi.w	11520 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xc14>
   1132e:	vmov.f32	s15, #112	; 0x3f800000  1.0
   11332:	vmov.f32	s12, #16	; 0x40800000  4.0
   11336:	vmov.f32	s13, #240	; 0xbf800000 -1.0
   1133a:	vsub.f32	s15, s15, s14
   1133e:	vfma.f32	s13, s15, s12
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
   11342:	vmov.f32	s12, #104	; 0x3f400000  0.750
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
        ONE_POLE(fm_lp_, fm_, envelope_lp_f);
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
   11346:	cmp	r1, #0
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
   11348:	vmov.f32	s6, #112	; 0x3f800000  1.0
   1134c:	ldr	r1, [pc, #616]	; (115b8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcac>)
   1134e:	vabs.f32	s4, s13
    filter_.Init();
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
   11352:	vldr	s15, [r0, #132]	; 0x84
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
   11356:	vadd.f32	s14, s14, s12
   1135a:	mul.w	r1, r1, r2
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
   1135e:	vadd.f32	s10, s13, s13
   11362:	ldr	r2, [pc, #600]	; (115bc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcb0>)
   11364:	vadd.f32	s4, s4, s6
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
    ONE_POLE(hp_, lp_, 0.04f);
   11368:	vldr	s7, [r0, #136]	; 0x88
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
}

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
   1136c:	vcvt.s32.f32	s8, s14
   11370:	add	r2, r1
    filter_.Init();
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
   11372:	vmov.f32	s0, #96	; 0x3f000000  0.5
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   11376:	vldr	s12, [r0, #152]	; 0x98
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
   1137a:	vdiv.f32	s13, s10, s4
   1137e:	vcvt.f32.s32	s10, s8
   11382:	vldr	s8, [r0, #140]	; 0x8c
        ONE_POLE(body_env_lp_, body_env_, envelope_lp_f);
        ONE_POLE(transient_env_lp_, transient_env_, envelope_lp_f);
        ONE_POLE(fm_lp_, fm_, envelope_lp_f);
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
   11386:	ite	ne
   11388:	vmovne.f32	s4, s17
   1138c:	vmoveq.f32	s4, s6
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   11390:	vsub.f32	s6, s6, s3
   11394:	vsub.f32	s14, s14, s10
    filter_.Init();
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
   11398:	vsub.f32	s4, s4, s15
  index *= size;
   1139c:	vmul.f32	s14, s14, s20
   113a0:	vcmpe.f32	s4, #0.0
  MAKE_INTEGRAL_FRACTIONAL(index)
   113a4:	vcvt.s32.f32	s31, s14
   113a8:	vmrs	APSR_nzcv, fpscr
  float a = table[index_integral];
   113ac:	vmov	r1, s31
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   113b0:	vcvt.f32.s32	s31, s31
    filter_.Init();
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
   113b4:	it	le
   113b6:	vmovle.f32	s0, s1
   113ba:	lsls	r1, r1, #2
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   113bc:	vsub.f32	s14, s14, s31
   113c0:	add.w	ip, r6, r1
  float b = table[index_integral + 1];
   113c4:	add	r1, r7
    filter_.Init();
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
   113c6:	vfma.f32	s15, s4, s0
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   113ca:	vmov	s4, r2

inline float InterpolateWrap(const float* table, float index, float size) {
  index -= static_cast<float>(static_cast<int32_t>(index));
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   113ce:	vldr	s10, [ip]
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   113d2:	vldr	s31, [r1]
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   113d6:	vcvt.f32.u32	s0, s4
   113da:	vldr	s4, [r0, #156]	; 0x9c
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   113de:	vsub.f32	s31, s31, s10
    filter_.Init();
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
   113e2:	vstr	s15, [r0, #132]	; 0x84
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   113e6:	vfma.f32	s10, s14, s31
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   113ea:	vldr	s14, [r0, #160]	; 0xa0
   113ee:	vmov.f32	s31, s14
   113f2:	vfnms.f32	s31, s0, s18
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
    float sine = 2.0f * triangle / (1.0f + fabsf(triangle));
    float clean_sine = stmlib::InterpolateWrap(
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
   113f6:	vsub.f32	s10, s10, s13
   113fa:	vfma.f32	s13, s6, s10
   113fe:	vldr	s6, [r0, #148]	; 0x94
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
            body_env_pulse_width_ ? 0.0f : 1.0f) + noise_.Render();
      
        mix -= TransistorVCA(body, body_env_lp_);
   11402:	vmov.f32	s10, #0	; 0x40000000  2.0
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   11406:	vmov.f32	s0, s31
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
    ONE_POLE(hp_, lp_, 0.04f);
   1140a:	vsub.f32	s31, s15, s7
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   1140e:	vfma.f32	s14, s0, s28
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
    ONE_POLE(hp_, lp_, 0.04f);
   11412:	vfma.f32	s7, s31, s29
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
  }
  
  inline float TransistorVCA(float s, float gain) {
    s = (s - 0.6f) * gain;
   11416:	vsub.f32	s13, s13, s19
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
            body_env_pulse_width_ ? 0.0f : 1.0f) + noise_.Render();
      
        mix -= TransistorVCA(body, body_env_lp_);
   1141a:	vmov.f32	s0, #8	; 0x40400000  3.0
        lut_sine, phase + 0.75f, 1024.0f);
    return sine + (1.0f - dirtiness) * (clean_sine - sine);
  }
  
  inline float TransistorVCA(float s, float gain) {
    s = (s - 0.6f) * gain;
   1141e:	vmul.f32	s13, s13, s11
    hp_ = 0.0f;
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
   11422:	vstr	s14, [r0, #160]	; 0xa0
   11426:	vsub.f32	s15, s15, s7
    filter_.set_f_q<stmlib::FREQUENCY_FAST>(5000.0f / kSampleRate, 2.0f);
  }
  
  float Process(float in) {
    SLOPE(lp_, in, 0.5f, 0.1f);
    ONE_POLE(hp_, lp_, 0.04f);
   1142a:	vstr	s7, [r0, #136]	; 0x88
   1142e:	vldr	s7, [r0, #144]	; 0x90
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
            body_env_pulse_width_ ? 0.0f : 1.0f) + noise_.Render();
      
        mix -= TransistorVCA(body, body_env_lp_);
   11432:	vabs.f32	s31, s13
   11436:	vmul.f32	s0, s13, s0
   1143a:	vfms.f32	s15, s7, s12
   1143e:	vldr	s7, [pc, #384]	; 115c0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcb4>
   11442:	vadd.f32	s31, s31, s10
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
    ONE_POLE(hp_, lp_, 0.005f);
   11446:	vldr	s10, [r0, #164]	; 0xa4
   1144a:	vfms.f32	s15, s12, s8
   1144e:	vmov.f32	s13, s15
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
            body_env_pulse_width_ ? 0.0f : 1.0f) + noise_.Render();
      
        mix -= TransistorVCA(body, body_env_lp_);
   11452:	vdiv.f32	s15, s0, s31
   11456:	vsub.f32	s13, s13, s4
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
    ONE_POLE(hp_, lp_, 0.005f);
   1145a:	vsub.f32	s0, s14, s10
   1145e:	vmul.f32	s13, s13, s6
   11462:	vfma.f32	s10, s0, s27
    bp = g_ * hp + state_1_;
   11466:	vfma.f32	s12, s8, s13
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
            body_env_pulse_width_ ? 0.0f : 1.0f) + noise_.Render();
      
        mix -= TransistorVCA(body, body_env_lp_);
        mix -= transient * transient_env_lp_ * transient_level;
   1146a:	vsub.f32	s14, s14, s10
  }
  
  float Render() {
    float sample = stmlib::Random::GetFloat();
    ONE_POLE(lp_, sample, 0.05f);
    ONE_POLE(hp_, lp_, 0.005f);
   1146e:	vstr	s10, [r0, #164]	; 0xa4
      
        float body = DistortedSine(phase_, phase_noise_, dirtiness);
        float transient = click_.Process(
            body_env_pulse_width_ ? 0.0f : 1.0f) + noise_.Render();
      
        mix -= TransistorVCA(body, body_env_lp_);
   11472:	vfma.f32	s15, s11, s7
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
   11476:	vfma.f32	s4, s8, s12
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   1147a:	vmov.f32	s11, s12
   1147e:	vfma.f32	s11, s8, s13
   11482:	vsub.f32	s15, s17, s15
        mix -= transient * transient_env_lp_ * transient_level;
   11486:	vadd.f32	s14, s14, s4
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   1148a:	vfma.f32	s4, s8, s12
   1148e:	vmul.f32	s9, s14, s9
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   11492:	vstr	s11, [r0, #152]	; 0x98
   11496:	vfms.f32	s15, s25, s9
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   1149a:	vstr	s4, [r0, #156]	; 0x9c
   1149e:	b.n	11256 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x94a>
          --fm_pulse_width_;
          phase_ = 0.25f;
        } else {
          fm_ *= fm_decay;
          float fm = 1.0f + fm_envelope_amount * 3.5f * fm_lp_;
          phase_ += std::min(f0_mod.Next() * fm, 0.5f);
   114a0:	vmov.f32	s9, #112	; 0x3f800000  1.0
   114a4:	vldr	s15, [r0, #104]	; 0x68
   114a8:	vmov.f32	s10, #12	; 0x40600000  3.5
   114ac:	vldr	s13, [r0, #92]	; 0x5c
   114b0:	vadd.f32	s5, s5, s24
      } else {
        if (fm_pulse_width_) {
          --fm_pulse_width_;
          phase_ = 0.25f;
        } else {
          fm_ *= fm_decay;
   114b4:	vldr	s11, [r0, #100]	; 0x64
          float fm = 1.0f + fm_envelope_amount * 3.5f * fm_lp_;
          phase_ += std::min(f0_mod.Next() * fm, 0.5f);
   114b8:	vmov.f32	s8, s9
          if (phase_ >= 1.0f) {
            phase_ -= 1.0f;
          }
        }
      
        if (body_env_pulse_width_) {
   114bc:	ldr.w	r1, [r0, #168]	; 0xa8
          --fm_pulse_width_;
          phase_ = 0.25f;
        } else {
          fm_ *= fm_decay;
          float fm = 1.0f + fm_envelope_amount * 3.5f * fm_lp_;
          phase_ += std::min(f0_mod.Next() * fm, 0.5f);
   114c0:	vmul.f32	s10, s22, s10
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   114c4:	vmov.f32	s12, #96	; 0x3f000000  0.5
      } else {
        if (fm_pulse_width_) {
          --fm_pulse_width_;
          phase_ = 0.25f;
        } else {
          fm_ *= fm_decay;
   114c8:	vmul.f32	s11, s11, s23
          float fm = 1.0f + fm_envelope_amount * 3.5f * fm_lp_;
          phase_ += std::min(f0_mod.Next() * fm, 0.5f);
   114cc:	vfma.f32	s8, s10, s15
      } else {
        if (fm_pulse_width_) {
          --fm_pulse_width_;
          phase_ = 0.25f;
        } else {
          fm_ *= fm_decay;
   114d0:	vstr	s11, [r0, #100]	; 0x64
          float fm = 1.0f + fm_envelope_amount * 3.5f * fm_lp_;
          phase_ += std::min(f0_mod.Next() * fm, 0.5f);
   114d4:	vmul.f32	s10, s8, s5
	return __b;
      return __a;
   114d8:	vcmpe.f32	s10, s12
   114dc:	vmrs	APSR_nzcv, fpscr
   114e0:	it	le
   114e2:	vmovle.f32	s12, s10
   114e6:	vadd.f32	s13, s12, s13
          if (phase_ >= 1.0f) {
   114ea:	vcmpe.f32	s13, s9
   114ee:	vmrs	APSR_nzcv, fpscr
            phase_ -= 1.0f;
   114f2:	it	ge
   114f4:	vsubge.f32	s13, s13, s9
   114f8:	vstr	s13, [r0, #92]	; 0x5c
          }
        }
      
        if (body_env_pulse_width_) {
   114fc:	cmp	r1, #0
   114fe:	bne.w	112cc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9c0>
          --body_env_pulse_width_;
        } else {
          body_env_ *= body_env_decay;
   11502:	vldr	s12, [r0, #108]	; 0x6c
          transient_env_ *= transient_env_decay;
   11506:	vldr	s13, [r0, #116]	; 0x74
   1150a:	vldr	s10, [pc, #184]	; 115c4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcb8>
        }
      
        if (body_env_pulse_width_) {
          --body_env_pulse_width_;
        } else {
          body_env_ *= body_env_decay;
   1150e:	vmul.f32	s12, s30, s12
          transient_env_ *= transient_env_decay;
   11512:	vmul.f32	s13, s13, s10
        }
      
        if (body_env_pulse_width_) {
          --body_env_pulse_width_;
        } else {
          body_env_ *= body_env_decay;
   11516:	vstr	s12, [r0, #108]	; 0x6c
          transient_env_ *= transient_env_decay;
   1151a:	vstr	s13, [r0, #116]	; 0x74
   1151e:	b.n	112da <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9ce>
  
  inline float DistortedSine(float phase, float phase_noise, float dirtiness) {
    phase += phase_noise * dirtiness;
    MAKE_INTEGRAL_FRACTIONAL(phase);
    phase = phase_fractional;
    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.0f;
   11520:	vmov.f32	s15, #16	; 0x40800000  4.0
   11524:	vmov.f32	s13, #240	; 0xbf800000 -1.0
   11528:	vfma.f32	s13, s14, s15
   1152c:	b.n	11342 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa36>
   1152e:	vmov.f32	s13, #16	; 0x40800000  4.0
   11532:	vmov.f32	s14, #240	; 0xbf800000 -1.0
   11536:	vfma.f32	s14, s15, s13
   1153a:	b.n	111c6 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8ba>
   1153c:	str.w	r2, [lr]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   11540:	vstr	s2, [r0, #124]	; 0x7c
   11544:	vstr	s5, [r0, #88]	; 0x58
      aux,
      size);
}
   11548:	add	sp, #20
   1154a:	vpop	{d8-d15}
   1154e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  overdrive_.Process(
      0.5f + 0.5f * drive,
      out,
      size);

  synthetic_bass_drum_.Render(
   11552:	vmov.f32	s15, #80	; 0x3e800000  0.250
   11556:	vldr	s3, [pc, #112]	; 115c8 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcbc>
   1155a:	vldr	s22, [r1, #16]
   1155e:	vmov.f32	s7, s3
   11562:	vmul.f32	s15, s13, s15
   11566:	vfms.f32	s7, s13, s15
   1156a:	b.n	10f80 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x674>
   1156c:	vldr	s14, [pc, #92]	; 115cc <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcc0>
   11570:	vadd.f32	s15, s15, s14
   11574:	vcvt.s32.f32	s14, s15
   11578:	vmov	r5, s14
   1157c:	vcvt.f32.s32	s14, s14
   11580:	vsub.f32	s15, s15, s14
   11584:	vmov.f32	s14, s15
   11588:	vcvt.s32.f32	s14, s14, #8
   1158c:	vmov	r4, s14
   11590:	b.w	1094a <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e>
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   11594:	vcmpe.f32	s14, #0.0
   11598:	vldr	s9, [pc, #52]	; 115d0 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcc4>
   1159c:	vmrs	APSR_nzcv, fpscr
   115a0:	it	pl
   115a2:	vmovpl.f32	s9, s14
   115a6:	b.w	1099a <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x8e>
}

inline float SoftClip(float x) {
  if (x < -3.0f) {
    return -1.0f;
  } else if (x > 3.0f) {
   115aa:	vmov.f32	s14, #112	; 0x3f800000  1.0
   115ae:	b.n	10ed4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x5c8>
   115b0:	vldr	s23, [pc, #32]	; 115d4 <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xcc8>
   115b4:	b.n	10fce <plaits::BassDrumEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6c2>
   115b6:	nop
   115b8:	.word	0x0019660d
   115bc:	.word	0x3c6ef35f
   115c0:	.word	0x3e99999a
   115c4:	.word	0x3f7eeeef
   115c8:	.word	0x3ecccccd
   115cc:	.word	0x43000000
   115d0:	.word	0x00000000
   115d4:	.word	0x3f7f5555

000115d8 <plaits::NoiseEngine::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace std;
using namespace stmlib;

void NoiseEngine::Init(BufferAllocator* allocator) {
   115d8:	push	{r4, r5, r6, r7}
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
   115da:	ldr	r6, [r1, #8]
 public:
  ClockedNoise() { }
  ~ClockedNoise() { }
  
  void Init() {
    phase_ = 0.0f;
   115dc:	movs	r3, #0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   115de:	ldr	r5, [pc, #96]	; (11640 <plaits::NoiseEngine::Init(stmlib::BufferAllocator*)+0x68>)
    r_ = 1.0f / resonance;
   115e0:	ldr	r4, [pc, #96]	; (11644 <plaits::NoiseEngine::Init(stmlib::BufferAllocator*)+0x6c>)
   115e2:	cmp.w	r6, #512	; 0x200
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   115e6:	ldr	r2, [pc, #96]	; (11648 <plaits::NoiseEngine::Init(stmlib::BufferAllocator*)+0x70>)
    sample_ = 0.0f;
    next_sample_ = 0.0f;
    frequency_ = 0.001f;
   115e8:	ldr	r7, [pc, #96]	; (1164c <plaits::NoiseEngine::Init(stmlib::BufferAllocator*)+0x74>)
 public:
  ClockedNoise() { }
  ~ClockedNoise() { }
  
  void Init() {
    phase_ = 0.0f;
   115ea:	str	r3, [r0, #16]
    sample_ = 0.0f;
   115ec:	str	r3, [r0, #20]
    next_sample_ = 0.0f;
   115ee:	str	r3, [r0, #24]
 public:
  ClockedNoise() { }
  ~ClockedNoise() { }
  
  void Init() {
    phase_ = 0.0f;
   115f0:	str	r3, [r0, #32]
    sample_ = 0.0f;
   115f2:	str	r3, [r0, #36]	; 0x24
    next_sample_ = 0.0f;
   115f4:	str	r3, [r0, #40]	; 0x28
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   115f6:	str	r3, [r0, #64]	; 0x40
   115f8:	str	r3, [r0, #60]	; 0x3c
   115fa:	str	r3, [r0, #84]	; 0x54
   115fc:	str	r3, [r0, #80]	; 0x50
   115fe:	str	r3, [r0, #104]	; 0x68
   11600:	str	r3, [r0, #100]	; 0x64
  clocked_noise_[1].Init();
  lp_hp_filter_.Init();
  bp_filter_[0].Init();
  bp_filter_[1].Init();

  previous_f0_ = 0.0f;
   11602:	str	r3, [r0, #108]	; 0x6c
  previous_f1_ = 0.0f;
   11604:	str	r3, [r0, #112]	; 0x70
  previous_q_ = 0.0f;
   11606:	str	r3, [r0, #116]	; 0x74
  previous_mode_ = 0.0f;
   11608:	str	r3, [r0, #120]	; 0x78
    frequency_ = 0.001f;
   1160a:	str	r7, [r0, #28]
   1160c:	str	r7, [r0, #44]	; 0x2c

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   1160e:	str	r5, [r0, #48]	; 0x30
   11610:	str	r5, [r0, #68]	; 0x44
   11612:	str	r5, [r0, #88]	; 0x58
    r_ = 1.0f / resonance;
   11614:	str	r4, [r0, #52]	; 0x34
   11616:	str	r4, [r0, #72]	; 0x48
   11618:	str	r4, [r0, #92]	; 0x5c
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   1161a:	str	r2, [r0, #56]	; 0x38
   1161c:	str	r2, [r0, #76]	; 0x4c
   1161e:	str	r2, [r0, #96]	; 0x60
   11620:	bcc.n	11636 <plaits::NoiseEngine::Init(stmlib::BufferAllocator*)+0x5e>
      T* start = static_cast<T*>(static_cast<void*>(next_));
   11622:	ldr	r3, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
   11624:	sub.w	r6, r6, #512	; 0x200
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
   11628:	add.w	r2, r3, #512	; 0x200
      free_ -= size_bytes;
   1162c:	str	r6, [r1, #8]
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
   1162e:	str	r2, [r1, #0]

  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
   11630:	str	r3, [r0, #124]	; 0x7c
}
   11632:	pop	{r4, r5, r6, r7}
   11634:	bx	lr
      free_ -= size_bytes;
      return start;
    } else {
      return NULL;
   11636:	movs	r3, #0
   11638:	pop	{r4, r5, r6, r7}
  previous_f0_ = 0.0f;
  previous_f1_ = 0.0f;
  previous_q_ = 0.0f;
  previous_mode_ = 0.0f;

  temp_buffer_ = allocator->Allocate<float>(kMaxBlockSize);
   1163a:	str	r3, [r0, #124]	; 0x7c
}
   1163c:	bx	lr
   1163e:	nop
   11640:	.word	0x3d00ba22
   11644:	.word	0x3c23d70a
   11648:	.word	0x3f7faaca
   1164c:	.word	0x3a83126f

00011650 <plaits::NoiseEngine::Reset()>:

void NoiseEngine::Reset() {
   11650:	bx	lr
   11652:	nop

00011654 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   11654:	vmov.f32	s14, #34	; 0x41100000  9.0
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
   11658:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   1165c:	vldr	s13, [pc, #840]	; 119a8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x354>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   11660:	vsub.f32	s14, s15, s14
void NoiseEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
   11664:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   11668:	vcmpe.f32	s14, s13
   1166c:	vpush	{d8-d15}
   11670:	vmrs	APSR_nzcv, fpscr
   11674:	ldr.w	ip, [sp, #96]	; 0x60
   11678:	bmi.n	11690 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3c>
   1167a:	vldr	s13, [pc, #816]	; 119ac <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x358>
   1167e:	vcmpe.f32	s14, s13
   11682:	vmrs	APSR_nzcv, fpscr
   11686:	ble.w	11d7a <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x726>
   1168a:	movs	r4, #0
   1168c:	movs	r7, #255	; 0xff
   1168e:	b.n	11694 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40>
   11690:	movs	r4, #0
   11692:	mov	r7, r4
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   11694:	vldr	s13, [r1, #16]
   11698:	vmov.f32	s10, #56	; 0x41c00000  24.0
   1169c:	vldr	s14, [pc, #784]	; 119b0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x35c>
   116a0:	vmov.f32	s11, #34	; 0x41100000  9.0

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   116a4:	ldr	r6, [pc, #780]	; (119b4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x360>)
   116a6:	vfma.f32	s15, s13, s14
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   116aa:	ldr	r5, [pc, #780]	; (119b8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x364>)
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   116ac:	vldr	s13, [pc, #760]	; 119a8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x354>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   116b0:	add.w	r7, r6, r7, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   116b4:	add.w	r4, r5, r4, lsl #2
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   116b8:	vldr	s12, [pc, #768]	; 119bc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x368>
   116bc:	vldr	s14, [r7]
   116c0:	vldr	s5, [r4]
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   116c4:	vsub.f32	s15, s15, s10
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   116c8:	vmul.f32	s14, s14, s5
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   116cc:	vsub.f32	s15, s15, s11
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   116d0:	vmul.f32	s5, s14, s12

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   116d4:	vcmpe.f32	s15, s13
   116d8:	vmrs	APSR_nzcv, fpscr
   116dc:	bmi.n	116f4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa0>
   116de:	vldr	s14, [pc, #716]	; 119ac <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x358>
   116e2:	vcmpe.f32	s15, s14
   116e6:	vmrs	APSR_nzcv, fpscr
   116ea:	ble.w	11d54 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x700>
   116ee:	movs	r4, #0
   116f0:	movs	r7, #255	; 0xff
   116f2:	b.n	116f8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa4>
   116f4:	movs	r4, #0
   116f6:	mov	r7, r4
  const float f0 = NoteToFrequency(parameters.note);
  const float f1 = NoteToFrequency(
      parameters.note + parameters.harmonics * 48.0f - 24.0f);
  const float clock_lowest_note = parameters.trigger & TRIGGER_UNPATCHED
   116f8:	ldrb.w	r9, [r1]
      ? 0.0f
      : -24.0f;
   116fc:	vmov.f32	s15, #184	; 0xc1c00000 -24.0
   11700:	vldr	s14, [pc, #700]	; 119c0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   11704:	add.w	r7, r6, r7, lsl #2
   11708:	and.w	lr, r9, #2
   1170c:	vldr	s11, [pc, #692]	; 119c4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x370>
   11710:	vldr	s12, [pc, #692]	; 119c8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x374>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11714:	add.w	r4, r5, r4, lsl #2
   11718:	cmp.w	lr, #0
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   1171c:	vldr	s8, [r1, #8]
   11720:	vmov.f32	s10, #34	; 0x41100000  9.0
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   11724:	vldr	s13, [r7]
   11728:	it	ne
   1172a:	vmovne.f32	s15, s14
   1172e:	vldr	s14, [r4]
   11732:	it	ne
   11734:	vmovne.f32	s12, s11
   11738:	vldr	s9, [pc, #640]	; 119bc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x368>
   1173c:	vmul.f32	s14, s13, s14

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   11740:	vldr	s13, [pc, #612]	; 119a8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x354>
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   11744:	vfma.f32	s15, s8, s12
  CONSTRAIN(midi_note, -128.0f, 127.0f);
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   11748:	vmul.f32	s6, s14, s9
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   1174c:	vsub.f32	s15, s15, s10
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   11750:	vcmpe.f32	s15, s13
   11754:	vmrs	APSR_nzcv, fpscr
   11758:	bmi.n	11770 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11c>
   1175a:	vldr	s14, [pc, #592]	; 119ac <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x358>
   1175e:	vcmpe.f32	s15, s14
   11762:	vmrs	APSR_nzcv, fpscr
   11766:	ble.w	11d32 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6de>
   1176a:	movs	r4, #0
   1176c:	movs	r7, #255	; 0xff
   1176e:	b.n	11774 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x120>
   11770:	movs	r4, #0
   11772:	mov	r7, r4

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   11774:	vldr	s12, [pc, #596]	; 119cc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x378>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11778:	add.w	r4, r5, r4, lsl #2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   1177c:	vldr	s11, [r1, #12]
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   11780:	add.w	r7, r6, r7, lsl #2

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   11784:	vldr	s15, [pc, #572]	; 119c4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x370>
  const float clock_f = NoteToFrequency(
      parameters.timbre * (128.0f - clock_lowest_note) + clock_lowest_note);
  const float q = 0.5f * SemitonesToRatio(parameters.morph * 120.0f);
   11788:	vmov.f32	s13, #96	; 0x3f000000  0.5
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   1178c:	vldr	s18, [r4]
   11790:	and.w	r9, r9, #1
   11794:	vfma.f32	s15, s11, s12
   11798:	vldr	s14, [r7]
   1179c:	vldr	s12, [pc, #540]	; 119bc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x368>
   117a0:	vmul.f32	s14, s14, s18
   117a4:	vmul.f32	s18, s14, s12
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   117a8:	vcvt.s32.f32	s14, s15
  }

  void Render(bool sync, float frequency, float* out, size_t size) {
    CONSTRAIN(frequency, 0.0f, 1.0f);
   117ac:	vcmpe.f32	s18, #0.0

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   117b0:	vcvt.f32.s32	s12, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   117b4:	vmov	r4, s14
   117b8:	add.w	r6, r6, r4, lsl #2
   117bc:	vmrs	APSR_nzcv, fpscr
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   117c0:	vsub.f32	s15, s15, s12
   117c4:	vldr	s4, [r6]
   117c8:	vcvt.s32.f32	s15, s15, #8
   117cc:	vmov	r4, s15
   117d0:	add.w	r5, r5, r4, lsl #2
   117d4:	vldr	s15, [r5]
   117d8:	vmul.f32	s15, s15, s4
   117dc:	vmul.f32	s4, s15, s13
   117e0:	bmi.w	11da6 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x752>
   117e4:	vmov.f32	s15, #112	; 0x3f800000  1.0
   117e8:	vcmpe.f32	s18, s15
   117ec:	vmrs	APSR_nzcv, fpscr
   117f0:	it	le
   117f2:	vmovle.f32	s15, s18
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   117f6:	vldr	s12, [r0, #28]
    increment_ = (new_value - *state) / static_cast<float>(size);
   117fa:	vmov	s14, ip
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);

    float next_sample = next_sample_;
   117fe:	vldr	s10, [r0, #24]
   11802:	vcvt.f32.u32	s7, s14
    float sample = sample_;
   11806:	vldr	s8, [r0, #20]
   1180a:	vsub.f32	s15, s15, s12
   1180e:	vdiv.f32	s17, s15, s7
    
    if (sync) {
   11812:	cmp.w	r9, #0
   11816:	beq.n	1181e <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1ca>
      phase_ = 1.0f;
   11818:	mov.w	r4, #1065353216	; 0x3f800000
   1181c:	str	r4, [r0, #16]
    }

    while (size--) {
   1181e:	add.w	r5, ip, #4294967295
   11822:	cmp.w	ip, #0
   11826:	beq.n	11918 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c4>
   11828:	ldr.w	r8, [pc, #428]	; 119d8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x384>
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   1182c:	vmov.f32	s16, #0	; 0x40000000  2.0
   11830:	vmov.f32	s0, #240	; 0xbf800000 -1.0
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   11834:	mov	r7, r3
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
   11836:	vmov.f32	s1, #80	; 0x3e800000  0.250
   1183a:	ldr.w	r4, [r8]
   1183e:	vmov.f32	s2, #16	; 0x40800000  4.0
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   11842:	mov	r6, r5
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   11844:	vmov.f32	s9, #112	; 0x3f800000  1.0
   11848:	ldr.w	sl, [pc, #400]	; 119dc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x388>
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   1184c:	vmov.f32	s20, #96	; 0x3f000000  0.5
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11850:	vldr	s3, [pc, #380]	; 119d0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37c>
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   11854:	vldr	s19, [pc, #360]	; 119c0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
   11858:	b.n	118ce <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x27a>
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   1185a:	vcmp.f32	s15, s9
   1185e:	vmrs	APSR_nzcv, fpscr
   11862:	it	gt
   11864:	vmovgt.f32	s15, s9
      
      phase_ += frequency;
   11868:	vldr	s14, [r0, #16]
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   1186c:	vmov.f32	s11, #224	; 0xbf000000 -0.5
      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
      
      phase_ += frequency;
   11870:	vadd.f32	s14, s12, s14
      
      if (phase_ >= 1.0f) {
   11874:	vcmpe.f32	s14, s9
   11878:	vmrs	APSR_nzcv, fpscr
   1187c:	blt.n	11906 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2b2>
        phase_ -= 1.0f;
   1187e:	vsub.f32	s14, s14, s9
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
   11882:	vsub.f32	s22, s13, s8
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
        sample = new_sample;
   11886:	vmov.f32	s8, s13
      
      phase_ += frequency;
      
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
   1188a:	vdiv.f32	s21, s14, s12
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
      
      phase_ += frequency;
      
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
   1188e:	vstr	s14, [r0, #16]
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   11892:	vmul.f32	s14, s21, s20
   11896:	vsub.f32	s23, s9, s21
   1189a:	vmul.f32	s14, s14, s21
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   1189e:	vmul.f32	s11, s23, s11
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   118a2:	vfma.f32	s10, s22, s14
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   118a6:	vmul.f32	s11, s11, s23
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   118aa:	vmov.f32	s14, s10
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   118ae:	vmov.f32	s10, s19
   118b2:	vfma.f32	s10, s22, s11
        sample = new_sample;
      }
      next_sample += sample;
      *out++ = this_sample + raw_amount * (raw_sample - this_sample);
   118b6:	vsub.f32	s13, s13, s14
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   118ba:	subs	r6, #1
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
        sample = new_sample;
      }
      next_sample += sample;
   118bc:	vadd.f32	s10, s10, s8
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   118c0:	cmp.w	r6, #4294967295
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
        sample = new_sample;
      }
      next_sample += sample;
      *out++ = this_sample + raw_amount * (raw_sample - this_sample);
   118c4:	vfma.f32	s14, s13, s15
   118c8:	vstmia	r7!, {s14}
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   118cc:	beq.n	11914 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2c0>
  }

  inline float Next() {
    value_ += increment_;
   118ce:	vadd.f32	s12, s12, s17
   118d2:	mul.w	lr, sl, r4
   118d6:	ldr	r4, [pc, #252]	; (119d4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x380>)
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   118d8:	vmov.f32	s13, s0
      float raw_amount = 4.0f * (frequency - 0.25f);
   118dc:	vsub.f32	s15, s12, s1
   118e0:	add	r4, lr
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   118e2:	vmov	s14, r4
      float raw_amount = 4.0f * (frequency - 0.25f);
   118e6:	vmul.f32	s15, s15, s2
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   118ea:	vcvt.f32.u32	s14, s14
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   118ee:	vcmpe.f32	s15, #0.0
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   118f2:	vmul.f32	s14, s14, s3
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   118f6:	vmrs	APSR_nzcv, fpscr
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   118fa:	vfma.f32	s13, s14, s16
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   118fe:	bpl.n	1185a <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x206>
   11900:	vldr	s15, [pc, #188]	; 119c0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
   11904:	b.n	11868 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x214>
      
      phase_ += frequency;
   11906:	vstr	s14, [r0, #16]
   1190a:	vmov.f32	s14, s10
      phase_ = 1.0f;
    }

    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
   1190e:	vldr	s10, [pc, #176]	; 119c0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
   11912:	b.n	118b6 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x262>
   11914:	str.w	r4, [r8]
  const bool sync = parameters.trigger & TRIGGER_RISING_EDGE;
  clocked_noise_[0].Render(sync, clock_f, aux, size);
  clocked_noise_[1].Render(sync, clock_f * f1 / f0, temp_buffer_, size);
   11918:	vmul.f32	s18, s6, s18
        sample = new_sample;
      }
      next_sample += sample;
      *out++ = this_sample + raw_amount * (raw_sample - this_sample);
    }
    next_sample_ = next_sample;
   1191c:	vstr	s10, [r0, #24]
    sample_ = sample;
   11920:	vstr	s8, [r0, #20]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   11924:	vstr	s12, [r0, #28]
   11928:	vdiv.f32	s15, s18, s5
   1192c:	ldr	r7, [r0, #124]	; 0x7c
    next_sample_ = 0.0f;
    frequency_ = 0.001f;
  }

  void Render(bool sync, float frequency, float* out, size_t size) {
    CONSTRAIN(frequency, 0.0f, 1.0f);
   1192e:	vcmpe.f32	s15, #0.0
   11932:	vmrs	APSR_nzcv, fpscr
   11936:	bmi.w	11da0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x74c>
   1193a:	vmov.f32	s14, #112	; 0x3f800000  1.0
   1193e:	vcmp.f32	s15, s14
   11942:	vmrs	APSR_nzcv, fpscr
   11946:	it	gt
   11948:	vmovgt.f32	s15, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   1194c:	vldr	s12, [r0, #44]	; 0x2c
    
    stmlib::ParameterInterpolator fm(&frequency_, frequency, size);

    float next_sample = next_sample_;
   11950:	vldr	s3, [r0, #40]	; 0x28
    increment_ = (new_value - *state) / static_cast<float>(size);
   11954:	vsub.f32	s15, s15, s12
    float sample = sample_;
   11958:	vldr	s2, [r0, #36]	; 0x24
   1195c:	vdiv.f32	s18, s15, s7
    
    if (sync) {
   11960:	cmp.w	r9, #0
   11964:	beq.n	1196c <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x318>
      phase_ = 1.0f;
   11966:	mov.w	r4, #1065353216	; 0x3f800000
   1196a:	str	r4, [r0, #32]
    }

    while (size--) {
   1196c:	cmp.w	ip, #0
   11970:	beq.w	11a9e <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x44a>
   11974:	ldr.w	r8, [pc, #96]	; 119d8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x384>
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11978:	vmov.f32	s17, #0	; 0x40000000  2.0
   1197c:	vmov.f32	s16, #240	; 0xbf800000 -1.0
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   11980:	mov	lr, r7
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
   11982:	vmov.f32	s0, #80	; 0x3e800000  0.250
   11986:	ldr.w	r4, [r8]
   1198a:	vmov.f32	s1, #16	; 0x40800000  4.0
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   1198e:	mov	r6, r5
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   11990:	vmov.f32	s10, #112	; 0x3f800000  1.0
   11994:	ldr.w	sl, [pc, #68]	; 119dc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x388>
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   11998:	vmov.f32	s20, #96	; 0x3f000000  0.5
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   1199c:	vldr	s8, [pc, #48]	; 119d0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x37c>
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   119a0:	vldr	s19, [pc, #28]	; 119c0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x36c>
   119a4:	b.n	11a54 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x400>
   119a6:	nop
   119a8:	.word	0xc3000000
   119ac:	.word	0x42fe0000
   119b0:	.word	0x42400000
   119b4:	.word	0x20000554
   119b8:	.word	0x20000958
   119bc:	.word	0x39962fc9
   119c0:	.word	0x00000000
   119c4:	.word	0x43000000
   119c8:	.word	0x43180000
   119cc:	.word	0x42f00000
   119d0:	.word	0x2f800000
   119d4:	.word	0x3c6ef35f
   119d8:	.word	0x20020470
   119dc:	.word	0x0019660d
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   119e0:	vcmp.f32	s15, s10
   119e4:	vmrs	APSR_nzcv, fpscr
   119e8:	it	gt
   119ea:	vmovgt.f32	s15, s10
      
      phase_ += frequency;
   119ee:	vldr	s14, [r0, #32]
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   119f2:	vmov.f32	s11, #224	; 0xbf000000 -0.5
      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
      
      phase_ += frequency;
   119f6:	vadd.f32	s14, s12, s14
      
      if (phase_ >= 1.0f) {
   119fa:	vcmpe.f32	s14, s10
   119fe:	vmrs	APSR_nzcv, fpscr
   11a02:	blt.n	11a8c <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x438>
        phase_ -= 1.0f;
   11a04:	vsub.f32	s14, s14, s10
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
   11a08:	vsub.f32	s21, s13, s2
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
        sample = new_sample;
   11a0c:	vmov.f32	s2, s13
      
      phase_ += frequency;
      
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
   11a10:	vdiv.f32	s9, s14, s12
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
      
      phase_ += frequency;
      
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
   11a14:	vstr	s14, [r0, #32]
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   11a18:	vmul.f32	s14, s9, s20
   11a1c:	vsub.f32	s22, s10, s9
   11a20:	vmul.f32	s14, s14, s9
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   11a24:	vmul.f32	s11, s22, s11
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   11a28:	vfma.f32	s3, s21, s14
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   11a2c:	vmul.f32	s11, s11, s22
      if (phase_ >= 1.0f) {
        phase_ -= 1.0f;
        float t = phase_ / frequency;
        float new_sample = raw_sample;
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
   11a30:	vmov.f32	s14, s3
        next_sample += discontinuity * stmlib::NextBlepSample(t);
   11a34:	vmov.f32	s3, s19
   11a38:	vfma.f32	s3, s21, s11
        sample = new_sample;
      }
      next_sample += sample;
      *out++ = this_sample + raw_amount * (raw_sample - this_sample);
   11a3c:	vsub.f32	s13, s13, s14
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   11a40:	subs	r6, #1
        float discontinuity = new_sample - sample;
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
        sample = new_sample;
      }
      next_sample += sample;
   11a42:	vadd.f32	s3, s3, s2
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   11a46:	cmp.w	r6, #4294967295
        this_sample += discontinuity * stmlib::ThisBlepSample(t);
        next_sample += discontinuity * stmlib::NextBlepSample(t);
        sample = new_sample;
      }
      next_sample += sample;
      *out++ = this_sample + raw_amount * (raw_sample - this_sample);
   11a4a:	vfma.f32	s14, s13, s15
   11a4e:	vstmia	lr!, {s14}
    
    if (sync) {
      phase_ = 1.0f;
    }

    while (size--) {
   11a52:	beq.n	11a9a <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x446>
  }

  inline float Next() {
    value_ += increment_;
   11a54:	vadd.f32	s12, s12, s18
   11a58:	mul.w	r9, sl, r4
   11a5c:	ldr	r4, [pc, #844]	; (11dac <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x758>)
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11a5e:	vmov.f32	s13, s16
      float raw_amount = 4.0f * (frequency - 0.25f);
   11a62:	vsub.f32	s15, s12, s0
   11a66:	add	r4, r9
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11a68:	vmov	s14, r4
      float raw_amount = 4.0f * (frequency - 0.25f);
   11a6c:	vmul.f32	s15, s15, s1
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11a70:	vcvt.f32.u32	s14, s14
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   11a74:	vcmpe.f32	s15, #0.0
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11a78:	vmul.f32	s14, s14, s8
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   11a7c:	vmrs	APSR_nzcv, fpscr
    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;

      const float frequency = fm.Next();
      const float raw_sample = stmlib::Random::GetFloat() * 2.0f - 1.0f;
   11a80:	vfma.f32	s13, s14, s17
      float raw_amount = 4.0f * (frequency - 0.25f);
      CONSTRAIN(raw_amount, 0.0f, 1.0f);
   11a84:	bpl.n	119e0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x38c>
   11a86:	vldr	s15, [pc, #808]	; 11db0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x75c>
   11a8a:	b.n	119ee <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x39a>
      
      phase_ += frequency;
   11a8c:	vstr	s14, [r0, #32]
   11a90:	vmov.f32	s14, s3
      phase_ = 1.0f;
    }

    while (size--) {
      float this_sample = next_sample;
      next_sample = 0.0f;
   11a94:	vldr	s3, [pc, #792]	; 11db0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x75c>
   11a98:	b.n	11a3c <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3e8>
   11a9a:	str.w	r4, [r8]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   11a9e:	vstr	s12, [r0, #44]	; 0x2c
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   11aa2:	vldr	s8, [r0, #120]	; 0x78
    increment_ = (new_value - *state) / static_cast<float>(size);
   11aa6:	vldr	s15, [r1, #16]
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   11aaa:	vldr	s11, [r0, #108]	; 0x6c
   11aae:	vldr	s10, [r0, #112]	; 0x70
    increment_ = (new_value - *state) / static_cast<float>(size);
   11ab2:	vsub.f32	s15, s15, s8
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   11ab6:	vldr	s9, [r0, #116]	; 0x74
    increment_ = (new_value - *state) / static_cast<float>(size);
   11aba:	vsub.f32	s5, s5, s11
   11abe:	vsub.f32	s6, s6, s10
        sample = new_sample;
      }
      next_sample += sample;
      *out++ = this_sample + raw_amount * (raw_sample - this_sample);
    }
    next_sample_ = next_sample;
   11ac2:	vstr	s3, [r0, #40]	; 0x28
   11ac6:	vsub.f32	s4, s4, s9
    sample_ = sample;
   11aca:	vstr	s2, [r0, #36]	; 0x24
   11ace:	vdiv.f32	s17, s15, s7
   11ad2:	vdiv.f32	s20, s5, s7
   11ad6:	vdiv.f32	s19, s6, s7
   11ada:	vdiv.f32	s18, s4, s7
  ParameterInterpolator mode_modulation(
      &previous_mode_, parameters.harmonics, size);
  
  const float* in_1 = aux;
  const float* in_2 = temp_buffer_;
  while (size--) {
   11ade:	cmp.w	ip, #0
   11ae2:	beq.w	11d1a <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x6c6>
    return sqrtf(x);
  }
#else
  inline float Sqrt(float x) {
    float result;
    __asm ("vsqrt.f32 %0, %1" : "=w" (result) : "w" (x) );
   11ae6:	vldr	s16, [pc, #716]	; 11db4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x760>
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11aea:	vldr	s0, [pc, #716]	; 11db8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x764>
   11aee:	vldr	s1, [pc, #716]	; 11dbc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x768>
   11af2:	vldr	s2, [pc, #716]	; 11dc0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x76c>
   11af6:	vmov.f32	s3, #96	; 0x3f000000  0.5
   11afa:	vldr	s4, [pc, #712]	; 11dc4 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x770>
   11afe:	vldr	s5, [pc, #712]	; 11dc8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x774>
   11b02:	vldr	s6, [pc, #712]	; 11dcc <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x778>
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
   11b06:	vldr	s7, [pc, #680]	; 11db0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x75c>
  }

  inline float Next() {
    value_ += increment_;
   11b0a:	vadd.f32	s11, s11, s20
      const float* in,
      float* out,
      size_t size,
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
   11b0e:	vldr	s22, [r0, #60]	; 0x3c
   11b12:	vadd.f32	s10, s10, s19
    float state_2 = state_2_;
   11b16:	vldr	s25, [r0, #64]	; 0x40
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11b1a:	vmov.f32	s13, s1
   11b1e:	subs	r5, #1
      const float a = 3.333314036e-01 * M_PI_POW_3;
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
   11b20:	vmul.f32	s21, s11, s11
   11b24:	vmul.f32	s12, s10, s10
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11b28:	vmov.f32	s15, s1
   11b2c:	vfma.f32	s13, s21, s0
   11b30:	vmov.f32	s23, s2
   11b34:	vfma.f32	s15, s12, s0
   11b38:	vadd.f32	s9, s9, s18
   11b3c:	vmov.f32	s24, s4
    const float f0 = f0_modulation.Next();
    const float f1 = f1_modulation.Next();
    const float q = q_modulation.Next();
    const float gain = 1.0f / Sqrt((0.5f + q) * 40.0f * f0);
   11b40:	vmov.f32	s14, #112	; 0x3f800000  1.0
   11b44:	vfma.f32	s23, s21, s13
   11b48:	vmov.f32	s13, s2
   11b4c:	vmov.f32	s30, s6
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   11b50:	vdiv.f32	s27, s14, s9
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11b54:	vfma.f32	s13, s12, s15
   11b58:	vadd.f32	s15, s9, s3
   11b5c:	vfma.f32	s24, s21, s23
   11b60:	vmov.f32	s23, s4
   11b64:	vmul.f32	s15, s15, s16
   11b68:	vadd.f32	s8, s8, s17
   11b6c:	vfma.f32	s23, s12, s13
   11b70:	vmul.f32	s15, s15, s11
   11b74:	vsqrt.f32	s15, s15
   11b78:	vdiv.f32	s13, s14, s15
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   11b7c:	vstr	s27, [r0, #72]	; 0x48
   11b80:	vstr	s27, [r0, #92]	; 0x5c
   11b84:	vstr	s27, [r0, #52]	; 0x34
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11b88:	vmov.f32	s15, s5
      size_t size,
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
   11b8c:	vmov.f32	s28, #0	; 0x40000000  2.0
   11b90:	vneg.f32	s29, s8
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11b94:	vfma.f32	s15, s21, s24
   11b98:	vmov.f32	s24, s5
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
    float lp_gain = std::max(1.0f - mode * 2.0f, 0.0f);
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
   11b9c:	vneg.f32	s26, s22
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11ba0:	vfma.f32	s24, s12, s23
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
   11ba4:	vsub.f32	s23, s8, s3
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11ba8:	vfma.f32	s30, s21, s15
   11bac:	vmov.f32	s21, s6
   11bb0:	vfma.f32	s21, s12, s24
      size_t size,
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
   11bb4:	vmov.f32	s24, s14
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11bb8:	vmul.f32	s15, s30, s11
      size_t size,
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
   11bbc:	vfma.f32	s24, s29, s28
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
   11bc0:	vmov.f32	s29, s14

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   11bc4:	vstr	s15, [r0, #68]	; 0x44
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11bc8:	vmov.f32	s12, s21

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   11bcc:	vstr	s15, [r0, #48]	; 0x30
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
   11bd0:	vabs.f32	s21, s23
      const float b = 1.333923995e-01 * M_PI_POW_5;
      const float c = 5.33740603e-02 * M_PI_POW_7;
      const float d = 2.900525e-03 * M_PI_POW_9;
      const float e = 9.5168091e-03 * M_PI_POW_11;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + f2 * (b + f2 * (c + f2 * (d + f2 * e)))));
   11bd4:	vmul.f32	s12, s12, s10
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
   11bd8:	vfms.f32	s29, s21, s28
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   11bdc:	vmov.f32	s28, s14

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   11be0:	vstr	s12, [r0, #88]	; 0x58
   11be4:	vcmp.f32	s24, #0.0
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
    float lp_gain = std::max(1.0f - mode * 2.0f, 0.0f);
   11be8:	vmov.f32	s23, s24
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   11bec:	vfma.f32	s28, s12, s27
   11bf0:	vmrs	APSR_nzcv, fpscr
      float mode) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
   11bf4:	vmov.f32	s21, s29
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   11bf8:	vmov.f32	s29, s14
   11bfc:	it	gt
   11bfe:	vmovgt.f32	s24, s7
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
	return __b;
   11c02:	it	mi
   11c04:	vmovmi.f32	s23, s7
  ParameterInterpolator mode_modulation(
      &previous_mode_, parameters.harmonics, size);
  
  const float* in_1 = aux;
  const float* in_2 = temp_buffer_;
  while (size--) {
   11c08:	adds	r1, r5, #1
   11c0a:	vfma.f32	s29, s15, s27
   11c0e:	vfma.f32	s28, s12, s12
   11c12:	vfma.f32	s29, s15, s15
   11c16:	vmov.f32	s12, s28
   11c1a:	vdiv.f32	s28, s14, s29
   11c1e:	vdiv.f32	s29, s14, s12
   11c22:	vstr	s28, [r0, #76]	; 0x4c
   11c26:	vstr	s28, [r0, #56]	; 0x38
   11c2a:	vstr	s29, [r0, #96]	; 0x60
    const float gain = 1.0f / Sqrt((0.5f + q) * 40.0f * f0);
    lp_hp_filter_.set_f_q<FREQUENCY_ACCURATE>(f0, q);
    bp_filter_[0].set_f_q<FREQUENCY_ACCURATE>(f0, q);
    bp_filter_[1].set_f_q<FREQUENCY_ACCURATE>(f1, q);
    
    float input_1 = *in_1++ * gain;
   11c2e:	vldr	s14, [r3]
    float input_2 = *in_2++ * gain;
   11c32:	vldmia	r7!, {s12}
    const float gain = 1.0f / Sqrt((0.5f + q) * 40.0f * f0);
    lp_hp_filter_.set_f_q<FREQUENCY_ACCURATE>(f0, q);
    bp_filter_[0].set_f_q<FREQUENCY_ACCURATE>(f0, q);
    bp_filter_[1].set_f_q<FREQUENCY_ACCURATE>(f1, q);
    
    float input_1 = *in_1++ * gain;
   11c36:	vmul.f32	s14, s13, s14
    float input_2 = *in_2++ * gain;
   11c3a:	vmul.f32	s13, s13, s12
    float state_2 = state_2_;
    float hp_gain = std::min(-mode * 2.0f + 1.0f, 0.0f);
    float bp_gain = 1.0f - 2.0f * fabsf(mode - 0.5f);
    float lp_gain = std::max(1.0f - mode * 2.0f, 0.0f);
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
   11c3e:	vmov.f32	s12, s14
   11c42:	vfma.f32	s12, s26, s27
   11c46:	vfma.f32	s12, s26, s15
   11c4a:	vsub.f32	s12, s12, s25
   11c4e:	vmul.f32	s12, s12, s28
      bp = g_ * hp + state_1;
   11c52:	vfma.f32	s22, s15, s12
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
   11c56:	vfma.f32	s25, s15, s22
      state_2 = g_ * bp + lp;
      *out = hp_gain * hp + bp_gain * bp + lp_gain * lp;
   11c5a:	vmul.f32	s21, s21, s22
      ++in;
      ++out;
    }
    state_1_ = state_1;
   11c5e:	vmov.f32	s26, s22
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
      *out = hp_gain * hp + bp_gain * bp + lp_gain * lp;
   11c62:	vfma.f32	s21, s24, s12
      ++in;
      ++out;
    }
    state_1_ = state_1;
   11c66:	vfma.f32	s26, s15, s12
    state_2_ = state_2;
   11c6a:	vmov.f32	s28, s25
   11c6e:	vfma.f32	s28, s15, s22
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
      *out = hp_gain * hp + bp_gain * bp + lp_gain * lp;
   11c72:	vmov.f32	s15, s21
   11c76:	vfma.f32	s15, s23, s25
   11c7a:	vstmia	r2!, {s15}
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   11c7e:	vldr	s21, [r0, #80]	; 0x50
   11c82:	vldr	s22, [r0, #72]	; 0x48
   11c86:	vldr	s12, [r0, #100]	; 0x64
   11c8a:	vfms.f32	s14, s22, s21
   11c8e:	vldr	s15, [r0, #92]	; 0x5c
   11c92:	vldr	s24, [r0, #68]	; 0x44
   11c96:	vfms.f32	s13, s15, s12
   11c9a:	vldr	s25, [r0, #88]	; 0x58
   11c9e:	vldr	s23, [r0, #84]	; 0x54
   11ca2:	vldr	s22, [r0, #104]	; 0x68
   11ca6:	vldr	s15, [r0, #76]	; 0x4c
   11caa:	vfms.f32	s14, s21, s24
   11cae:	vldr	s27, [r0, #96]	; 0x60
      *out = hp_gain * hp + bp_gain * bp + lp_gain * lp;
      ++in;
      ++out;
    }
    state_1_ = state_1;
    state_2_ = state_2;
   11cb2:	vstr	s28, [r0, #64]	; 0x40
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   11cb6:	vfms.f32	s13, s12, s25
      state_2 = g_ * bp + lp;
      *out = hp_gain * hp + bp_gain * bp + lp_gain * lp;
      ++in;
      ++out;
    }
    state_1_ = state_1;
   11cba:	vstr	s26, [r0, #60]	; 0x3c
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   11cbe:	vsub.f32	s14, s14, s23
   11cc2:	vsub.f32	s13, s13, s22
   11cc6:	vmul.f32	s15, s14, s15
   11cca:	vmul.f32	s14, s13, s27
    bp = g_ * hp + state_1_;
   11cce:	vfma.f32	s21, s24, s15
   11cd2:	vmov.f32	s13, s12
   11cd6:	vfma.f32	s13, s25, s14
    state_1_ = g_ * hp + bp;
   11cda:	vmov.f32	s12, s21
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   11cde:	vfma.f32	s23, s24, s21
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   11ce2:	vfma.f32	s12, s24, s15
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   11ce6:	vfma.f32	s22, s25, s13
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   11cea:	vmov.f32	s15, s13
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   11cee:	vfma.f32	s23, s24, s21
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   11cf2:	vfma.f32	s15, s25, s14
   11cf6:	vstr	s12, [r0, #80]	; 0x50
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   11cfa:	vfma.f32	s22, s25, s13
   11cfe:	vstr	s23, [r0, #84]	; 0x54
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   11d02:	vmov.f32	s14, s15
    lp_hp_filter_.ProcessMultimodeLPtoHP(
        &input_1, out++, 1, mode_modulation.Next());
    *aux++ = bp_filter_[0].Process<FILTER_MODE_BAND_PASS>(input_1) + \
        bp_filter_[1].Process<FILTER_MODE_BAND_PASS>(input_2);
   11d06:	vadd.f32	s15, s13, s21
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   11d0a:	vstr	s22, [r0, #104]	; 0x68
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   11d0e:	vstr	s14, [r0, #100]	; 0x64
   11d12:	vstmia	r3!, {s15}
  ParameterInterpolator mode_modulation(
      &previous_mode_, parameters.harmonics, size);
  
  const float* in_1 = aux;
  const float* in_2 = temp_buffer_;
  while (size--) {
   11d16:	bne.w	11b0a <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x4b6>
    lp_hp_filter_.ProcessMultimodeLPtoHP(
        &input_1, out++, 1, mode_modulation.Next());
    *aux++ = bp_filter_[0].Process<FILTER_MODE_BAND_PASS>(input_1) + \
        bp_filter_[1].Process<FILTER_MODE_BAND_PASS>(input_2);
  }
}
   11d1a:	vpop	{d8-d15}
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   11d1e:	vstr	s8, [r0, #120]	; 0x78
   11d22:	vstr	s9, [r0, #116]	; 0x74
   11d26:	vstr	s10, [r0, #112]	; 0x70
   11d2a:	vstr	s11, [r0, #108]	; 0x6c
   11d2e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11d32:	vadd.f32	s15, s15, s11
   11d36:	vcvt.s32.f32	s14, s15
   11d3a:	vmov	r7, s14
   11d3e:	vcvt.f32.s32	s14, s14
   11d42:	vsub.f32	s15, s15, s14
   11d46:	vmov.f32	s14, s15
   11d4a:	vcvt.s32.f32	s14, s14, #8
   11d4e:	vmov	r4, s14
   11d52:	b.n	11774 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x120>
   11d54:	vldr	s14, [pc, #120]	; 11dd0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x77c>
   11d58:	vadd.f32	s15, s15, s14
   11d5c:	vcvt.s32.f32	s14, s15
   11d60:	vmov	r7, s14
   11d64:	vcvt.f32.s32	s14, s14
   11d68:	vsub.f32	s15, s15, s14
   11d6c:	vmov.f32	s14, s15
   11d70:	vcvt.s32.f32	s14, s14, #8
   11d74:	vmov	r4, s14
   11d78:	b.n	116f8 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xa4>
   11d7a:	vldr	s13, [pc, #84]	; 11dd0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x77c>
   11d7e:	vadd.f32	s14, s14, s13
   11d82:	vcvt.s32.f32	s13, s14
   11d86:	vmov	r7, s13
   11d8a:	vcvt.f32.s32	s13, s13
   11d8e:	vsub.f32	s14, s14, s13
   11d92:	vmov.f32	s13, s14
   11d96:	vcvt.s32.f32	s13, s13, #8
   11d9a:	vmov	r4, s13
   11d9e:	b.n	11694 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x40>
    next_sample_ = 0.0f;
    frequency_ = 0.001f;
  }

  void Render(bool sync, float frequency, float* out, size_t size) {
    CONSTRAIN(frequency, 0.0f, 1.0f);
   11da0:	vldr	s15, [pc, #12]	; 11db0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x75c>
   11da4:	b.n	1194c <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2f8>
   11da6:	vldr	s15, [pc, #8]	; 11db0 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x75c>
   11daa:	b.n	117f6 <plaits::NoiseEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1a2>
   11dac:	.word	0x3c6ef35f
   11db0:	.word	0x00000000
   11db4:	.word	0x42200000
   11db8:	.word	0x452efe23
   11dbc:	.word	0x42acec90
   11dc0:	.word	0x4321348f
   11dc4:	.word	0x42234866
   11dc8:	.word	0x41255da8
   11dcc:	.word	0x40490fdb
   11dd0:	.word	0x43000000

00011dd4 <plaits::WavetableEngine::Init(stmlib::BufferAllocator*)>:

using namespace std;
using namespace stmlib;

void WavetableEngine::Init(BufferAllocator* allocator) {
  phase_ = 0.0f;
   11dd4:	movs	r3, #0
  z_pre_lp_ = 0.0f;

  previous_x_ = 0.0f;
  previous_y_ = 0.0f;
  previous_z_ = 0.0f;
  previous_f0_ = a0;
   11dd6:	ldr	r2, [pc, #28]	; (11df4 <plaits::WavetableEngine::Init(stmlib::BufferAllocator*)+0x20>)

using namespace std;
using namespace stmlib;

void WavetableEngine::Init(BufferAllocator* allocator) {
  phase_ = 0.0f;
   11dd8:	str	r3, [r0, #16]
  z_pre_lp_ = 0.0f;

  previous_x_ = 0.0f;
  previous_y_ = 0.0f;
  previous_z_ = 0.0f;
  previous_f0_ = a0;
   11dda:	str	r2, [r0, #56]	; 0x38
using namespace stmlib;

void WavetableEngine::Init(BufferAllocator* allocator) {
  phase_ = 0.0f;

  x_lp_ = 0.0f;
   11ddc:	str	r3, [r0, #32]
  y_lp_ = 0.0f;
   11dde:	str	r3, [r0, #36]	; 0x24
  z_lp_ = 0.0f;
   11de0:	str	r3, [r0, #40]	; 0x28
  
  x_pre_lp_ = 0.0f;
   11de2:	str	r3, [r0, #20]
  y_pre_lp_ = 0.0f;
   11de4:	str	r3, [r0, #24]
  z_pre_lp_ = 0.0f;
   11de6:	str	r3, [r0, #28]

  previous_x_ = 0.0f;
   11de8:	str	r3, [r0, #44]	; 0x2c
  previous_y_ = 0.0f;
   11dea:	str	r3, [r0, #48]	; 0x30
  previous_z_ = 0.0f;
   11dec:	str	r3, [r0, #52]	; 0x34
 public:
  Differentiator() { }
  ~Differentiator() { }

  void Init() {
    previous_ = 0.0f;
   11dee:	str	r3, [r0, #64]	; 0x40
    lp_ = 0.0f;
   11df0:	str	r3, [r0, #60]	; 0x3c
   11df2:	bx	lr
   11df4:	.word	0x3a962fc9

00011df8 <plaits::WavetableEngine::Reset()>:
  previous_f0_ = a0;

  diff_out_.Init();
}

void WavetableEngine::Reset() {
   11df8:	bx	lr
   11dfa:	nop

00011dfc <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)>:
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   11dfc:	vmov.f32	s13, #34	; 0x41100000  9.0
   11e00:	vldr	s15, [r1, #4]
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   11e04:	vldr	s14, [pc, #484]	; 11fec <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f0>
void WavetableEngine::Render(
    const EngineParameters& parameters,
    float* out,
    float* aux,
    size_t size,
    bool* already_enveloped) {
   11e08:	mov	ip, r0
#include "stmlib/utils/buffer_allocator.h"

namespace plaits {

inline float NoteToFrequency(float midi_note) {
  midi_note -= 9.0f;
   11e0a:	vsub.f32	s15, s15, s13
   11e0e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  CONSTRAIN(midi_note, -128.0f, 127.0f);
   11e12:	vcmpe.f32	s15, s14
   11e16:	vpush	{d8-d15}
   11e1a:	vmrs	APSR_nzcv, fpscr
   11e1e:	sub	sp, #108	; 0x6c
   11e20:	str	r2, [sp, #48]	; 0x30
   11e22:	str	r3, [sp, #52]	; 0x34
   11e24:	ldr	r2, [sp, #208]	; 0xd0
   11e26:	bmi.n	11e3e <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x42>
   11e28:	vldr	s14, [pc, #452]	; 11ff0 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f4>
   11e2c:	vcmpe.f32	s15, s14
   11e30:	vmrs	APSR_nzcv, fpscr
   11e34:	ble.w	1278a <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x98e>
   11e38:	movs	r3, #0
   11e3a:	movs	r4, #255	; 0xff
   11e3c:	b.n	11e42 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x46>
   11e3e:	movs	r3, #0
   11e40:	mov	r4, r3
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
  ONE_POLE(z_pre_lp_, parameters.harmonics * 6.9999f, 0.05f);
   11e42:	vldr	s14, [ip, #28]
  
  const float x = x_pre_lp_;
  const float y = y_pre_lp_;
  const float z = z_pre_lp_;
  
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
   11e46:	vmov.f32	s10, #8	; 0x40400000  3.0
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
  ONE_POLE(z_pre_lp_, parameters.harmonics * 6.9999f, 0.05f);
   11e4a:	vldr	s15, [r1, #16]
   11e4e:	vmov.f32	s8, s14
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11e52:	vldr	s12, [pc, #416]	; 11ff4 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1f8>
   11e56:	vldr	s11, [r1, #8]
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
   11e5a:	vldr	s13, [ip, #24]
  ONE_POLE(z_pre_lp_, parameters.harmonics * 6.9999f, 0.05f);
   11e5e:	vfnms.f32	s8, s15, s12
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11e62:	vldr	s15, [ip, #20]
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
   11e66:	vmov.f32	s6, s13
   11e6a:	vldr	s7, [r1, #12]
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11e6e:	vmov.f32	s9, s15

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   11e72:	ldr	r0, [pc, #388]	; (11ff8 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1fc>)
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11e74:	ldr	r1, [pc, #388]	; (11ffc <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x200>)
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
   11e76:	vfnms.f32	s6, s7, s12

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   11e7a:	add.w	r0, r0, r4, lsl #2
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11e7e:	vfnms.f32	s9, s11, s12
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   11e82:	add.w	r3, r1, r3, lsl #2
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
   11e86:	vmov.f32	s12, s6
  
  const float x = x_pre_lp_;
  const float y = y_pre_lp_;
  const float z = z_pre_lp_;
  
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
   11e8a:	vldr	s6, [pc, #392]	; 12014 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x218>
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11e8e:	vmov.f32	s11, s9
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
  ONE_POLE(z_pre_lp_, parameters.harmonics * 6.9999f, 0.05f);
   11e92:	vldr	s9, [pc, #364]	; 12000 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x204>
   11e96:	vfma.f32	s14, s8, s9
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11e9a:	vldr	s9, [pc, #360]	; 12004 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x208>
  return a0 * 0.25f * stmlib::SemitonesToRatio(midi_note);
   11e9e:	vldr	s8, [pc, #360]	; 12008 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x20c>
   11ea2:	vfma.f32	s15, s11, s9
   11ea6:	vldr	s11, [r0]
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
   11eaa:	vfma.f32	s13, s12, s9
   11eae:	vldr	s12, [r3]
   11eb2:	vmul.f32	s12, s11, s12
  
  const float x = x_pre_lp_;
  const float y = y_pre_lp_;
  const float z = z_pre_lp_;
  
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
   11eb6:	vsub.f32	s10, s14, s10
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
  ONE_POLE(z_pre_lp_, parameters.harmonics * 6.9999f, 0.05f);
   11eba:	vstr	s14, [ip, #28]
    float* aux,
    size_t size,
    bool* already_enveloped) {
  const float f0 = NoteToFrequency(parameters.note);
  
  ONE_POLE(x_pre_lp_, parameters.timbre * 6.9999f, 0.2f);
   11ebe:	vstr	s15, [ip, #20]
   11ec2:	vmul.f32	s12, s12, s8
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   11ec6:	vcmpe.f32	s10, s6
  ONE_POLE(y_pre_lp_, parameters.morph * 6.9999f, 0.2f);
   11eca:	vstr	s13, [ip, #24]
   11ece:	vmrs	APSR_nzcv, fpscr
   11ed2:	bmi.w	127b6 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9ba>
  
  const float x = x_pre_lp_;
  const float y = y_pre_lp_;
  const float z = z_pre_lp_;
  
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
   11ed6:	vmov.f32	s11, #112	; 0x3f800000  1.0
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   11eda:	vcmpe.f32	s10, s11
   11ede:	vmrs	APSR_nzcv, fpscr
   11ee2:	ble.w	127b2 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x9b6>
   11ee6:	vmov.f32	s10, s11
   11eea:	vmov.f32	s6, s11
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
   11eee:	vadd.f32	s11, s12, s12
   11ef2:	vldr	s9, [pc, #280]	; 1200c <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x210>
   11ef6:	vmul.f32	s11, s11, s10
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   11efa:	vcmpe.f32	s11, s9
   11efe:	vmrs	APSR_nzcv, fpscr
   11f02:	bmi.n	11f6e <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x172>
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   11f04:	vldr	s10, [pc, #264]	; 12010 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x214>
   11f08:	vcmpe.f32	s11, s10
   11f0c:	vmrs	APSR_nzcv, fpscr
   11f10:	it	gt
   11f12:	vmovgt.f32	s11, s10
   11f16:	vstr	s11, [sp, #84]	; 0x54
  
  MAKE_INTEGRAL_FRACTIONAL(x);
   11f1a:	vcvt.s32.f32	s10, s15
void WavetableEngine::Reset() {
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
   11f1e:	vmov.f32	s8, #96	; 0x3f000000  0.5
  x *= amount;
   11f22:	vmov.f32	s11, #48	; 0x41800000  16.0
  
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
   11f26:	vcvt.f32.s32	s4, s10
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
  CONSTRAIN(x, -0.5f, 0.5f);
   11f2a:	vmov.f32	s9, #224	; 0xbf000000 -0.5
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
   11f2e:	vcvt.s32.f32	s5, s13
  
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
   11f32:	vsub.f32	s15, s15, s4
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
   11f36:	vcvt.s32.f32	s7, s14
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
   11f3a:	vcvt.f32.s32	s5, s5
void WavetableEngine::Reset() {
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
   11f3e:	vsub.f32	s10, s15, s8
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
   11f42:	vcvt.f32.s32	s7, s7
  const float quantization = min(max(z - 3.0f, 0.0f), 1.0f);
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
   11f46:	vsub.f32	s13, s13, s5
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
   11f4a:	vmul.f32	s11, s10, s11
  const float lp_coefficient = min(
      max(2.0f * f0 * (4.0f - 3.0f * quantization), 0.01f), 0.1f);
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
   11f4e:	vsub.f32	s14, s14, s7
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
  CONSTRAIN(x, -0.5f, 0.5f);
   11f52:	vcmpe.f32	s11, s9
   11f56:	vmrs	APSR_nzcv, fpscr
   11f5a:	bmi.n	11f74 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x178>
   11f5c:	vcmpe.f32	s11, s8
   11f60:	vmrs	APSR_nzcv, fpscr
   11f64:	ble.w	12782 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x986>
   11f68:	vmov.f32	s8, #112	; 0x3f800000  1.0
   11f6c:	b.n	11f78 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x17c>
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   11f6e:	vstr	s9, [sp, #84]	; 0x54
   11f72:	b.n	11f1a <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x11e>
   11f74:	vldr	s8, [pc, #156]	; 12014 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x218>
void WavetableEngine::Reset() {
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
   11f78:	vmov.f32	s9, #96	; 0x3f000000  0.5
  x *= amount;
   11f7c:	vmov.f32	s11, #48	; 0x41800000  16.0
  CONSTRAIN(x, -0.5f, 0.5f);
   11f80:	vmov.f32	s3, #224	; 0xbf000000 -0.5
void WavetableEngine::Reset() {
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
   11f84:	vsub.f32	s10, s13, s9
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
  
  x_fractional += quantization * (Clamp(x_fractional, 16.0f) - x_fractional);
   11f88:	vsub.f32	s8, s8, s15
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
   11f8c:	vmul.f32	s11, s10, s11
  
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
  
  x_fractional += quantization * (Clamp(x_fractional, 16.0f) - x_fractional);
   11f90:	vfma.f32	s15, s8, s6
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
  CONSTRAIN(x, -0.5f, 0.5f);
   11f94:	vcmpe.f32	s11, s3
   11f98:	vmrs	APSR_nzcv, fpscr
   11f9c:	bmi.n	11fb0 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b4>
   11f9e:	vcmpe.f32	s11, s9
   11fa2:	vmrs	APSR_nzcv, fpscr
   11fa6:	ble.w	1277c <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x980>
   11faa:	vmov.f32	s9, #112	; 0x3f800000  1.0
   11fae:	b.n	11fb4 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b8>
   11fb0:	vldr	s9, [pc, #96]	; 12014 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x218>
void WavetableEngine::Reset() {
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
   11fb4:	vmov.f32	s8, #96	; 0x3f000000  0.5
  x *= amount;
   11fb8:	vmov.f32	s11, #48	; 0x41800000  16.0
  CONSTRAIN(x, -0.5f, 0.5f);
   11fbc:	vmov.f32	s3, #224	; 0xbf000000 -0.5
void WavetableEngine::Reset() {
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
   11fc0:	vsub.f32	s10, s14, s8
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
  
  x_fractional += quantization * (Clamp(x_fractional, 16.0f) - x_fractional);
  y_fractional += quantization * (Clamp(y_fractional, 16.0f) - y_fractional);
   11fc4:	vsub.f32	s9, s9, s13
  
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
   11fc8:	vmul.f32	s11, s10, s11
  MAKE_INTEGRAL_FRACTIONAL(x);
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
  
  x_fractional += quantization * (Clamp(x_fractional, 16.0f) - x_fractional);
  y_fractional += quantization * (Clamp(y_fractional, 16.0f) - y_fractional);
   11fcc:	vfma.f32	s13, s9, s6
}

inline float Clamp(float x, float amount) {
  x = x - 0.5f;
  x *= amount;
  CONSTRAIN(x, -0.5f, 0.5f);
   11fd0:	vcmpe.f32	s11, s3
   11fd4:	vmrs	APSR_nzcv, fpscr
   11fd8:	bmi.n	12024 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x228>
   11fda:	vcmpe.f32	s11, s8
   11fde:	vmrs	APSR_nzcv, fpscr
   11fe2:	ble.w	12776 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x97a>
   11fe6:	vmov.f32	s11, #112	; 0x3f800000  1.0
   11fea:	b.n	12028 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22c>
   11fec:	.word	0xc3000000
   11ff0:	.word	0x42fe0000
   11ff4:	.word	0x40dfff2e
   11ff8:	.word	0x20000554
   11ffc:	.word	0x20000958
   12000:	.word	0x3d4ccccd
   12004:	.word	0x3e4ccccd
   12008:	.word	0x39962fc9
   1200c:	.word	0x3c23d70a
   12010:	.word	0x3dcccccd
   12014:	.word	0x00000000
   12018:	.word	0x48000000
   1201c:	.word	0x3f733333
   12020:	.word	0x43800000
   12024:	vldr	s11, [pc, #-20]	; 12014 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x218>
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   12028:	vldr	s10, [ip, #52]	; 0x34
  MAKE_INTEGRAL_FRACTIONAL(y);
  MAKE_INTEGRAL_FRACTIONAL(z);
  
  x_fractional += quantization * (Clamp(x_fractional, 16.0f) - x_fractional);
  y_fractional += quantization * (Clamp(y_fractional, 16.0f) - y_fractional);
  z_fractional += quantization * (Clamp(z_fractional, 16.0f) - z_fractional);
   1202c:	vsub.f32	s11, s11, s14
   12030:	vldr	s9, [ip, #48]	; 0x30
    increment_ = (new_value - *state) / static_cast<float>(size);
   12034:	vadd.f32	s13, s5, s13
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   12038:	vmov.f32	s8, s10
   1203c:	vstr	s10, [sp, #36]	; 0x24
    increment_ = (new_value - *state) / static_cast<float>(size);
   12040:	vadd.f32	s10, s4, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   12044:	vldr	s15, [ip, #44]	; 0x2c
    increment_ = (new_value - *state) / static_cast<float>(size);
   12048:	vfma.f32	s14, s11, s6
   1204c:	vmov	s11, r2
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   12050:	vmov.f32	s5, s9
   12054:	vstr	s9, [sp, #40]	; 0x28
    increment_ = (new_value - *state) / static_cast<float>(size);
   12058:	vcvt.f32.u32	s9, s11
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   1205c:	vstr	s15, [sp, #44]	; 0x2c
    increment_ = (new_value - *state) / static_cast<float>(size);
   12060:	vsub.f32	s11, s10, s15
    *state_ = value_;
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   12064:	vldr	s26, [ip, #56]	; 0x38
    increment_ = (new_value - *state) / static_cast<float>(size);
   12068:	vsub.f32	s13, s13, s5
  ParameterInterpolator z_modulation(
      &previous_z_, static_cast<float>(z_integral) + z_fractional, size);

  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
   1206c:	subs	r3, r2, #1
   1206e:	vsub.f32	s12, s12, s26
   12072:	vdiv.f32	s15, s11, s9
   12076:	str	r3, [sp, #32]
   12078:	vstr	s15, [sp, #68]	; 0x44
   1207c:	vadd.f32	s15, s14, s7
   12080:	vdiv.f32	s14, s13, s9
   12084:	vsub.f32	s15, s15, s8
   12088:	vstr	s14, [sp, #72]	; 0x48
   1208c:	vdiv.f32	s14, s12, s9
   12090:	vstr	s14, [sp, #80]	; 0x50
   12094:	vdiv.f32	s14, s15, s9
   12098:	vstr	s14, [sp, #76]	; 0x4c
   1209c:	cmp	r2, #0
   1209e:	beq.w	12750 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x954>
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   120a2:	vmov.f32	s27, #96	; 0x3f000000  0.5
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
      mix = diff_out_.Process(cutoff, mix) * gain;
      *out++ = mix;
      *aux++ = static_cast<float>(static_cast<int>(mix * 32.0f)) / 32.0f;
   120a6:	mov	r8, ip
  }

  inline float Next() {
    value_ += increment_;
   120a8:	vldr	s15, [sp, #80]	; 0x50
   120ac:	vldr	s14, [sp, #68]	; 0x44
   120b0:	vadd.f32	s26, s26, s15
   120b4:	vldr	s15, [sp, #44]	; 0x2c
   120b8:	vldr	s11, [sp, #36]	; 0x24
   120bc:	vadd.f32	s15, s15, s14
   120c0:	vldr	s14, [sp, #72]	; 0x48
   120c4:	vldr	s10, [sp, #76]	; 0x4c
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
   120c8:	vldr	s7, [r8, #32]
   120cc:	vmov.f32	s12, s15
   120d0:	vstr	s15, [sp, #44]	; 0x2c
   120d4:	vldr	s15, [sp, #40]	; 0x28
   120d8:	vadd.f32	s11, s11, s10
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
   120dc:	vldr	s18, [r8, #36]	; 0x24
   120e0:	vadd.f32	s15, s15, s14
    ONE_POLE(z_lp_, z_modulation.Next(), lp_coefficient);
   120e4:	vldr	s14, [r8, #40]	; 0x28
   120e8:	vmov.f32	s8, s11
   120ec:	vstr	s11, [sp, #36]	; 0x24
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
   120f0:	vsub.f32	s10, s12, s7
   120f4:	vmov.f32	s9, s15
   120f8:	vstr	s15, [sp, #40]	; 0x28
  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
   120fc:	vldr	s15, [pc, #-232]	; 12018 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x21c>
   12100:	vmov.f32	s12, #112	; 0x3f800000  1.0
   12104:	vmul.f32	s13, s26, s15

    MAKE_INTEGRAL_FRACTIONAL(x);
    MAKE_INTEGRAL_FRACTIONAL(y);
    MAKE_INTEGRAL_FRACTIONAL(z);

    phase_ += f0;
   12108:	vldr	s15, [r8, #16]
   1210c:	vadd.f32	s15, s26, s15
  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
   12110:	vdiv.f32	s11, s12, s13
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
    ONE_POLE(z_lp_, z_modulation.Next(), lp_coefficient);
   12114:	vsub.f32	s13, s8, s14
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
   12118:	vsub.f32	s12, s9, s18
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
   1211c:	vldr	s9, [sp, #84]	; 0x54
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
    ONE_POLE(z_lp_, z_modulation.Next(), lp_coefficient);
   12120:	vfma.f32	s14, s13, s9
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
   12124:	vldr	s13, [pc, #-264]	; 12020 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x224>
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
   12128:	vfma.f32	s7, s10, s9
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
   1212c:	vmul.f32	s28, s26, s13
  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
   12130:	vldr	s13, [pc, #-280]	; 1201c <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x220>
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
   12134:	vfma.f32	s18, s12, s9
  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
   12138:	vsub.f32	s12, s13, s26
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
    MAKE_INTEGRAL_FRACTIONAL(y);
    MAKE_INTEGRAL_FRACTIONAL(z);
   1213c:	vcvt.s32.f32	s10, s14
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
    ONE_POLE(z_lp_, z_modulation.Next(), lp_coefficient);
   12140:	vstr	s14, [r8, #40]	; 0x28
    
    const float x = x_lp_;
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
   12144:	vcvt.s32.f32	s13, s7
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
   12148:	vstr	s7, [r8, #32]
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
    MAKE_INTEGRAL_FRACTIONAL(y);
    MAKE_INTEGRAL_FRACTIONAL(z);
   1214c:	vmov	r7, s10
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
   12150:	vmov.f32	s10, #112	; 0x3f800000  1.0
    
    const float x = x_lp_;
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
   12154:	vmov	sl, s13
    MAKE_INTEGRAL_FRACTIONAL(y);
   12158:	vcvt.s32.f32	s13, s18
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
    const float cutoff = min(table_size_f * f0, 1.0f);
    
    ONE_POLE(x_lp_, x_modulation.Next(), lp_coefficient);
    ONE_POLE(y_lp_, y_modulation.Next(), lp_coefficient);
   1215c:	vstr	s18, [r8, #36]	; 0x24
   12160:	vcmp.f32	s28, s10
    
    const float x = x_lp_;
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
   12164:	vmov	s10, sl
    MAKE_INTEGRAL_FRACTIONAL(y);
   12168:	vcvt.f32.s32	s9, s13
    
    const float x = x_lp_;
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
   1216c:	vcvt.f32.s32	s8, s10
    MAKE_INTEGRAL_FRACTIONAL(y);
    MAKE_INTEGRAL_FRACTIONAL(z);
   12170:	vmov	s10, r7
   12174:	vmrs	APSR_nzcv, fpscr
   12178:	vcvt.f32.s32	s10, s10
    
    const float x = x_lp_;
    const float y = y_lp_;
    const float z = z_lp_;

    MAKE_INTEGRAL_FRACTIONAL(x);
   1217c:	vsub.f32	s7, s7, s8
    MAKE_INTEGRAL_FRACTIONAL(y);
   12180:	vsub.f32	s18, s18, s9
    MAKE_INTEGRAL_FRACTIONAL(z);
   12184:	vsub.f32	s14, s14, s10
   12188:	vstr	s14, [sp, #60]	; 0x3c
   1218c:	vmov.f32	s14, #112	; 0x3f800000  1.0
   12190:	it	gt
   12192:	vmovgt.f32	s28, s14
  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
    const float f0 = f0_modulation.Next();
    
    const float gain = (1.0f / (f0 * 131072.0f)) * (0.95f - f0);
   12196:	vmul.f32	s14, s11, s12
   1219a:	vstr	s14, [sp, #56]	; 0x38
    MAKE_INTEGRAL_FRACTIONAL(x);
    MAKE_INTEGRAL_FRACTIONAL(y);
    MAKE_INTEGRAL_FRACTIONAL(z);

    phase_ += f0;
    if (phase_ >= 1.0f) {
   1219e:	vmov.f32	s14, #112	; 0x3f800000  1.0
   121a2:	vcmpe.f32	s15, s14
   121a6:	vmrs	APSR_nzcv, fpscr
   121aa:	blt.n	121b4 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x3b8>
      phase_ -= 1.0f;
   121ac:	vmov.f32	s14, #112	; 0x3f800000  1.0
   121b0:	vsub.f32	s15, s15, s14
    int y,
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
   121b4:	vmov	r3, s13
      int x0 = x_integral;
      int x1 = x_integral + 1;
      int y0 = y_integral;
      int y1 = y_integral + 1;
      int z0 = z_integral;
      int z1 = z_integral + 1;
   121b8:	adds	r2, r7, #1
      
      if (z0 >= 4) {
   121ba:	cmp	r7, #3
    const float p = phase_ * table_size_f;
    MAKE_INTEGRAL_FRACTIONAL(p);
    
    {
      int x0 = x_integral;
      int x1 = x_integral + 1;
   121bc:	add.w	lr, sl, #1
    int y,
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
   121c0:	mov.w	r0, r3, lsl #3
  ParameterInterpolator z_modulation(
      &previous_z_, static_cast<float>(z_integral) + z_fractional, size);

  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
   121c4:	ldr	r3, [sp, #32]
      int y1 = y_integral + 1;
      int z0 = z_integral;
      int z1 = z_integral + 1;
      
      if (z0 >= 4) {
        z0 = 7 - z0;
   121c6:	it	gt
   121c8:	rsbgt	r7, r7, #7
      }
      if (z1 >= 4) {
   121cc:	cmp	r2, #3
  ParameterInterpolator z_modulation(
      &previous_z_, static_cast<float>(z_integral) + z_fractional, size);

  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
   121ce:	add.w	r3, r3, #4294967295
    phase_ += f0;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    const float p = phase_ * table_size_f;
   121d2:	vldr	s14, [pc, #-436]	; 12020 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x224>
      
      if (z0 >= 4) {
        z0 = 7 - z0;
      }
      if (z1 >= 4) {
        z1 = 7 - z1;
   121d6:	it	gt
   121d8:	rsbgt	r2, r2, #7
      }
      
      int r0 = z0 == 3 ? 101 : 1;
   121dc:	cmp	r7, #3
  ParameterInterpolator z_modulation(
      &previous_z_, static_cast<float>(z_integral) + z_fractional, size);

  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
   121de:	str	r3, [sp, #32]
    int y,
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
   121e0:	add.w	r3, r0, #8
   121e4:	mov.w	ip, r2, lsl #6
    MAKE_INTEGRAL_FRACTIONAL(y);
    MAKE_INTEGRAL_FRACTIONAL(z);

    phase_ += f0;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
   121e8:	vstr	s15, [r8, #16]
    int y,
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
   121ec:	add.w	r6, sl, r3
   121f0:	mov.w	r7, r7, lsl #6
   121f4:	add	r3, lr
    phase_ += f0;
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    const float p = phase_ * table_size_f;
   121f6:	vmul.f32	s15, s15, s14
      }
      if (z1 >= 4) {
        z1 = 7 - z1;
      }
      
      int r0 = z0 == 3 ? 101 : 1;
   121fa:	ite	ne
   121fc:	movne	r1, #1
   121fe:	moveq	r1, #101	; 0x65
    int y,
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
   12200:	add	sl, r0
      if (z1 >= 4) {
        z1 = 7 - z1;
      }
      
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;
   12202:	cmp	r2, #3
    int y,
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
   12204:	add	r0, lr
  return InterpolateWaveHermite(
   12206:	add.w	r2, ip, r6
   1220a:	add.w	r5, r6, r7
   1220e:	add.w	r6, r3, r7
   12212:	str	r2, [sp, #4]
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    const float p = phase_ * table_size_f;
    MAKE_INTEGRAL_FRACTIONAL(p);
   12214:	vcvt.s32.f32	s14, s15
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
  return InterpolateWaveHermite(
   12218:	add.w	r2, r0, r7
   1221c:	add.w	lr, ip, r0
   12220:	mul.w	r0, r1, r6
      if (z1 >= 4) {
        z1 = 7 - z1;
      }
      
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;
   12224:	ite	ne
   12226:	movne.w	fp, #1
   1222a:	moveq.w	fp, #101	; 0x65
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
  return InterpolateWaveHermite(
   1222e:	add.w	r4, sl, r7
   12232:	mul.w	r7, r1, r2
   12236:	ldr	r2, [sp, #4]
   12238:	str	r0, [sp, #12]
   1223a:	add	r3, ip
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    const float p = phase_ * table_size_f;
    MAKE_INTEGRAL_FRACTIONAL(p);
   1223c:	vstr	s14, [sp, #8]
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
  return InterpolateWaveHermite(
   12240:	add	sl, ip
   12242:	mul.w	r5, r1, r5

inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
   12246:	ldr	r0, [sp, #8]
   12248:	mul.w	r4, r1, r4
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    const float p = phase_ * table_size_f;
    MAKE_INTEGRAL_FRACTIONAL(p);
   1224c:	vcvt.f32.s32	s14, s14
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
  return InterpolateWaveHermite(
   12250:	mul.w	r1, fp, r2
   12254:	ldr	r2, [sp, #12]
   12256:	mov.w	r9, r0, lsl #1
   1225a:	asrs	r0, r2, #31
   1225c:	mul.w	r2, fp, r3
   12260:	ldr	r3, [sp, #12]
   12262:	mov.w	ip, r5, asr #31
   12266:	str	r2, [sp, #28]
  const float x0 = table[index_integral + 1];
   12268:	add.w	r6, r9, #2
   1226c:	mul.w	r2, fp, sl
    if (phase_ >= 1.0f) {
      phase_ -= 1.0f;
    }
    
    const float p = phase_ * table_size_f;
    MAKE_INTEGRAL_FRACTIONAL(p);
   12270:	vsub.f32	s15, s15, s14
    int z,
    int randomize,
    int phase_integral,
    float phase_fractional) {
  int wave = ((x + y * 8 + z * 64) * randomize) % 192;
  return InterpolateWaveHermite(
   12274:	str	r1, [sp, #24]
   12276:	str	r2, [sp, #16]
   12278:	ldr	r2, [pc, #940]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   1227a:	mul.w	r1, fp, lr
   1227e:	smull	lr, sl, r2, r5
   12282:	mov	lr, r3
   12284:	ldr	r3, [pc, #928]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   12286:	asrs	r2, r7, #31
   12288:	str	r1, [sp, #20]
   1228a:	rsb	ip, ip, sl, asr #5
   1228e:	smull	fp, lr, r3, lr
  const float x1 = table[index_integral + 2];
   12292:	add.w	r3, r9, #4
   12296:	asrs	r1, r4, #31
   12298:	str	r3, [sp, #4]
   1229a:	rsb	r0, r0, lr, asr #5
   1229e:	ldr	r3, [pc, #904]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   122a0:	add.w	ip, ip, ip, lsl #1
   122a4:	add.w	r0, r0, r0, lsl #1
   122a8:	smull	sl, lr, r3, r4
   122ac:	ldr	r3, [sp, #24]
   122ae:	str.w	ip, [sp, #64]	; 0x40
  const float x2 = table[index_integral + 3];
   122b2:	add.w	ip, r9, #6
   122b6:	rsb	lr, r1, lr, asr #5
   122ba:	ldr	r1, [pc, #876]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   122bc:	smull	r9, r1, r1, r7
   122c0:	add.w	lr, lr, lr, lsl #1
   122c4:	rsb	r1, r2, r1, asr #5
   122c8:	ldr	r2, [pc, #860]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   122ca:	sub.w	r4, r4, lr, lsl #6
   122ce:	smull	sl, r9, r2, r3
   122d2:	asrs	r2, r3, #31
   122d4:	ldr	r3, [sp, #28]
   122d6:	add.w	r1, r1, r1, lsl #1
   122da:	rsb	r2, r2, r9, asr #5
   122de:	mov	r9, r3
   122e0:	ldr	r3, [pc, #836]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   122e2:	sub.w	r1, r7, r1, lsl #6
   122e6:	ldr	r7, [sp, #16]
   122e8:	smull	r9, fp, r3, r9
   122ec:	ldr	r3, [sp, #16]
   122ee:	asrs	r7, r7, #31
   122f0:	mov	r9, r3
   122f2:	ldr	r3, [pc, #820]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   122f4:	add.w	r2, r2, r2, lsl #1
   122f8:	smull	r9, sl, r3, r9
   122fc:	ldr	r3, [sp, #20]
   122fe:	add.w	r4, r4, r4, lsl #6
   12302:	mov	r9, r3
   12304:	ldr	r3, [pc, #800]	; (12628 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x82c>)
   12306:	rsb	sl, r7, sl, asr #5
   1230a:	ldr	r7, [sp, #20]
   1230c:	smull	r3, r9, r3, r9
   12310:	ldr	r3, [sp, #64]	; 0x40
   12312:	asrs	r7, r7, #31
   12314:	sub.w	r5, r5, r3, lsl #6
   12318:	ldr	r3, [sp, #12]
   1231a:	rsb	r9, r7, r9, asr #5
   1231e:	ldr	r7, [pc, #780]	; (1262c <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x830>)
   12320:	sub.w	r0, r3, r0, lsl #6
   12324:	ldr	r3, [sp, #28]
   12326:	add.w	sl, sl, sl, lsl #1
   1232a:	mov.w	lr, r3, asr #31
   1232e:	ldr	r3, [sp, #24]
   12330:	add.w	r5, r5, r5, lsl #6
   12334:	rsb	fp, lr, fp, asr #5
   12338:	sub.w	r2, r3, r2, lsl #6
   1233c:	ldr	r3, [sp, #28]
   1233e:	add.w	fp, fp, fp, lsl #1
   12342:	add.w	r5, r7, r5, lsl #3
   12346:	sub.w	fp, r3, fp, lsl #6
   1234a:	ldr	r3, [sp, #16]
   1234c:	add.w	r9, r9, r9, lsl #1
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12350:	ldrsh.w	lr, [r5, r6]
   12354:	sub.w	sl, r3, sl, lsl #6
   12358:	ldr	r3, [sp, #20]
   1235a:	vmov	s12, lr
   1235e:	add.w	r0, r0, r0, lsl #6
   12362:	sub.w	r9, r3, r9, lsl #6
  const float x1 = table[index_integral + 2];
   12366:	ldr	r3, [sp, #4]
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12368:	vcvt.f32.s32	s12, s12
   1236c:	add.w	r1, r1, r1, lsl #6
  const float x1 = table[index_integral + 2];
   12370:	ldrsh.w	lr, [r5, r3]
   12374:	add.w	r2, r2, r2, lsl #6
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12378:	ldr	r3, [sp, #8]
   1237a:	add.w	fp, fp, fp, lsl #6
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   1237e:	vmov	s13, lr
   12382:	add.w	r4, r7, r4, lsl #3
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12386:	ldrsh.w	lr, [r5, r3, lsl #1]
   1238a:	add.w	r0, r7, r0, lsl #3
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   1238e:	vcvt.f32.s32	s13, s13
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12392:	ldrsh.w	r5, [r5, ip]
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12396:	vmov	s16, lr
   1239a:	add.w	r1, r7, r1, lsl #3
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1239e:	vmov	s2, r5
   123a2:	add.w	r2, r7, r2, lsl #3
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
   123a6:	vsub.f32	s4, s12, s13
   123aa:	add.w	fp, r7, fp, lsl #3
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   123ae:	vcvt.f32.s32	s16, s16
   123b2:	ldr	r7, [pc, #632]	; (1262c <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x830>)
   123b4:	add.w	sl, sl, sl, lsl #6
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   123b8:	vcvt.f32.s32	s2, s2
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   123bc:	vmov.f32	s1, s4
   123c0:	add.w	r9, r9, r9, lsl #6
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   123c4:	vsub.f32	s16, s13, s16
   123c8:	add.w	sl, r7, sl, lsl #3
   123cc:	add.w	r9, r7, r9, lsl #3
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   123d0:	ldrsh.w	lr, [r0, r6]
  const float x1 = table[index_integral + 2];
   123d4:	ldr	r7, [sp, #4]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   123d6:	vsub.f32	s2, s2, s12
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   123da:	vfma.f32	s1, s16, s27
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   123de:	vmov	s31, lr
  const float x1 = table[index_integral + 2];
   123e2:	ldrsh.w	lr, [r0, r7]
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   123e6:	vcvt.f32.s32	s31, s31
  const float x1 = table[index_integral + 2];
   123ea:	ldr	r7, [sp, #4]
   123ec:	vmov	s8, lr
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   123f0:	ldrsh.w	lr, [r0, r3, lsl #1]
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   123f4:	ldrsh.w	r0, [r0, ip]
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   123f8:	vmov	s5, lr
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   123fc:	vcvt.f32.s32	s8, s8
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12400:	vadd.f32	s4, s4, s1
   12404:	vmov	s3, r0
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12408:	vcvt.f32.s32	s5, s5
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   1240c:	ldrsh.w	lr, [r4, r6]
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12410:	vcvt.f32.s32	s3, s3
   12414:	vfma.f32	s4, s2, s27
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12418:	vmov	s14, lr
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   1241c:	vsub.f32	s5, s8, s5
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   12420:	ldrsh.w	lr, [r4, r7]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
   12424:	vsub.f32	s8, s31, s8
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   12428:	ldr	r7, [sp, #4]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1242a:	vsub.f32	s3, s3, s31
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   1242e:	vmov	s9, lr
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12432:	ldrsh.w	lr, [r4, r3, lsl #1]
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12436:	vcvt.f32.s32	s14, s14
  const float x1 = table[index_integral + 2];
   1243a:	vcvt.f32.s32	s9, s9
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   1243e:	vadd.f32	s1, s1, s4
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12442:	vmov	s25, lr
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12446:	ldrsh.w	lr, [r1, r6]
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   1244a:	vcvt.f32.s32	s25, s25
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   1244e:	vfnms.f32	s1, s15, s4
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12452:	vmov	s19, lr
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   12456:	vmov.f32	s4, s8
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   1245a:	ldrsh.w	lr, [r1, r7]
   1245e:	ldr	r7, [sp, #4]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12460:	vsub.f32	s25, s9, s25
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   12464:	vmov	s10, lr
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12468:	ldrsh.w	lr, [r1, r3, lsl #1]
  const float v = x0 - x1;
  const float w = c + v;
   1246c:	vfma.f32	s4, s5, s27
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12470:	vmov	s24, lr
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12474:	ldrsh.w	lr, [r2, r6]
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   12478:	vmul.f32	s1, s1, s15
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   1247c:	vmov	s6, lr
  const float x1 = table[index_integral + 2];
   12480:	ldrsh.w	lr, [r2, r7]
   12484:	ldr	r7, [sp, #4]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
   12486:	vsub.f32	s9, s14, s9
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   1248a:	vmov	s17, lr
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   1248e:	ldrsh.w	lr, [r2, r3, lsl #1]
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12492:	vadd.f32	s8, s8, s4
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12496:	vmov	s30, lr
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   1249a:	ldrsh.w	lr, [fp, r6]
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   1249e:	vfma.f32	s1, s16, s27
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   124a2:	vfma.f32	s8, s3, s27
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   124a6:	vmov	s21, lr
  const float x1 = table[index_integral + 2];
   124aa:	ldrsh.w	lr, [fp, r7]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   124ae:	vmov.f32	s16, s9
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   124b2:	ldr	r7, [sp, #4]
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   124b4:	vcvt.f32.s32	s19, s19
  const float x1 = table[index_integral + 2];
   124b8:	vmov	s0, lr
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   124bc:	ldrsh.w	lr, [fp, r3, lsl #1]
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   124c0:	ldrsh.w	r3, [r9, r7]
   124c4:	vcvt.f32.s32	s10, s10
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   124c8:	vmov	s29, lr
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   124cc:	ldrsh.w	lr, [sl, r6]

      float x0y1z0 = ReadWave(x0, y1, z0, r0, p_integral, p_fractional); 
      float x1y1z0 = ReadWave(x1, y1, z0, r0, p_integral, p_fractional);
      float xy1z0 = x0y1z0 + (x1y1z0 - x0y1z0) * x_fractional;

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;
   124d0:	vadd.f32	s4, s4, s8
  const float x1 = table[index_integral + 2];
   124d4:	vmov	s2, r3
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   124d8:	vfma.f32	s12, s15, s1
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   124dc:	vmov	s13, lr
   124e0:	ldrsh.w	lr, [r9, r6]
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   124e4:	vcvt.f32.s32	s24, s24
   124e8:	vfnms.f32	s4, s15, s8
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   124ec:	vmov	s20, lr
  const float x1 = table[index_integral + 2];
   124f0:	ldrsh.w	lr, [sl, r7]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   124f4:	ldr	r7, [sp, #8]
  const float v = x0 - x1;
  const float w = c + v;
   124f6:	vfma.f32	s16, s25, s27
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   124fa:	vsub.f32	s24, s10, s24
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   124fe:	vmov	s11, lr
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12502:	ldrsh.w	r6, [sl, r7, lsl #1]
  const float v = x0 - x1;
   12506:	vsub.f32	s10, s19, s10
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   1250a:	vcvt.f32.s32	s21, s21
   1250e:	vmov.f32	s8, s4
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12512:	vmov	s23, r6
   12516:	ldrsh.w	r6, [r9, r7, lsl #1]
  const float v = x0 - x1;
  const float w = c + v;
   1251a:	vmov.f32	s1, s10
  const float a = w + v + (x2 - x0) * 0.5f;
   1251e:	ldrsh.w	r0, [r4, ip]
   12522:	vadd.f32	s9, s9, s16
   12526:	vmul.f32	s8, s8, s15
   1252a:	ldrsh.w	r1, [r1, ip]
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   1252e:	vfma.f32	s1, s24, s27
  const float a = w + v + (x2 - x0) * 0.5f;
   12532:	ldrsh.w	r4, [fp, ip]
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   12536:	vcvt.f32.s32	s0, s0
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   1253a:	vmov	s22, r6
   1253e:	vfma.f32	s8, s5, s27
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12542:	ldrsh.w	r5, [sl, ip]
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12546:	vcvt.f32.s32	s29, s29
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1254a:	ldrsh.w	r2, [r2, ip]
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   1254e:	vcvt.f32.s32	s13, s13
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12552:	ldrsh.w	r6, [r9, ip]
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   12556:	vcvt.f32.s32	s11, s11
  ParameterInterpolator z_modulation(
      &previous_z_, static_cast<float>(z_integral) + z_fractional, size);

  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
   1255a:	ldr	r3, [sp, #32]
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1255c:	vadd.f32	s10, s10, s1
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   12560:	vsub.f32	s29, s0, s29
   12564:	adds	r3, #1

      float x0y1z0 = ReadWave(x0, y1, z0, r0, p_integral, p_fractional); 
      float x1y1z0 = ReadWave(x1, y1, z0, r0, p_integral, p_fractional);
      float xy1z0 = x0y1z0 + (x1y1z0 - x0y1z0) * x_fractional;

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;
   12566:	vfma.f32	s31, s15, s8
  const float v = x0 - x1;
   1256a:	vsub.f32	s0, s21, s0
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   1256e:	vcvt.f32.s32	s23, s23
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12572:	vcvt.f32.s32	s6, s6
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   12576:	vmov.f32	s4, s0
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   1257a:	vsub.f32	s23, s11, s23
   1257e:	vsub.f32	s31, s31, s12
  const float v = x0 - x1;
  const float w = c + v;
   12582:	vfma.f32	s4, s29, s27
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
   12586:	vsub.f32	s11, s13, s11
   1258a:	vfma.f32	s12, s7, s31
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1258e:	vmov	s31, r0
inline float InterpolateWaveHermite(
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
   12592:	vcvt.f32.s32	s20, s20
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12596:	vcvt.f32.s32	s31, s31
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   1259a:	vmov.f32	s5, s11
  const float a = w + v + (x2 - x0) * 0.5f;
   1259e:	vadd.f32	s0, s0, s4
   125a2:	vsub.f32	s31, s31, s14
    const int16_t* table,
    int32_t index_integral,
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
   125a6:	vcvt.f32.s32	s17, s17
   125aa:	vcvt.f32.s32	s2, s2
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   125ae:	vfma.f32	s9, s31, s27
   125b2:	vmov	s31, r1
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   125b6:	vcvt.f32.s32	s30, s30
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   125ba:	vcvt.f32.s32	s31, s31
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   125be:	vcvt.f32.s32	s22, s22
  const float v = x0 - x1;
  const float w = c + v;
   125c2:	vfma.f32	s5, s23, s27
  const float a = w + v + (x2 - x0) * 0.5f;
   125c6:	vsub.f32	s31, s31, s19
    float index_fractional) {
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
   125ca:	vsub.f32	s30, s17, s30
   125ce:	vsub.f32	s22, s2, s22
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   125d2:	vfma.f32	s10, s31, s27
  const float xm1 = table[index_integral];
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
   125d6:	vsub.f32	s17, s6, s17
   125da:	vsub.f32	s2, s20, s2
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   125de:	vadd.f32	s11, s11, s5
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   125e2:	vmov.f32	s3, s17
   125e6:	vmov.f32	s8, s2
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;

      float x0y0z0 = ReadWave(x0, y0, z0, r0, p_integral, p_fractional);
      float x1y0z0 = ReadWave(x1, y0, z0, r0, p_integral, p_fractional);
      float xy0z0 = x0y0z0 + (x1y0z0 - x0y0z0) * x_fractional;
   125ea:	vadd.f32	s1, s1, s10
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   125ee:	vadd.f32	s16, s16, s9
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   125f2:	vfma.f32	s3, s30, s27
   125f6:	vfnms.f32	s1, s15, s10
  const float a = w + v + (x2 - x0) * 0.5f;
   125fa:	vmov	s10, r4
  const float x0 = table[index_integral + 1];
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
   125fe:	vfma.f32	s8, s22, s27
  const float a = w + v + (x2 - x0) * 0.5f;
   12602:	vcvt.f32.s32	s10, s10
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   12606:	vfnms.f32	s16, s15, s9
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1260a:	vmov	s9, r2
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
      mix = diff_out_.Process(cutoff, mix) * gain;
      *out++ = mix;
   1260e:	ldr	r2, [sp, #48]	; 0x30
   12610:	vsub.f32	s10, s10, s21
   12614:	vcvt.f32.s32	s9, s9
   12618:	vadd.f32	s17, s17, s3
   1261c:	vfma.f32	s0, s10, s27
   12620:	vmov	s10, r5
   12624:	b.n	1263c <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x840>
   12626:	nop
   12628:	.word	0x2aaaaaab
   1262c:	.word	0x20004520
   12630:	.word	0x42000000
   12634:	.word	0x3d000000
   12638:	.word	0x43000000
   1263c:	vadd.f32	s2, s2, s8
   12640:	vcvt.f32.s32	s10, s10
   12644:	vsub.f32	s9, s9, s6
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   12648:	vmul.f32	s16, s16, s15
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1264c:	vsub.f32	s10, s10, s13
   12650:	vfma.f32	s17, s9, s27
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   12654:	vadd.f32	s4, s4, s0
   12658:	vfma.f32	s11, s10, s27
   1265c:	vmov	s10, r6
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;

      float x0y0z0 = ReadWave(x0, y0, z0, r0, p_integral, p_fractional);
      float x1y0z0 = ReadWave(x1, y0, z0, r0, p_integral, p_fractional);
      float xy0z0 = x0y0z0 + (x1y0z0 - x0y0z0) * x_fractional;
   12660:	vmul.f32	s1, s1, s15
   12664:	vcvt.f32.s32	s10, s10
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   12668:	vfnms.f32	s4, s15, s0
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   1266c:	vadd.f32	s3, s3, s17
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   12670:	vsub.f32	s10, s10, s20
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   12674:	vadd.f32	s5, s5, s11
   12678:	vfnms.f32	s3, s15, s17
  const float x1 = table[index_integral + 2];
  const float x2 = table[index_integral + 3];
  const float c = (x1 - xm1) * 0.5f;
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
   1267c:	vfma.f32	s2, s10, s27
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
   12680:	vldr	s10, [r8, #64]	; 0x40
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   12684:	vfnms.f32	s5, s15, s11
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
   12688:	vldr	s11, [r8, #60]	; 0x3c
   1268c:	vmul.f32	s4, s4, s15
  const float v = x0 - x1;
  const float w = c + v;
  const float a = w + v + (x2 - x0) * 0.5f;
  const float b_neg = w + a;
  const float f = index_fractional;
  return (((a * f) - b_neg) * f + c) * f + x0;
   12690:	vfma.f32	s16, s25, s27
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;

      float x0y0z0 = ReadWave(x0, y0, z0, r0, p_integral, p_fractional);
      float x1y0z0 = ReadWave(x1, y0, z0, r0, p_integral, p_fractional);
      float xy0z0 = x0y0z0 + (x1y0z0 - x0y0z0) * x_fractional;
   12694:	vfma.f32	s1, s24, s27
   12698:	vmul.f32	s3, s3, s15

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;

      float x0y0z1 = ReadWave(x0, y0, z1, r1, p_integral, p_fractional);
      float x1y0z1 = ReadWave(x1, y0, z1, r1, p_integral, p_fractional);
      float xy0z1 = x0y0z1 + (x1y0z1 - x0y0z1) * x_fractional;
   1269c:	vadd.f32	s8, s8, s2
   126a0:	vmul.f32	s5, s5, s15
   126a4:	vfma.f32	s3, s30, s27
   126a8:	vfnms.f32	s8, s15, s2
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   126ac:	vfma.f32	s4, s29, s27
   126b0:	vfma.f32	s5, s23, s27
   126b4:	vfma.f32	s14, s15, s16
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;

      float x0y0z0 = ReadWave(x0, y0, z0, r0, p_integral, p_fractional);
      float x1y0z0 = ReadWave(x1, y0, z0, r0, p_integral, p_fractional);
      float xy0z0 = x0y0z0 + (x1y0z0 - x0y0z0) * x_fractional;
   126b8:	vfma.f32	s19, s15, s1
   126bc:	vfma.f32	s6, s15, s3

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;

      float x0y0z1 = ReadWave(x0, y0, z1, r1, p_integral, p_fractional);
      float x1y0z1 = ReadWave(x1, y0, z1, r1, p_integral, p_fractional);
      float xy0z1 = x0y0z1 + (x1y0z1 - x0y0z1) * x_fractional;
   126c0:	vmul.f32	s8, s8, s15
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   126c4:	vfma.f32	s21, s15, s4
   126c8:	vfma.f32	s13, s15, s5

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;

      float x0y0z1 = ReadWave(x0, y0, z1, r1, p_integral, p_fractional);
      float x1y0z1 = ReadWave(x1, y0, z1, r1, p_integral, p_fractional);
      float xy0z1 = x0y0z1 + (x1y0z1 - x0y0z1) * x_fractional;
   126cc:	vfma.f32	s8, s22, s27
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;

      float x0y0z0 = ReadWave(x0, y0, z0, r0, p_integral, p_fractional);
      float x1y0z0 = ReadWave(x1, y0, z0, r0, p_integral, p_fractional);
      float xy0z0 = x0y0z0 + (x1y0z0 - x0y0z0) * x_fractional;
   126d0:	vsub.f32	s19, s19, s14
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   126d4:	vsub.f32	s21, s21, s6
      int r0 = z0 == 3 ? 101 : 1;
      int r1 = z1 == 3 ? 101 : 1;

      float x0y0z0 = ReadWave(x0, y0, z0, r0, p_integral, p_fractional);
      float x1y0z0 = ReadWave(x1, y0, z0, r0, p_integral, p_fractional);
      float xy0z0 = x0y0z0 + (x1y0z0 - x0y0z0) * x_fractional;
   126d8:	vfma.f32	s14, s7, s19

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;

      float x0y0z1 = ReadWave(x0, y0, z1, r1, p_integral, p_fractional);
      float x1y0z1 = ReadWave(x1, y0, z1, r1, p_integral, p_fractional);
      float xy0z1 = x0y0z1 + (x1y0z1 - x0y0z1) * x_fractional;
   126dc:	vfma.f32	s20, s15, s8
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   126e0:	vldr	s15, [sp, #60]	; 0x3c
   126e4:	vfma.f32	s6, s7, s21

      float x0y1z0 = ReadWave(x0, y1, z0, r0, p_integral, p_fractional); 
      float x1y1z0 = ReadWave(x1, y1, z0, r0, p_integral, p_fractional);
      float xy1z0 = x0y1z0 + (x1y1z0 - x0y1z0) * x_fractional;

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;
   126e8:	vsub.f32	s12, s12, s14

      float x0y0z1 = ReadWave(x0, y0, z1, r1, p_integral, p_fractional);
      float x1y0z1 = ReadWave(x1, y0, z1, r1, p_integral, p_fractional);
      float xy0z1 = x0y0z1 + (x1y0z1 - x0y0z1) * x_fractional;
   126ec:	vsub.f32	s20, s20, s13

      float x0y1z0 = ReadWave(x0, y1, z0, r0, p_integral, p_fractional); 
      float x1y1z0 = ReadWave(x1, y1, z0, r0, p_integral, p_fractional);
      float xy1z0 = x0y1z0 + (x1y1z0 - x0y1z0) * x_fractional;

      float xyz0 = xy0z0 + (xy1z0 - xy0z0) * y_fractional;
   126f0:	vfma.f32	s14, s18, s12

      float x0y0z1 = ReadWave(x0, y0, z1, r1, p_integral, p_fractional);
      float x1y0z1 = ReadWave(x1, y0, z1, r1, p_integral, p_fractional);
      float xy0z1 = x0y0z1 + (x1y0z1 - x0y0z1) * x_fractional;
   126f4:	vfma.f32	s13, s7, s20
      float x1y1z1 = ReadWave(x1, y1, z1, r1, p_integral, p_fractional);
      float xy1z1 = x0y1z1 + (x1y1z1 - x0y1z1) * x_fractional;
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
   126f8:	vsub.f32	s6, s6, s13
   126fc:	vfma.f32	s13, s18, s6
   12700:	vsub.f32	s13, s13, s14
   12704:	vfma.f32	s14, s15, s13
      mix = diff_out_.Process(cutoff, mix) * gain;
   12708:	vldr	s15, [sp, #56]	; 0x38
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
   1270c:	vsub.f32	s10, s14, s10
    previous_ = s;
   12710:	vstr	s14, [r8, #64]	; 0x40
    previous_ = 0.0f;
    lp_ = 0.0f;
  }
  
  float Process(float coefficient, float s) {
    ONE_POLE(lp_, s - previous_, coefficient);
   12714:	vsub.f32	s10, s10, s11
   12718:	vfma.f32	s11, s28, s10
   1271c:	vmul.f32	s14, s15, s11
      *out++ = mix;
      *aux++ = static_cast<float>(static_cast<int>(mix * 32.0f)) / 32.0f;
   12720:	vldr	s15, [pc, #-244]	; 12630 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x834>
   12724:	vstr	s11, [r8, #60]	; 0x3c
   12728:	vmul.f32	s15, s14, s15
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
      mix = diff_out_.Process(cutoff, mix) * gain;
      *out++ = mix;
   1272c:	vstmia	r2!, {s14}
      *aux++ = static_cast<float>(static_cast<int>(mix * 32.0f)) / 32.0f;
   12730:	vldr	s14, [pc, #-256]	; 12634 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x838>
      
      float xyz1 = xy0z1 + (xy1z1 - xy0z1) * y_fractional;

      float mix = xyz0 + (xyz1 - xyz0) * z_fractional;
      mix = diff_out_.Process(cutoff, mix) * gain;
      *out++ = mix;
   12734:	str	r2, [sp, #48]	; 0x30
      *aux++ = static_cast<float>(static_cast<int>(mix * 32.0f)) / 32.0f;
   12736:	vcvt.s32.f32	s15, s15
   1273a:	ldr	r2, [sp, #52]	; 0x34
   1273c:	vcvt.f32.s32	s15, s15
   12740:	vmul.f32	s15, s15, s14
   12744:	vstmia	r2!, {s15}
   12748:	str	r2, [sp, #52]	; 0x34
  ParameterInterpolator z_modulation(
      &previous_z_, static_cast<float>(z_integral) + z_fractional, size);

  ParameterInterpolator f0_modulation(&previous_f0_, f0, size);
  
  while (size--) {
   1274a:	bne.w	120a8 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x2ac>
   1274e:	mov	ip, r8
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   12750:	vldr	s15, [sp, #36]	; 0x24
   12754:	vstr	s26, [ip, #56]	; 0x38
   12758:	vstr	s15, [ip, #52]	; 0x34
   1275c:	vldr	s15, [sp, #40]	; 0x28
   12760:	vstr	s15, [ip, #48]	; 0x30
   12764:	vldr	s15, [sp, #44]	; 0x2c
   12768:	vstr	s15, [ip, #44]	; 0x2c
      mix = diff_out_.Process(cutoff, mix) * gain;
      *out++ = mix;
      *aux++ = static_cast<float>(static_cast<int>(mix * 32.0f)) / 32.0f;
    }
  }
}
   1276c:	add	sp, #108	; 0x6c
   1276e:	vpop	{d8-d15}
   12772:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12776:	vadd.f32	s11, s11, s8
   1277a:	b.n	12028 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x22c>
   1277c:	vadd.f32	s9, s11, s9
   12780:	b.n	11fb4 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x1b8>
   12782:	vadd.f32	s8, s11, s8
   12786:	b.w	11f78 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x17c>
   1278a:	vldr	s14, [pc, #-340]	; 12638 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x83c>
   1278e:	vadd.f32	s15, s15, s14
   12792:	vcvt.s32.f32	s14, s15
   12796:	vmov	r4, s14
   1279a:	vcvt.f32.s32	s14, s14
   1279e:	vsub.f32	s15, s15, s14
   127a2:	vmov.f32	s14, s15
   127a6:	vcvt.s32.f32	s14, s14, #8
   127aa:	vmov	r3, s14
   127ae:	b.w	11e42 <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0x46>
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   127b2:	vmov.f32	s6, s10
   127b6:	vmov.f32	s10, #8	; 0x40400000  3.0
   127ba:	vmov.f32	s11, #16	; 0x40800000  4.0
   127be:	vfms.f32	s11, s6, s10
   127c2:	vmov.f32	s10, s11
   127c6:	b.w	11eee <plaits::WavetableEngine::Render(plaits::EngineParameters const&, float*, float*, unsigned int, bool*)+0xf2>
   127ca:	nop

000127cc <plaits::StringVoice::Init(stmlib::BufferAllocator*)>:
namespace plaits {

using namespace std;
using namespace stmlib;

void StringVoice::Init(BufferAllocator* allocator) {
   127cc:	push	{r4, r5, r6, lr}
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   127ce:	movs	r3, #0
   127d0:	mov	r4, r0
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   127d2:	ldr	r2, [pc, #28]	; (127f0 <plaits::StringVoice::Init(stmlib::BufferAllocator*)+0x24>)
  excitation_filter_.Init();
  string_.Init(allocator);
   127d4:	adds	r0, #20

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   127d6:	ldr	r6, [pc, #28]	; (127f4 <plaits::StringVoice::Init(stmlib::BufferAllocator*)+0x28>)
    r_ = 1.0f / resonance;
   127d8:	ldr	r5, [pc, #28]	; (127f8 <plaits::StringVoice::Init(stmlib::BufferAllocator*)+0x2c>)
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   127da:	str	r3, [r4, #16]
   127dc:	str	r3, [r4, #12]

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   127de:	str	r6, [r4, #0]
    r_ = 1.0f / resonance;
   127e0:	str	r5, [r4, #4]
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   127e2:	str	r2, [r4, #8]
   127e4:	bl	12be0 <plaits::String::Init(stmlib::BufferAllocator*)>
  remaining_noise_samples_ = 0;
   127e8:	movs	r3, #0
   127ea:	str	r3, [r4, #92]	; 0x5c
   127ec:	pop	{r4, r5, r6, pc}
   127ee:	nop
   127f0:	.word	0x3f7faaca
   127f4:	.word	0x3d00ba22
   127f8:	.word	0x3c23d70a

000127fc <plaits::StringVoice::Reset()>:
}

void StringVoice::Reset() {
  string_.Reset();
   127fc:	adds	r0, #20
   127fe:	b.w	12b7c <plaits::String::Reset()>
   12802:	nop

00012804 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)>:
    float* out,
    float* aux,
    size_t size) {
  const float density = brightness * brightness;

  brightness += 0.25f * accent * (1.0f - brightness);
   12804:	vmov.f32	s14, #112	; 0x3f800000  1.0
   12808:	vmov.f32	s15, #80	; 0x3e800000  0.250
   1280c:	vmov.f32	s9, s3
   12810:	vsub.f32	s13, s14, s3
   12814:	vmul.f32	s15, s0, s15
  damping += 0.25f * accent * (1.0f - damping);
   12818:	vsub.f32	s14, s14, s4
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   1281c:	vmov.f32	s10, s1
  const float density = brightness * brightness;

  brightness += 0.25f * accent * (1.0f - brightness);
   12820:	vfma.f32	s9, s15, s13
  damping += 0.25f * accent * (1.0f - damping);
   12824:	vfma.f32	s4, s14, s15
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   12828:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1282c:	ldr	r6, [sp, #32]
   1282e:	mov	r5, r1
   12830:	ldr	r4, [sp, #36]	; 0x24
   12832:	mov	r1, r3
   12834:	ldr	r3, [sp, #40]	; 0x28

  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
  
  // Synthesize excitation signal.
  if (trigger || sustain) {
   12836:	cmp	r2, #0
   12838:	bne.w	12976 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x172>
   1283c:	cmp	r5, #0
   1283e:	bne.w	12976 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x172>
   12842:	ldr	r2, [r0, #92]	; 0x5c
  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
    for (size_t i = 0; i < size; ++i) {
      temp[i] = Dust(dust_f) * (8.0f - dust_f * 6.0f) * accent;
    }
  } else if (remaining_noise_samples_) {
   12844:	cmp	r2, #0
   12846:	beq.w	12aea <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2e6>
   1284a:	cmp	r3, r2
   1284c:	mov	r7, r3
   1284e:	it	cs
   12850:	movcs	r7, r2
    size_t noise_samples = min(remaining_noise_samples_, size);
    remaining_noise_samples_ -= noise_samples;
   12852:	subs	r2, r2, r7
    size_t tail = size - noise_samples;
   12854:	rsb	r9, r7, r3
    float* start = temp;
    while (noise_samples--) {
   12858:	subs	r5, r7, #1
    for (size_t i = 0; i < size; ++i) {
      temp[i] = Dust(dust_f) * (8.0f - dust_f * 6.0f) * accent;
    }
  } else if (remaining_noise_samples_) {
    size_t noise_samples = min(remaining_noise_samples_, size);
    remaining_noise_samples_ -= noise_samples;
   1285a:	str	r2, [r0, #92]	; 0x5c
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
   1285c:	cmp	r7, #0
   1285e:	beq.w	12b26 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x322>
   12862:	ldr.w	ip, [pc, #784]	; 12b74 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x370>
      *start++ = 2.0f * Random::GetFloat() - 1.0f;
   12866:	vmov.f32	s12, #0	; 0x40000000  2.0
   1286a:	vmov.f32	s13, #240	; 0xbf800000 -1.0
  } else if (remaining_noise_samples_) {
    size_t noise_samples = min(remaining_noise_samples_, size);
    remaining_noise_samples_ -= noise_samples;
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
   1286e:	mov	lr, r1
   12870:	ldr.w	r2, [ip]
   12874:	ldr.w	sl, [pc, #768]	; 12b78 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x374>
      *start++ = 2.0f * Random::GetFloat() - 1.0f;
   12878:	vldr	s14, [pc, #688]	; 12b2c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x328>
   1287c:	mul.w	r8, sl, r2
   12880:	ldr	r2, [pc, #684]	; (12b30 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x32c>)
   12882:	vmov.f32	s11, s13
  } else if (remaining_noise_samples_) {
    size_t noise_samples = min(remaining_noise_samples_, size);
    remaining_noise_samples_ -= noise_samples;
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
   12886:	subs	r5, #1
   12888:	add	r2, r8
   1288a:	cmp.w	r5, #4294967295
      *start++ = 2.0f * Random::GetFloat() - 1.0f;
   1288e:	vmov	s15, r2
   12892:	vcvt.f32.u32	s15, s15
   12896:	vmul.f32	s15, s15, s14
   1289a:	vfma.f32	s11, s15, s12
   1289e:	vstmia	lr!, {s11}
  } else if (remaining_noise_samples_) {
    size_t noise_samples = min(remaining_noise_samples_, size);
    remaining_noise_samples_ -= noise_samples;
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
   128a2:	bne.n	1287c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x78>
   128a4:	add.w	r5, r1, r7, lsl #2
   128a8:	str.w	r2, [ip]
      *start++ = 2.0f * Random::GetFloat() - 1.0f;
    }
    while (tail--) {
   128ac:	add.w	r2, r9, #4294967295
   128b0:	cmp.w	r9, #0
   128b4:	beq.n	128c4 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xc0>
      *start++ = 0.0f;
   128b6:	movs	r7, #0
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
      *start++ = 2.0f * Random::GetFloat() - 1.0f;
    }
    while (tail--) {
   128b8:	subs	r2, #1
      *start++ = 0.0f;
   128ba:	str.w	r7, [r5], #4
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
      *start++ = 2.0f * Random::GetFloat() - 1.0f;
    }
    while (tail--) {
   128be:	cmp.w	r2, #4294967295
   128c2:	bne.n	128b8 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xb4>
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
   128c4:	vldr	s12, [r0, #12]
    float state_2 = state_2_;
    
    while (size--) {
   128c8:	subs	r2, r3, #1
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
   128ca:	vldr	s14, [r0, #16]
    
    while (size--) {
   128ce:	cbz	r3, 12932 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x12e>
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   128d0:	mov	r5, r1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
   128d2:	vldr	s11, [r0, #4]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
   128d6:	subs	r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
   128d8:	vldr	s15, [r5]
   128dc:	vldr	s13, [r0]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
   128e0:	adds	r7, r2, #1
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
   128e2:	vfms.f32	s15, s11, s12
   128e6:	vldr	s11, [r0, #8]
   128ea:	vfms.f32	s15, s13, s12
   128ee:	vsub.f32	s15, s15, s14
   128f2:	vmul.f32	s15, s15, s11
      bp = g_ * hp + state_1;
   128f6:	vfma.f32	s12, s13, s15
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
   128fa:	vfma.f32	s14, s13, s12
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
   128fe:	vmov.f32	s11, s12
      state_1 = g_ * hp + bp;
   12902:	vfma.f32	s12, s13, s15
        value = bp * r_;
      } else if (mode == FILTER_MODE_HIGH_PASS) {
        value = hp;
      }
      
      *out = value;
   12906:	vstmia	r5!, {s14}
    while (size--) {
      hp = (*in - r_ * state_1 - g_ * state_1 - state_2) * h_;
      bp = g_ * hp + state_1;
      state_1 = g_ * hp + bp;
      lp = g_ * bp + state_2;
      state_2 = g_ * bp + lp;
   1290a:	vfma.f32	s14, s13, s11
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
   1290e:	bne.n	128d2 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xce>
   12910:	mov	r5, r1
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
    state_2_ = state_2;
   12912:	movs	r2, #0
      
      *out = value;
      ++out;
      ++in;
    }
    state_1_ = state_1;
   12914:	vstr	s12, [r0, #12]
    state_2_ = state_2;
   12918:	vstr	s14, [r0, #16]
    fill(&temp[0], &temp[size], 0.0f);
  }
  
  excitation_filter_.Process<FILTER_MODE_LOW_PASS>(temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
    aux[i] += temp[i];
   1291c:	vldmia	r5!, {s14}
  } else {
    fill(&temp[0], &temp[size], 0.0f);
  }
  
  excitation_filter_.Process<FILTER_MODE_LOW_PASS>(temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
   12920:	adds	r2, #1
    aux[i] += temp[i];
   12922:	vldr	s15, [r4]
  } else {
    fill(&temp[0], &temp[size], 0.0f);
  }
  
  excitation_filter_.Process<FILTER_MODE_LOW_PASS>(temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
   12926:	cmp	r3, r2
    aux[i] += temp[i];
   12928:	vadd.f32	s15, s15, s14
   1292c:	vstmia	r4!, {s15}
  } else {
    fill(&temp[0], &temp[size], 0.0f);
  }
  
  excitation_filter_.Process<FILTER_MODE_LOW_PASS>(temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
   12930:	bhi.n	1291c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x118>
    aux[i] += temp[i];
  }
  
  float non_linearity = structure < 0.24f
      ? (structure - 0.24f) * 4.166f
      : (structure > 0.26f ? (structure - 0.26f) * 1.35135f : 0.0f);
   12932:	vldr	s15, [pc, #512]	; 12b34 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x330>
   12936:	vcmpe.f32	s2, s15
   1293a:	vmrs	APSR_nzcv, fpscr
   1293e:	bmi.w	12b12 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x30e>
   12942:	vldr	s14, [pc, #500]	; 12b38 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x334>
   12946:	vcmpe.f32	s2, s14
   1294a:	vmrs	APSR_nzcv, fpscr
   1294e:	ble.w	12b20 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x31c>
   12952:	vsub.f32	s14, s2, s14
   12956:	vldr	s1, [pc, #484]	; 12b3c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x338>
   1295a:	vmul.f32	s1, s14, s1
  string_.Process(f0, non_linearity, brightness, damping, temp, out, size);
   1295e:	mov	r2, r6
   12960:	vmov.f32	s3, s4
   12964:	vmov.f32	s2, s9
   12968:	adds	r0, #20
   1296a:	vmov.f32	s0, s10
}
   1296e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  }
  
  float non_linearity = structure < 0.24f
      ? (structure - 0.24f) * 4.166f
      : (structure > 0.26f ? (structure - 0.26f) * 1.35135f : 0.0f);
  string_.Process(f0, non_linearity, brightness, damping, temp, out, size);
   12972:	b.w	13574 <plaits::String::Process(float, float, float, float, float const*, float*, unsigned int)>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   12976:	vmov.f32	s13, #0	; 0x40000000  2.0
   1297a:	vldr	s8, [pc, #452]	; 12b40 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x33c>
   1297e:	vmov.f32	s15, #224	; 0xbf000000 -0.5
   12982:	vldr	s14, [pc, #448]	; 12b44 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x340>
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   12986:	ldr	r7, [pc, #448]	; (12b48 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x344>)
  // Synthesize excitation signal.
  if (trigger || sustain) {
    const float range = 72.0f;
    const float f = 4.0f * f0;
    const float cutoff = min(
        f * SemitonesToRatio((brightness * (2.0f - brightness) - 0.5f) * range),
   12988:	vmov.f32	s12, #16	; 0x40800000  4.0

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   1298c:	vsub.f32	s13, s13, s9
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   12990:	ldr	r2, [pc, #440]	; (12b4c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x348>)
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   12992:	vldr	s11, [pc, #444]	; 12b50 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x34c>
   12996:	vmul.f32	s12, s10, s12

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   1299a:	vfma.f32	s15, s9, s13
   1299e:	vfma.f32	s14, s15, s8
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   129a2:	vcvt.s32.f32	s15, s14

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   129a6:	vcvt.f32.s32	s13, s15

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   129aa:	vmov	lr, s15
   129ae:	add.w	r7, r7, lr, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   129b2:	vsub.f32	s14, s14, s13
   129b6:	vldr	s15, [r7]
   129ba:	vcvt.s32.f32	s14, s14, #8
   129be:	vmov	r7, s14
   129c2:	add.w	r2, r2, r7, lsl #2
   129c6:	vldr	s13, [r2]
   129ca:	vmul.f32	s15, s13, s15
   129ce:	vmul.f32	s14, s15, s12
   129d2:	vcmpe.f32	s14, s11
   129d6:	vmrs	APSR_nzcv, fpscr
   129da:	ble.n	12a20 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x21c>
   129dc:	vldr	s8, [pc, #372]	; 12b54 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x350>
   129e0:	vldr	s15, [pc, #372]	; 12b58 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x354>
        0.499f);
    const float q = sustain ? 1.0f : 0.5f;
   129e4:	cbnz	r5, 12a3c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x238>
    remaining_noise_samples_ = static_cast<size_t>(1.0f / f0);
   129e6:	vmov.f32	s13, #112	; 0x3f800000  1.0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   129ea:	vstr	s15, [r0]
    r_ = 1.0f / resonance;
   129ee:	vmov.f32	s12, #0	; 0x40000000  2.0
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   129f2:	vmov.f32	s11, s13
   129f6:	vdiv.f32	s14, s13, s10
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   129fa:	vstr	s12, [r0, #4]
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   129fe:	vfma.f32	s11, s15, s12
   12a02:	vadd.f32	s15, s11, s8
   12a06:	vdiv.f32	s12, s13, s15
   12a0a:	vcvt.u32.f32	s15, s14
   12a0e:	vmov	r2, s15
   12a12:	vstr	s15, [r0, #92]	; 0x5c
   12a16:	vstr	s12, [r0, #8]
  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
    for (size_t i = 0; i < size; ++i) {
      temp[i] = Dust(dust_f) * (8.0f - dust_f * 6.0f) * accent;
    }
  } else if (remaining_noise_samples_) {
   12a1a:	cmp	r2, #0
   12a1c:	beq.n	12aea <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2e6>
   12a1e:	b.n	1284a <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x46>
   12a20:	vldr	s13, [pc, #312]	; 12b5c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x358>
   12a24:	vldr	s15, [pc, #312]	; 12b60 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x35c>
   12a28:	vmul.f32	s13, s14, s13
   12a2c:	vfma.f32	s15, s14, s13
   12a30:	vmul.f32	s15, s15, s14
   12a34:	vmul.f32	s8, s15, s15
    const float range = 72.0f;
    const float f = 4.0f * f0;
    const float cutoff = min(
        f * SemitonesToRatio((brightness * (2.0f - brightness) - 0.5f) * range),
        0.499f);
    const float q = sustain ? 1.0f : 0.5f;
   12a38:	cmp	r5, #0
   12a3a:	beq.n	129e6 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x1e2>
    remaining_noise_samples_ = static_cast<size_t>(1.0f / f0);
   12a3c:	vmov.f32	s14, #112	; 0x3f800000  1.0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   12a40:	vstr	s15, [r0]
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
  const float density = brightness * brightness;
   12a44:	vmul.f32	s3, s3, s3
    remaining_noise_samples_ = static_cast<size_t>(1.0f / f0);
    excitation_filter_.set_f_q<FREQUENCY_DIRTY>(cutoff, q);
  }

  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
   12a48:	vldr	s11, [pc, #280]	; 12b64 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x360>
   12a4c:	vldr	s13, [pc, #280]	; 12b68 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x364>
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12a50:	vadd.f32	s15, s15, s14
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   12a54:	vstr	s14, [r0, #4]
    const float f = 4.0f * f0;
    const float cutoff = min(
        f * SemitonesToRatio((brightness * (2.0f - brightness) - 0.5f) * range),
        0.499f);
    const float q = sustain ? 1.0f : 0.5f;
    remaining_noise_samples_ = static_cast<size_t>(1.0f / f0);
   12a58:	vdiv.f32	s12, s14, s10
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12a5c:	vadd.f32	s15, s15, s8
    excitation_filter_.set_f_q<FREQUENCY_DIRTY>(cutoff, q);
  }

  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
   12a60:	vmul.f32	s11, s3, s11
   12a64:	vdiv.f32	s8, s14, s15
   12a68:	vfma.f32	s13, s3, s11
    const float f = 4.0f * f0;
    const float cutoff = min(
        f * SemitonesToRatio((brightness * (2.0f - brightness) - 0.5f) * range),
        0.499f);
    const float q = sustain ? 1.0f : 0.5f;
    remaining_noise_samples_ = static_cast<size_t>(1.0f / f0);
   12a6c:	vcvt.u32.f32	s12, s12
   12a70:	vstr	s12, [r0, #92]	; 0x5c
   12a74:	vstr	s8, [r0, #8]
    excitation_filter_.set_f_q<FREQUENCY_DIRTY>(cutoff, q);
  }

  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
    for (size_t i = 0; i < size; ++i) {
   12a78:	cmp	r3, #0
   12a7a:	beq.w	12932 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x12e>
   12a7e:	vdiv.f32	s8, s14, s13
   12a82:	ldr.w	ip, [pc, #240]	; 12b74 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x370>
   12a86:	mov	r5, r1
   12a88:	add.w	r8, r1, r3, lsl #2
   12a8c:	ldr.w	r2, [ip]
   12a90:	ldr.w	lr, [pc, #228]	; 12b78 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x374>
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
   12a94:	vldr	s11, [pc, #148]	; 12b2c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x328>
   12a98:	vmov.f32	s15, #24	; 0x40c00000  6.0
   12a9c:	vmov.f32	s12, #32	; 0x41000000  8.0
   12aa0:	vfms.f32	s12, s13, s15
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
   12aa4:	mul.w	r7, lr, r2
   12aa8:	ldr	r2, [pc, #132]	; (12b30 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x32c>)
  float inv_frequency = 1.0f / frequency;
  float u = stmlib::Random::GetFloat();
  if (u < frequency) {
    return u * inv_frequency;
  } else {
    return 0.0f;
   12aaa:	vldr	s15, [pc, #192]	; 12b6c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x368>
   12aae:	add	r2, r7
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
   12ab0:	vmov	s14, r2
   12ab4:	vcvt.f32.u32	s14, s14
   12ab8:	vmul.f32	s14, s14, s11
namespace plaits {

inline float Dust(float frequency) {
  float inv_frequency = 1.0f / frequency;
  float u = stmlib::Random::GetFloat();
  if (u < frequency) {
   12abc:	vcmpe.f32	s13, s14
   12ac0:	vmrs	APSR_nzcv, fpscr
    return u * inv_frequency;
   12ac4:	it	gt
   12ac6:	vmulgt.f32	s15, s14, s8
      temp[i] = Dust(dust_f) * (8.0f - dust_f * 6.0f) * accent;
   12aca:	vmul.f32	s15, s15, s12
   12ace:	vmul.f32	s15, s15, s0
   12ad2:	vstmia	r5!, {s15}
    excitation_filter_.set_f_q<FREQUENCY_DIRTY>(cutoff, q);
  }

  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
    for (size_t i = 0; i < size; ++i) {
   12ad6:	cmp	r5, r8
   12ad8:	bne.n	12aa4 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2a0>
   12ada:	str.w	r2, [ip]
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
    
    while (size--) {
   12ade:	subs	r2, r3, #1
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
   12ae0:	vldr	s12, [r0, #12]
    float state_2 = state_2_;
   12ae4:	vldr	s14, [r0, #16]
   12ae8:	b.n	128d0 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xcc>
    }
    while (tail--) {
      *start++ = 0.0f;
    }
  } else {
    fill(&temp[0], &temp[size], 0.0f);
   12aea:	add.w	r5, r1, r3, lsl #2
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12aee:	cmp	r1, r5
   12af0:	beq.w	128c4 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xc0>
   12af4:	mov	r2, r1
	*__first = __tmp;
   12af6:	movs	r7, #0
   12af8:	str.w	r7, [r2], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12afc:	cmp	r5, r2
   12afe:	bne.n	12af8 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2f4>
  }
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
   12b00:	vldr	s12, [r0, #12]
    float state_2 = state_2_;
    
    while (size--) {
   12b04:	subs	r2, r3, #1
  
  template<FilterMode mode>
  inline void Process(const float* in, float* out, size_t size) {
    float hp, bp, lp;
    float state_1 = state_1_;
    float state_2 = state_2_;
   12b06:	vldr	s14, [r0, #16]
    
    while (size--) {
   12b0a:	cmp	r3, #0
   12b0c:	bne.w	128d0 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xcc>
   12b10:	b.n	12932 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x12e>
    aux[i] += temp[i];
  }
  
  float non_linearity = structure < 0.24f
      ? (structure - 0.24f) * 4.166f
      : (structure > 0.26f ? (structure - 0.26f) * 1.35135f : 0.0f);
   12b12:	vsub.f32	s15, s2, s15
   12b16:	vldr	s1, [pc, #88]	; 12b70 <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x36c>
   12b1a:	vmul.f32	s1, s15, s1
   12b1e:	b.n	1295e <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x15a>
   12b20:	vldr	s1, [pc, #72]	; 12b6c <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x368>
   12b24:	b.n	1295e <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x15a>
  } else if (remaining_noise_samples_) {
    size_t noise_samples = min(remaining_noise_samples_, size);
    remaining_noise_samples_ -= noise_samples;
    size_t tail = size - noise_samples;
    float* start = temp;
    while (noise_samples--) {
   12b26:	mov	r5, r1
   12b28:	b.n	128ac <plaits::StringVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xa8>
   12b2a:	nop
   12b2c:	.word	0x2f800000
   12b30:	.word	0x3c6ef35f
   12b34:	.word	0x3e75c28f
   12b38:	.word	0x3e851eb8
   12b3c:	.word	0x3facf909
   12b40:	.word	0x42900000
   12b44:	.word	0x43000000
   12b48:	.word	0x20000554
   12b4c:	.word	0x20000958
   12b50:	.word	0x3eff7cee
   12b54:	.word	0x4110abad
   12b58:	.word	0x40407251
   12b5c:	.word	0x413957d7
   12b60:	.word	0x40490fdb
   12b64:	.word	0x3f7ffcb9
   12b68:	.word	0x3851b717
   12b6c:	.word	0x00000000
   12b70:	.word	0x40854fdf
   12b74:	.word	0x20020470
   12b78:	.word	0x0019660d

00012b7c <plaits::String::Reset()>:
    line_ = buffer;
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
   12b7c:	ldr	r3, [r0, #4]
	*__first = __tmp;
   12b7e:	movs	r1, #0
   12b80:	add.w	r2, r3, #4096	; 0x1000
   12b84:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12b88:	cmp	r2, r3
   12b8a:	bne.n	12b84 <plaits::String::Reset()+0x8>
   12b8c:	ldr	r3, [r0, #12]
    write_ptr_ = 0;
   12b8e:	movs	r2, #0
  stretch_.Init(allocator->Allocate<float>(kDelayLineSize / 4));
  delay_ = 100.0f;
  Reset();
}

void String::Reset() {
   12b90:	push	{r4, r5, r6}
    line_ = buffer;
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
   12b92:	add.w	r1, r3, #1024	; 0x400
	*__first = __tmp;
   12b96:	movs	r4, #0
    write_ptr_ = 0;
   12b98:	str	r2, [r0, #0]
   12b9a:	str.w	r4, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12b9e:	cmp	r1, r3
	*__first = __tmp;
   12ba0:	mov.w	r2, #0
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12ba4:	bne.n	12b9a <plaits::String::Reset()+0x1e>
   12ba6:	movs	r6, #0

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   12ba8:	ldr	r5, [pc, #36]	; (12bd0 <plaits::String::Reset()+0x54>)
    r_ = 1.0f / resonance;
   12baa:	ldr	r4, [pc, #40]	; (12bd4 <plaits::String::Reset()+0x58>)
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12bac:	ldr	r1, [pc, #40]	; (12bd8 <plaits::String::Reset()+0x5c>)
  ~DCBlocker() { }
  
  void Init(float pole) {
    x_ = 0.0f;
    y_ = 0.0f;
    pole_ = pole;
   12bae:	ldr	r3, [pc, #44]	; (12bdc <plaits::String::Reset()+0x60>)
   12bb0:	str	r6, [r0, #8]

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   12bb2:	str	r5, [r0, #16]
    r_ = 1.0f / resonance;
   12bb4:	str	r4, [r0, #20]
    set_f_q<FREQUENCY_DIRTY>(0.01f, 100.0f);
    Reset();
  }
  
  void Reset() {
    state_1_ = state_2_ = 0.0f;
   12bb6:	str	r2, [r0, #32]
   12bb8:	str	r2, [r0, #28]
 public:
  DCBlocker() { }
  ~DCBlocker() { }
  
  void Init(float pole) {
    x_ = 0.0f;
   12bba:	str	r2, [r0, #40]	; 0x28
    y_ = 0.0f;
   12bbc:	str	r2, [r0, #44]	; 0x2c
  string_.Reset();
  stretch_.Reset();
  iir_damping_filter_.Init();
  dc_blocker_.Init(1.0f - 20.0f / kSampleRate);
  dispersion_noise_ = 0.0f;
   12bbe:	str	r2, [r0, #52]	; 0x34
  curved_bridge_ = 0.0f;
   12bc0:	str	r2, [r0, #56]	; 0x38
  out_sample_[0] = out_sample_[1] = 0.0f;
   12bc2:	str	r2, [r0, #68]	; 0x44
   12bc4:	str	r2, [r0, #64]	; 0x40
  src_phase_ = 0.0f;
   12bc6:	str	r2, [r0, #60]	; 0x3c
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12bc8:	str	r1, [r0, #24]
  ~DCBlocker() { }
  
  void Init(float pole) {
    x_ = 0.0f;
    y_ = 0.0f;
    pole_ = pole;
   12bca:	str	r3, [r0, #36]	; 0x24
}
   12bcc:	pop	{r4, r5, r6}
   12bce:	bx	lr
   12bd0:	.word	0x3d00ba22
   12bd4:	.word	0x3c23d70a
   12bd8:	.word	0x3f7faaca
   12bdc:	.word	0x3f7fe4b1

00012be0 <plaits::String::Init(stmlib::BufferAllocator*)>:
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
   12be0:	ldr	r2, [r1, #8]
   12be2:	cmp.w	r2, #4096	; 0x1000
namespace plaits {
  
using namespace std;
using namespace stmlib;

void String::Init(BufferAllocator* allocator) {
   12be6:	push	{r4}
   12be8:	mov	r4, r0
   12bea:	bcc.n	12c4a <plaits::String::Init(stmlib::BufferAllocator*)+0x6a>
      T* start = static_cast<T*>(static_cast<void*>(next_));
   12bec:	ldr	r3, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
   12bee:	sub.w	r2, r2, #4096	; 0x1000
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
   12bf2:	add.w	r0, r3, #4096	; 0x1000
      free_ -= size_bytes;
   12bf6:	str	r2, [r1, #8]
    line_ = buffer;
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
   12bf8:	mov	r2, r0
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
   12bfa:	str	r0, [r1, #0]
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
   12bfc:	str	r3, [r4, #4]
	*__first = __tmp;
   12bfe:	movs	r0, #0
   12c00:	str.w	r0, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12c04:	cmp	r3, r2
   12c06:	bne.n	12c00 <plaits::String::Init(stmlib::BufferAllocator*)+0x20>
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
   12c08:	movs	r3, #0
   12c0a:	str	r3, [r4, #0]
  }
  
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
   12c0c:	ldr	r2, [r1, #8]
   12c0e:	cmp.w	r2, #1024	; 0x400
   12c12:	bcc.n	12c42 <plaits::String::Init(stmlib::BufferAllocator*)+0x62>
      T* start = static_cast<T*>(static_cast<void*>(next_));
   12c14:	ldr	r3, [r1, #0]
      next_ += size_bytes;
      free_ -= size_bytes;
   12c16:	sub.w	r2, r2, #1024	; 0x400
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
   12c1a:	add.w	r0, r3, #1024	; 0x400
      free_ -= size_bytes;
   12c1e:	str	r2, [r1, #8]
    line_ = buffer;
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
   12c20:	mov	r2, r0
  template<typename T>
  inline T* Allocate(size_t size) {
    size_t size_bytes = sizeof(T) * size;
    if (size_bytes <= free_) {
      T* start = static_cast<T*>(static_cast<void*>(next_));
      next_ += size_bytes;
   12c22:	str	r0, [r1, #0]
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
   12c24:	str	r3, [r4, #12]
	*__first = __tmp;
   12c26:	movs	r1, #0
   12c28:	str.w	r1, [r3], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   12c2c:	cmp	r3, r2
   12c2e:	bne.n	12c28 <plaits::String::Init(stmlib::BufferAllocator*)+0x48>
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
   12c30:	movs	r2, #0
  string_.Init(allocator->Allocate<float>(kDelayLineSize));
  stretch_.Init(allocator->Allocate<float>(kDelayLineSize / 4));
  delay_ = 100.0f;
   12c32:	ldr	r3, [pc, #32]	; (12c54 <plaits::String::Init(stmlib::BufferAllocator*)+0x74>)
  Reset();
   12c34:	mov	r0, r4
   12c36:	str	r2, [r4, #8]
using namespace stmlib;

void String::Init(BufferAllocator* allocator) {
  string_.Init(allocator->Allocate<float>(kDelayLineSize));
  stretch_.Init(allocator->Allocate<float>(kDelayLineSize / 4));
  delay_ = 100.0f;
   12c38:	str	r3, [r4, #48]	; 0x30
  Reset();
}
   12c3a:	ldr.w	r4, [sp], #4

void String::Init(BufferAllocator* allocator) {
  string_.Init(allocator->Allocate<float>(kDelayLineSize));
  stretch_.Init(allocator->Allocate<float>(kDelayLineSize / 4));
  delay_ = 100.0f;
  Reset();
   12c3e:	b.w	12b7c <plaits::String::Reset()>
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
   12c42:	str	r3, [r4, #12]
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
   12c44:	mov.w	r2, #1024	; 0x400
   12c48:	b.n	12c26 <plaits::String::Init(stmlib::BufferAllocator*)+0x46>
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
   12c4a:	movs	r3, #0
    Reset();
  }
  
  void Reset() {
    std::fill(&line_[0], &line_[max_delay], T(0));
   12c4c:	mov.w	r2, #4096	; 0x1000
 public:
  DelayLine() { }
  ~DelayLine() { }
  
  void Init(float* buffer) {
    line_ = buffer;
   12c50:	str	r3, [r0, #4]
   12c52:	b.n	12bfe <plaits::String::Init(stmlib::BufferAllocator*)+0x1e>
   12c54:	.word	0x42c80000

00012c58 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)>:
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
   12c58:	vmov.f32	s14, #112	; 0x3f800000  1.0
  CONSTRAIN(delay, 4.0f, kDelayLineSize - 4.0f);
   12c5c:	vmov.f32	s15, #16	; 0x40800000  4.0
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
   12c60:	vdiv.f32	s13, s14, s0
        f0, non_linearity_amount, brightness, damping, in, out, size);
  }
}

template<StringNonLinearity non_linearity>
void String::ProcessInternal(
   12c64:	push	{r4, r5, r6, r7, lr}
   12c66:	vpush	{d8}
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
  CONSTRAIN(delay, 4.0f, kDelayLineSize - 4.0f);
   12c6a:	vcmpe.f32	s13, s15
   12c6e:	vmrs	APSR_nzcv, fpscr
   12c72:	bmi.w	12fce <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x376>
   12c76:	vldr	s15, [pc, #860]	; 12fd4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x37c>
   12c7a:	vcmp.f32	s13, s15
   12c7e:	vmrs	APSR_nzcv, fpscr
   12c82:	it	gt
   12c84:	vmovgt.f32	s13, s15
  
  // If there is not enough delay time in the delay line, we play at the
  // lowest possible note and we upsample on the fly with a shitty linear
  // interpolator. We don't care because it's a corner case (f0 < 11.7Hz)
  float src_ratio = delay * f0;
   12c88:	vmul.f32	s8, s13, s0
  if (src_ratio >= 0.9999f) {
   12c8c:	vldr	s15, [pc, #840]	; 12fd8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x380>
   12c90:	vcmpe.f32	s8, s15
   12c94:	vmrs	APSR_nzcv, fpscr
   12c98:	blt.n	12ca6 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x4e>
    // When we are above 11.7 Hz, we make sure that the linear interpolator
    // does not get in the way.
    src_phase_ = 1.0f;
   12c9a:	vmov.f32	s15, #112	; 0x3f800000  1.0
    src_ratio = 1.0f;
   12c9e:	vmov.f32	s8, s15
  // interpolator. We don't care because it's a corner case (f0 < 11.7Hz)
  float src_ratio = delay * f0;
  if (src_ratio >= 0.9999f) {
    // When we are above 11.7 Hz, we make sure that the linear interpolator
    // does not get in the way.
    src_phase_ = 1.0f;
   12ca2:	vstr	s15, [r0, #60]	; 0x3c
    src_ratio = 1.0f;
  }

  float damping_cutoff = min(
      12.0f + damping * damping * 60.0f + brightness * 24.0f,
      84.0f);
   12ca6:	vmul.f32	s10, s3, s3
   12caa:	vldr	s11, [pc, #816]	; 12fdc <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x384>
   12cae:	vmov.f32	s14, #40	; 0x41400000  12.0
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   12cb2:	vldr	s15, [pc, #812]	; 12fe0 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x388>
   12cb6:	vmov.f32	s12, #56	; 0x41c00000  24.0
   12cba:	vfma.f32	s14, s10, s11
   12cbe:	vfma.f32	s14, s2, s12
   12cc2:	vcmpe.f32	s14, s15
   12cc6:	vmrs	APSR_nzcv, fpscr
   12cca:	bgt.w	12fc4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x36c>
   12cce:	vldr	s15, [pc, #788]	; 12fe4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x38c>
   12cd2:	vadd.f32	s15, s14, s15
   12cd6:	vcvt.s32.f32	s12, s15
   12cda:	vmov	r6, s12
   12cde:	vcvt.f32.s32	s12, s12
   12ce2:	vsub.f32	s15, s15, s12
   12ce6:	vmov.f32	s12, s15
   12cea:	vcvt.s32.f32	s12, s12, #8
   12cee:	vmov	r4, s12

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   12cf2:	ldr	r7, [pc, #756]	; (12fe8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x390>)
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   12cf4:	ldr	r5, [pc, #756]	; (12fec <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x394>)

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   12cf6:	add.w	r6, r7, r6, lsl #2
   12cfa:	vldr	s12, [pc, #756]	; 12ff0 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x398>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   12cfe:	add.w	r4, r5, r4, lsl #2
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
   12d02:	vldr	s11, [pc, #752]	; 12ff4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x39c>
  }

  float damping_cutoff = min(
      12.0f + damping * damping * 60.0f + brightness * 24.0f,
      84.0f);
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
   12d06:	vldr	s15, [r6]
   12d0a:	vldr	s10, [r4]
   12d0e:	vmul.f32	s15, s15, s10
   12d12:	vmul.f32	s0, s15, s0
	return __b;
   12d16:	vcmp.f32	s0, s12
   12d1a:	vmrs	APSR_nzcv, fpscr
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
   12d1e:	vcmpe.f32	s3, s11
   12d22:	it	gt
   12d24:	vmovgt.f32	s0, s12
   12d28:	vmrs	APSR_nzcv, fpscr
   12d2c:	blt.n	12d52 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0xfa>
    float to_infinite = 20.0f * (damping - 0.95f);
   12d2e:	vsub.f32	s3, s3, s11
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
   12d32:	vldr	s12, [pc, #708]	; 12ff8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3a0>
      84.0f);
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
   12d36:	vmov.f32	s11, #52	; 0x41a00000  20.0
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
    damping_cutoff += to_infinite * (128.0f - damping_cutoff);
   12d3a:	vldr	s15, [pc, #680]	; 12fe4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x38c>
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
   12d3e:	vsub.f32	s12, s12, s0
    damping_cutoff += to_infinite * (128.0f - damping_cutoff);
   12d42:	vsub.f32	s15, s15, s14
      84.0f);
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
   12d46:	vmul.f32	s3, s3, s11
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
   12d4a:	vfma.f32	s0, s3, s12
    damping_cutoff += to_infinite * (128.0f - damping_cutoff);
   12d4e:	vfma.f32	s14, s3, s15
      // The usual tangent approximation uses 3.1755e-01 and 2.033e-01, but
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
   12d52:	vmul.f32	s5, s0, s0
      return f * (M_PI_F + f2 * (a + b * f2));
   12d56:	vldr	s11, [pc, #676]	; 12ffc <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3a4>
   12d5a:	vldr	s7, [pc, #676]	; 13000 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3a8>
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12d5e:	vmov.f32	s12, #112	; 0x3f800000  1.0
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   12d62:	vldr	s15, [pc, #672]	; 13004 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3ac>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   12d66:	vmov.f32	s6, #0	; 0x40000000  2.0
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   12d6a:	vfma.f32	s7, s5, s11
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   12d6e:	ldr	r5, [pc, #664]	; (13008 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3b0>)
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
   12d70:	vcvt.s32.f32	s10, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   12d74:	vldr	s11, [r0, #48]	; 0x30
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   12d78:	vstr	s6, [r0, #20]
    increment_ = (new_value - *state) / static_cast<float>(size);
   12d7c:	vmov	s9, r3
      : 0.0f;
  float noise_amount = noise_amount_sqrt * noise_amount_sqrt * 0.1f;
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
  
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
   12d80:	vmul.f32	s1, s1, s1
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   12d84:	subs	r6, r3, #1
  float a = table[index_integral];
   12d86:	vmov	r4, s10
   12d8a:	vcvt.f32.s32	s10, s10
   12d8e:	vcvt.f32.u32	s4, s9
      : 0.0f;
  float noise_amount = noise_amount_sqrt * noise_amount_sqrt * 0.1f;
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
  
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
   12d92:	vldr	s9, [pc, #632]	; 1300c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3b4>
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   12d96:	vfma.f32	s15, s5, s7
   12d9a:	lsls	r4, r4, #2
   12d9c:	vsub.f32	s14, s14, s10
   12da0:	adds	r7, r4, r5
   12da2:	vmul.f32	s1, s1, s9
   12da6:	vmul.f32	s0, s15, s0
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12daa:	vmov.f32	s15, s12

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   12dae:	vstr	s0, [r0, #16]
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   12db2:	vfma.f32	s15, s0, s6
   12db6:	vfma.f32	s15, s0, s0
   12dba:	vdiv.f32	s10, s12, s15
   12dbe:	vstr	s10, [r0, #24]
   12dc2:	vldr	s15, [r7]
   12dc6:	vldr	s10, [r7, #4]
   12dca:	vsub.f32	s10, s10, s15
   12dce:	vfma.f32	s15, s14, s10
   12dd2:	vmov.f32	s14, s11
   12dd6:	vfnms.f32	s14, s13, s15
   12dda:	vdiv.f32	s7, s14, s4
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   12dde:	cmp	r3, #0
   12de0:	beq.w	12fba <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x362>
      } else {
        s = string_.ReadHermite(delay);
      }
      
      if (non_linearity == STRING_NON_LINEARITY_CURVED_BRIDGE) {
        float value = fabsf(s) - 0.025f;
   12de4:	vldr	s3, [pc, #552]	; 13010 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x3b8>
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
        delay *= 1.0f + dispersion_noise_ * noise_amount;
      } else {
        delay *= 1.0f - curved_bridge_ * bridge_curving;
   12de8:	vneg.f32	s9, s1
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
    const T c = (x1 - xm1) * 0.5f;
    const T v = x0 - x1;
    const T w = c + v;
   12dec:	vmov.f32	s10, #96	; 0x3f000000  0.5
        s = string_.ReadHermite(delay);
      }
      
      if (non_linearity == STRING_NON_LINEARITY_CURVED_BRIDGE) {
        float value = fabsf(s) - 0.025f;
        float sign = s > 0.0f ? 1.0f : -1.5f;
   12df0:	vmov.f32	s4, #248	; 0xbfc00000 -1.5
        curved_bridge_ = (fabsf(value) + value) * sign;
      }
    
      s += *in;
      CONSTRAIN(s, -20.0f, +20.0f);
   12df4:	vmov.f32	s5, #180	; 0xc1a00000 -20.0
   12df8:	vmov.f32	s6, #52	; 0x41a00000  20.0
   12dfc:	b.n	12eb8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x260>
   12dfe:	vcmp.f32	s15, s6
   12e02:	vmrs	APSR_nzcv, fpscr
   12e06:	it	gt
   12e08:	vmovgt.f32	s15, s6
    float y = y_;
    const float pole = pole_;
    while (size--) {
      float old_x = x;
      x = *in_out;
      *in_out++ = y = y * pole + x - old_x;
   12e0c:	vmov.f32	s1, s15
   12e10:	vldr	s13, [r0, #44]	; 0x2c
   12e14:	vldr	s14, [r0, #36]	; 0x24
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
   12e18:	add.w	r5, r5, r4, lsl #2
   12e1c:	vldr	s17, [r0, #40]	; 0x28
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   12e20:	addw	r4, r4, #1023	; 0x3ff
   12e24:	vfma.f32	s1, s13, s14
    }
    x_ = x;
   12e28:	vstr	s15, [r0, #40]	; 0x28
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   12e2c:	vldr	s13, [r0, #28]
   12e30:	ubfx	r4, r4, #0, #10
   12e34:	vldr	s16, [r0, #20]
   12e38:	vldr	s2, [r0, #16]
   12e3c:	vldr	s14, [r0, #32]
   12e40:	vldr	s0, [r0, #24]
    float y = y_;
    const float pole = pole_;
    while (size--) {
      float old_x = x;
      x = *in_out;
      *in_out++ = y = y * pole + x - old_x;
   12e44:	vsub.f32	s1, s1, s17
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   12e48:	vmov.f32	s15, s1
      float old_x = x;
      x = *in_out;
      *in_out++ = y = y * pole + x - old_x;
    }
    x_ = x;
    y_ = y;
   12e4c:	vstr	s1, [r0, #44]	; 0x2c
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   12e50:	vfms.f32	s15, s16, s13
   12e54:	vfms.f32	s15, s13, s2
   12e58:	vsub.f32	s15, s15, s14
   12e5c:	vmul.f32	s15, s15, s0
    bp = g_ * hp + state_1_;
   12e60:	vfma.f32	s13, s2, s15
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
   12e64:	vfma.f32	s14, s2, s13
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   12e68:	vmov.f32	s1, s13
   12e6c:	vfma.f32	s1, s2, s15
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   12e70:	vmov.f32	s15, s14
   12e74:	vfma.f32	s15, s2, s13
   12e78:	vmov.f32	s2, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   12e7c:	vstr	s1, [r0, #28]
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   12e80:	vstr	s15, [r0, #32]
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
   12e84:	vstr	s14, [r5]
      
      dc_blocker_.Process(&s, 1);
      s = iir_damping_filter_.Process<FILTER_MODE_LOW_PASS>(s);
      string_.Write(s);

      out_sample_[1] = out_sample_[0];
   12e88:	vldr	s13, [r0, #64]	; 0x40
   12e8c:	vldr	s15, [r0, #60]	; 0x3c
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   12e90:	str	r4, [r0, #0]
   12e92:	vstr	s13, [r0, #68]	; 0x44
      out_sample_[0] = s;
   12e96:	vstr	s14, [r0, #64]	; 0x40
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
   12e9a:	vsub.f32	s2, s2, s13
   12e9e:	vldmia	r2!, {s14}
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   12ea2:	subs	r6, #1

      out_sample_[1] = out_sample_[0];
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
    in++;
   12ea4:	adds	r1, #4
      string_.Write(s);

      out_sample_[1] = out_sample_[0];
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
   12ea6:	vfma.f32	s13, s2, s15
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   12eaa:	adds	r3, r6, #1
      string_.Write(s);

      out_sample_[1] = out_sample_[0];
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
   12eac:	vadd.f32	s13, s14, s13
   12eb0:	vstr	s13, [r2, #-4]
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   12eb4:	beq.w	12fba <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x362>
    src_phase_ += src_ratio;
   12eb8:	vldr	s15, [r0, #60]	; 0x3c
   12ebc:	vadd.f32	s15, s8, s15
    if (src_phase_ > 1.0f) {
   12ec0:	vcmpe.f32	s15, s12
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
    src_phase_ += src_ratio;
   12ec4:	vstr	s15, [r0, #60]	; 0x3c
    if (src_phase_ > 1.0f) {
   12ec8:	vmrs	APSR_nzcv, fpscr
   12ecc:	ble.n	12fb0 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x358>
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
        delay *= 1.0f + dispersion_noise_ * noise_amount;
      } else {
        delay *= 1.0f - curved_bridge_ * bridge_curving;
   12ece:	vmov.f32	s13, s12
   12ed2:	vldr	s14, [r0, #56]	; 0x38
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
    src_phase_ += src_ratio;
    if (src_phase_ > 1.0f) {
      src_phase_ -= 1.0f;
   12ed6:	vsub.f32	s15, s15, s12
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   12eda:	ldr	r4, [r0, #0]
  }

  inline float Next() {
    value_ += increment_;
   12edc:	vadd.f32	s11, s11, s7
    const T xm1 = line_[(t - 1) % max_delay];
   12ee0:	ldr	r5, [r0, #4]
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
        delay *= 1.0f + dispersion_noise_ * noise_amount;
      } else {
        delay *= 1.0f - curved_bridge_ * bridge_curving;
   12ee2:	vfma.f32	s13, s9, s14
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   12ee6:	add.w	r3, r4, #1024	; 0x400
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
    src_phase_ += src_ratio;
    if (src_phase_ > 1.0f) {
      src_phase_ -= 1.0f;
   12eea:	vstr	s15, [r0, #60]	; 0x3c
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
        delay *= 1.0f + dispersion_noise_ * noise_amount;
      } else {
        delay *= 1.0f - curved_bridge_ * bridge_curving;
   12eee:	vmul.f32	s15, s13, s11
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   12ef2:	vcvt.s32.f32	s13, s15
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   12ef6:	vmov	r7, s13
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   12efa:	vcvt.f32.s32	s13, s13
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   12efe:	add	r3, r7
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   12f00:	vsub.f32	s13, s15, s13
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   12f04:	add.w	lr, r3, #1
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
   12f08:	ubfx	ip, r3, #0, #10
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
   12f0c:	subs	r7, r3, #1
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
   12f0e:	adds	r3, #2
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   12f10:	ubfx	lr, lr, #0, #10
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
   12f14:	add.w	ip, r5, ip, lsl #2
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
   12f18:	ubfx	r7, r7, #0, #10
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
   12f1c:	ubfx	r3, r3, #0, #10
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   12f20:	add.w	lr, r5, lr, lsl #2
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
   12f24:	vldr	s15, [ip]
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
   12f28:	add.w	r7, r5, r7, lsl #2
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   12f2c:	vldr	s14, [lr]
    const T x2 = line_[(t + 2) % max_delay];
   12f30:	add.w	r3, r5, r3, lsl #2
    const T c = (x1 - xm1) * 0.5f;
   12f34:	vldr	s1, [r7]
    const T v = x0 - x1;
   12f38:	vsub.f32	s2, s15, s14
    const T w = c + v;
    const T a = w + v + (x2 - x0) * 0.5f;
   12f3c:	vldr	s0, [r3]
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
    const T c = (x1 - xm1) * 0.5f;
   12f40:	vsub.f32	s1, s14, s1
    const T v = x0 - x1;
    const T w = c + v;
    const T a = w + v + (x2 - x0) * 0.5f;
   12f44:	vsub.f32	s0, s0, s15
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
    const T c = (x1 - xm1) * 0.5f;
    const T v = x0 - x1;
    const T w = c + v;
   12f48:	vmov.f32	s14, s2
   12f4c:	vfma.f32	s14, s1, s10
    const T a = w + v + (x2 - x0) * 0.5f;
   12f50:	vadd.f32	s2, s2, s14
   12f54:	vfma.f32	s2, s0, s10
    const T b_neg = w + a;
    const T f = delay_fractional;
    return (((a * f) - b_neg) * f + c) * f + x0;
   12f58:	vadd.f32	s14, s14, s2
   12f5c:	vfnms.f32	s14, s13, s2
   12f60:	vmul.f32	s14, s14, s13
   12f64:	vfma.f32	s14, s1, s10
   12f68:	vfma.f32	s15, s13, s14
      } else {
        s = string_.ReadHermite(delay);
      }
      
      if (non_linearity == STRING_NON_LINEARITY_CURVED_BRIDGE) {
        float value = fabsf(s) - 0.025f;
   12f6c:	vabs.f32	s14, s15
        float sign = s > 0.0f ? 1.0f : -1.5f;
   12f70:	vcmpe.f32	s15, #0.0
      } else {
        s = string_.ReadHermite(delay);
      }
      
      if (non_linearity == STRING_NON_LINEARITY_CURVED_BRIDGE) {
        float value = fabsf(s) - 0.025f;
   12f74:	vsub.f32	s14, s14, s3
        float sign = s > 0.0f ? 1.0f : -1.5f;
   12f78:	vmrs	APSR_nzcv, fpscr
        curved_bridge_ = (fabsf(value) + value) * sign;
   12f7c:	vabs.f32	s13, s14
        s = string_.ReadHermite(delay);
      }
      
      if (non_linearity == STRING_NON_LINEARITY_CURVED_BRIDGE) {
        float value = fabsf(s) - 0.025f;
        float sign = s > 0.0f ? 1.0f : -1.5f;
   12f80:	ite	le
   12f82:	vmovle.f32	s2, s4
   12f86:	vmovgt.f32	s2, s12
        curved_bridge_ = (fabsf(value) + value) * sign;
   12f8a:	vadd.f32	s14, s13, s14
   12f8e:	vmul.f32	s14, s14, s2
   12f92:	vstr	s14, [r0, #56]	; 0x38
      }
    
      s += *in;
   12f96:	vldr	s14, [r1]
   12f9a:	vadd.f32	s15, s15, s14
      CONSTRAIN(s, -20.0f, +20.0f);
   12f9e:	vcmpe.f32	s15, s5
   12fa2:	vmrs	APSR_nzcv, fpscr
   12fa6:	bpl.w	12dfe <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x1a6>
   12faa:	vmov.f32	s15, #180	; 0xc1a00000 -20.0
   12fae:	b.n	12e0c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x1b4>
   12fb0:	vldr	s13, [r0, #68]	; 0x44
   12fb4:	vldr	s2, [r0, #64]	; 0x40
   12fb8:	b.n	12e9a <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x242>
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
    in++;
  }
}
   12fba:	vpop	{d8}
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   12fbe:	vstr	s11, [r0, #48]	; 0x30
   12fc2:	pop	{r4, r5, r6, r7, pc}
   12fc4:	vmov.f32	s14, s15
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   12fc8:	movs	r4, #0
   12fca:	movs	r6, #212	; 0xd4
   12fcc:	b.n	12cf2 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x9a>
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
  CONSTRAIN(delay, 4.0f, kDelayLineSize - 4.0f);
   12fce:	vmov.f32	s13, s15
   12fd2:	b.n	12c88 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)+0x30>
   12fd4:	.word	0x447f0000
   12fd8:	.word	0x3f7ff972
   12fdc:	.word	0x42700000
   12fe0:	.word	0x42a80000
   12fe4:	.word	0x43000000
   12fe8:	.word	0x20000554
   12fec:	.word	0x20000958
   12ff0:	.word	0x3eff7cee
   12ff4:	.word	0x3f733333
   12ff8:	.word	0x3efff2e5
   12ffc:	.word	0x425f2649
   13000:	.word	0x4121ba8f
   13004:	.word	0x40490fdb
   13008:	.word	0x20002084
   1300c:	.word	0x3c23d70a
   13010:	.word	0x3ccccccd

00013014 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)>:
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
   13014:	vmov.f32	s14, #112	; 0x3f800000  1.0
  CONSTRAIN(delay, 4.0f, kDelayLineSize - 4.0f);
   13018:	vmov.f32	s15, #16	; 0x40800000  4.0
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
   1301c:	vdiv.f32	s13, s14, s0
        f0, non_linearity_amount, brightness, damping, in, out, size);
  }
}

template<StringNonLinearity non_linearity>
void String::ProcessInternal(
   13020:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13024:	vpush	{d8-d11}
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float delay = 1.0f / f0;
  CONSTRAIN(delay, 4.0f, kDelayLineSize - 4.0f);
   13028:	vcmpe.f32	s13, s15
   1302c:	vmrs	APSR_nzcv, fpscr
   13030:	bmi.n	1304c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x38>
   13032:	vldr	s15, [pc, #552]	; 1325c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x248>
   13036:	vcmpe.f32	s13, s15
   1303a:	vmrs	APSR_nzcv, fpscr
   1303e:	ble.w	13556 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x542>
   13042:	vmov.f32	s13, s15
   13046:	vldr	s5, [pc, #536]	; 13260 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x24c>
   1304a:	b.n	13054 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x40>
   1304c:	vmov.f32	s13, s15
   13050:	vldr	s5, [pc, #528]	; 13264 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x250>
  
  // If there is not enough delay time in the delay line, we play at the
  // lowest possible note and we upsample on the fly with a shitty linear
  // interpolator. We don't care because it's a corner case (f0 < 11.7Hz)
  float src_ratio = delay * f0;
   13054:	vmul.f32	s8, s13, s0
  if (src_ratio >= 0.9999f) {
   13058:	vldr	s15, [pc, #524]	; 13268 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x254>
   1305c:	vcmpe.f32	s8, s15
   13060:	vmrs	APSR_nzcv, fpscr
   13064:	blt.n	13072 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x5e>
    // When we are above 11.7 Hz, we make sure that the linear interpolator
    // does not get in the way.
    src_phase_ = 1.0f;
   13066:	vmov.f32	s15, #112	; 0x3f800000  1.0
    src_ratio = 1.0f;
   1306a:	vmov.f32	s8, s15
  // interpolator. We don't care because it's a corner case (f0 < 11.7Hz)
  float src_ratio = delay * f0;
  if (src_ratio >= 0.9999f) {
    // When we are above 11.7 Hz, we make sure that the linear interpolator
    // does not get in the way.
    src_phase_ = 1.0f;
   1306e:	vstr	s15, [r0, #60]	; 0x3c
    src_ratio = 1.0f;
  }

  float damping_cutoff = min(
      12.0f + damping * damping * 60.0f + brightness * 24.0f,
      84.0f);
   13072:	vmul.f32	s10, s3, s3
   13076:	vldr	s11, [pc, #500]	; 1326c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x258>
   1307a:	vmov.f32	s14, #40	; 0x41400000  12.0
   1307e:	vldr	s15, [pc, #496]	; 13270 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x25c>
   13082:	vmov.f32	s12, #56	; 0x41c00000  24.0
   13086:	vfma.f32	s14, s10, s11
   1308a:	vfma.f32	s14, s2, s12
   1308e:	vcmpe.f32	s14, s15
   13092:	vmrs	APSR_nzcv, fpscr
   13096:	bgt.w	1354c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x538>
   1309a:	vldr	s15, [pc, #472]	; 13274 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x260>
   1309e:	vadd.f32	s15, s14, s15
   130a2:	vcvt.s32.f32	s12, s15
   130a6:	vmov	r6, s12
   130aa:	vcvt.f32.s32	s12, s12
   130ae:	vsub.f32	s15, s15, s12
   130b2:	vmov.f32	s12, s15
   130b6:	vcvt.s32.f32	s12, s12, #8
   130ba:	vmov	r4, s12

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   130be:	ldr	r7, [pc, #440]	; (13278 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x264>)
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   130c0:	ldr	r5, [pc, #440]	; (1327c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x268>)

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   130c2:	add.w	r6, r7, r6, lsl #2
   130c6:	vldr	s12, [pc, #440]	; 13280 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x26c>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   130ca:	add.w	r4, r5, r4, lsl #2
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
   130ce:	vldr	s11, [pc, #436]	; 13284 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x270>
  }

  float damping_cutoff = min(
      12.0f + damping * damping * 60.0f + brightness * 24.0f,
      84.0f);
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
   130d2:	vldr	s15, [r6]
   130d6:	vldr	s10, [r4]
   130da:	vmul.f32	s15, s15, s10
   130de:	vmul.f32	s0, s15, s0
	return __b;
   130e2:	vcmp.f32	s0, s12
   130e6:	vmrs	APSR_nzcv, fpscr
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
   130ea:	vcmpe.f32	s3, s11
   130ee:	it	gt
   130f0:	vmovgt.f32	s0, s12
   130f4:	vmrs	APSR_nzcv, fpscr
   130f8:	blt.n	1312a <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x116>
    float to_infinite = 20.0f * (damping - 0.95f);
   130fa:	vsub.f32	s3, s3, s11
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
    damping_cutoff += to_infinite * (128.0f - damping_cutoff);
   130fe:	vldr	s15, [pc, #372]	; 13274 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x260>
      84.0f);
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
   13102:	vmov.f32	s10, #52	; 0x41a00000  20.0
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
   13106:	vldr	s11, [pc, #384]	; 13288 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x274>
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
    brightness += to_infinite * (1.0f - brightness);
   1310a:	vmov.f32	s12, #112	; 0x3f800000  1.0
    damping_f += to_infinite * (0.4999f - damping_f);
   1310e:	vsub.f32	s11, s11, s0
      84.0f);
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
   13112:	vmul.f32	s3, s3, s10
    brightness += to_infinite * (1.0f - brightness);
   13116:	vsub.f32	s12, s12, s2
    damping_f += to_infinite * (0.4999f - damping_f);
    damping_cutoff += to_infinite * (128.0f - damping_cutoff);
   1311a:	vsub.f32	s15, s15, s14
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
    brightness += to_infinite * (1.0f - brightness);
    damping_f += to_infinite * (0.4999f - damping_f);
   1311e:	vfma.f32	s0, s3, s11
  float damping_f = min(f0 * SemitonesToRatio(damping_cutoff), 0.499f);
  
  // Crossfade to infinite decay.
  if (damping >= 0.95f) {
    float to_infinite = 20.0f * (damping - 0.95f);
    brightness += to_infinite * (1.0f - brightness);
   13122:	vfma.f32	s2, s3, s12
    damping_f += to_infinite * (0.4999f - damping_f);
    damping_cutoff += to_infinite * (128.0f - damping_cutoff);
   13126:	vfma.f32	s14, s3, s15
      // The usual tangent approximation uses 3.1755e-01 and 2.033e-01, but
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
   1312a:	vmul.f32	s4, s0, s0
      return f * (M_PI_F + f2 * (a + b * f2));
   1312e:	vldr	s12, [pc, #348]	; 1328c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x278>
   13132:	vldr	s7, [pc, #348]	; 13290 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x27c>
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   13136:	vmov.f32	s6, #112	; 0x3f800000  1.0
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   1313a:	vldr	s15, [pc, #344]	; 13294 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x280>
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   1313e:	vmov.f32	s9, #0	; 0x40000000  2.0
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   13142:	vfma.f32	s7, s4, s12
   13146:	ldr	r5, [pc, #336]	; (13298 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x284>)
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
   13148:	vcvt.s32.f32	s12, s14
  }
  
  inline void Init(float* state, float new_value, size_t size) {
    state_ = state;
    value_ = *state;
   1314c:	vldr	s11, [r0, #48]	; 0x30
  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
   13150:	vstr	s9, [r0, #20]
  
  // Linearly interpolate delay time.
  ParameterInterpolator delay_modulation(
      &delay_, delay * damping_compensation, size);
  
  float stretch_point = non_linearity_amount * (2.0f - non_linearity_amount) * 0.225f;
   13154:	vsub.f32	s10, s9, s1
  float stretch_correction = (160.0f / kSampleRate) * delay;
  CONSTRAIN(stretch_correction, 1.0f, 2.1f);
   13158:	vcmpe.f32	s5, s6
  
  // Linearly interpolate delay time.
  ParameterInterpolator delay_modulation(
      &delay_, delay * damping_compensation, size);
  
  float stretch_point = non_linearity_amount * (2.0f - non_linearity_amount) * 0.225f;
   1315c:	vldr	s3, [pc, #316]	; 1329c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x288>
  float a = table[index_integral];
   13160:	vmov	r4, s12
    increment_ = (new_value - *state) / static_cast<float>(size);
   13164:	vcvt.f32.s32	s12, s12
   13168:	vmul.f32	s10, s10, s1
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   1316c:	vfma.f32	s15, s4, s7
   13170:	lsls	r4, r4, #2
   13172:	vsub.f32	s14, s14, s12
   13176:	adds	r6, r4, r5
  float stretch_correction = (160.0f / kSampleRate) * delay;
  CONSTRAIN(stretch_correction, 1.0f, 2.1f);
   13178:	vmrs	APSR_nzcv, fpscr
  
  // Linearly interpolate delay time.
  ParameterInterpolator delay_modulation(
      &delay_, delay * damping_compensation, size);
  
  float stretch_point = non_linearity_amount * (2.0f - non_linearity_amount) * 0.225f;
   1317c:	vmul.f32	s10, s10, s3
   13180:	vmul.f32	s0, s15, s0
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   13184:	vmov.f32	s15, s6

  // Set frequency and resonance from true units. Various approximations
  // are available to avoid the cost of tanf.
  template<FrequencyApproximation approximation>
  inline void set_f_q(float f, float resonance) {
    g_ = OnePole::tan<approximation>(f);
   13188:	vstr	s0, [r0, #16]
    r_ = 1.0f / resonance;
    h_ = 1.0f / (1.0f + r_ * g_ + g_ * g_);
   1318c:	vfma.f32	s15, s0, s9
   13190:	vfma.f32	s15, s0, s0
   13194:	vdiv.f32	s12, s6, s15
   13198:	vstr	s12, [r0, #24]
   1319c:	vldr	s15, [r6]
   131a0:	vldr	s12, [r6, #4]
   131a4:	vsub.f32	s12, s12, s15
   131a8:	vfma.f32	s15, s14, s12
   131ac:	vmov.f32	s14, s11
   131b0:	vfnms.f32	s14, s13, s15
   131b4:	vmov	s15, r3
   131b8:	vcvt.f32.u32	s15, s15
   131bc:	vdiv.f32	s4, s14, s15
  float stretch_correction = (160.0f / kSampleRate) * delay;
  CONSTRAIN(stretch_correction, 1.0f, 2.1f);
   131c0:	bmi.w	13560 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x54c>
   131c4:	vldr	s15, [pc, #216]	; 132a0 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x28c>
   131c8:	vcmp.f32	s5, s15
   131cc:	vmrs	APSR_nzcv, fpscr
   131d0:	it	gt
   131d2:	vmovgt.f32	s5, s15
  
  float noise_amount_sqrt = non_linearity_amount > 0.75f
      ? 4.0f * (non_linearity_amount - 0.75f)
      : 0.0f;
   131d6:	vmov.f32	s15, #104	; 0x3f400000  0.750
   131da:	vcmpe.f32	s1, s15
   131de:	vmrs	APSR_nzcv, fpscr
   131e2:	ble.w	13546 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x532>
   131e6:	vsub.f32	s15, s1, s15
   131ea:	vldr	s9, [pc, #184]	; 132a4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x290>
   131ee:	vmov.f32	s14, #16	; 0x40800000  4.0
   131f2:	vmul.f32	s15, s15, s14
   131f6:	vmul.f32	s15, s15, s15
   131fa:	vmul.f32	s9, s15, s9
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
  
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
   131fe:	vabs.f32	s14, s1
   13202:	vldr	s12, [pc, #164]	; 132a8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x294>
   13206:	vldr	s13, [pc, #164]	; 132ac <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x298>
  
  while (size--) {
   1320a:	add.w	ip, r3, #4294967295
  
  float noise_amount_sqrt = non_linearity_amount > 0.75f
      ? 4.0f * (non_linearity_amount - 0.75f)
      : 0.0f;
  float noise_amount = noise_amount_sqrt * noise_amount_sqrt * 0.1f;
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
   1320e:	vldr	s15, [pc, #160]	; 132b0 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x29c>
  
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
   13212:	vadd.f32	s14, s14, s12
  
  float noise_amount_sqrt = non_linearity_amount > 0.75f
      ? 4.0f * (non_linearity_amount - 0.75f)
      : 0.0f;
  float noise_amount = noise_amount_sqrt * noise_amount_sqrt * 0.1f;
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
   13216:	vldr	s6, [pc, #156]	; 132b4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2a0>
  
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
   1321a:	vmul.f32	s1, s1, s13
  
  float noise_amount_sqrt = non_linearity_amount > 0.75f
      ? 4.0f * (non_linearity_amount - 0.75f)
      : 0.0f;
  float noise_amount = noise_amount_sqrt * noise_amount_sqrt * 0.1f;
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
   1321e:	vmul.f32	s15, s2, s15
  
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
   13222:	vdiv.f32	s0, s1, s14
  
  float noise_amount_sqrt = non_linearity_amount > 0.75f
      ? 4.0f * (non_linearity_amount - 0.75f)
      : 0.0f;
  float noise_amount = noise_amount_sqrt * noise_amount_sqrt * 0.1f;
  float noise_filter = 0.06f + 0.94f * brightness * brightness;
   13226:	vfma.f32	s6, s2, s15
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   1322a:	cmp	r3, #0
   1322c:	beq.w	1353a <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x526>
   13230:	ldr.w	r9, [pc, #144]	; 132c4 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2b0>
    src_phase_ += src_ratio;
    if (src_phase_ > 1.0f) {
   13234:	vmov.f32	s12, #112	; 0x3f800000  1.0
      float delay = delay_modulation.Next();
      float s = 0.0f;
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
   13238:	vmov.f32	s1, #224	; 0xbf000000 -0.5
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   1323c:	movs	r4, #0
      }
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float ap_delay = delay * stretch_point;
        float main_delay = delay - ap_delay * (0.408f - stretch_point * 0.308f) * stretch_correction;
        if (ap_delay >= 4.0f && main_delay >= 4.0f) {
   1323e:	vmov.f32	s7, #16	; 0x40800000  4.0
   13242:	ldr.w	r7, [r9]
        float sign = s > 0.0f ? 1.0f : -1.5f;
        curved_bridge_ = (fabsf(value) + value) * sign;
      }
    
      s += *in;
      CONSTRAIN(s, -20.0f, +20.0f);
   13246:	vmov.f32	s2, #180	; 0xc1a00000 -20.0
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
   1324a:	ldr.w	r8, [pc, #124]	; 132c8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2b4>
      float delay = delay_modulation.Next();
      float s = 0.0f;
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
   1324e:	vldr	s3, [pc, #104]	; 132b8 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2a4>
        delay *= 1.0f - curved_bridge_ * bridge_curving;
      }
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float ap_delay = delay * stretch_point;
        float main_delay = delay - ap_delay * (0.408f - stretch_point * 0.308f) * stretch_correction;
   13252:	vldr	s17, [pc, #104]	; 132bc <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2a8>
   13256:	vldr	s16, [pc, #104]	; 132c0 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2ac>
   1325a:	b.n	13432 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x41e>
   1325c:	.word	0x447f0000
   13260:	.word	0x4059999a
   13264:	.word	0x3c5a740e
   13268:	.word	0x3f7ff972
   1326c:	.word	0x42700000
   13270:	.word	0x42a80000
   13274:	.word	0x43000000
   13278:	.word	0x20000554
   1327c:	.word	0x20000958
   13280:	.word	0x3eff7cee
   13284:	.word	0x3f733333
   13288:	.word	0x3efff2e5
   1328c:	.word	0x425f2649
   13290:	.word	0x4121ba8f
   13294:	.word	0x40490fdb
   13298:	.word	0x20002084
   1329c:	.word	0x3e666666
   132a0:	.word	0x40066666
   132a4:	.word	0x3dcccccd
   132a8:	.word	0x3e19999a
   132ac:	.word	0xbf1e353f
   132b0:	.word	0x3f70a3d7
   132b4:	.word	0x3d75c28f
   132b8:	.word	0x2f800000
   132bc:	.word	0x3e9db22d
   132c0:	.word	0x3ed0e560
   132c4:	.word	0x20020470
   132c8:	.word	0x0019660d
   132cc:	vmov.f32	s13, s16
   132d0:	vmov.f32	s18, s15
   132d4:	vfms.f32	s13, s10, s17
   132d8:	vmul.f32	s13, s13, s14
   132dc:	vfms.f32	s18, s5, s13
        if (ap_delay >= 4.0f && main_delay >= 4.0f) {
   132e0:	vcmpe.f32	s18, s7
   132e4:	vmrs	APSR_nzcv, fpscr
   132e8:	blt.w	13498 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x484>
    Write(sample);
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   132ec:	vcvt.s32.f32	s15, s18
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   132f0:	ldr	r6, [r0, #8]
   132f2:	vcvt.u32.f32	s14, s14
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
   132f6:	ldmia.w	r0, {r5, lr}
   132fa:	vmov	sl, s15
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
    T write = sample + coefficient * read;
   132fe:	vcvt.f32.s32	s15, s15
          s = string_.Read(main_delay);
          s = stretch_.Allpass(s, ap_delay, ap_gain);
   13302:	mov	r3, r5
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   13304:	vmov	r4, s14
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
   13308:	add	r5, sl
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
    T write = sample + coefficient * read;
   1330a:	vsub.f32	s13, s18, s15
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   1330e:	add	r4, r6
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
   13310:	add.w	sl, r5, #1
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
   13314:	ubfx	r5, r5, #0, #10
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   13318:	uxtb	r4, r4
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
   1331a:	ubfx	sl, sl, #0, #10
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
   1331e:	add.w	r5, lr, r5, lsl #2
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
   13322:	add.w	sl, lr, sl, lsl #2
    return Read(delay);
  }
  
  inline const T Read(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    const T a = line_[(write_ptr_ + delay_integral) % max_delay];
   13326:	vldr	s14, [r5]
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   1332a:	ldr	r5, [r0, #12]
    T write = sample + coefficient * read;
   1332c:	vldr	s18, [sl]
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   13330:	add.w	sl, r6, #255	; 0xff
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   13334:	add.w	r4, r5, r4, lsl #2
    T write = sample + coefficient * read;
   13338:	vsub.f32	s18, s18, s14
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
   1333c:	add.w	r6, r5, r6, lsl #2
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
   13340:	vldr	s15, [r4]
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   13344:	uxtb.w	r4, sl
  }
  
  inline const T Allpass(const T sample, size_t delay, const T coefficient) {
    T read = line_[(write_ptr_ + delay) % max_delay];
    T write = sample + coefficient * read;
   13348:	vfma.f32	s14, s13, s18
   1334c:	vfma.f32	s14, s0, s15
    Write(write);
    return -write * coefficient + read;
   13350:	vfms.f32	s15, s14, s0
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
   13354:	vstr	s14, [r6]
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   13358:	str	r4, [r0, #8]
        float value = fabsf(s) - 0.025f;
        float sign = s > 0.0f ? 1.0f : -1.5f;
        curved_bridge_ = (fabsf(value) + value) * sign;
      }
    
      s += *in;
   1335a:	vldr	s14, [r1]
   1335e:	vadd.f32	s15, s15, s14
      CONSTRAIN(s, -20.0f, +20.0f);
   13362:	vcmpe.f32	s15, s2
   13366:	vmrs	APSR_nzcv, fpscr
   1336a:	bmi.w	13524 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x510>
   1336e:	vmov.f32	s14, #52	; 0x41a00000  20.0
   13372:	vcmp.f32	s15, s14
   13376:	vmrs	APSR_nzcv, fpscr
   1337a:	it	gt
   1337c:	vmovgt.f32	s15, s14
    float y = y_;
    const float pole = pole_;
    while (size--) {
      float old_x = x;
      x = *in_out;
      *in_out++ = y = y * pole + x - old_x;
   13380:	vmov.f32	s19, s15
   13384:	vldr	s13, [r0, #44]	; 0x2c
   13388:	vldr	s14, [r0, #36]	; 0x24
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
   1338c:	add.w	lr, lr, r3, lsl #2
   13390:	vldr	s22, [r0, #40]	; 0x28
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   13394:	addw	r3, r3, #1023	; 0x3ff
   13398:	vfma.f32	s19, s13, s14
    }
    x_ = x;
   1339c:	vstr	s15, [r0, #40]	; 0x28
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   133a0:	vldr	s13, [r0, #28]
   133a4:	ubfx	r3, r3, #0, #10
   133a8:	vldr	s21, [r0, #20]
   133ac:	movs	r4, #1
   133ae:	vldr	s18, [r0, #16]
   133b2:	vldr	s14, [r0, #32]
   133b6:	vldr	s20, [r0, #24]
    float y = y_;
    const float pole = pole_;
    while (size--) {
      float old_x = x;
      x = *in_out;
      *in_out++ = y = y * pole + x - old_x;
   133ba:	vsub.f32	s19, s19, s22
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   133be:	vmov.f32	s15, s19
      float old_x = x;
      x = *in_out;
      *in_out++ = y = y * pole + x - old_x;
    }
    x_ = x;
    y_ = y;
   133c2:	vstr	s19, [r0, #44]	; 0x2c
  }
  
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
   133c6:	vfms.f32	s15, s21, s13
   133ca:	vfms.f32	s15, s13, s18
   133ce:	vsub.f32	s15, s15, s14
   133d2:	vmul.f32	s15, s15, s20
    bp = g_ * hp + state_1_;
   133d6:	vfma.f32	s13, s18, s15
    state_1_ = g_ * hp + bp;
    lp = g_ * bp + state_2_;
   133da:	vfma.f32	s14, s18, s13
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   133de:	vmov.f32	s19, s13
   133e2:	vfma.f32	s19, s18, s15
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   133e6:	vmov.f32	s15, s14
   133ea:	vfma.f32	s15, s18, s13
   133ee:	vmov.f32	s18, s14
  template<FilterMode mode>
  inline float Process(float in) {
    float hp, bp, lp;
    hp = (in - r_ * state_1_ - g_ * state_1_ - state_2_) * h_;
    bp = g_ * hp + state_1_;
    state_1_ = g_ * hp + bp;
   133f2:	vstr	s19, [r0, #28]
    lp = g_ * bp + state_2_;
    state_2_ = g_ * bp + lp;
   133f6:	vstr	s15, [r0, #32]
    std::fill(&line_[0], &line_[max_delay], T(0));
    write_ptr_ = 0;
  }
  
  inline void Write(const T sample) {
    line_[write_ptr_] = sample;
   133fa:	vstr	s14, [lr]
      
      dc_blocker_.Process(&s, 1);
      s = iir_damping_filter_.Process<FILTER_MODE_LOW_PASS>(s);
      string_.Write(s);

      out_sample_[1] = out_sample_[0];
   133fe:	vldr	s13, [r0, #64]	; 0x40
   13402:	vldr	s15, [r0, #60]	; 0x3c
    write_ptr_ = (write_ptr_ - 1 + max_delay) % max_delay;
   13406:	str	r3, [r0, #0]
   13408:	vstr	s13, [r0, #68]	; 0x44
      out_sample_[0] = s;
   1340c:	vstr	s14, [r0, #64]	; 0x40
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
   13410:	vsub.f32	s18, s18, s13
   13414:	vldmia	r2!, {s14}
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   13418:	add.w	ip, ip, #4294967295

      out_sample_[1] = out_sample_[0];
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
    in++;
   1341c:	adds	r1, #4
      string_.Write(s);

      out_sample_[1] = out_sample_[0];
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
   1341e:	vfma.f32	s13, s18, s15
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   13422:	cmp.w	ip, #4294967295
      string_.Write(s);

      out_sample_[1] = out_sample_[0];
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
   13426:	vadd.f32	s13, s14, s13
   1342a:	vstr	s13, [r2, #-4]
  float bridge_curving_sqrt = non_linearity_amount;
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
   1342e:	beq.w	13534 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x520>
    src_phase_ += src_ratio;
   13432:	vldr	s15, [r0, #60]	; 0x3c
   13436:	vadd.f32	s15, s8, s15
    if (src_phase_ > 1.0f) {
   1343a:	vcmpe.f32	s15, s12
  float bridge_curving = bridge_curving_sqrt * bridge_curving_sqrt * 0.01f;
  
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
    src_phase_ += src_ratio;
   1343e:	vstr	s15, [r0, #60]	; 0x3c
    if (src_phase_ > 1.0f) {
   13442:	vmrs	APSR_nzcv, fpscr
   13446:	ble.n	1352a <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x516>
   13448:	mul.w	r3, r8, r7
   1344c:	ldr	r7, [pc, #280]	; (13568 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x554>)
      src_phase_ -= 1.0f;
   1344e:	vsub.f32	s15, s15, s12
      float delay = delay_modulation.Next();
      float s = 0.0f;
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
   13452:	vldr	s14, [r0, #52]	; 0x34
   13456:	add	r7, r3
  }

  inline float Next() {
    value_ += increment_;
   13458:	vadd.f32	s11, s11, s4
   1345c:	vmov	s13, r7
  float ap_gain = -0.618f * non_linearity_amount / (0.15f + fabsf(non_linearity_amount));
  
  while (size--) {
    src_phase_ += src_ratio;
    if (src_phase_ > 1.0f) {
      src_phase_ -= 1.0f;
   13460:	vstr	s15, [r0, #60]	; 0x3c
      float delay = delay_modulation.Next();
      float s = 0.0f;
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
   13464:	vmov.f32	s15, s1
   13468:	vcvt.f32.u32	s13, s13
   1346c:	vfma.f32	s15, s13, s3
   13470:	vsub.f32	s15, s15, s14
   13474:	vfma.f32	s14, s6, s15
        delay *= 1.0f + dispersion_noise_ * noise_amount;
   13478:	vmov.f32	s15, s12
   1347c:	vfma.f32	s15, s14, s9
      float delay = delay_modulation.Next();
      float s = 0.0f;
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float noise = Random::GetFloat() - 0.5f;
        ONE_POLE(dispersion_noise_, noise, noise_filter)
   13480:	vstr	s14, [r0, #52]	; 0x34
        delay *= 1.0f + dispersion_noise_ * noise_amount;
   13484:	vmul.f32	s15, s15, s11
      } else {
        delay *= 1.0f - curved_bridge_ * bridge_curving;
      }
      
      if (non_linearity == STRING_NON_LINEARITY_DISPERSION) {
        float ap_delay = delay * stretch_point;
   13488:	vmul.f32	s14, s10, s15
        float main_delay = delay - ap_delay * (0.408f - stretch_point * 0.308f) * stretch_correction;
        if (ap_delay >= 4.0f && main_delay >= 4.0f) {
   1348c:	vcmpe.f32	s14, s7
   13490:	vmrs	APSR_nzcv, fpscr
   13494:	bge.w	132cc <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x2b8>
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   13498:	vcvt.s32.f32	s13, s15
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   1349c:	ldr	r3, [r0, #0]
    const T xm1 = line_[(t - 1) % max_delay];
   1349e:	ldr	r6, [r0, #4]
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
    const T c = (x1 - xm1) * 0.5f;
    const T v = x0 - x1;
    const T w = c + v;
   134a0:	vmov.f32	s20, #96	; 0x3f000000  0.5
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   134a4:	add.w	r5, r3, #1024	; 0x400
   134a8:	vmov	r4, s13
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   134ac:	vcvt.f32.s32	s14, s13
    const T v = x0 - x1;
    const T w = c + v;
    const T a = w + v + (x2 - x0) * 0.5f;
    const T b_neg = w + a;
    const T f = delay_fractional;
    return (((a * f) - b_neg) * f + c) * f + x0;
   134b0:	mov	lr, r6
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
   134b2:	add	r5, r4
    const T b = line_[(write_ptr_ + delay_integral + 1) % max_delay];
    return a + (b - a) * T(delay_fractional);
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
   134b4:	vsub.f32	s14, s15, s14
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   134b8:	add.w	fp, r5, #1
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
   134bc:	ubfx	r4, r5, #0, #10
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
   134c0:	add.w	sl, r5, #4294967295
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
   134c4:	adds	r5, #2
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   134c6:	ubfx	fp, fp, #0, #10
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
   134ca:	add.w	r4, r6, r4, lsl #2
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
   134ce:	ubfx	sl, sl, #0, #10
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
   134d2:	ubfx	r5, r5, #0, #10
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   134d6:	add.w	fp, r6, fp, lsl #2
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
   134da:	vldr	s15, [r4]
  }
  
  inline const T ReadHermite(float delay) const {
    MAKE_INTEGRAL_FRACTIONAL(delay)
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
   134de:	add.w	sl, r6, sl, lsl #2
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
   134e2:	vldr	s13, [fp]
    const T x2 = line_[(t + 2) % max_delay];
   134e6:	add.w	r4, r6, r5, lsl #2
    const T c = (x1 - xm1) * 0.5f;
   134ea:	vldr	s19, [sl]
    const T v = x0 - x1;
   134ee:	vsub.f32	s18, s15, s13
    const T w = c + v;
    const T a = w + v + (x2 - x0) * 0.5f;
   134f2:	vldr	s21, [r4]
    int32_t t = (write_ptr_ + delay_integral + max_delay);
    const T xm1 = line_[(t - 1) % max_delay];
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
    const T c = (x1 - xm1) * 0.5f;
   134f6:	vsub.f32	s19, s13, s19
    const T v = x0 - x1;
    const T w = c + v;
    const T a = w + v + (x2 - x0) * 0.5f;
   134fa:	vsub.f32	s21, s21, s15
    const T x0 = line_[(t) % max_delay];
    const T x1 = line_[(t + 1) % max_delay];
    const T x2 = line_[(t + 2) % max_delay];
    const T c = (x1 - xm1) * 0.5f;
    const T v = x0 - x1;
    const T w = c + v;
   134fe:	vmov.f32	s13, s18
   13502:	vfma.f32	s13, s19, s20
    const T a = w + v + (x2 - x0) * 0.5f;
   13506:	vadd.f32	s18, s18, s13
   1350a:	vfma.f32	s18, s21, s20
    const T b_neg = w + a;
    const T f = delay_fractional;
    return (((a * f) - b_neg) * f + c) * f + x0;
   1350e:	vadd.f32	s13, s13, s18
   13512:	vfnms.f32	s13, s14, s18
   13516:	vmul.f32	s13, s13, s14
   1351a:	vfma.f32	s13, s19, s20
   1351e:	vfma.f32	s15, s14, s13
   13522:	b.n	1335a <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x346>
        float sign = s > 0.0f ? 1.0f : -1.5f;
        curved_bridge_ = (fabsf(value) + value) * sign;
      }
    
      s += *in;
      CONSTRAIN(s, -20.0f, +20.0f);
   13524:	vmov.f32	s15, #180	; 0xc1a00000 -20.0
   13528:	b.n	13380 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x36c>
   1352a:	vldr	s13, [r0, #68]	; 0x44
   1352e:	vldr	s18, [r0, #64]	; 0x40
   13532:	b.n	13410 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x3fc>
   13534:	cbz	r4, 1353a <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x526>
   13536:	str.w	r7, [r9]
    value_ = *state;
    increment_ = (new_value - *state) * step;
  }

  ~ParameterInterpolator() {
    *state_ = value_;
   1353a:	vstr	s11, [r0, #48]	; 0x30
      out_sample_[0] = s;
    }
    *out++ += Crossfade(out_sample_[1], out_sample_[0], src_phase_);
    in++;
  }
}
   1353e:	vpop	{d8-d11}
   13542:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13546:	vldr	s9, [pc, #36]	; 1356c <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x558>
   1354a:	b.n	131fe <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x1ea>
   1354c:	vmov.f32	s14, s15
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   13550:	movs	r4, #0
   13552:	movs	r6, #212	; 0xd4
   13554:	b.n	130be <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0xaa>
   13556:	vldr	s5, [pc, #24]	; 13570 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x55c>
   1355a:	vmul.f32	s5, s13, s5
   1355e:	b.n	13054 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x40>
  ParameterInterpolator delay_modulation(
      &delay_, delay * damping_compensation, size);
  
  float stretch_point = non_linearity_amount * (2.0f - non_linearity_amount) * 0.225f;
  float stretch_correction = (160.0f / kSampleRate) * delay;
  CONSTRAIN(stretch_correction, 1.0f, 2.1f);
   13560:	vmov.f32	s5, s6
   13564:	b.n	131d6 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)+0x1c2>
   13566:	nop
   13568:	.word	0x3c6ef35f
   1356c:	.word	0x00000000
   13570:	.word	0x3b5a740e

00013574 <plaits::String::Process(float, float, float, float, float const*, float*, unsigned int)>:
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
  if (non_linearity_amount <= 0.0f) {
   13574:	vcmpe.f32	s1, #0.0
    float non_linearity_amount,
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
   13578:	push	{r3, lr}
  if (non_linearity_amount <= 0.0f) {
   1357a:	vmrs	APSR_nzcv, fpscr
   1357e:	bls.n	13586 <plaits::String::Process(float, float, float, float, float const*, float*, unsigned int)+0x12>
    ProcessInternal<STRING_NON_LINEARITY_CURVED_BRIDGE>(
        f0, -non_linearity_amount, brightness, damping, in, out, size);
  } else {
    ProcessInternal<STRING_NON_LINEARITY_DISPERSION>(
        f0, non_linearity_amount, brightness, damping, in, out, size);
   13580:	bl	13014 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)1>(float, float, float, float, float const*, float*, unsigned int)>
   13584:	pop	{r3, pc}
    const float* in,
    float* out,
    size_t size) {
  if (non_linearity_amount <= 0.0f) {
    ProcessInternal<STRING_NON_LINEARITY_CURVED_BRIDGE>(
        f0, -non_linearity_amount, brightness, damping, in, out, size);
   13586:	vneg.f32	s1, s1
   1358a:	bl	12c58 <void plaits::String::ProcessInternal<(plaits::StringNonLinearity)0>(float, float, float, float, float const*, float*, unsigned int)>
   1358e:	pop	{r3, pc}

00013590 <plaits::Resonator::Init(float, int)>:
    Start();
  }
  
  inline void InitApproximate(float frequency) {
    float sign = 16.0f;
    frequency -= 0.25f;
   13590:	vmov.f32	s15, #80	; 0x3e800000  0.250

using namespace std;
using namespace stmlib;

void Resonator::Init(float position, int resolution) {
  resolution_ = min(resolution, kMaxNumModes);
   13594:	cmp	r1, #24
   13596:	mov	r3, r1
   13598:	it	ge
   1359a:	movge	r3, #24
   1359c:	vsub.f32	s0, s0, s15
   135a0:	str	r3, [r0, #0]
    if (frequency < 0.0f) {
   135a2:	vcmpe.f32	s0, #0.0
   135a6:	vmrs	APSR_nzcv, fpscr
   135aa:	bmi.n	13636 <plaits::Resonator::Init(float, int)+0xa6>
      frequency = -frequency;
    } else {
      if (frequency > 0.5f) {
   135ac:	vmov.f32	s15, #96	; 0x3f000000  0.5
   135b0:	vcmpe.f32	s0, s15
   135b4:	vmrs	APSR_nzcv, fpscr
   135b8:	bgt.n	1362c <plaits::Resonator::Init(float, int)+0x9c>
        frequency -= 0.5f;
      } else {
        sign = -16.0f;
   135ba:	vmov.f32	s15, #176	; 0xc1800000 -16.0
      }
    }
    iir_coefficient_ = sign * frequency * (1.0f - 2.0f * frequency);
   135be:	vmov.f32	s14, #0	; 0x40000000  2.0
  
  CosineOscillator amplitudes;
  amplitudes.Init<COSINE_OSCILLATOR_APPROXIMATE>(position);
  
  for (int i = 0; i < resolution; ++i) {
   135c2:	cmp	r1, #0
   135c4:	vmov.f32	s11, #112	; 0x3f800000  1.0
   135c8:	vmul.f32	s15, s0, s15
    initial_amplitude_ = iir_coefficient_ * 0.25f;
   135cc:	vmov.f32	s10, #80	; 0x3e800000  0.250
        frequency -= 0.5f;
      } else {
        sign = -16.0f;
      }
    }
    iir_coefficient_ = sign * frequency * (1.0f - 2.0f * frequency);
   135d0:	vfms.f32	s11, s0, s14
   135d4:	vmul.f32	s11, s11, s15
    initial_amplitude_ = iir_coefficient_ * 0.25f;
   135d8:	vmul.f32	s13, s11, s10
   135dc:	ble.n	1360e <plaits::Resonator::Init(float, int)+0x7e>
   135de:	vmov.f32	s15, #96	; 0x3f000000  0.5
   135e2:	adds	r2, r1, #1
   135e4:	adds	r3, r0, #4
   135e6:	add.w	r2, r0, r2, lsl #2
    mode_amplitude_[i] = amplitudes.Next() * 0.25f;
   135ea:	vmov.f32	s9, s15
    return y1_ + 0.5f;
  }

  inline float Next() {
    float temp = y0_;
    y0_ = iir_coefficient_ * y0_ - y1_;
   135ee:	vfnms.f32	s13, s15, s11
   135f2:	vadd.f32	s14, s15, s9
   135f6:	vmov.f32	s12, s13
   135fa:	vmov.f32	s13, s15
   135fe:	vmul.f32	s15, s14, s10
   13602:	vstmia	r3!, {s15}
  resolution_ = min(resolution, kMaxNumModes);
  
  CosineOscillator amplitudes;
  amplitudes.Init<COSINE_OSCILLATOR_APPROXIMATE>(position);
  
  for (int i = 0; i < resolution; ++i) {
   13606:	cmp	r2, r3
   13608:	vmov.f32	s15, s12
   1360c:	bne.n	135ee <plaits::Resonator::Init(float, int)+0x5e>
  ResonatorSvf() { }
  ~ResonatorSvf() { }
  
  void Init() {
    for (int i = 0; i < batch_size; ++i) {
      state_1_[i] = state_2_[i] = 0.0f;
   1360e:	movs	r3, #0
   13610:	add.w	r2, r0, #192	; 0xc0
   13614:	str	r3, [r0, #116]	; 0x74
   13616:	adds	r0, #32
   13618:	str	r3, [r0, #68]	; 0x44
   1361a:	str	r3, [r0, #88]	; 0x58
   1361c:	str	r3, [r0, #72]	; 0x48
   1361e:	str	r3, [r0, #92]	; 0x5c
   13620:	str	r3, [r0, #76]	; 0x4c
   13622:	str	r3, [r0, #96]	; 0x60
   13624:	str	r3, [r0, #80]	; 0x50
    mode_amplitude_[i] = amplitudes.Next() * 0.25f;
  }
  
  for (int i = 0; i < kMaxNumModes / kModeBatchSize; ++i) {
   13626:	cmp	r2, r0
   13628:	bne.n	13614 <plaits::Resonator::Init(float, int)+0x84>
    mode_filters_[i].Init();
  }
}
   1362a:	bx	lr
    frequency -= 0.25f;
    if (frequency < 0.0f) {
      frequency = -frequency;
    } else {
      if (frequency > 0.5f) {
        frequency -= 0.5f;
   1362c:	vsub.f32	s0, s0, s15
    }
    Start();
  }
  
  inline void InitApproximate(float frequency) {
    float sign = 16.0f;
   13630:	vmov.f32	s15, #48	; 0x41800000  16.0
   13634:	b.n	135be <plaits::Resonator::Init(float, int)+0x2e>
    frequency -= 0.25f;
    if (frequency < 0.0f) {
      frequency = -frequency;
   13636:	vneg.f32	s0, s0
    }
    Start();
  }
  
  inline void InitApproximate(float frequency) {
    float sign = 16.0f;
   1363a:	vmov.f32	s15, #48	; 0x41800000  16.0
   1363e:	b.n	135be <plaits::Resonator::Init(float, int)+0x2e>

00013640 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)>:
#define MAKE_INTEGRAL_FRACTIONAL(x) \
  int32_t x ## _integral = static_cast<int32_t>(x); \
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
   13640:	vldr	s15, [pc, #764]	; 13940 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x300>

inline float NthHarmonicCompensation(int n, float stiffness) {
  float stretch_factor = 1.0f;
  for (int i = 0; i < n - 1; ++i) {
    stretch_factor += stiffness;
   13644:	vmov.f32	s14, #112	; 0x3f800000  1.0

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   13648:	vldr	s12, [pc, #760]	; 13944 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x304>
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float stiffness = Interpolate(lut_stiffness, structure, 64.0f);
  f0 *= NthHarmonicCompensation(3, stiffness);
   1364c:	vmov.f32	s6, #112	; 0x3f800000  1.0
   13650:	vmul.f32	s15, s1, s15
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
   13654:	vldr	s10, [pc, #752]	; 13948 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x308>
  brightness *= 1.0f - damping * 0.3f;
  float q_loss = brightness * (2.0f - brightness) * 0.85f + 0.15f;
   13658:	vldr	s8, [pc, #752]	; 1394c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x30c>
   1365c:	vldr	s9, [pc, #752]	; 13950 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x310>
  MAKE_INTEGRAL_FRACTIONAL(index)
   13660:	vcvt.s32.f32	s13, s15
  f0 *= NthHarmonicCompensation(3, stiffness);
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
   13664:	vldr	s5, [pc, #748]	; 13954 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x314>
    float structure,
    float brightness,
    float damping,
    const float* in,
    float* out,
    size_t size) {
   13668:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1366c:	vpush	{d8-d9}
   13670:	sub	sp, #180	; 0xb4
  float a = table[index_integral];
   13672:	ldr	r4, [pc, #740]	; (13958 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x318>)
   13674:	str	r3, [sp, #20]
   13676:	vmov	r3, s13
   1367a:	str	r2, [sp, #28]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
   1367c:	vcvt.f32.s32	s13, s13
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   13680:	lsls	r3, r3, #2
   13682:	str	r1, [sp, #24]
  float mode_q[kModeBatchSize];
  float mode_f[kModeBatchSize];
  float mode_a[kModeBatchSize];
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
   13684:	add.w	r1, r0, #100	; 0x64
   13688:	adds	r2, r3, r4
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
   1368a:	vsub.f32	s15, s15, s13
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   1368e:	ldr	r3, [pc, #716]	; (1395c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x31c>)
  float x ## _fractional = x - static_cast<float>(x ## _integral);

inline float Interpolate(const float* table, float index, float size) {
  index *= size;
  MAKE_INTEGRAL_FRACTIONAL(index)
  float a = table[index_integral];
   13690:	vldr	s7, [r2]
  float b = table[index_integral + 1];
  return a + (b - a) * index_fractional;
   13694:	vldr	s11, [r2, #4]
   13698:	str	r1, [sp, #4]
   1369a:	vsub.f32	s11, s11, s7
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   1369e:	ldr	r2, [pc, #704]	; (13960 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x320>)
   136a0:	vfma.f32	s7, s15, s11

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   136a4:	vldr	s15, [pc, #700]	; 13964 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x324>
   136a8:	vfma.f32	s15, s3, s12
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
   136ac:	vmov.f32	s12, s6

inline float NthHarmonicCompensation(int n, float stiffness) {
  float stretch_factor = 1.0f;
  for (int i = 0; i < n - 1; ++i) {
    stretch_factor += stiffness;
    if (stiffness < 0.0f) {
   136b0:	vcmpe.f32	s7, #0.0
}

inline float NthHarmonicCompensation(int n, float stiffness) {
  float stretch_factor = 1.0f;
  for (int i = 0; i < n - 1; ++i) {
    stretch_factor += stiffness;
   136b4:	vadd.f32	s14, s7, s14
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   136b8:	vcvt.s32.f32	s11, s15
    if (stiffness < 0.0f) {
   136bc:	vmrs	APSR_nzcv, fpscr
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
   136c0:	vfms.f32	s12, s1, s10

  return lut_pitch_ratio_high[pitch_integral] * \
   136c4:	vmov	r1, s11
  for (int i = 0; i < n - 1; ++i) {
    stretch_factor += stiffness;
    if (stiffness < 0.0f) {
      stiffness *= 0.93f;
    } else {
      stiffness *= 0.98f;
   136c8:	ite	pl
   136ca:	vldrpl	s13, [pc, #668]	; 13968 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x328>
inline float NthHarmonicCompensation(int n, float stiffness) {
  float stretch_factor = 1.0f;
  for (int i = 0; i < n - 1; ++i) {
    stretch_factor += stiffness;
    if (stiffness < 0.0f) {
      stiffness *= 0.93f;
   136ce:	vldrmi	s13, [pc, #668]	; 1396c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x32c>
   136d2:	add.w	r3, r3, r1, lsl #2
   136d6:	vmul.f32	s13, s7, s13
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
   136da:	vmul.f32	s12, s12, s2
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float stiffness = Interpolate(lut_stiffness, structure, 64.0f);
  f0 *= NthHarmonicCompensation(3, stiffness);
   136de:	vadd.f32	s13, s14, s13
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
  brightness *= 1.0f - damping * 0.3f;
  float q_loss = brightness * (2.0f - brightness) * 0.85f + 0.15f;
   136e2:	vmov.f32	s14, #0	; 0x40000000  2.0
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float stiffness = Interpolate(lut_stiffness, structure, 64.0f);
  f0 *= NthHarmonicCompensation(3, stiffness);
   136e6:	vdiv.f32	s4, s6, s13
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
  brightness *= 1.0f - damping * 0.3f;
   136ea:	vmov.f32	s13, s6
   136ee:	vfms.f32	s13, s3, s10
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   136f2:	vcvt.f32.s32	s10, s11
   136f6:	vldr	s11, [r3]
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   136fa:	ldr	r3, [r0, #0]
   136fc:	vsub.f32	s15, s15, s10
   13700:	cmp	r3, #0
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
  brightness *= 1.0f - damping * 0.3f;
   13702:	vmul.f32	s13, s13, s12
   13706:	vcvt.s32.f32	s15, s15, #8
    float damping,
    const float* in,
    float* out,
    size_t size) {
  float stiffness = Interpolate(lut_stiffness, structure, 64.0f);
  f0 *= NthHarmonicCompensation(3, stiffness);
   1370a:	vmul.f32	s3, s4, s0
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
  brightness *= 1.0f - structure * 0.3f;
  brightness *= 1.0f - damping * 0.3f;
  float q_loss = brightness * (2.0f - brightness) * 0.85f + 0.15f;
   1370e:	vsub.f32	s14, s14, s13
   13712:	vmov	r1, s15
   13716:	add.w	r2, r2, r1, lsl #2
   1371a:	vmul.f32	s15, s14, s13
   1371e:	vldr	s14, [r2]
   13722:	vfma.f32	s9, s15, s8
   13726:	vmul.f32	s14, s14, s11
  f0 *= NthHarmonicCompensation(3, stiffness);
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
   1372a:	vmul.f32	s5, s14, s5
  brightness *= 1.0f - structure * 0.3f;
  brightness *= 1.0f - damping * 0.3f;
  float q_loss = brightness * (2.0f - brightness) * 0.85f + 0.15f;
   1372e:	vmov.f32	s2, s9
  f0 *= NthHarmonicCompensation(3, stiffness);
  
  float harmonic = f0;
  float stretch_factor = 1.0f;
  float q_sqrt = SemitonesToRatio(damping * 79.7f);
  float q = 500.0f * q_sqrt * q_sqrt;
   13732:	vmul.f32	s5, s5, s14
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   13736:	ble.n	137e6 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x1a6>
   13738:	adds	r3, #1
   1373a:	add.w	fp, r0, #4
   1373e:	vmov.f32	s4, s3
    float mode_frequency = harmonic * stretch_factor;
    if (mode_frequency >= 0.499f) {
   13742:	vldr	s1, [pc, #556]	; 13970 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x330>
   13746:	add.w	r3, r0, r3, lsl #2
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
      return f * (M_PI_F + f2 * (a + b * f2));
   1374a:	vldr	s18, [pc, #552]	; 13974 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x334>
   1374e:	vldr	s17, [pc, #552]	; 13978 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x338>
   13752:	str	r3, [sp, #0]
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   13754:	movs	r3, #0
   13756:	vldr	s16, [pc, #548]	; 1397c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x33c>
    if (stiffness < 0.0f) {
      // Make sure that the partials do not fold back into negative frequencies.
      stiffness *= 0.93f;
    } else {
      // This helps adding a few extra partials in the highest frequencies.
      stiffness *= 0.98f;
   1375a:	vldr	s0, [pc, #524]	; 13968 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x328>
   1375e:	b.n	137b8 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x178>
   13760:	vmov.f32	s14, #0	; 0x40000000  2.0
   13764:	vmov.f32	s15, #112	; 0x3f800000  1.0
   13768:	vfms.f32	s15, s13, s14
      mode_frequency = 0.499f;
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
   1376c:	vmov.f32	s12, #112	; 0x3f800000  1.0
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
   13770:	vldmia	fp!, {s14}
    if (mode_frequency >= 0.499f) {
      mode_frequency = 0.499f;
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
   13774:	add	r2, sp, #176	; 0xb0
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
   13776:	vmul.f32	s15, s14, s15
      mode_frequency = 0.499f;
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
   1377a:	vmov.f32	s14, s12
    if (mode_frequency >= 0.499f) {
      mode_frequency = 0.499f;
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
   1377e:	add.w	r2, r2, r3, lsl #2
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
    ++batch_counter;
   13782:	adds	r3, #1
    if (mode_frequency >= 0.499f) {
      mode_frequency = 0.499f;
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
   13784:	vstr	s13, [r2, #-128]	; 0xffffff80
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
   13788:	vfma.f32	s14, s13, s5
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
    ++batch_counter;
    
    if (batch_counter == kModeBatchSize) {
   1378c:	cmp	r3, #4
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
   1378e:	vstr	s15, [r2, #-112]	; 0xffffff90
      mode_frequency = 0.499f;
    }
    const float mode_attenuation = 1.0f - mode_frequency * 2.0f;
    
    mode_f[batch_counter] = mode_frequency;
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
   13792:	vstr	s14, [r2, #-144]	; 0xffffff70
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
    ++batch_counter;
    
    if (batch_counter == kModeBatchSize) {
   13796:	beq.n	137f0 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x1b0>
          size);
      ++batch_processor;
    }
    
    stretch_factor += stiffness;
    if (stiffness < 0.0f) {
   13798:	vcmpe.f32	s7, #0.0
          out,
          size);
      ++batch_processor;
    }
    
    stretch_factor += stiffness;
   1379c:	vadd.f32	s6, s6, s7
    if (stiffness < 0.0f) {
   137a0:	vmrs	APSR_nzcv, fpscr
   137a4:	bmi.n	137d0 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x190>
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   137a6:	ldr	r2, [sp, #0]
    if (stiffness < 0.0f) {
      // Make sure that the partials do not fold back into negative frequencies.
      stiffness *= 0.93f;
    } else {
      // This helps adding a few extra partials in the highest frequencies.
      stiffness *= 0.98f;
   137a8:	vmul.f32	s7, s7, s0
    }
    harmonic += f0;
   137ac:	vadd.f32	s4, s4, s3
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   137b0:	cmp	r2, fp
    } else {
      // This helps adding a few extra partials in the highest frequencies.
      stiffness *= 0.98f;
    }
    harmonic += f0;
    q *= q_loss;
   137b2:	vmul.f32	s5, s5, s2
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   137b6:	beq.n	137e6 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x1a6>
    float mode_frequency = harmonic * stretch_factor;
   137b8:	vmul.f32	s13, s6, s4
    if (mode_frequency >= 0.499f) {
   137bc:	vcmpe.f32	s13, s1
   137c0:	vmrs	APSR_nzcv, fpscr
   137c4:	blt.n	13760 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x120>
   137c6:	vldr	s15, [pc, #440]	; 13980 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x340>
      mode_frequency = 0.499f;
   137ca:	vldr	s13, [pc, #420]	; 13970 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x330>
   137ce:	b.n	1376c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x12c>
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   137d0:	ldr	r2, [sp, #0]
      stiffness *= 0.93f;
    } else {
      // This helps adding a few extra partials in the highest frequencies.
      stiffness *= 0.98f;
    }
    harmonic += f0;
   137d2:	vadd.f32	s4, s4, s3
    }
    
    stretch_factor += stiffness;
    if (stiffness < 0.0f) {
      // Make sure that the partials do not fold back into negative frequencies.
      stiffness *= 0.93f;
   137d6:	vldr	s15, [pc, #404]	; 1396c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x32c>
    } else {
      // This helps adding a few extra partials in the highest frequencies.
      stiffness *= 0.98f;
    }
    harmonic += f0;
    q *= q_loss;
   137da:	vmul.f32	s5, s5, s2
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   137de:	cmp	r2, fp
    }
    
    stretch_factor += stiffness;
    if (stiffness < 0.0f) {
      // Make sure that the partials do not fold back into negative frequencies.
      stiffness *= 0.93f;
   137e0:	vmul.f32	s7, s7, s15
  int batch_counter = 0;
  
  ResonatorSvf<kModeBatchSize>* batch_processor = &mode_filters_[0];
  
  
  for (int i = 0; i < resolution_; ++i) {
   137e4:	bne.n	137b8 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x178>
      stiffness *= 0.98f;
    }
    harmonic += f0;
    q *= q_loss;
  }
}
   137e6:	add	sp, #180	; 0xb4
   137e8:	vpop	{d8-d9}
   137ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   137f0:	add	r3, sp, #112	; 0x70
   137f2:	add	r1, sp, #128	; 0x80
   137f4:	ldr	r4, [sp, #4]
   137f6:	add	r2, sp, #144	; 0x90
    mode_f[batch_counter] = mode_frequency;
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
    ++batch_counter;
    
    if (batch_counter == kModeBatchSize) {
   137f8:	str.w	fp, [sp, #12]
   137fc:	add.w	sl, sp, #80	; 0x50
   13800:	mov	r9, r3
   13802:	add.w	r8, sp, #96	; 0x60
   13806:	add.w	ip, sp, #160	; 0xa0
   1380a:	add.w	lr, sp, #48	; 0x30
   1380e:	add	r7, sp, #32
   13810:	mov	r0, r4
   13812:	add	r6, sp, #64	; 0x40
   13814:	movs	r5, #0
   13816:	mov	fp, r1
   13818:	str	r2, [sp, #8]
   1381a:	str	r2, [sp, #16]
    float state_1[batch_size];
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
   1381c:	vldmia	r7!, {s11}
    float r_plus_g[batch_size];
    float h[batch_size];
    float state_1[batch_size];
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
   13820:	adds	r5, #1
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
   13822:	vldmia	lr!, {s15}
   13826:	adds	r4, #4
      r[i] = 1.0f / q[i];
   13828:	vdiv.f32	s13, s12, s11
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
   1382c:	vldr	s11, [r4, #12]
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
      state_1[i] = state_1_[i];
   13830:	vldr	s10, [r4, #-4]
    float r_plus_g[batch_size];
    float h[batch_size];
    float state_1[batch_size];
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
   13834:	cmp	r5, #4
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
   13836:	vstmia	r2!, {s11}
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
      state_1[i] = state_1_[i];
   1383a:	vstmia	fp!, {s10}
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
   1383e:	vldmia	r6!, {s10}
      // The usual tangent approximation uses 3.1755e-01 and 2.033e-01, but
      // the coefficients used here are optimized to minimize error for the
      // 16Hz to 16kHz range, with a sample rate of 48kHz.
      const float a = 3.260e-01 * M_PI_POW_3;
      const float b = 1.823e-01 * M_PI_POW_5;
      float f2 = f * f;
   13842:	vmul.f32	s14, s15, s15
      return f * (M_PI_F + f2 * (a + b * f2));
   13846:	vmov.f32	s11, s17
   1384a:	vstmia	ip!, {s10}
   1384e:	vmov.f32	s10, s16
   13852:	vfma.f32	s11, s14, s18
   13856:	vfma.f32	s10, s14, s11
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   1385a:	vmov.f32	s14, s12
   1385e:	vmul.f32	s15, s10, s15
   13862:	vfma.f32	s14, s15, s13
    float h[batch_size];
    float state_1[batch_size];
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
   13866:	vstmia	sl!, {s15}
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
   1386a:	vadd.f32	s13, s15, s13
   1386e:	vstmia	r8!, {s13}
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   13872:	vfma.f32	s14, s15, s15
   13876:	vmov.f32	s15, s14
   1387a:	vdiv.f32	s14, s12, s15
   1387e:	vstmia	r9!, {s14}
    float r_plus_g[batch_size];
    float h[batch_size];
    float state_1[batch_size];
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
   13882:	bne.n	1381c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x1dc>
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13884:	ldr	r5, [sp, #20]
   13886:	ldr.w	fp, [sp, #12]
   1388a:	ldr	r2, [sp, #16]
   1388c:	add.w	r8, r5, #4294967295
   13890:	cmp	r5, #0
   13892:	beq.n	1391e <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x2de>
   13894:	ldr.w	r9, [sp, #28]
   13898:	ldr.w	sl, [sp, #24]
      float s_in = *in++;
   1389c:	vldmia	sl!, {s8}
   138a0:	add.w	ip, sp, #160	; 0xa0
   138a4:	mov	r6, r2
   138a6:	mov	r5, r1
   138a8:	add.w	lr, sp, #80	; 0x50
   138ac:	mov	r7, r3
   138ae:	add	r4, sp, #96	; 0x60
      float s_out = 0.0f;
   138b0:	vldr	s10, [pc, #208]	; 13984 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x344>
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
   138b4:	vmov.f32	s14, s8
   138b8:	vldr	s13, [r5]
   138bc:	vldmia	r4!, {s15}
   138c0:	vldr	s12, [r6]
   138c4:	vfms.f32	s14, s15, s13
        const float bp = g[i] * hp + state_1[i];
   138c8:	vldmia	lr!, {s11}
        state_1[i] = g[i] * hp + bp;
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
   138cc:	vldmia	ip!, {s9}
    }
    
    while (size--) {
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
   138d0:	cmp	r4, r3
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
   138d2:	vmov.f32	s15, s14
   138d6:	vldmia	r7!, {s14}
   138da:	vsub.f32	s15, s15, s12
   138de:	vmul.f32	s15, s15, s14
        const float bp = g[i] * hp + state_1[i];
   138e2:	vmov.f32	s14, s13
   138e6:	vfma.f32	s14, s15, s11
        state_1[i] = g[i] * hp + bp;
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
   138ea:	vfma.f32	s12, s11, s14
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
        const float bp = g[i] * hp + state_1[i];
        state_1[i] = g[i] * hp + bp;
   138ee:	vmov.f32	s13, s14
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
   138f2:	vfma.f32	s10, s14, s9
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
        const float bp = g[i] * hp + state_1[i];
        state_1[i] = g[i] * hp + bp;
   138f6:	vfma.f32	s13, s15, s11
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
   138fa:	vfma.f32	s12, s11, s14
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
        const float bp = g[i] * hp + state_1[i];
        state_1[i] = g[i] * hp + bp;
   138fe:	vstmia	r5!, {s13}
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
   13902:	vstmia	r6!, {s12}
    }
    
    while (size--) {
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
   13906:	bne.n	138b4 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x274>
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
      }
      if (add) {
        *out++ += s_out;
   13908:	vldmia	r9!, {s15}
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   1390c:	add.w	r8, r8, #4294967295
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
      }
      if (add) {
        *out++ += s_out;
   13910:	vadd.f32	s10, s15, s10
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13914:	cmp.w	r8, #4294967295
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
      }
      if (add) {
        *out++ += s_out;
   13918:	vstr	s10, [r9, #-4]
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   1391c:	bne.n	1389c <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x25c>
   1391e:	ldr	r3, [sp, #4]
   13920:	add.w	r5, r3, #16
      } else {
        *out++ = s_out;
      }
    }
    for (int i = 0; i < batch_size; ++i) {
      state_1_[i] = state_1[i];
   13924:	ldr.w	r4, [r1], #4
      state_2_[i] = state_2[i];
   13928:	ldr.w	r3, [r2], #4
      } else {
        *out++ = s_out;
      }
    }
    for (int i = 0; i < batch_size; ++i) {
      state_1_[i] = state_1[i];
   1392c:	str.w	r4, [r0], #4
        *out++ += s_out;
      } else {
        *out++ = s_out;
      }
    }
    for (int i = 0; i < batch_size; ++i) {
   13930:	cmp	r5, r0
      state_1_[i] = state_1[i];
      state_2_[i] = state_2[i];
   13932:	str	r3, [r0, #12]
        *out++ += s_out;
      } else {
        *out++ = s_out;
      }
    }
    for (int i = 0; i < batch_size; ++i) {
   13934:	bne.n	13924 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x2e4>
          mode_q,
          mode_a,
          in,
          out,
          size);
      ++batch_processor;
   13936:	ldr	r3, [sp, #4]
   13938:	adds	r3, #32
   1393a:	str	r3, [sp, #4]
    mode_q[batch_counter] = 1.0f + mode_frequency * q;
    mode_a[batch_counter] = mode_amplitude_[i] * mode_attenuation;
    ++batch_counter;
    
    if (batch_counter == kModeBatchSize) {
      batch_counter = 0;
   1393c:	movs	r3, #0
   1393e:	b.n	13798 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)+0x158>
   13940:	.word	0x42800000
   13944:	.word	0x429f6666
   13948:	.word	0x3e99999a
   1394c:	.word	0x3f59999a
   13950:	.word	0x3e19999a
   13954:	.word	0x43fa0000
   13958:	.word	0x20000d5c
   1395c:	.word	0x20000554
   13960:	.word	0x20000958
   13964:	.word	0x43000000
   13968:	.word	0x3f7ae148
   1396c:	.word	0x3f6e147b
   13970:	.word	0x3eff7cee
   13974:	.word	0x425f2649
   13978:	.word	0x4121ba8f
   1397c:	.word	0x40490fdb
   13980:	.word	0x3b031200
   13984:	.word	0x00000000

00013988 <plaits::ModalVoice::Init()>:
  ResonatorSvf() { }
  ~ResonatorSvf() { }
  
  void Init() {
    for (int i = 0; i < batch_size; ++i) {
      state_1_[i] = state_2_[i] = 0.0f;
   13988:	movs	r2, #0
   1398a:	mov	r3, r0
using namespace std;
using namespace stmlib;

void ModalVoice::Init() {
  excitation_filter_.Init();
  resonator_.Init(0.015f, kMaxNumModes);
   1398c:	movs	r1, #24
   1398e:	vldr	s0, [pc, #16]	; 139a0 <plaits::ModalVoice::Init()+0x18>
   13992:	str	r2, [r0, #4]
   13994:	str.w	r2, [r3], #8
   13998:	mov	r0, r3
   1399a:	b.w	13590 <plaits::Resonator::Init(float, int)>
   1399e:	nop
   139a0:	.word	0x3c75c28f

000139a4 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)>:
    float* out,
    float* aux,
    size_t size) {
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
   139a4:	vmov.f32	s14, #112	; 0x3f800000  1.0
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   139a8:	mov	ip, r2
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
   139aa:	vmov.f32	s15, #80	; 0x3e800000  0.250
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   139ae:	vmov.f32	s7, s1
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
   139b2:	vsub.f32	s13, s14, s3
   139b6:	vmul.f32	s15, s0, s15
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   139ba:	vmov.f32	s1, s2
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
   139be:	vsub.f32	s14, s14, s4
    float* out,
    float* aux,
    size_t size) {
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
   139c2:	vmov.f32	s2, s3
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   139c6:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   139ca:	ldr	r2, [sp, #28]
   139cc:	mov	r6, r3
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
   139ce:	vfma.f32	s2, s15, s13
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   139d2:	ldr	r4, [sp, #32]
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
   139d4:	vfma.f32	s4, s14, s15
    float brightness,
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
   139d8:	ldr	r3, [sp, #36]	; 0x24
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
  
  const float range = sustain ? 36.0f : 60.0f;
   139da:	cmp	r1, #0
   139dc:	beq.w	13c56 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2b2>
  const float f = sustain ? 4.0f * f0 : 2.0f * f0;
   139e0:	vmov.f32	s13, #16	; 0x40800000  4.0
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
  
  const float range = sustain ? 36.0f : 60.0f;
   139e4:	vldr	s10, [pc, #632]	; 13c60 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2bc>
  const float f = sustain ? 4.0f * f0 : 2.0f * f0;
   139e8:	vmul.f32	s13, s7, s13

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   139ec:	vmov.f32	s12, #0	; 0x40000000  2.0
   139f0:	vldr	s15, [pc, #624]	; 13c64 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2c0>
   139f4:	vmov.f32	s14, #224	; 0xbf000000 -0.5
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   139f8:	ldr.w	r9, [pc, #688]	; 13cac <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x308>
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   139fc:	ldr.w	r8, [pc, #688]	; 13cb0 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x30c>

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   13a00:	vsub.f32	s12, s12, s2
   13a04:	vldr	s11, [pc, #608]	; 13c68 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2c4>
   13a08:	vfma.f32	s14, s2, s12
   13a0c:	vfma.f32	s15, s14, s10
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   13a10:	vcvt.s32.f32	s14, s15

  return lut_pitch_ratio_high[pitch_integral] * \
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   13a14:	vcvt.f32.s32	s10, s14

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   13a18:	vmov	r5, s14
   13a1c:	add.w	r5, r9, r5, lsl #2
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   13a20:	vsub.f32	s15, s15, s10
  const float cutoff = min(
      f * SemitonesToRatio((brightness * (2.0f - brightness) - 0.5f) * range),
   13a24:	vldr	s12, [r5]
   13a28:	vcvt.s32.f32	s15, s15, #8
   13a2c:	vmov	r5, s15
   13a30:	add.w	r5, r8, r5, lsl #2
   13a34:	vldr	s14, [r5]
   13a38:	vmul.f32	s15, s14, s12
   13a3c:	vmul.f32	s15, s15, s13
   13a40:	vcmpe.f32	s15, s11
   13a44:	vmrs	APSR_nzcv, fpscr
   13a48:	bgt.w	13b96 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x1f2>
   13a4c:	vmul.f32	s14, s15, s15
   13a50:	vldr	s10, [pc, #536]	; 13c6c <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2c8>
   13a54:	vldr	s12, [pc, #536]	; 13c70 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2cc>
	return __b;
      return __a;
   13a58:	vmov.f32	s11, s15
   13a5c:	vldr	s13, [pc, #532]	; 13c74 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2d0>
   13a60:	vfma.f32	s12, s14, s10
   13a64:	vfma.f32	s13, s14, s12
   13a68:	vmul.f32	s13, s13, s15
   13a6c:	vmul.f32	s8, s13, s13
      0.499f);
  const float q = sustain ? 0.7f : 1.5f;
   13a70:	cmp	r1, #0
   13a72:	beq.w	13ba8 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x204>
    float damping,
    float* temp,
    float* out,
    float* aux,
    size_t size) {
  const float density = brightness * brightness;
   13a76:	vmul.f32	s3, s3, s3
      0.499f);
  const float q = sustain ? 0.7f : 1.5f;
  
  // Synthesize excitation signal.
  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
   13a7a:	vldr	s15, [pc, #508]	; 13c78 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2d4>
   13a7e:	vldr	s12, [pc, #508]	; 13c7c <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2d8>
   13a82:	vmul.f32	s15, s3, s15
   13a86:	vfma.f32	s12, s3, s15
    for (size_t i = 0; i < size; ++i) {
   13a8a:	cmp	r3, #0
   13a8c:	beq.n	13b82 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x1de>
   13a8e:	vmov.f32	s15, #112	; 0x3f800000  1.0
   13a92:	ldr.w	r9, [pc, #544]	; 13cb4 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x310>
   13a96:	vmov.f32	s14, #8	; 0x40400000  3.0
   13a9a:	lsls	r7, r3, #2
   13a9c:	vmov.f32	s11, #16	; 0x40800000  4.0
   13aa0:	ldr.w	r1, [r9]
   13aa4:	vdiv.f32	s9, s15, s12
   13aa8:	add.w	r8, r6, r7
   13aac:	mov	r5, r6
   13aae:	ldr.w	ip, [pc, #520]	; 13cb8 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x314>
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
   13ab2:	vldr	s10, [pc, #460]	; 13c80 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2dc>
   13ab6:	vfms.f32	s11, s12, s14
  static inline void Seed(uint32_t seed) {
    rng_state_ = seed;
  }

  static inline uint32_t GetWord() {
    rng_state_ = rng_state_ * 1664525L + 1013904223L;
   13aba:	mul.w	lr, ip, r1
   13abe:	ldr	r1, [pc, #452]	; (13c84 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2e0>)
  } else {
    return 0.0f;
   13ac0:	vldr	s15, [pc, #452]	; 13c88 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2e4>
   13ac4:	add	r1, lr
  static inline int16_t GetSample() {
    return static_cast<int16_t>(GetWord() >> 16);
  }

  static inline float GetFloat() {
    return static_cast<float>(GetWord()) / 4294967296.0f;
   13ac6:	vmov	s14, r1
   13aca:	vcvt.f32.u32	s14, s14
   13ace:	vmul.f32	s14, s14, s10
namespace plaits {

inline float Dust(float frequency) {
  float inv_frequency = 1.0f / frequency;
  float u = stmlib::Random::GetFloat();
  if (u < frequency) {
   13ad2:	vcmpe.f32	s12, s14
   13ad6:	vmrs	APSR_nzcv, fpscr
    return u * inv_frequency;
   13ada:	it	gt
   13adc:	vmulgt.f32	s15, s14, s9
      temp[i] = Dust(dust_f) * (4.0f - dust_f * 3.0f) * accent;
   13ae0:	vmul.f32	s15, s15, s11
   13ae4:	vmul.f32	s15, s15, s0
   13ae8:	vstmia	r5!, {s15}
  const float q = sustain ? 0.7f : 1.5f;
  
  // Synthesize excitation signal.
  if (sustain) {
    const float dust_f = 0.00005f + 0.99995f * density * density;
    for (size_t i = 0; i < size; ++i) {
   13aec:	cmp	r8, r5
   13aee:	bne.n	13aba <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x116>
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   13af0:	vmov.f32	s12, #112	; 0x3f800000  1.0
   13af4:	vldr	s15, [pc, #404]	; 13c8c <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2e8>
   13af8:	str.w	r1, [r9]
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13afc:	subs	r1, r3, #1
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
   13afe:	vadd.f32	s10, s13, s15
      state_1[i] = state_1_[i];
   13b02:	vldr	s11, [r0]
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   13b06:	vmov.f32	s14, s12
   13b0a:	vfma.f32	s14, s13, s15
   13b0e:	vmov.f32	s15, s14
      r_plus_g[i] = r[i] + g[i];
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
   13b12:	vldr	s14, [r0, #4]
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   13b16:	vadd.f32	s15, s15, s8
   13b1a:	vdiv.f32	s9, s12, s15
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   13b1e:	mov	r5, r6
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
      }
      if (add) {
        *out++ += s_out;
      } else {
        *out++ = s_out;
   13b20:	vldr	s8, [pc, #356]	; 13c88 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2e4>
   13b24:	vneg.f32	s10, s10
    
    while (size--) {
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
   13b28:	vldr	s15, [r5]
        const float bp = g[i] * hp + state_1[i];
   13b2c:	vmov.f32	s12, s11
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13b30:	subs	r1, #1
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
   13b32:	vfma.f32	s15, s10, s11
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13b36:	cmp.w	r1, #4294967295
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
   13b3a:	vsub.f32	s15, s15, s14
   13b3e:	vmul.f32	s15, s15, s9
        const float bp = g[i] * hp + state_1[i];
   13b42:	vfma.f32	s12, s15, s13
        state_1[i] = g[i] * hp + bp;
        const float lp = g[i] * bp + state_2[i];
   13b46:	vfma.f32	s14, s12, s13
      float s_in = *in++;
      float s_out = 0.0f;
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
        const float bp = g[i] * hp + state_1[i];
        state_1[i] = g[i] * hp + bp;
   13b4a:	vmov.f32	s11, s12
   13b4e:	vfma.f32	s11, s15, s13
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
      }
      if (add) {
        *out++ += s_out;
      } else {
        *out++ = s_out;
   13b52:	vadd.f32	s15, s14, s8
      for (int i = 0; i < batch_size; ++i) {
        const float hp = (s_in - r_plus_g[i] * state_1[i] - state_2[i]) * h[i];
        const float bp = g[i] * hp + state_1[i];
        state_1[i] = g[i] * hp + bp;
        const float lp = g[i] * bp + state_2[i];
        state_2[i] = g[i] * bp + lp;
   13b56:	vfma.f32	s14, s12, s13
        s_out += gains[i] * ((mode == stmlib::FILTER_MODE_LOW_PASS) ? lp : bp);
      }
      if (add) {
        *out++ += s_out;
      } else {
        *out++ = s_out;
   13b5a:	vstmia	r5!, {s15}
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13b5e:	bne.n	13b28 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x184>
   13b60:	mov	r1, r4
   13b62:	mov	r4, r6
      } else {
        *out++ = s_out;
      }
    }
    for (int i = 0; i < batch_size; ++i) {
      state_1_[i] = state_1[i];
   13b64:	vstr	s11, [r0]
   13b68:	adds	r5, r1, r7
      state_2_[i] = state_2[i];
   13b6a:	vstr	s14, [r0, #4]
  }
  const float one = 1.0f;
  excitation_filter_.Process<FILTER_MODE_LOW_PASS, false>(
      &cutoff, &q, &one, temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
    aux[i] += temp[i];
   13b6e:	vldmia	r4!, {s14}
   13b72:	vldr	s15, [r1]
   13b76:	vadd.f32	s15, s15, s14
   13b7a:	vstmia	r1!, {s15}
    }
  }
  const float one = 1.0f;
  excitation_filter_.Process<FILTER_MODE_LOW_PASS, false>(
      &cutoff, &q, &one, temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
   13b7e:	cmp	r1, r5
   13b80:	bne.n	13b6e <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x1ca>
    aux[i] += temp[i];
  }
  
  resonator_.Process(f0, structure, brightness, damping, temp, out, size);
   13b82:	mov	r1, r6
   13b84:	vmov.f32	s3, s4
   13b88:	vmov.f32	s0, s7
   13b8c:	adds	r0, #8
}
   13b8e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
      &cutoff, &q, &one, temp, temp, size);
  for (size_t i = 0; i < size; ++i) {
    aux[i] += temp[i];
  }
  
  resonator_.Process(f0, structure, brightness, damping, temp, out, size);
   13b92:	b.w	13640 <plaits::Resonator::Process(float, float, float, float, float const*, float*, unsigned int)>
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
   13b96:	vldr	s8, [pc, #248]	; 13c90 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2ec>
   13b9a:	vldr	s13, [pc, #248]	; 13c94 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2f0>
   13b9e:	vldr	s14, [pc, #248]	; 13c98 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2f4>
  const float range = sustain ? 36.0f : 60.0f;
  const float f = sustain ? 4.0f * f0 : 2.0f * f0;
  const float cutoff = min(
      f * SemitonesToRatio((brightness * (2.0f - brightness) - 0.5f) * range),
      0.499f);
  const float q = sustain ? 0.7f : 1.5f;
   13ba2:	cmp	r1, #0
   13ba4:	bne.w	13a76 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0xd2>
    const float dust_f = 0.00005f + 0.99995f * density * density;
    for (size_t i = 0; i < size; ++i) {
      temp[i] = Dust(dust_f) * (4.0f - dust_f * 3.0f) * accent;
    }
  } else {
    fill(&temp[0], &temp[size], 0.0f);
   13ba8:	lsls	r7, r3, #2
   13baa:	adds	r5, r6, r7
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   13bac:	cmp	r6, r5
   13bae:	beq.n	13bbe <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x21a>
   13bb0:	mov	r1, r6
	*__first = __tmp;
   13bb2:	mov.w	lr, #0
   13bb6:	str.w	lr, [r1], #4
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
   13bba:	cmp	r5, r1
   13bbc:	bne.n	13bb6 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x212>
    if (trigger) {
   13bbe:	cmp.w	ip, #0
   13bc2:	beq.n	13c28 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x284>
      const float attenuation = 1.0f - damping * 0.5f;
      const float amplitude = (0.12f + 0.08f * accent) * attenuation;
      temp[0] = amplitude * SemitonesToRatio(cutoff * cutoff * 24.0f) / cutoff;
   13bc4:	vmov.f32	s12, #112	; 0x3f800000  1.0

extern const float lut_pitch_ratio_high[257];
extern const float lut_pitch_ratio_low[257];

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
   13bc8:	vldr	s15, [pc, #152]	; 13c64 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2c0>
   13bcc:	vmov.f32	s5, #56	; 0x41c00000  24.0
   13bd0:	vldr	s6, [pc, #200]	; 13c9c <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2f8>
   13bd4:	vmov.f32	s10, #96	; 0x3f000000  0.5
   13bd8:	vldr	s9, [pc, #196]	; 13ca0 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x2fc>
   13bdc:	vfma.f32	s15, s14, s5
   13be0:	vmov.f32	s14, s12
   13be4:	vfma.f32	s9, s0, s6
   13be8:	vfms.f32	s14, s4, s10
  MAKE_INTEGRAL_FRACTIONAL(pitch)
   13bec:	vcvt.s32.f32	s10, s15

  return lut_pitch_ratio_high[pitch_integral] * \
   13bf0:	vmov	r1, s10
   13bf4:	vmul.f32	s12, s14, s9
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   13bf8:	vcvt.f32.s32	s14, s10

inline float SemitonesToRatio(float semitones) {
  float pitch = semitones + 128.0f;
  MAKE_INTEGRAL_FRACTIONAL(pitch)

  return lut_pitch_ratio_high[pitch_integral] * \
   13bfc:	add.w	r9, r9, r1, lsl #2
   13c00:	vldr	s10, [r9]
      lut_pitch_ratio_low[static_cast<int32_t>(pitch_fractional * 256.0f)];
   13c04:	vsub.f32	s15, s15, s14
   13c08:	vcvt.s32.f32	s15, s15, #8
   13c0c:	vmov	r1, s15
   13c10:	add.w	r8, r8, r1, lsl #2
   13c14:	vldr	s14, [r8]
   13c18:	vmul.f32	s15, s14, s10
   13c1c:	vmul.f32	s15, s15, s12
   13c20:	vdiv.f32	s14, s15, s11
   13c24:	vstr	s14, [r6]
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   13c28:	vmov.f32	s12, #112	; 0x3f800000  1.0
   13c2c:	vldr	s15, [pc, #116]	; 13ca4 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x300>
      r_plus_g[i] = r[i] + g[i];
      state_1[i] = state_1_[i];
   13c30:	vldr	s11, [r0]
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13c34:	subs	r1, r3, #1
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
      r_plus_g[i] = r[i] + g[i];
   13c36:	vadd.f32	s10, s13, s15
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
   13c3a:	vldr	s14, [r0, #4]
    float state_2[batch_size];
    float gains[batch_size];
    for (int i = 0; i < batch_size; ++i) {
      g[i] = stmlib::OnePole::tan<stmlib::FREQUENCY_FAST>(f[i]);
      r[i] = 1.0f / q[i];
      h[i] = 1.0f / (1.0f + r[i] * g[i] + g[i] * g[i]);
   13c3e:	vmov.f32	s9, s12
   13c42:	vfma.f32	s9, s13, s15
   13c46:	vadd.f32	s15, s9, s8
   13c4a:	vdiv.f32	s9, s12, s15
      state_1[i] = state_1_[i];
      state_2[i] = state_2_[i];
      gains[i] = gain[i];
    }
    
    while (size--) {
   13c4e:	cmp	r3, #0
   13c50:	bne.w	13b1e <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x17a>
   13c54:	b.n	13b82 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x1de>
  
  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
  
  const float range = sustain ? 36.0f : 60.0f;
  const float f = sustain ? 4.0f * f0 : 2.0f * f0;
   13c56:	vadd.f32	s13, s7, s7
  const float density = brightness * brightness;
  
  brightness += 0.25f * accent * (1.0f - brightness);
  damping += 0.25f * accent * (1.0f - damping);
  
  const float range = sustain ? 36.0f : 60.0f;
   13c5a:	vldr	s10, [pc, #76]	; 13ca8 <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x304>
   13c5e:	b.n	139ec <plaits::ModalVoice::Render(bool, bool, float, float, float, float, float, float*, float*, float*, unsigned int)+0x48>
   13c60:	.word	0x42100000
   13c64:	.word	0x43000000
   13c68:	.word	0x3eff7cee
   13c6c:	.word	0x425f2649
   13c70:	.word	0x4121ba8f
   13c74:	.word	0x40490fdb
   13c78:	.word	0x3f7ffcb9
   13c7c:	.word	0x3851b717
   13c80:	.word	0x2f800000
   13c84:	.word	0x3c6ef35f
   13c88:	.word	0x00000000
   13c8c:	.word	0x3fb6db6e
   13c90:	.word	0x41a59707
   13c94:	.word	0x40919638
   13c98:	.word	0x3e7efa1f
   13c9c:	.word	0x3da3d70a
   13ca0:	.word	0x3df5c28f
   13ca4:	.word	0x3f2aaaab
   13ca8:	.word	0x42700000
   13cac:	.word	0x20000554
   13cb0:	.word	0x20000958
   13cb4:	.word	0x20020470
   13cb8:	.word	0x0019660d

00013cbc <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
   13cbc:	push	{r4, lr}
   13cbe:	mov	r4, r0
		release();
   13cc0:	bl	17778 <DMAChannel::release()>
	}
   13cc4:	mov	r0, r4
   13cc6:	pop	{r4, pc}

00013cc8 <_GLOBAL__sub_I__ZN17AudioOutputI2SOct13block_ch1_1stE>:
uint16_t  AudioOutputI2SOct::ch6_offset = 0;
uint16_t  AudioOutputI2SOct::ch7_offset = 0;
uint16_t  AudioOutputI2SOct::ch8_offset = 0;
bool AudioOutputI2SOct::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
DMAChannel AudioOutputI2SOct::dma(false);
   13cc8:	ldr	r2, [pc, #8]	; (13cd4 <_GLOBAL__sub_I__ZN17AudioOutputI2SOct13block_ch1_1stE+0xc>)
   13cca:	ldr	r1, [pc, #12]	; (13cd8 <_GLOBAL__sub_I__ZN17AudioOutputI2SOct13block_ch1_1stE+0x10>)
   13ccc:	ldr	r0, [pc, #12]	; (13cdc <_GLOBAL__sub_I__ZN17AudioOutputI2SOct13block_ch1_1stE+0x14>)
   13cce:	b.w	1aa24 <__aeabi_atexit>
   13cd2:	nop
   13cd4:	.word	0x20020464
   13cd8:	.word	0x00013cbd
   13cdc:	.word	0x20057e14

00013ce0 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
   13ce0:	ldr	r2, [pc, #8]	; (13cec <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
   13ce2:	ldr	r1, [pc, #12]	; (13cf0 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
   13ce4:	ldr	r0, [pc, #12]	; (13cf4 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
   13ce6:	b.w	1aa24 <__aeabi_atexit>
   13cea:	nop
   13cec:	.word	0x20020464
   13cf0:	.word	0x00013cbd
   13cf4:	.word	0x20057e1c

00013cf8 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
   13cf8:	ldr	r2, [pc, #8]	; (13d04 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
   13cfa:	ldr	r1, [pc, #12]	; (13d08 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
   13cfc:	ldr	r0, [pc, #12]	; (13d0c <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
   13cfe:	b.w	1aa24 <__aeabi_atexit>
   13d02:	nop
   13d04:	.word	0x20020464
   13d08:	.word	0x00013cbd
   13d0c:	.word	0x20057e24

00013d10 <_GLOBAL__sub_I__ZN19AudioOutputPT8211_214block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211_2::dma(false);
   13d10:	ldr	r2, [pc, #8]	; (13d1c <_GLOBAL__sub_I__ZN19AudioOutputPT8211_214block_left_1stE+0xc>)
   13d12:	ldr	r1, [pc, #12]	; (13d20 <_GLOBAL__sub_I__ZN19AudioOutputPT8211_214block_left_1stE+0x10>)
   13d14:	ldr	r0, [pc, #12]	; (13d24 <_GLOBAL__sub_I__ZN19AudioOutputPT8211_214block_left_1stE+0x14>)
   13d16:	b.w	1aa24 <__aeabi_atexit>
   13d1a:	nop
   13d1c:	.word	0x20020464
   13d20:	.word	0x00013cbd
   13d24:	.word	0x20057e2c

00013d28 <AudioOutputI2S::isr()>:
#if defined(KINETISK) || defined(__IMXRT1062__)
	int16_t *dest;
	audio_block_t *blockL, *blockR;
	uint32_t saddr, offsetL, offsetR;

	saddr = (uint32_t)(dma.TCD->SADDR);
   13d28:	ldr	r3, [pc, #292]	; (13e50 <AudioOutputI2S::isr()+0x128>)
	dma.attachInterrupt(isr);
}


void AudioOutputI2S::isr(void)
{
   13d2a:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined(KINETISK) || defined(__IMXRT1062__)
	int16_t *dest;
	audio_block_t *blockL, *blockR;
	uint32_t saddr, offsetL, offsetR;

	saddr = (uint32_t)(dma.TCD->SADDR);
   13d2e:	ldr	r2, [r3, #0]
	dma.attachInterrupt(isr);
}


void AudioOutputI2S::isr(void)
{
   13d30:	sub	sp, #12
	audio_block_t *blockL, *blockR;
	uint32_t saddr, offsetL, offsetR;

	saddr = (uint32_t)(dma.TCD->SADDR);
	dma.clearInterrupt();
	if (saddr < (uint32_t)i2s_tx_buffer + sizeof(i2s_tx_buffer) / 2) {
   13d32:	ldr	r4, [pc, #288]	; (13e54 <AudioOutputI2S::isr()+0x12c>)
   13d34:	ldrb	r1, [r3, #4]
   13d36:	add.w	r5, r4, #256	; 0x100
#if defined(KINETISK) || defined(__IMXRT1062__)
	int16_t *dest;
	audio_block_t *blockL, *blockR;
	uint32_t saddr, offsetL, offsetR;

	saddr = (uint32_t)(dma.TCD->SADDR);
   13d3a:	ldr	r3, [r2, #0]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
   13d3c:	ldr	r2, [pc, #280]	; (13e58 <AudioOutputI2S::isr()+0x130>)
	dma.clearInterrupt();
	if (saddr < (uint32_t)i2s_tx_buffer + sizeof(i2s_tx_buffer) / 2) {
   13d3e:	cmp	r3, r5
   13d40:	strb	r1, [r2, #31]
   13d42:	bcs.n	13d58 <AudioOutputI2S::isr()+0x30>
		// DMA is transmitting the first half of the buffer
		// so we must fill the second half
		dest = (int16_t *)&i2s_tx_buffer[AUDIO_BLOCK_SAMPLES/2];
		if (AudioOutputI2S::update_responsibility) AudioStream::update_all();
   13d44:	ldr	r3, [pc, #276]	; (13e5c <AudioOutputI2S::isr()+0x134>)
   13d46:	ldrb	r3, [r3, #0]
   13d48:	cmp	r3, #0
   13d4a:	beq.n	13de6 <AudioOutputI2S::isr()+0xbe>
	void transmit(audio_block_t *block, unsigned char index = 0);
	audio_block_t * receiveReadOnly(unsigned int index = 0);
	audio_block_t * receiveWritable(unsigned int index = 0);
	static bool update_setup(void);
	static void update_stop(void);
	static void update_all(void) { NVIC_SET_PENDING(IRQ_SOFTWARE); }
   13d4c:	ldr	r3, [pc, #272]	; (13e60 <AudioOutputI2S::isr()+0x138>)
   13d4e:	movs	r2, #64	; 0x40
   13d50:	mov	r4, r5
   13d52:	add.w	r5, r5, #256	; 0x100
   13d56:	str	r2, [r3, #0]
		// DMA is transmitting the second half of the buffer
		// so we must fill the first half
		dest = (int16_t *)i2s_tx_buffer;
	}

	blockL = AudioOutputI2S::block_left_1st;
   13d58:	ldr	r3, [pc, #264]	; (13e64 <AudioOutputI2S::isr()+0x13c>)
	blockR = AudioOutputI2S::block_right_1st;
   13d5a:	ldr.w	fp, [pc, #280]	; 13e74 <AudioOutputI2S::isr()+0x14c>
		// DMA is transmitting the second half of the buffer
		// so we must fill the first half
		dest = (int16_t *)i2s_tx_buffer;
	}

	blockL = AudioOutputI2S::block_left_1st;
   13d5e:	ldr.w	r8, [r3]
	blockR = AudioOutputI2S::block_right_1st;
	offsetL = AudioOutputI2S::block_left_offset;
   13d62:	ldr.w	sl, [pc, #276]	; 13e78 <AudioOutputI2S::isr()+0x150>
	offsetR = AudioOutputI2S::block_right_offset;
   13d66:	ldr.w	r9, [pc, #276]	; 13e7c <AudioOutputI2S::isr()+0x154>
		// so we must fill the first half
		dest = (int16_t *)i2s_tx_buffer;
	}

	blockL = AudioOutputI2S::block_left_1st;
	blockR = AudioOutputI2S::block_right_1st;
   13d6a:	ldr.w	r3, [fp]
	offsetL = AudioOutputI2S::block_left_offset;
   13d6e:	ldrh.w	r6, [sl]
	offsetR = AudioOutputI2S::block_right_offset;
   13d72:	ldrh.w	r7, [r9]

	if (blockL && blockR) {
   13d76:	cmp.w	r8, #0
   13d7a:	beq.n	13d7e <AudioOutputI2S::isr()+0x56>
   13d7c:	cbnz	r3, 13dc8 <AudioOutputI2S::isr()+0xa0>
		memcpy_tointerleaveLR(dest, blockL->data + offsetL, blockR->data + offsetR);
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockL) {
   13d7e:	cmp.w	r8, #0
   13d82:	beq.n	13dee <AudioOutputI2S::isr()+0xc6>
		memcpy_tointerleaveL(dest, blockL->data + offsetL);
   13d84:	add.w	r1, r8, #4
   13d88:	mov	r0, r4
   13d8a:	str	r3, [sp, #4]
   13d8c:	add.w	r1, r1, r6, lsl #1
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
   13d90:	adds	r6, #64	; 0x40
	if (blockL && blockR) {
		memcpy_tointerleaveLR(dest, blockL->data + offsetL, blockR->data + offsetR);
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockL) {
		memcpy_tointerleaveL(dest, blockL->data + offsetL);
   13d92:	bl	154be <memcpy_tointerleaveL>
   13d96:	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
   13d98:	bic.w	r4, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
   13d9c:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
   13da0:	ldr	r2, [pc, #196]	; (13e68 <AudioOutputI2S::isr()+0x140>)
   13da2:	str	r4, [r2, #0]
		location += 32;
   13da4:	adds	r4, #32
	} while (location < end_addr);
   13da6:	cmp	r4, r5
   13da8:	bcc.n	13da2 <AudioOutputI2S::isr()+0x7a>
	asm("dsb");
   13daa:	dsb	sy
	asm("isb");
   13dae:	isb	sy
		memset(dest,0,AUDIO_BLOCK_SAMPLES * 2);
	}

	arm_dcache_flush_delete(dest, sizeof(i2s_tx_buffer) / 2 );

	if (offsetL < AUDIO_BLOCK_SAMPLES) {
   13db2:	cmp	r6, #127	; 0x7f
   13db4:	bhi.n	13e20 <AudioOutputI2S::isr()+0xf8>
		AudioOutputI2S::block_left_offset = offsetL;
   13db6:	strh.w	r6, [sl]
		AudioOutputI2S::block_left_offset = 0;
		AudioStream::release(blockL);
		AudioOutputI2S::block_left_1st = AudioOutputI2S::block_left_2nd;
		AudioOutputI2S::block_left_2nd = NULL;
	}
	if (offsetR < AUDIO_BLOCK_SAMPLES) {
   13dba:	cmp	r7, #127	; 0x7f
   13dbc:	bhi.n	13e04 <AudioOutputI2S::isr()+0xdc>
		AudioOutputI2S::block_right_offset = offsetR;
   13dbe:	strh.w	r7, [r9]
			*dest = 0;
			dest += 2;
		} while (dest < end);
	}
#endif
}
   13dc2:	add	sp, #12
   13dc4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	blockR = AudioOutputI2S::block_right_1st;
	offsetL = AudioOutputI2S::block_left_offset;
	offsetR = AudioOutputI2S::block_right_offset;

	if (blockL && blockR) {
		memcpy_tointerleaveLR(dest, blockL->data + offsetL, blockR->data + offsetR);
   13dc8:	adds	r2, r3, #4
   13dca:	add.w	r1, r8, #4
   13dce:	mov	r0, r4
   13dd0:	str	r3, [sp, #4]
   13dd2:	add.w	r2, r2, r7, lsl #1
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
   13dd6:	adds	r7, #64	; 0x40
	blockR = AudioOutputI2S::block_right_1st;
	offsetL = AudioOutputI2S::block_left_offset;
	offsetR = AudioOutputI2S::block_right_offset;

	if (blockL && blockR) {
		memcpy_tointerleaveLR(dest, blockL->data + offsetL, blockR->data + offsetR);
   13dd8:	add.w	r1, r1, r6, lsl #1
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
   13ddc:	adds	r6, #64	; 0x40
	blockR = AudioOutputI2S::block_right_1st;
	offsetL = AudioOutputI2S::block_left_offset;
	offsetR = AudioOutputI2S::block_right_offset;

	if (blockL && blockR) {
		memcpy_tointerleaveLR(dest, blockL->data + offsetL, blockR->data + offsetR);
   13dde:	bl	15480 <memcpy_tointerleaveLR>
   13de2:	ldr	r3, [sp, #4]
   13de4:	b.n	13d98 <AudioOutputI2S::isr()+0x70>
   13de6:	mov	r4, r5
   13de8:	add.w	r5, r5, #256	; 0x100
   13dec:	b.n	13d58 <AudioOutputI2S::isr()+0x30>
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockL) {
		memcpy_tointerleaveL(dest, blockL->data + offsetL);
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockR) {
   13dee:	cbz	r3, 13e3c <AudioOutputI2S::isr()+0x114>
		memcpy_tointerleaveR(dest, blockR->data + offsetR);
   13df0:	adds	r1, r3, #4
   13df2:	mov	r0, r4
   13df4:	str	r3, [sp, #4]
   13df6:	add.w	r1, r1, r7, lsl #1
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
   13dfa:	adds	r7, #64	; 0x40
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockL) {
		memcpy_tointerleaveL(dest, blockL->data + offsetL);
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockR) {
		memcpy_tointerleaveR(dest, blockR->data + offsetR);
   13dfc:	bl	154fe <memcpy_tointerleaveR>
   13e00:	ldr	r3, [sp, #4]
   13e02:	b.n	13d98 <AudioOutputI2S::isr()+0x70>
		AudioOutputI2S::block_left_2nd = NULL;
	}
	if (offsetR < AUDIO_BLOCK_SAMPLES) {
		AudioOutputI2S::block_right_offset = offsetR;
	} else {
		AudioOutputI2S::block_right_offset = 0;
   13e04:	movs	r4, #0
		AudioStream::release(blockR);
   13e06:	mov	r0, r3
		AudioOutputI2S::block_left_2nd = NULL;
	}
	if (offsetR < AUDIO_BLOCK_SAMPLES) {
		AudioOutputI2S::block_right_offset = offsetR;
	} else {
		AudioOutputI2S::block_right_offset = 0;
   13e08:	strh.w	r4, [r9]
		AudioStream::release(blockR);
   13e0c:	bl	17abc <AudioStream::release(audio_block_struct*)>
		AudioOutputI2S::block_right_1st = AudioOutputI2S::block_right_2nd;
   13e10:	ldr	r3, [pc, #88]	; (13e6c <AudioOutputI2S::isr()+0x144>)
   13e12:	ldr	r2, [r3, #0]
		AudioOutputI2S::block_right_2nd = NULL;
   13e14:	str	r4, [r3, #0]
	if (offsetR < AUDIO_BLOCK_SAMPLES) {
		AudioOutputI2S::block_right_offset = offsetR;
	} else {
		AudioOutputI2S::block_right_offset = 0;
		AudioStream::release(blockR);
		AudioOutputI2S::block_right_1st = AudioOutputI2S::block_right_2nd;
   13e16:	str.w	r2, [fp]
			*dest = 0;
			dest += 2;
		} while (dest < end);
	}
#endif
}
   13e1a:	add	sp, #12
   13e1c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	arm_dcache_flush_delete(dest, sizeof(i2s_tx_buffer) / 2 );

	if (offsetL < AUDIO_BLOCK_SAMPLES) {
		AudioOutputI2S::block_left_offset = offsetL;
	} else {
		AudioOutputI2S::block_left_offset = 0;
   13e20:	movs	r4, #0
		AudioStream::release(blockL);
   13e22:	mov	r0, r8
   13e24:	str	r3, [sp, #4]
	arm_dcache_flush_delete(dest, sizeof(i2s_tx_buffer) / 2 );

	if (offsetL < AUDIO_BLOCK_SAMPLES) {
		AudioOutputI2S::block_left_offset = offsetL;
	} else {
		AudioOutputI2S::block_left_offset = 0;
   13e26:	strh.w	r4, [sl]
		AudioStream::release(blockL);
   13e2a:	bl	17abc <AudioStream::release(audio_block_struct*)>
		AudioOutputI2S::block_left_1st = AudioOutputI2S::block_left_2nd;
   13e2e:	ldr	r2, [pc, #64]	; (13e70 <AudioOutputI2S::isr()+0x148>)
   13e30:	ldr	r3, [pc, #48]	; (13e64 <AudioOutputI2S::isr()+0x13c>)
   13e32:	ldr	r1, [r2, #0]
		AudioOutputI2S::block_left_2nd = NULL;
   13e34:	str	r4, [r2, #0]
	if (offsetL < AUDIO_BLOCK_SAMPLES) {
		AudioOutputI2S::block_left_offset = offsetL;
	} else {
		AudioOutputI2S::block_left_offset = 0;
		AudioStream::release(blockL);
		AudioOutputI2S::block_left_1st = AudioOutputI2S::block_left_2nd;
   13e36:	str	r1, [r3, #0]
   13e38:	ldr	r3, [sp, #4]
   13e3a:	b.n	13dba <AudioOutputI2S::isr()+0x92>
		offsetL += AUDIO_BLOCK_SAMPLES / 2;
	} else if (blockR) {
		memcpy_tointerleaveR(dest, blockR->data + offsetR);
		offsetR += AUDIO_BLOCK_SAMPLES / 2;
	} else {
		memset(dest,0,AUDIO_BLOCK_SAMPLES * 2);
   13e3c:	mov	r1, r3
   13e3e:	mov.w	r2, #256	; 0x100
   13e42:	mov	r0, r4
   13e44:	str	r3, [sp, #4]
   13e46:	bl	1b018 <memset>
   13e4a:	ldr	r3, [sp, #4]
   13e4c:	b.n	13d98 <AudioOutputI2S::isr()+0x70>
   13e4e:	nop
   13e50:	.word	0x20057e38
   13e54:	.word	0x20200220
   13e58:	.word	0x400e8000
   13e5c:	.word	0x20057e50
   13e60:	.word	0xe000e208
   13e64:	.word	0x20057e48
   13e68:	.word	0xe000ef70
   13e6c:	.word	0x20057e4c
   13e70:	.word	0x20057e54
   13e74:	.word	0x20057e40
   13e78:	.word	0x20057e34
   13e7c:	.word	0x20057e44

00013e80 <AudioOutputI2S::update()>:




void AudioOutputI2S::update(void)
{
   13e80:	push	{r3, r4, r5, r6, r7, lr}
	//if (!active) return;
	//audio_block_t *block = receiveReadOnly();
	//if (block) release(block);

	audio_block_t *block;
	block = receiveReadOnly(0); // input 0 = left channel
   13e82:	movs	r1, #0




void AudioOutputI2S::update(void)
{
   13e84:	mov	r4, r0
	//if (!active) return;
	//audio_block_t *block = receiveReadOnly();
	//if (block) release(block);

	audio_block_t *block;
	block = receiveReadOnly(0); // input 0 = left channel
   13e86:	bl	17b44 <AudioStream::receiveReadOnly(unsigned int)>
	if (block) {
   13e8a:	cbz	r0, 13eae <AudioOutputI2S::update()+0x2e>
		__disable_irq();
   13e8c:	cpsid	i
		if (block_left_1st == NULL) {
   13e8e:	ldr	r2, [pc, #112]	; (13f00 <AudioOutputI2S::update()+0x80>)
   13e90:	ldr	r3, [r2, #0]
   13e92:	cmp	r3, #0
   13e94:	beq.n	13eea <AudioOutputI2S::update()+0x6a>
			block_left_1st = block;
			block_left_offset = 0;
			__enable_irq();
		} else if (block_left_2nd == NULL) {
   13e96:	ldr	r1, [pc, #108]	; (13f04 <AudioOutputI2S::update()+0x84>)
   13e98:	ldr	r5, [r1, #0]
   13e9a:	cbz	r5, 13ede <AudioOutputI2S::update()+0x5e>
			__enable_irq();
		} else {
			audio_block_t *tmp = block_left_1st;
			block_left_1st = block_left_2nd;
			block_left_2nd = block;
			block_left_offset = 0;
   13e9c:	ldr	r6, [pc, #104]	; (13f08 <AudioOutputI2S::update()+0x88>)
   13e9e:	movs	r7, #0
		} else if (block_left_2nd == NULL) {
			block_left_2nd = block;
			__enable_irq();
		} else {
			audio_block_t *tmp = block_left_1st;
			block_left_1st = block_left_2nd;
   13ea0:	str	r5, [r2, #0]
			block_left_2nd = block;
   13ea2:	str	r0, [r1, #0]
			block_left_offset = 0;
   13ea4:	strh	r7, [r6, #0]
			__enable_irq();
   13ea6:	cpsie	i
			release(tmp);
   13ea8:	mov	r0, r3
   13eaa:	bl	17abc <AudioStream::release(audio_block_struct*)>
		}
	}
	block = receiveReadOnly(1); // input 1 = right channel
   13eae:	mov	r0, r4
   13eb0:	movs	r1, #1
   13eb2:	bl	17b44 <AudioStream::receiveReadOnly(unsigned int)>
	if (block) {
   13eb6:	cbz	r0, 13edc <AudioOutputI2S::update()+0x5c>
		__disable_irq();
   13eb8:	cpsid	i
		if (block_right_1st == NULL) {
   13eba:	ldr	r2, [pc, #80]	; (13f0c <AudioOutputI2S::update()+0x8c>)
   13ebc:	ldr	r3, [r2, #0]
   13ebe:	cbz	r3, 13ef4 <AudioOutputI2S::update()+0x74>
			block_right_1st = block;
			block_right_offset = 0;
			__enable_irq();
		} else if (block_right_2nd == NULL) {
   13ec0:	ldr	r1, [pc, #76]	; (13f10 <AudioOutputI2S::update()+0x90>)
   13ec2:	ldr	r4, [r1, #0]
   13ec4:	cbz	r4, 13ee4 <AudioOutputI2S::update()+0x64>
			__enable_irq();
		} else {
			audio_block_t *tmp = block_right_1st;
			block_right_1st = block_right_2nd;
			block_right_2nd = block;
			block_right_offset = 0;
   13ec6:	ldr	r5, [pc, #76]	; (13f14 <AudioOutputI2S::update()+0x94>)
   13ec8:	movs	r6, #0
		} else if (block_right_2nd == NULL) {
			block_right_2nd = block;
			__enable_irq();
		} else {
			audio_block_t *tmp = block_right_1st;
			block_right_1st = block_right_2nd;
   13eca:	str	r4, [r2, #0]
			block_right_2nd = block;
   13ecc:	str	r0, [r1, #0]
			block_right_offset = 0;
   13ece:	strh	r6, [r5, #0]
			__enable_irq();
   13ed0:	cpsie	i
			release(tmp);
   13ed2:	mov	r0, r3
		}
	}
}
   13ed4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			audio_block_t *tmp = block_right_1st;
			block_right_1st = block_right_2nd;
			block_right_2nd = block;
			block_right_offset = 0;
			__enable_irq();
			release(tmp);
   13ed8:	b.w	17abc <AudioStream::release(audio_block_struct*)>
   13edc:	pop	{r3, r4, r5, r6, r7, pc}
		if (block_left_1st == NULL) {
			block_left_1st = block;
			block_left_offset = 0;
			__enable_irq();
		} else if (block_left_2nd == NULL) {
			block_left_2nd = block;
   13ede:	str	r0, [r1, #0]
			__enable_irq();
   13ee0:	cpsie	i
   13ee2:	b.n	13eae <AudioOutputI2S::update()+0x2e>
		if (block_right_1st == NULL) {
			block_right_1st = block;
			block_right_offset = 0;
			__enable_irq();
		} else if (block_right_2nd == NULL) {
			block_right_2nd = block;
   13ee4:	str	r0, [r1, #0]
			__enable_irq();
   13ee6:	cpsie	i
   13ee8:	pop	{r3, r4, r5, r6, r7, pc}
	block = receiveReadOnly(0); // input 0 = left channel
	if (block) {
		__disable_irq();
		if (block_left_1st == NULL) {
			block_left_1st = block;
			block_left_offset = 0;
   13eea:	ldr	r1, [pc, #28]	; (13f08 <AudioOutputI2S::update()+0x88>)
	audio_block_t *block;
	block = receiveReadOnly(0); // input 0 = left channel
	if (block) {
		__disable_irq();
		if (block_left_1st == NULL) {
			block_left_1st = block;
   13eec:	str	r0, [r2, #0]
			block_left_offset = 0;
   13eee:	strh	r3, [r1, #0]
			__enable_irq();
   13ef0:	cpsie	i
   13ef2:	b.n	13eae <AudioOutputI2S::update()+0x2e>
	block = receiveReadOnly(1); // input 1 = right channel
	if (block) {
		__disable_irq();
		if (block_right_1st == NULL) {
			block_right_1st = block;
			block_right_offset = 0;
   13ef4:	ldr	r1, [pc, #28]	; (13f14 <AudioOutputI2S::update()+0x94>)
	}
	block = receiveReadOnly(1); // input 1 = right channel
	if (block) {
		__disable_irq();
		if (block_right_1st == NULL) {
			block_right_1st = block;
   13ef6:	str	r0, [r2, #0]
			block_right_offset = 0;
   13ef8:	strh	r3, [r1, #0]
			__enable_irq();
   13efa:	cpsie	i
   13efc:	pop	{r3, r4, r5, r6, r7, pc}
   13efe:	nop
   13f00:	.word	0x20057e48
   13f04:	.word	0x20057e54
   13f08:	.word	0x20057e34
   13f0c:	.word	0x20057e40
   13f10:	.word	0x20057e4c
   13f14:	.word	0x20057e44

00013f18 <AudioOutputI2S::config_i2s()>:
#endif
#endif


void AudioOutputI2S::config_i2s(void)
{
   13f18:	push	{r3, r4, r5, r6, r7, lr}
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
	CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK

#elif defined(__IMXRT1062__)

	CCM_CCGR5 |= CCM_CCGR5_SAI1(CCM_CCGR_ON);
   13f1a:	ldr	r5, [pc, #160]	; (13fbc <AudioOutputI2S::config_i2s()+0xa4>)

	// if either transmitter or receiver is enabled, do nothing
	if (I2S1_TCSR & I2S_TCSR_TE) return;
   13f1c:	ldr	r4, [pc, #160]	; (13fc0 <AudioOutputI2S::config_i2s()+0xa8>)
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
	CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK

#elif defined(__IMXRT1062__)

	CCM_CCGR5 |= CCM_CCGR5_SAI1(CCM_CCGR_ON);
   13f1e:	ldr	r3, [r5, #124]	; 0x7c
   13f20:	orr.w	r3, r3, #786432	; 0xc0000
   13f24:	str	r3, [r5, #124]	; 0x7c

	// if either transmitter or receiver is enabled, do nothing
	if (I2S1_TCSR & I2S_TCSR_TE) return;
   13f26:	ldr	r3, [r4, #8]
   13f28:	cmp	r3, #0
   13f2a:	blt.n	13fb8 <AudioOutputI2S::config_i2s()+0xa0>
	if (I2S1_RCSR & I2S_RCSR_RE) return;
   13f2c:	ldr.w	r3, [r4, #136]	; 0x88
   13f30:	cmp	r3, #0
   13f32:	blt.n	13fb8 <AudioOutputI2S::config_i2s()+0xa0>

	double C = ((double)fs * 256 * n1 * n2) / 24000000;
	int c0 = C;
	int c2 = 10000;
	int c1 = C * c2 - (c0 * c2);
	set_audioClock(c0, c1, c2);
   13f34:	movs	r3, #0
   13f36:	movw	r2, #10000	; 0x2710
   13f3a:	mov.w	r1, #6720	; 0x1a40
   13f3e:	movs	r0, #28
   13f40:	bl	1b3f8 <___Z14set_audioClockilmb_veneer>

	// clear SAI1_CLK register locations
	CCM_CSCMR1 = (CCM_CSCMR1 & ~(CCM_CSCMR1_SAI1_CLK_SEL_MASK))
   13f44:	ldr	r1, [r5, #28]
		   | CCM_CSCMR1_SAI1_CLK_SEL(2); // &0x03 // (0,1,2): PLL3PFD0, PLL5, PLL4
	CCM_CS1CDR = (CCM_CS1CDR & ~(CCM_CS1CDR_SAI1_CLK_PRED_MASK | CCM_CS1CDR_SAI1_CLK_PODF_MASK))
		   | CCM_CS1CDR_SAI1_CLK_PRED(n1-1) // &0x07
		   | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f
   13f46:	ldr	r2, [pc, #124]	; (13fc4 <AudioOutputI2S::config_i2s()+0xac>)
	// Select MCLK
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
		& ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
		| (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));

	CORE_PIN23_CONFIG = 3;  //1:MCLK
   13f48:	movs	r6, #3
	int c1 = C * c2 - (c0 * c2);
	set_audioClock(c0, c1, c2);

	// clear SAI1_CLK register locations
	CCM_CSCMR1 = (CCM_CSCMR1 & ~(CCM_CSCMR1_SAI1_CLK_SEL_MASK))
		   | CCM_CSCMR1_SAI1_CLK_SEL(2); // &0x03 // (0,1,2): PLL3PFD0, PLL5, PLL4
   13f4a:	bic.w	r1, r1, #3072	; 0xc00
	CCM_CS1CDR = (CCM_CS1CDR & ~(CCM_CS1CDR_SAI1_CLK_PRED_MASK | CCM_CS1CDR_SAI1_CLK_PODF_MASK))
		   | CCM_CS1CDR_SAI1_CLK_PRED(n1-1) // &0x07
		   | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f

	// Select MCLK
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
   13f4e:	ldr.w	lr, [pc, #144]	; 13fe0 <AudioOutputI2S::config_i2s()+0xc8>
		& ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
		| (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));
   13f52:	ldr	r3, [pc, #116]	; (13fc8 <AudioOutputI2S::config_i2s()+0xb0>)
	CORE_PIN20_CONFIG = 3;  //1:RX_SYNC

	int rsync = 0;
	int tsync = 1;

	I2S1_TMR = 0;
   13f54:	movs	r7, #0
	int c1 = C * c2 - (c0 * c2);
	set_audioClock(c0, c1, c2);

	// clear SAI1_CLK register locations
	CCM_CSCMR1 = (CCM_CSCMR1 & ~(CCM_CSCMR1_SAI1_CLK_SEL_MASK))
		   | CCM_CSCMR1_SAI1_CLK_SEL(2); // &0x03 // (0,1,2): PLL3PFD0, PLL5, PLL4
   13f56:	orr.w	r1, r1, #2048	; 0x800
	// Select MCLK
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
		& ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
		| (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));

	CORE_PIN23_CONFIG = 3;  //1:MCLK
   13f5a:	ldr	r0, [pc, #112]	; (13fcc <AudioOutputI2S::config_i2s()+0xb4>)
	int rsync = 0;
	int tsync = 1;

	I2S1_TMR = 0;
	//I2S1_TCSR = (1<<25); //Reset
	I2S1_TCR1 = I2S_TCR1_RFW(1);
   13f5c:	mov.w	ip, #1
	int c1 = C * c2 - (c0 * c2);
	set_audioClock(c0, c1, c2);

	// clear SAI1_CLK register locations
	CCM_CSCMR1 = (CCM_CSCMR1 & ~(CCM_CSCMR1_SAI1_CLK_SEL_MASK))
		   | CCM_CSCMR1_SAI1_CLK_SEL(2); // &0x03 // (0,1,2): PLL3PFD0, PLL5, PLL4
   13f60:	str	r1, [r5, #28]
	CCM_CS1CDR = (CCM_CS1CDR & ~(CCM_CS1CDR_SAI1_CLK_PRED_MASK | CCM_CS1CDR_SAI1_CLK_PODF_MASK))
   13f62:	ldr	r1, [r5, #40]	; 0x28
		   | CCM_CS1CDR_SAI1_CLK_PRED(n1-1) // &0x07
		   | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f
   13f64:	ands	r2, r1
	I2S1_TMR = 0;
	//I2S1_TCSR = (1<<25); //Reset
	I2S1_TCR1 = I2S_TCR1_RFW(1);
	I2S1_TCR2 = I2S_TCR2_SYNC(tsync) | I2S_TCR2_BCP // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((1)) | I2S_TCR2_MSEL(1));
	I2S1_TCR3 = I2S_TCR3_TCE;
   13f66:	mov.w	r1, #65536	; 0x10000
	// clear SAI1_CLK register locations
	CCM_CSCMR1 = (CCM_CSCMR1 & ~(CCM_CSCMR1_SAI1_CLK_SEL_MASK))
		   | CCM_CSCMR1_SAI1_CLK_SEL(2); // &0x03 // (0,1,2): PLL3PFD0, PLL5, PLL4
	CCM_CS1CDR = (CCM_CS1CDR & ~(CCM_CS1CDR_SAI1_CLK_PRED_MASK | CCM_CS1CDR_SAI1_CLK_PODF_MASK))
		   | CCM_CS1CDR_SAI1_CLK_PRED(n1-1) // &0x07
		   | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f
   13f6a:	orr.w	r2, r2, #205	; 0xcd
   13f6e:	str	r2, [r5, #40]	; 0x28

	// Select MCLK
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
   13f70:	ldr.w	r2, [lr, #4]

	I2S1_TMR = 0;
	//I2S1_TCSR = (1<<25); //Reset
	I2S1_TCR1 = I2S_TCR1_RFW(1);
	I2S1_TCR2 = I2S_TCR2_SYNC(tsync) | I2S_TCR2_BCP // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((1)) | I2S_TCR2_MSEL(1));
   13f74:	ldr	r5, [pc, #88]	; (13fd0 <AudioOutputI2S::config_i2s()+0xb8>)
		   | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f

	// Select MCLK
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
		& ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
		| (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));
   13f76:	ands	r3, r2
	I2S1_TCR1 = I2S_TCR1_RFW(1);
	I2S1_TCR2 = I2S_TCR2_SYNC(tsync) | I2S_TCR2_BCP // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((1)) | I2S_TCR2_MSEL(1));
	I2S1_TCR3 = I2S_TCR3_TCE;
	I2S1_TCR4 = I2S_TCR4_FRSZ((2-1)) | I2S_TCR4_SYWD((32-1)) | I2S_TCR4_MF
		    | I2S_TCR4_FSD | I2S_TCR4_FSE | I2S_TCR4_FSP;
   13f78:	ldr	r2, [pc, #88]	; (13fd4 <AudioOutputI2S::config_i2s()+0xbc>)
		   | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f

	// Select MCLK
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
		& ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
		| (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));
   13f7a:	orr.w	r3, r3, #524288	; 0x80000
   13f7e:	str.w	r3, [lr, #4]

	CORE_PIN23_CONFIG = 3;  //1:MCLK
   13f82:	str.w	r6, [r0, #288]	; 0x120
	I2S1_TCR2 = I2S_TCR2_SYNC(tsync) | I2S_TCR2_BCP // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((1)) | I2S_TCR2_MSEL(1));
	I2S1_TCR3 = I2S_TCR3_TCE;
	I2S1_TCR4 = I2S_TCR4_FRSZ((2-1)) | I2S_TCR4_SYWD((32-1)) | I2S_TCR4_MF
		    | I2S_TCR4_FSD | I2S_TCR4_FSE | I2S_TCR4_FSP;
	I2S1_TCR5 = I2S_TCR5_WNW((32-1)) | I2S_TCR5_W0W((32-1)) | I2S_TCR5_FBT((32-1));
   13f86:	ldr	r3, [pc, #80]	; (13fd8 <AudioOutputI2S::config_i2s()+0xc0>)
	IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
		& ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
		| (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));

	CORE_PIN23_CONFIG = 3;  //1:MCLK
	CORE_PIN21_CONFIG = 3;  //1:RX_BCLK
   13f88:	str.w	r6, [r0, #296]	; 0x128
	CORE_PIN20_CONFIG = 3;  //1:RX_SYNC
   13f8c:	str.w	r6, [r0, #292]	; 0x124

	I2S1_RMR = 0;
	//I2S1_RCSR = (1<<25); //Reset
	I2S1_RCR1 = I2S_RCR1_RFW(1);
	I2S1_RCR2 = I2S_RCR2_SYNC(rsync) | I2S_RCR2_BCP  // sync=0; rx is async;
		    | (I2S_RCR2_BCD | I2S_RCR2_DIV((1)) | I2S_RCR2_MSEL(1));
   13f90:	ldr	r0, [pc, #72]	; (13fdc <AudioOutputI2S::config_i2s()+0xc4>)
	CORE_PIN20_CONFIG = 3;  //1:RX_SYNC

	int rsync = 0;
	int tsync = 1;

	I2S1_TMR = 0;
   13f92:	str	r7, [r4, #96]	; 0x60
	//I2S1_TCSR = (1<<25); //Reset
	I2S1_TCR1 = I2S_TCR1_RFW(1);
   13f94:	str.w	ip, [r4, #12]
	I2S1_TCR2 = I2S_TCR2_SYNC(tsync) | I2S_TCR2_BCP // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((1)) | I2S_TCR2_MSEL(1));
   13f98:	str	r5, [r4, #16]
	I2S1_TCR3 = I2S_TCR3_TCE;
   13f9a:	str	r1, [r4, #20]
	I2S1_TCR4 = I2S_TCR4_FRSZ((2-1)) | I2S_TCR4_SYWD((32-1)) | I2S_TCR4_MF
		    | I2S_TCR4_FSD | I2S_TCR4_FSE | I2S_TCR4_FSP;
   13f9c:	str	r2, [r4, #24]
	I2S1_TCR5 = I2S_TCR5_WNW((32-1)) | I2S_TCR5_W0W((32-1)) | I2S_TCR5_FBT((32-1));
   13f9e:	str	r3, [r4, #28]

	I2S1_RMR = 0;
   13fa0:	str.w	r7, [r4, #224]	; 0xe0
	//I2S1_RCSR = (1<<25); //Reset
	I2S1_RCR1 = I2S_RCR1_RFW(1);
   13fa4:	str.w	ip, [r4, #140]	; 0x8c
	I2S1_RCR2 = I2S_RCR2_SYNC(rsync) | I2S_RCR2_BCP  // sync=0; rx is async;
		    | (I2S_RCR2_BCD | I2S_RCR2_DIV((1)) | I2S_RCR2_MSEL(1));
   13fa8:	str.w	r0, [r4, #144]	; 0x90
	I2S1_RCR3 = I2S_RCR3_RCE;
   13fac:	str.w	r1, [r4, #148]	; 0x94
	I2S1_RCR4 = I2S_RCR4_FRSZ((2-1)) | I2S_RCR4_SYWD((32-1)) | I2S_RCR4_MF
		    | I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
   13fb0:	str.w	r2, [r4, #152]	; 0x98
	I2S1_RCR5 = I2S_RCR5_WNW((32-1)) | I2S_RCR5_W0W((32-1)) | I2S_RCR5_FBT((32-1));
   13fb4:	str.w	r3, [r4, #156]	; 0x9c
   13fb8:	pop	{r3, r4, r5, r6, r7, pc}
   13fba:	nop
   13fbc:	.word	0x400fc000
   13fc0:	.word	0x40384000
   13fc4:	.word	0xfffffe00
   13fc8:	.word	0xfff7fff8
   13fcc:	.word	0x401f8000
   13fd0:	.word	0x47000001
   13fd4:	.word	0x00011f1b
   13fd8:	.word	0x1f1f1f00
   13fdc:	.word	0x07000001
   13fe0:	.word	0x400ac000

00013fe4 <AudioOutputI2S::begin()>:
#if defined(__IMXRT1062__)
#include "utility/imxrt_hw.h"
#endif

void AudioOutputI2S::begin(void)
{
   13fe4:	push	{r3, r4, r5, r6, r7, lr}
	dma.begin(true); // Allocate the DMA channel first
   13fe6:	ldr	r4, [pc, #156]	; (14084 <AudioOutputI2S::begin()+0xa0>)
   13fe8:	movs	r1, #1

	block_left_1st = NULL;
   13fea:	movs	r5, #0
	I2S0_TCSR = I2S_TCSR_SR;
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
	dma.TCD->SADDR = i2s_tx_buffer;
   13fec:	ldr	r6, [pc, #152]	; (14088 <AudioOutputI2S::begin()+0xa4>)
#include "utility/imxrt_hw.h"
#endif

void AudioOutputI2S::begin(void)
{
	dma.begin(true); // Allocate the DMA channel first
   13fee:	mov	r0, r4
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->DLASTSGA = 0;
	dma.TCD->BITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.TCD->DADDR = (void *)((uint32_t)&I2S1_TDR0 + 2);
   13ff0:	ldr	r7, [pc, #152]	; (1408c <AudioOutputI2S::begin()+0xa8>)
#include "utility/imxrt_hw.h"
#endif

void AudioOutputI2S::begin(void)
{
	dma.begin(true); // Allocate the DMA channel first
   13ff2:	bl	176d8 <DMAChannel::begin(bool)>

	block_left_1st = NULL;
   13ff6:	ldr	r2, [pc, #152]	; (14090 <AudioOutputI2S::begin()+0xac>)
	block_right_1st = NULL;
   13ff8:	ldr	r3, [pc, #152]	; (14094 <AudioOutputI2S::begin()+0xb0>)

void AudioOutputI2S::begin(void)
{
	dma.begin(true); // Allocate the DMA channel first

	block_left_1st = NULL;
   13ffa:	str	r5, [r2, #0]
	block_right_1st = NULL;
   13ffc:	str	r5, [r3, #0]

	config_i2s();
   13ffe:	bl	13f18 <AudioOutputI2S::config_i2s()>

	I2S0_TCSR = I2S_TCSR_SR;
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
   14002:	ldr	r3, [pc, #148]	; (14098 <AudioOutputI2S::begin()+0xb4>)
   14004:	movs	r2, #3
	dma.TCD->SADDR = i2s_tx_buffer;
	dma.TCD->SOFF = 2;
   14006:	movs	r0, #2
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
   14008:	movw	r1, #257	; 0x101

	I2S0_TCSR = I2S_TCSR_SR;
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
   1400c:	str.w	r2, [r3, #384]	; 0x180
	dma.TCD->SOFF = 2;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
   14010:	mov.w	r2, #256	; 0x100
	I2S0_TCSR = I2S_TCSR_SR;
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
	dma.TCD->SADDR = i2s_tx_buffer;
   14014:	ldr	r3, [r4, #0]
	dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->DLASTSGA = 0;
	dma.TCD->BITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
   14016:	mov.w	lr, #6
	I2S0_TCSR = I2S_TCSR_SR;
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
	dma.TCD->SADDR = i2s_tx_buffer;
   1401a:	str	r6, [r3, #0]
	dma.TCD->SOFF = 2;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
   1401c:	ldr	r6, [pc, #124]	; (1409c <AudioOutputI2S::begin()+0xb8>)
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
   1401e:	strh	r2, [r3, #22]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
	dma.TCD->SADDR = i2s_tx_buffer;
	dma.TCD->SOFF = 2;
   14020:	strh	r0, [r3, #4]
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->DLASTSGA = 0;
	dma.TCD->BITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
   14022:	strh	r2, [r3, #30]

#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
	dma.TCD->SADDR = i2s_tx_buffer;
	dma.TCD->SOFF = 2;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
   14024:	strh	r1, [r3, #6]
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
   14026:	str	r6, [r3, #12]
	// trigger moves a single data unit, which is typically 8, 16 or
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint32_t *mux = &DMAMUX_CHCFG0 + channel;
   14028:	ldrb	r1, [r4, #4]
   1402a:	ldr	r2, [pc, #116]	; (140a0 <AudioOutputI2S::begin()+0xbc>)
		//mux = (volatile uint32_t *)&(DMAMUX_CHCFG0) + channel;
		*mux = 0;
		*mux = (source & 0x7F) | DMAMUX_CHCFG_ENBL;
   1402c:	ldr	r6, [pc, #116]	; (140a4 <AudioOutputI2S::begin()+0xc0>)
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->DLASTSGA = 0;
	dma.TCD->BITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
   1402e:	strh.w	lr, [r3, #28]
#elif defined(__IMXRT1062__)
	CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
	dma.TCD->SADDR = i2s_tx_buffer;
	dma.TCD->SOFF = 2;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
   14032:	str	r0, [r3, #8]
	dma.TCD->DOFF = 0;
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->DLASTSGA = 0;
	dma.TCD->BITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.TCD->DADDR = (void *)((uint32_t)&I2S1_TDR0 + 2);
   14034:	str	r7, [r3, #16]
	dma.TCD->SADDR = i2s_tx_buffer;
	dma.TCD->SOFF = 2;
	dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
	dma.TCD->NBYTES_MLNO = 2;
	dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
	dma.TCD->DOFF = 0;
   14036:	strh	r5, [r3, #20]
	dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
	dma.TCD->DLASTSGA = 0;
   14038:	str	r5, [r3, #24]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
   1403a:	ldr	r0, [pc, #108]	; (140a8 <AudioOutputI2S::begin()+0xc4>)

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint32_t *mux = &DMAMUX_CHCFG0 + channel;
		//mux = (volatile uint32_t *)&(DMAMUX_CHCFG0) + channel;
		*mux = 0;
   1403c:	str.w	r5, [r2, r1, lsl #2]
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.TCD->DADDR = (void *)((uint32_t)&I2S1_TDR0 + 2);
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_SAI1_TX);
	dma.enable();

	I2S1_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE;
   14040:	ldr	r3, [pc, #104]	; (140ac <AudioOutputI2S::begin()+0xc8>)
		*mux = (source & 0x7F) | DMAMUX_CHCFG_ENBL;
   14042:	str.w	r6, [r2, r1, lsl #2]
   14046:	ldrb	r2, [r4, #4]
	I2S1_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
   14048:	ldr	r1, [pc, #100]	; (140b0 <AudioOutputI2S::begin()+0xcc>)
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
   1404a:	strb	r2, [r0, #27]
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.TCD->DADDR = (void *)((uint32_t)&I2S1_TDR0 + 2);
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_SAI1_TX);
	dma.enable();

	I2S1_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE;
   1404c:	ldr.w	r2, [r3, #136]	; 0x88
	I2S1_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
#endif
	update_responsibility = update_setup();
   14050:	ldr	r7, [pc, #96]	; (140b4 <AudioOutputI2S::begin()+0xd0>)
	dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
	dma.TCD->DADDR = (void *)((uint32_t)&I2S1_TDR0 + 2);
	dma.triggerAtHardwareEvent(DMAMUX_SOURCE_SAI1_TX);
	dma.enable();

	I2S1_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE;
   14052:	orr.w	r2, r2, #2415919104	; 0x90000000

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
   14056:	ldr	r6, [pc, #96]	; (140b8 <AudioOutputI2S::begin()+0xd4>)
   14058:	str.w	r2, [r3, #136]	; 0x88
	I2S1_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
   1405c:	str	r1, [r3, #8]
#endif
	update_responsibility = update_setup();
   1405e:	bl	17bc4 <AudioStream::update_setup()>
   14062:	ldrb	r3, [r4, #4]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
   14064:	movs	r2, #1

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
   14066:	ldr	r4, [pc, #84]	; (140bc <AudioOutputI2S::begin()+0xd8>)
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
   14068:	and.w	r1, r3, #31

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
   1406c:	add.w	r5, r3, #16
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
   14070:	asrs	r3, r3, #5
   14072:	strb	r0, [r7, #0]
   14074:	lsls	r2, r1
   14076:	ldr	r1, [pc, #72]	; (140c0 <AudioOutputI2S::begin()+0xdc>)

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
   14078:	str.w	r6, [r4, r5, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
   1407c:	str.w	r2, [r1, r3, lsl #2]
   14080:	pop	{r3, r4, r5, r6, r7, pc}
   14082:	nop
   14084:	.word	0x20057e38
   14088:	.word	0x20200220
   1408c:	.word	0x40384022
   14090:	.word	0x20057e48
   14094:	.word	0x20057e40
   14098:	.word	0x401f8000
   1409c:	.word	0xfffffe00
   140a0:	.word	0x400ec000
   140a4:	.word	0x80000014
   140a8:	.word	0x400e8000
   140ac:	.word	0x40384000
   140b0:	.word	0x90000001
   140b4:	.word	0x20057e50
   140b8:	.word	0x00013d29
   140bc:	.word	0x2005a400
   140c0:	.word	0xe000e100

000140c4 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
   140c4:	ldr	r2, [pc, #8]	; (140d0 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
   140c6:	ldr	r1, [pc, #12]	; (140d4 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
   140c8:	ldr	r0, [pc, #12]	; (140d8 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
   140ca:	b.w	1aa24 <__aeabi_atexit>
   140ce:	nop
   140d0:	.word	0x20020464
   140d4:	.word	0x00013cbd
   140d8:	.word	0x20057e38

000140dc <_GLOBAL__sub_I__ZN16AudioInputSPDIF310block_leftE>:
static uint32_t spdif_rx_buffer[AUDIO_BLOCK_SAMPLES * 4];
audio_block_t * AudioInputSPDIF3::block_left = NULL;
audio_block_t * AudioInputSPDIF3::block_right = NULL;
uint16_t AudioInputSPDIF3::block_offset = 0;
bool AudioInputSPDIF3::update_responsibility = false;
DMAChannel AudioInputSPDIF3::dma(false);
   140dc:	ldr	r2, [pc, #8]	; (140e8 <_GLOBAL__sub_I__ZN16AudioInputSPDIF310block_leftE+0xc>)
   140de:	ldr	r1, [pc, #12]	; (140ec <_GLOBAL__sub_I__ZN16AudioInputSPDIF310block_leftE+0x10>)
   140e0:	ldr	r0, [pc, #12]	; (140f0 <_GLOBAL__sub_I__ZN16AudioInputSPDIF310block_leftE+0x14>)
   140e2:	b.w	1aa24 <__aeabi_atexit>
   140e6:	nop
   140e8:	.word	0x20020464
   140ec:	.word	0x00013cbd
   140f0:	.word	0x20057e58

000140f4 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
   140f4:	ldr	r2, [pc, #8]	; (14100 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0xc>)
   140f6:	ldr	r1, [pc, #12]	; (14104 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x10>)
   140f8:	ldr	r0, [pc, #12]	; (14108 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x14>)
   140fa:	b.w	1aa24 <__aeabi_atexit>
   140fe:	nop
   14100:	.word	0x20020464
   14104:	.word	0x00013cbd
   14108:	.word	0x20057e60

0001410c <_GLOBAL__sub_I__ZN14AudioInputTDM214block_incomingE>:
audio_block_t * AudioInputTDM2::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM2::update_responsibility = false;
DMAChannel AudioInputTDM2::dma(false);
   1410c:	ldr	r2, [pc, #8]	; (14118 <_GLOBAL__sub_I__ZN14AudioInputTDM214block_incomingE+0xc>)
   1410e:	ldr	r1, [pc, #12]	; (1411c <_GLOBAL__sub_I__ZN14AudioInputTDM214block_incomingE+0x10>)
   14110:	ldr	r0, [pc, #12]	; (14120 <_GLOBAL__sub_I__ZN14AudioInputTDM214block_incomingE+0x14>)
   14112:	b.w	1aa24 <__aeabi_atexit>
   14116:	nop
   14118:	.word	0x20020464
   1411c:	.word	0x00013cbd
   14120:	.word	0x20057e68

00014124 <_GLOBAL__sub_I__ZN16AudioInputAnalog3dmaE>:

extern "C" void xbar_connect(unsigned int input, unsigned int output);

#define FILTERLEN 15

DMAChannel AudioInputAnalog::dma(false);
   14124:	ldr	r2, [pc, #8]	; (14130 <_GLOBAL__sub_I__ZN16AudioInputAnalog3dmaE+0xc>)
   14126:	ldr	r1, [pc, #12]	; (14134 <_GLOBAL__sub_I__ZN16AudioInputAnalog3dmaE+0x10>)
   14128:	ldr	r0, [pc, #12]	; (14138 <_GLOBAL__sub_I__ZN16AudioInputAnalog3dmaE+0x14>)
   1412a:	b.w	1aa24 <__aeabi_atexit>
   1412e:	nop
   14130:	.word	0x20020464
   14134:	.word	0x00013cbd
   14138:	.word	0x20057e70

0001413c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
   1413c:	ldr	r2, [pc, #8]	; (14148 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
   1413e:	ldr	r1, [pc, #12]	; (1414c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
   14140:	ldr	r0, [pc, #12]	; (14150 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
   14142:	b.w	1aa24 <__aeabi_atexit>
   14146:	nop
   14148:	.word	0x20020464
   1414c:	.word	0x00013cbd
   14150:	.word	0x20057e78

00014154 <_GLOBAL__sub_I__ZN14AudioInputI2S210block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s2_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S2::block_left = NULL;
audio_block_t * AudioInputI2S2::block_right = NULL;
uint16_t AudioInputI2S2::block_offset = 0;
bool AudioInputI2S2::update_responsibility = false;
DMAChannel AudioInputI2S2::dma(false);
   14154:	ldr	r2, [pc, #8]	; (14160 <_GLOBAL__sub_I__ZN14AudioInputI2S210block_leftE+0xc>)
   14156:	ldr	r1, [pc, #12]	; (14164 <_GLOBAL__sub_I__ZN14AudioInputI2S210block_leftE+0x10>)
   14158:	ldr	r0, [pc, #12]	; (14168 <_GLOBAL__sub_I__ZN14AudioInputI2S210block_leftE+0x14>)
   1415a:	b.w	1aa24 <__aeabi_atexit>
   1415e:	nop
   14160:	.word	0x20020464
   14164:	.word	0x00013cbd
   14168:	.word	0x20057e80

0001416c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
   1416c:	ldr	r2, [pc, #8]	; (14178 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
   1416e:	ldr	r1, [pc, #12]	; (1417c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
   14170:	ldr	r0, [pc, #12]	; (14180 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
   14172:	b.w	1aa24 <__aeabi_atexit>
   14176:	nop
   14178:	.word	0x20020464
   1417c:	.word	0x00013cbd
   14180:	.word	0x20057e88

00014184 <_GLOBAL__sub_I__ZN15AudioOutputTDM211block_inputE>:
audio_block_t * AudioOutputTDM2::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM2::update_responsibility = false;
DMAChannel AudioOutputTDM2::dma(false);
   14184:	ldr	r2, [pc, #8]	; (14190 <_GLOBAL__sub_I__ZN15AudioOutputTDM211block_inputE+0xc>)
   14186:	ldr	r1, [pc, #12]	; (14194 <_GLOBAL__sub_I__ZN15AudioOutputTDM211block_inputE+0x10>)
   14188:	ldr	r0, [pc, #12]	; (14198 <_GLOBAL__sub_I__ZN15AudioOutputTDM211block_inputE+0x14>)
   1418a:	b.w	1aa24 <__aeabi_atexit>
   1418e:	nop
   14190:	.word	0x20020464
   14194:	.word	0x00013cbd
   14198:	.word	0x20057e90

0001419c <_GLOBAL__sub_I__ZN15AudioOutputI2S214block_left_1stE>:
audio_block_t * AudioOutputI2S2::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S2::block_right_2nd = NULL;
uint16_t  AudioOutputI2S2::block_left_offset = 0;
uint16_t  AudioOutputI2S2::block_right_offset = 0;
bool AudioOutputI2S2::update_responsibility = false;
DMAChannel AudioOutputI2S2::dma(false);
   1419c:	ldr	r2, [pc, #8]	; (141a8 <_GLOBAL__sub_I__ZN15AudioOutputI2S214block_left_1stE+0xc>)
   1419e:	ldr	r1, [pc, #12]	; (141ac <_GLOBAL__sub_I__ZN15AudioOutputI2S214block_left_1stE+0x10>)
   141a0:	ldr	r0, [pc, #12]	; (141b0 <_GLOBAL__sub_I__ZN15AudioOutputI2S214block_left_1stE+0x14>)
   141a2:	b.w	1aa24 <__aeabi_atexit>
   141a6:	nop
   141a8:	.word	0x20020464
   141ac:	.word	0x00013cbd
   141b0:	.word	0x20057e98

000141b4 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
   141b4:	ldr	r2, [pc, #8]	; (141c0 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
   141b6:	ldr	r1, [pc, #12]	; (141c4 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
   141b8:	ldr	r0, [pc, #12]	; (141c8 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
   141ba:	b.w	1aa24 <__aeabi_atexit>
   141be:	nop
   141c0:	.word	0x20020464
   141c4:	.word	0x00013cbd
   141c8:	.word	0x20057ea0

000141cc <_GLOBAL__sub_I__ZN17AudioOutputSPDIF314block_left_1stE>:
audio_block_t * AudioOutputSPDIF3::block_left_1st = nullptr;
audio_block_t * AudioOutputSPDIF3::block_right_1st = nullptr;
audio_block_t * AudioOutputSPDIF3::block_left_2nd = nullptr;
audio_block_t * AudioOutputSPDIF3::block_right_2nd = nullptr;
bool AudioOutputSPDIF3::update_responsibility = false;
DMAChannel AudioOutputSPDIF3::dma(false);
   141cc:	ldr	r2, [pc, #8]	; (141d8 <_GLOBAL__sub_I__ZN17AudioOutputSPDIF314block_left_1stE+0xc>)
   141ce:	ldr	r1, [pc, #12]	; (141dc <_GLOBAL__sub_I__ZN17AudioOutputSPDIF314block_left_1stE+0x10>)
   141d0:	ldr	r0, [pc, #12]	; (141e0 <_GLOBAL__sub_I__ZN17AudioOutputSPDIF314block_left_1stE+0x14>)
   141d2:	b.w	1aa24 <__aeabi_atexit>
   141d6:	nop
   141d8:	.word	0x20020464
   141dc:	.word	0x00013cbd
   141e0:	.word	0x20057ea8

000141e4 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
   141e4:	ldr	r2, [pc, #8]	; (141f0 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
   141e6:	ldr	r1, [pc, #12]	; (141f4 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
   141e8:	ldr	r0, [pc, #12]	; (141f8 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
   141ea:	b.w	1aa24 <__aeabi_atexit>
   141ee:	nop
   141f0:	.word	0x20020464
   141f4:	.word	0x00013cbd
   141f8:	.word	0x20057eb0

000141fc <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
   141fc:	ldr	r2, [pc, #8]	; (14208 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0xc>)
   141fe:	ldr	r1, [pc, #12]	; (1420c <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x10>)
   14200:	ldr	r0, [pc, #12]	; (14210 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x14>)
   14202:	b.w	1aa24 <__aeabi_atexit>
   14206:	nop
   14208:	.word	0x20020464
   1420c:	.word	0x00013cbd
   14210:	.word	0x20057eb8

00014214 <_GLOBAL__sub_I__ZN14AudioOutputMQS14block_left_1stE>:
audio_block_t * AudioOutputMQS::block_left_2nd = NULL;
audio_block_t * AudioOutputMQS::block_right_2nd = NULL;
uint16_t  AudioOutputMQS::block_left_offset = 0;
uint16_t  AudioOutputMQS::block_right_offset = 0;
bool AudioOutputMQS::update_responsibility = false;
DMAChannel AudioOutputMQS::dma(false);
   14214:	ldr	r2, [pc, #8]	; (14220 <_GLOBAL__sub_I__ZN14AudioOutputMQS14block_left_1stE+0xc>)
   14216:	ldr	r1, [pc, #12]	; (14224 <_GLOBAL__sub_I__ZN14AudioOutputMQS14block_left_1stE+0x10>)
   14218:	ldr	r0, [pc, #12]	; (14228 <_GLOBAL__sub_I__ZN14AudioOutputMQS14block_left_1stE+0x14>)
   1421a:	b.w	1aa24 <__aeabi_atexit>
   1421e:	nop
   14220:	.word	0x20020464
   14224:	.word	0x00013cbd
   14228:	.word	0x20057ec0

0001422c <_GLOBAL__sub_I__ZN21AsyncAudioInputSPDIF314resetResamplerE>:
volatile int32_t AsyncAudioInputSPDIF3::buffer_offset = 0;	// read by resample/ written in spdif input isr -> copied at the beginning of 'resmaple' protected by __disable_irq() in resample
int32_t AsyncAudioInputSPDIF3::resample_offset = 0; // read/written by resample/ read in spdif input isr -> no protection needed?

volatile bool AsyncAudioInputSPDIF3::lockChanged=false;
volatile bool AsyncAudioInputSPDIF3::locked=false;
DMAChannel AsyncAudioInputSPDIF3::dma(false);
   1422c:	ldr	r2, [pc, #8]	; (14238 <_GLOBAL__sub_I__ZN21AsyncAudioInputSPDIF314resetResamplerE+0xc>)
   1422e:	ldr	r1, [pc, #12]	; (1423c <_GLOBAL__sub_I__ZN21AsyncAudioInputSPDIF314resetResamplerE+0x10>)
   14230:	ldr	r0, [pc, #12]	; (14240 <_GLOBAL__sub_I__ZN21AsyncAudioInputSPDIF314resetResamplerE+0x14>)
   14232:	b.w	1aa24 <__aeabi_atexit>
   14236:	nop
   14238:	.word	0x20020464
   1423c:	.word	0x00013cbd
   14240:	.word	0x20057ec8

00014244 <_GLOBAL__sub_I__ZN17AudioOutputI2SHex13block_ch1_1stE>:
uint16_t  AudioOutputI2SHex::ch4_offset = 0;
uint16_t  AudioOutputI2SHex::ch5_offset = 0;
uint16_t  AudioOutputI2SHex::ch6_offset = 0;
bool AudioOutputI2SHex::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*3];
DMAChannel AudioOutputI2SHex::dma(false);
   14244:	ldr	r2, [pc, #8]	; (14250 <_GLOBAL__sub_I__ZN17AudioOutputI2SHex13block_ch1_1stE+0xc>)
   14246:	ldr	r1, [pc, #12]	; (14254 <_GLOBAL__sub_I__ZN17AudioOutputI2SHex13block_ch1_1stE+0x10>)
   14248:	ldr	r0, [pc, #12]	; (14258 <_GLOBAL__sub_I__ZN17AudioOutputI2SHex13block_ch1_1stE+0x14>)
   1424a:	b.w	1aa24 <__aeabi_atexit>
   1424e:	nop
   14250:	.word	0x20020464
   14254:	.word	0x00013cbd
   14258:	.word	0x20057ed0

0001425c <_GLOBAL__sub_I__ZN17AudioOutputSPDIF214block_left_1stE>:
audio_block_t * AudioOutputSPDIF2::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF2::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF2::block_left_offset = 0;
uint16_t  AudioOutputSPDIF2::block_right_offset = 0;
bool AudioOutputSPDIF2::update_responsibility = false;
DMAChannel AudioOutputSPDIF2::dma(false);
   1425c:	ldr	r2, [pc, #8]	; (14268 <_GLOBAL__sub_I__ZN17AudioOutputSPDIF214block_left_1stE+0xc>)
   1425e:	ldr	r1, [pc, #12]	; (1426c <_GLOBAL__sub_I__ZN17AudioOutputSPDIF214block_left_1stE+0x10>)
   14260:	ldr	r0, [pc, #12]	; (14270 <_GLOBAL__sub_I__ZN17AudioOutputSPDIF214block_left_1stE+0x14>)
   14262:	b.w	1aa24 <__aeabi_atexit>
   14266:	nop
   14268:	.word	0x20020464
   1426c:	.word	0x00013cbd
   14270:	.word	0x20057ed8

00014274 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
   14274:	ldr	r2, [pc, #8]	; (14280 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
   14276:	ldr	r1, [pc, #12]	; (14284 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
   14278:	ldr	r0, [pc, #12]	; (14288 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
   1427a:	b.w	1aa24 <__aeabi_atexit>
   1427e:	nop
   14280:	.word	0x20020464
   14284:	.word	0x00013cbd
   14288:	.word	0x20057ee0

0001428c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
   1428c:	movs	r0, #0
   1428e:	bx	lr

00014290 <Print::flush()>:
	virtual void flush()				{ }
   14290:	bx	lr
   14292:	nop

00014294 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc>:
 * \brief Raw access to SD and SDHC flash memory cards.
 */
class Sd2Card {
 public:
  /** Construct an instance of Sd2Card. */
  Sd2Card(void) : type_(0) {}
   14294:	ldr	r3, [pc, #24]	; (142b0 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc+0x1c>)
   14296:	movs	r2, #0
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   14298:	movs	r0, #2
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   1429a:	ldr	r1, [pc, #24]	; (142b4 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc+0x20>)
   1429c:	strb	r2, [r3, #2]
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   1429e:	str	r0, [r3, #4]
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   142a0:	str	r1, [r3, #44]	; 0x2c
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   142a2:	strb.w	r2, [r3, #36]	; 0x24
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
   142a6:	strb.w	r2, [r3, #48]	; 0x30
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   142aa:	strb.w	r2, [r3, #50]	; 0x32
   142ae:	bx	lr
   142b0:	.word	0x20057f88
   142b4:	.word	0x2001fab4

000142b8 <SdVolume::cacheFlush()>:
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
   142b8:	push	{r4, r5, r6, lr}
  if (cacheDirty_) {
   142ba:	ldr	r4, [pc, #104]	; (14324 <SdVolume::cacheFlush()+0x6c>)
   142bc:	ldrb	r3, [r4, #0]
   142be:	cbnz	r3, 142c4 <SdVolume::cacheFlush()+0xc>
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
  }
  return true;
   142c0:	movs	r0, #1
}
   142c2:	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
   142c4:	ldr	r5, [pc, #96]	; (14328 <SdVolume::cacheFlush()+0x70>)
   142c6:	ldr	r3, [pc, #100]	; (1432c <SdVolume::cacheFlush()+0x74>)
   142c8:	ldr	r0, [r5, #0]
   142ca:	ldr	r1, [r3, #0]
    return SD_readBlock(block, dst);
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
   142cc:	ldrb	r3, [r0, #0]
   142ce:	cmp	r3, #254	; 0xfe
   142d0:	beq.n	14302 <SdVolume::cacheFlush()+0x4a>
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    }
    #endif
    return SD_writeBlock(block, src);
   142d2:	ldr	r2, [pc, #92]	; (14330 <SdVolume::cacheFlush()+0x78>)
   142d4:	bl	14e84 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
   142d8:	cbz	r0, 142fe <SdVolume::cacheFlush()+0x46>
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
   142da:	ldr	r6, [pc, #88]	; (14334 <SdVolume::cacheFlush()+0x7c>)
   142dc:	ldr	r1, [r6, #0]
   142de:	cbnz	r1, 142e8 <SdVolume::cacheFlush()+0x30>
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
        return false;
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
   142e0:	movs	r3, #0
  }
  return true;
   142e2:	movs	r0, #1
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
        return false;
      }
      cacheMirrorBlock_ = 0;
    }
    cacheDirty_ = 0;
   142e4:	strb	r3, [r4, #0]
   142e6:	pop	{r4, r5, r6, pc}
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
   142e8:	ldr	r0, [r5, #0]
    return SD_readBlock(block, dst);
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
   142ea:	ldrb	r3, [r0, #0]
   142ec:	cmp	r3, #254	; 0xfe
   142ee:	beq.n	14310 <SdVolume::cacheFlush()+0x58>
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    }
    #endif
    return SD_writeBlock(block, src);
   142f0:	ldr	r2, [pc, #60]	; (14330 <SdVolume::cacheFlush()+0x78>)
   142f2:	bl	14e84 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
   142f6:	cbz	r0, 142fe <SdVolume::cacheFlush()+0x46>
        return false;
      }
      cacheMirrorBlock_ = 0;
   142f8:	movs	r3, #0
   142fa:	str	r3, [r6, #0]
   142fc:	b.n	142e0 <SdVolume::cacheFlush()+0x28>
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
      return false;
   142fe:	movs	r0, #0
   14300:	pop	{r4, r5, r6, pc}
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
   14302:	ldr	r0, [pc, #44]	; (14330 <SdVolume::cacheFlush()+0x78>)
   14304:	bl	14748 <SDHC_CardWriteBlock(void const*, unsigned long)>
   14308:	clz	r0, r0
   1430c:	lsrs	r0, r0, #5
   1430e:	b.n	142d8 <SdVolume::cacheFlush()+0x20>
   14310:	ldr	r0, [pc, #28]	; (14330 <SdVolume::cacheFlush()+0x78>)
   14312:	bl	14748 <SDHC_CardWriteBlock(void const*, unsigned long)>
   14316:	clz	r0, r0
   1431a:	lsrs	r0, r0, #5
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
   1431c:	cmp	r0, #0
   1431e:	bne.n	142f8 <SdVolume::cacheFlush()+0x40>
   14320:	b.n	142fe <SdVolume::cacheFlush()+0x46>
   14322:	nop
   14324:	.word	0x200581e4
   14328:	.word	0x20057fe0
   1432c:	.word	0x200207cc
   14330:	.word	0x20057fe4
   14334:	.word	0x20057fdc

00014338 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>:
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
   14338:	push	{r4, r5, r6, lr}
  if (cacheBlockNumber_ != blockNumber) {
   1433a:	ldr	r5, [pc, #72]	; (14384 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x4c>)
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
   1433c:	mov	r6, r1
  if (cacheBlockNumber_ != blockNumber) {
   1433e:	ldr	r3, [r5, #0]
   14340:	cmp	r3, r0
   14342:	beq.n	14368 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x30>
   14344:	mov	r4, r0
    if (!cacheFlush()) return false;
   14346:	bl	142b8 <SdVolume::cacheFlush()>
   1434a:	cbnz	r0, 14350 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x18>
   1434c:	movs	r0, #0
   1434e:	pop	{r4, r5, r6, pc}
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
   14350:	ldr	r3, [pc, #52]	; (14388 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x50>)
   14352:	ldr	r0, [r3, #0]
  /* return the type of SD card detected during init() */
  uint8_t type(void) const {return type_;}
  /** Returns the current value, true or false, for partial block read. */
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
   14354:	ldrb	r3, [r0, #0]
   14356:	cmp	r3, #254	; 0xfe
   14358:	beq.n	14374 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x3c>
      return (SDHC_CardReadBlock(dst, block) == 0) ? true : false;
    }
    #endif
    return SD_readBlock(block, dst);
   1435a:	ldr	r2, [pc, #48]	; (1438c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x54>)
   1435c:	mov	r1, r4
   1435e:	bl	14d94 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)>
   14362:	cmp	r0, #0
   14364:	beq.n	1434c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x14>
    cacheBlockNumber_ = blockNumber;
   14366:	str	r4, [r5, #0]
  }
  cacheDirty_ |= action;
   14368:	ldr	r3, [pc, #36]	; (14390 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x58>)
  return true;
   1436a:	movs	r0, #1
  if (cacheBlockNumber_ != blockNumber) {
    if (!cacheFlush()) return false;
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
   1436c:	ldrb	r1, [r3, #0]
   1436e:	orrs	r1, r6
   14370:	strb	r1, [r3, #0]
  return true;
}
   14372:	pop	{r4, r5, r6, pc}
  uint8_t type(void) const {return type_;}
  /** Returns the current value, true or false, for partial block read. */
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
      return (SDHC_CardReadBlock(dst, block) == 0) ? true : false;
   14374:	mov	r1, r4
   14376:	ldr	r0, [pc, #20]	; (1438c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x54>)
   14378:	bl	14650 <SDHC_CardReadBlock(void*, unsigned long)>
   1437c:	clz	r0, r0
   14380:	lsrs	r0, r0, #5
   14382:	b.n	14362 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x2a>
   14384:	.word	0x200207cc
   14388:	.word	0x20057fe0
   1438c:	.word	0x20057fe4
   14390:	.word	0x200581e4

00014394 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
   14394:	push	{r3, r4, r5, r6, r7, lr}
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   14396:	ldrb.w	r3, [r0, #32]
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
   1439a:	mov	r5, r0
   1439c:	mov	r6, r1
   1439e:	mov	r7, r2
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   143a0:	cmp	r3, #16

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
   143a2:	ldr	r4, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;

  if (lba != cacheBlockNumber_) {
   143a4:	ldr	r3, [pc, #96]	; (14408 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x74>)
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   143a6:	beq.n	143d8 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x44>
   143a8:	add.w	r4, r4, r1, lsr #7

  if (lba != cacheBlockNumber_) {
   143ac:	ldr	r3, [r3, #0]
   143ae:	cmp	r4, r3
   143b0:	bne.n	143e2 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x4e>
  }
  // store entry
  if (fatType_ == 16) {
    cacheBuffer_.fat16[cluster & 0XFF] = value;
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
   143b2:	and.w	r1, r6, #127	; 0x7f
   143b6:	ldr	r2, [pc, #84]	; (1440c <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x78>)
   143b8:	str.w	r7, [r2, r1, lsl #2]
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
   143bc:	ldr	r1, [pc, #80]	; (14410 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x7c>)
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
   143be:	ldrb	r0, [r5, #24]
   143c0:	ldrb	r2, [r1, #0]
   143c2:	cmp	r0, #1
   143c4:	orr.w	r2, r2, #1
   143c8:	strb	r2, [r1, #0]
   143ca:	bls.n	14400 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x6c>
   143cc:	ldr	r1, [r5, #8]
  return true;
   143ce:	movs	r0, #1
    cacheBuffer_.fat32[cluster & 0X7F] = value;
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
   143d0:	ldr	r2, [pc, #64]	; (14414 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x80>)
   143d2:	add	r3, r1
   143d4:	str	r3, [r2, #0]
   143d6:	pop	{r3, r4, r5, r6, r7, pc}
  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   143d8:	add.w	r4, r4, r1, lsr #8

  if (lba != cacheBlockNumber_) {
   143dc:	ldr	r3, [r3, #0]
   143de:	cmp	r4, r3
   143e0:	beq.n	143f4 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x60>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
   143e2:	movs	r1, #0
   143e4:	mov	r0, r4
   143e6:	bl	14338 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
   143ea:	cbz	r0, 14402 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x6e>
  }
  // store entry
  if (fatType_ == 16) {
   143ec:	ldrb.w	r3, [r5, #32]
   143f0:	cmp	r3, #16
   143f2:	bne.n	14404 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x70>
    cacheBuffer_.fat16[cluster & 0XFF] = value;
   143f4:	uxtb	r1, r6
   143f6:	ldr	r2, [pc, #20]	; (1440c <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x78>)
   143f8:	mov	r3, r4
   143fa:	strh.w	r7, [r2, r1, lsl #1]
   143fe:	b.n	143bc <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x28>
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
   14400:	movs	r0, #1
}
   14402:	pop	{r3, r4, r5, r6, r7, pc}

  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  // store entry
  if (fatType_ == 16) {
   14404:	mov	r3, r4
   14406:	b.n	143b2 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]+0x1e>
   14408:	.word	0x200207cc
   1440c:	.word	0x20057fe4
   14410:	.word	0x200581e4
   14414:	.word	0x20057fdc

00014418 <SdVolume::fatGet(unsigned long, unsigned long*) const>:
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
   14418:	ldr	r3, [r0, #12]
   1441a:	adds	r3, #1
   1441c:	cmp	r3, r1
   1441e:	bcc.n	14452 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x3a>
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
   14420:	push	{r4, r5, r6, lr}
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   14422:	ldrb.w	r3, [r0, #32]
   14426:	mov	r4, r0
   14428:	mov	r6, r2
   1442a:	mov	r5, r1
   1442c:	cmp	r3, #16
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
   1442e:	ldr	r0, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
  if (lba != cacheBlockNumber_) {
   14430:	ldr	r3, [pc, #80]	; (14484 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x6c>)
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   14432:	beq.n	14456 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x3e>
   14434:	add.w	r0, r0, r1, lsr #7
  if (lba != cacheBlockNumber_) {
   14438:	ldr	r3, [r3, #0]
   1443a:	cmp	r0, r3
   1443c:	bne.n	14460 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x48>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
   1443e:	and.w	r1, r5, #127	; 0x7f
   14442:	ldr	r3, [pc, #68]	; (14488 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x70>)
   14444:	movs	r0, #1
   14446:	ldr.w	r3, [r3, r1, lsl #2]
   1444a:	bic.w	r3, r3, #4026531840	; 0xf0000000
   1444e:	str	r3, [r6, #0]
  }
  return true;
}
   14450:	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
   14452:	movs	r0, #0
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
}
   14454:	bx	lr
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   14456:	add.w	r0, r0, r1, lsr #8
  if (lba != cacheBlockNumber_) {
   1445a:	ldr	r3, [r3, #0]
   1445c:	cmp	r0, r3
   1445e:	beq.n	14470 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x58>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
   14460:	movs	r1, #0
   14462:	bl	14338 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
   14466:	cbz	r0, 1447e <SdVolume::fatGet(unsigned long, unsigned long*) const+0x66>
  }
  if (fatType_ == 16) {
   14468:	ldrb.w	r3, [r4, #32]
   1446c:	cmp	r3, #16
   1446e:	bne.n	1443e <SdVolume::fatGet(unsigned long, unsigned long*) const+0x26>
    *value = cacheBuffer_.fat16[cluster & 0XFF];
   14470:	uxtb	r1, r5
   14472:	ldr	r3, [pc, #20]	; (14488 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x70>)
   14474:	movs	r0, #1
   14476:	ldrh.w	r3, [r3, r1, lsl #1]
   1447a:	str	r3, [r6, #0]
   1447c:	pop	{r4, r5, r6, pc}
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
   1447e:	movs	r0, #0
   14480:	pop	{r4, r5, r6, pc}
   14482:	nop
   14484:	.word	0x200207cc
   14488:	.word	0x20057fe4

0001448c <SdVolume::allocContiguous(unsigned long, unsigned long*)>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   1448c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
   14490:	ldr	r7, [r2, #0]
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   14492:	sub	sp, #12

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
   14494:	cbz	r7, 144f0 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x64>
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
   14496:	adds	r7, #1

    // don't save new start location
    setStart = false;
   14498:	mov.w	sl, #0
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
   1449c:	ldr	r3, [r0, #12]
   1449e:	add.w	r8, r3, #1

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
   144a2:	cbz	r3, 144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
   144a4:	mov	fp, r1
   144a6:	mov	r6, r0
   144a8:	mov	r9, r2
   144aa:	mov	r4, r7
   144ac:	movs	r5, #0
   144ae:	b.n	144bc <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x30>
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;

    if (f != 0) {
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
   144b0:	mov	r4, r3
   144b2:	mov	r7, r3

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
   144b4:	adds	r5, #1
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
   144b6:	ldr	r3, [r6, #12]
   144b8:	cmp	r3, r5
   144ba:	bls.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
   144bc:	cmp	r8, r4
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
   144be:	add	r2, sp, #4
   144c0:	mov	r0, r6
  for (uint32_t n = 0;; n++, endCluster++) {
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
   144c2:	bcs.n	144c8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x3c>
      bgnCluster = endCluster = 2;
   144c4:	movs	r4, #2
   144c6:	mov	r7, r4
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
   144c8:	mov	r1, r4
   144ca:	bl	14418 <SdVolume::fatGet(unsigned long, unsigned long*) const>
   144ce:	adds	r3, r4, #1
   144d0:	cbz	r0, 144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>

    if (f != 0) {
   144d2:	ldr	r2, [sp, #4]
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
   144d4:	subs	r1, r3, r7
      bgnCluster = endCluster = 2;
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;

    if (f != 0) {
   144d6:	cmp	r2, #0
   144d8:	bne.n	144b0 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x24>
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
   144da:	cmp	fp, r1
   144dc:	beq.n	14500 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x74>
   144de:	mov	r4, r3

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
   144e0:	adds	r5, #1
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
   144e2:	ldr	r3, [r6, #12]
   144e4:	cmp	r3, r5
   144e6:	bhi.n	144bc <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x30>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
   144e8:	movs	r0, #0

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
   144ea:	add	sp, #12
   144ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;

    // save next search start if one cluster
    setStart = 1 == count;
   144f0:	sub.w	sl, r1, #1

    // don't save new start location
    setStart = false;
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
   144f4:	ldr	r7, [r0, #0]

    // save next search start if one cluster
    setStart = 1 == count;
   144f6:	clz	sl, sl
   144fa:	mov.w	sl, sl, lsr #5
   144fe:	b.n	1449c <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x10>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
   14500:	cmp	r4, #1
   14502:	bls.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
   14504:	ldr	r3, [r6, #12]
   14506:	adds	r3, #1
   14508:	cmp	r4, r3
   1450a:	bhi.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
   1450c:	mvn.w	r2, #4026531840	; 0xf0000000
   14510:	mov	r1, r4
   14512:	mov	r0, r6
   14514:	bl	14394 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
   14518:	cmp	r0, #0
   1451a:	beq.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>

  // link clusters
  while (endCluster > bgnCluster) {
   1451c:	cmp	r7, r4
   1451e:	bcs.n	1454a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xbe>
    if (!fatPut(endCluster - 1, endCluster)) return false;
   14520:	subs	r4, #1
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
   14522:	cmp	r4, #1
   14524:	bls.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
   14526:	ldr	r3, [r6, #12]
   14528:	adds	r3, #1
   1452a:	cmp	r4, r3
   1452c:	bhi.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
   1452e:	adds	r2, r4, #1
   14530:	mov	r1, r4
   14532:	mov	r0, r6
   14534:	bl	14394 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) return false;
   14538:	cmp	r0, #0
   1453a:	beq.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
   1453c:	cmp	r7, r4
    if (!fatPut(endCluster - 1, endCluster)) return false;
   1453e:	add.w	r4, r4, #4294967295
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
   14542:	beq.n	1454a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xbe>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
   14544:	cmp	r4, #1
   14546:	bne.n	14526 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x9a>
   14548:	b.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
  // link clusters
  while (endCluster > bgnCluster) {
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
   1454a:	ldr.w	r1, [r9]
   1454e:	cbz	r1, 14568 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xdc>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
   14550:	cmp	r1, #1
   14552:	bls.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
   14554:	ldr	r3, [r6, #12]
   14556:	adds	r3, #1
   14558:	cmp	r1, r3
   1455a:	bhi.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
   1455c:	mov	r2, r7
   1455e:	mov	r0, r6
   14560:	bl	14394 <SdVolume::fatPut(unsigned long, unsigned long) [clone .part.3]>
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
   14564:	cmp	r0, #0
   14566:	beq.n	144e8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5c>
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
   14568:	str.w	r7, [r9]

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
   1456c:	cmp.w	sl, #0
   14570:	beq.n	1457a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xee>
   14572:	adds	r7, #1

  return true;
   14574:	movs	r0, #1
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
   14576:	str	r7, [r6, #0]
   14578:	b.n	144ea <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>

  return true;
   1457a:	movs	r0, #1
   1457c:	b.n	144ea <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5e>
   1457e:	nop

00014580 <SDHC_CMD_Do(unsigned long)>:

// sends the command to SDcard
static int SDHC_CMD_Do(uint32_t xfertyp)
{
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
   14580:	ldr	r3, [pc, #128]	; (14604 <SDHC_CMD_Do(unsigned long)+0x84>)
   14582:	ldr	r2, [r3, #48]	; 0x30

  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) { };
   14584:	mov	r1, r3
	return SDHC_RESULT_OK;
}

// sends the command to SDcard
static int SDHC_CMD_Do(uint32_t xfertyp)
{
   14586:	push	{r4}
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
   14588:	orr.w	r2, r2, #128	; 0x80

  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) { };
   1458c:	mov	r4, r3

// sends the command to SDcard
static int SDHC_CMD_Do(uint32_t xfertyp)
{
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
   1458e:	str	r2, [r3, #48]	; 0x30

  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) { };
   14590:	ldr	r2, [r1, #36]	; 0x24
   14592:	ldr	r3, [pc, #112]	; (14604 <SDHC_CMD_Do(unsigned long)+0x84>)
   14594:	lsls	r2, r2, #31
   14596:	bmi.n	14590 <SDHC_CMD_Do(unsigned long)+0x10>
   14598:	ldr	r2, [r4, #36]	; 0x24
   1459a:	lsls	r2, r2, #30
   1459c:	bmi.n	14590 <SDHC_CMD_Do(unsigned long)+0x10>
  SDHC_XFERTYP = xfertyp;
   1459e:	str	r0, [r3, #12]

// waits for status bits sets
static uint32_t SDHC_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
   145a0:	mov.w	r2, #16777216	; 0x1000000
  do
  { result = SDHC_IRQSTAT & mask;
   145a4:	mov	r0, r3
   145a6:	b.n	145aa <SDHC_CMD_Do(unsigned long)+0x2a>
    timeout--;
  } while (!result && (timeout));
   145a8:	cbz	r2, 145d6 <SDHC_CMD_Do(unsigned long)+0x56>
static uint32_t SDHC_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
   145aa:	ldr	r1, [r0, #48]	; 0x30
    timeout--;
   145ac:	subs	r2, #1
static uint32_t SDHC_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
   145ae:	ldr	r3, [pc, #88]	; (14608 <SDHC_CMD_Do(unsigned long)+0x88>)
   145b0:	ldr	r4, [pc, #80]	; (14604 <SDHC_CMD_Do(unsigned long)+0x84>)
   145b2:	ands	r3, r1
    timeout--;
  } while (!result && (timeout));
   145b4:	cmp	r3, #0
   145b6:	beq.n	145a8 <SDHC_CMD_Do(unsigned long)+0x28>
  if (timeout) return result;
   145b8:	cbz	r2, 145d6 <SDHC_CMD_Do(unsigned long)+0x56>
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) { };
  SDHC_XFERTYP = xfertyp;

  /* Wait for response */
  const uint32_t mask = SDHC_IRQSTAT_CIE | SDHC_IRQSTAT_CEBE | SDHC_IRQSTAT_CCE | SDHC_IRQSTAT_CC;
  if (SDHC_WaitStatus(mask) != SDHC_IRQSTAT_CC) {
   145ba:	cmp	r3, #1
   145bc:	bne.n	145d6 <SDHC_CMD_Do(unsigned long)+0x56>
      //SDHC_IRQSTAT |= mask;
      SDHC_IRQSTAT |= (mask | SDHC_IRQSTAT_CTOE);
      return SDHC_RESULT_ERROR;
  }
  /* Check card removal */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM) {
   145be:	ldr	r3, [r4, #48]	; 0x30
   145c0:	tst.w	r3, #128	; 0x80
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
   145c4:	ldr	r3, [r4, #48]	; 0x30
      //SDHC_IRQSTAT |= mask;
      SDHC_IRQSTAT |= (mask | SDHC_IRQSTAT_CTOE);
      return SDHC_RESULT_ERROR;
  }
  /* Check card removal */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM) {
   145c6:	beq.n	145e8 <SDHC_CMD_Do(unsigned long)+0x68>
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
   145c8:	orr.w	r3, r3, #65537	; 0x10001
      return SDHC_RESULT_NOT_READY;
   145cc:	movs	r0, #3
      SDHC_IRQSTAT |= (mask | SDHC_IRQSTAT_CTOE);
      return SDHC_RESULT_ERROR;
  }
  /* Check card removal */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM) {
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
   145ce:	str	r3, [r4, #48]	; 0x30
      return SDHC_RESULT_NO_RESPONSE;
  }
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CC;

  return SDHC_RESULT_OK;
}
   145d0:	ldr.w	r4, [sp], #4
   145d4:	bx	lr

  /* Wait for response */
  const uint32_t mask = SDHC_IRQSTAT_CIE | SDHC_IRQSTAT_CEBE | SDHC_IRQSTAT_CCE | SDHC_IRQSTAT_CC;
  if (SDHC_WaitStatus(mask) != SDHC_IRQSTAT_CC) {
      //SDHC_IRQSTAT |= mask;
      SDHC_IRQSTAT |= (mask | SDHC_IRQSTAT_CTOE);
   145d6:	ldr	r2, [pc, #44]	; (14604 <SDHC_CMD_Do(unsigned long)+0x84>)
      return SDHC_RESULT_ERROR;
   145d8:	movs	r0, #1

  /* Wait for response */
  const uint32_t mask = SDHC_IRQSTAT_CIE | SDHC_IRQSTAT_CEBE | SDHC_IRQSTAT_CCE | SDHC_IRQSTAT_CC;
  if (SDHC_WaitStatus(mask) != SDHC_IRQSTAT_CC) {
      //SDHC_IRQSTAT |= mask;
      SDHC_IRQSTAT |= (mask | SDHC_IRQSTAT_CTOE);
   145da:	ldr	r3, [pc, #48]	; (1460c <SDHC_CMD_Do(unsigned long)+0x8c>)
   145dc:	ldr	r1, [r2, #48]	; 0x30
   145de:	orrs	r3, r1
   145e0:	str	r3, [r2, #48]	; 0x30
      return SDHC_RESULT_NO_RESPONSE;
  }
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CC;

  return SDHC_RESULT_OK;
}
   145e2:	ldr.w	r4, [sp], #4
   145e6:	bx	lr
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
      return SDHC_RESULT_NOT_READY;
  }

  /* Get response, if available */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE) {
   145e8:	ands.w	r0, r3, #65536	; 0x10000
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
   145ec:	ldr	r3, [r4, #48]	; 0x30
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
      return SDHC_RESULT_NOT_READY;
  }

  /* Get response, if available */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE) {
   145ee:	beq.n	145fa <SDHC_CMD_Do(unsigned long)+0x7a>
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
   145f0:	orr.w	r3, r3, #65537	; 0x10001
      return SDHC_RESULT_NO_RESPONSE;
   145f4:	movs	r0, #5
      return SDHC_RESULT_NOT_READY;
  }

  /* Get response, if available */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE) {
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
   145f6:	str	r3, [r4, #48]	; 0x30
   145f8:	b.n	145e2 <SDHC_CMD_Do(unsigned long)+0x62>
      return SDHC_RESULT_NO_RESPONSE;
  }
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CC;
   145fa:	orr.w	r3, r3, #1
   145fe:	str	r3, [r4, #48]	; 0x30
   14600:	b.n	145e2 <SDHC_CMD_Do(unsigned long)+0x62>
   14602:	nop
   14604:	.word	0x402c0000
   14608:	.word	0x000e0001
   1460c:	.word	0x000f0001

00014610 <SDHC_CMD12_StopTransferWaitForBusy()>:
  return result;
}

// sends CMD12 to stop transfer and first waits to ready SDCArd
static int SDHC_CMD12_StopTransferWaitForBusy(void)
{
   14610:	push	{r4, r5, r6, lr}
static int SDHC_CMD12_StopTransfer(void)
{
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = 0;
   14612:	ldr	r5, [pc, #52]	; (14648 <SDHC_CMD12_StopTransferWaitForBusy()+0x38>)
   14614:	movs	r6, #0
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
   14616:	ldr	r0, [pc, #52]	; (1464c <SDHC_CMD12_StopTransferWaitForBusy()+0x3c>)
{
  uint32_t timeOut = 1000;
  int result;
  do {
    result = SDHC_CMD12_StopTransfer();
    timeOut--;
   14618:	movw	r4, #999	; 0x3e7
static int SDHC_CMD12_StopTransfer(void)
{
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = 0;
   1461c:	str	r6, [r5, #8]
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
   1461e:	bl	14580 <SDHC_CMD_Do(unsigned long)>
   14622:	mov	r3, r0
   14624:	b.n	14634 <SDHC_CMD12_StopTransferWaitForBusy()+0x24>
  uint32_t timeOut = 1000;
  int result;
  do {
    result = SDHC_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
   14626:	cbnz	r3, 1463c <SDHC_CMD12_StopTransferWaitForBusy()+0x2c>
static int SDHC_CMD12_StopTransfer(void)
{
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = 0;
   14628:	str	r6, [r5, #8]
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
   1462a:	bl	14580 <SDHC_CMD_Do(unsigned long)>
  uint32_t timeOut = 1000;
  int result;
  do {
    result = SDHC_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
   1462e:	subs	r4, #1

  SDHC_CMDARG = 0;
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
   14630:	mov	r3, r0
  uint32_t timeOut = 1000;
  int result;
  do {
    result = SDHC_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
   14632:	beq.n	14640 <SDHC_CMD12_StopTransferWaitForBusy()+0x30>
   14634:	ldr	r2, [r5, #36]	; 0x24

  SDHC_CMDARG = 0;
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
   14636:	ldr	r0, [pc, #20]	; (1464c <SDHC_CMD12_StopTransferWaitForBusy()+0x3c>)
  uint32_t timeOut = 1000;
  int result;
  do {
    result = SDHC_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
   14638:	lsls	r2, r2, #29
   1463a:	bmi.n	14626 <SDHC_CMD12_StopTransferWaitForBusy()+0x16>
   1463c:	mov	r0, r3
   1463e:	pop	{r4, r5, r6, pc}

  SDHC_CMDARG = 0;
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
   14640:	cmp	r0, #0
   14642:	it	eq
   14644:	moveq	r0, #5

  if (result != SDHC_RESULT_OK)  return result;
  if (!timeOut)  return SDHC_RESULT_NO_RESPONSE;

  return SDHC_RESULT_OK;
}
   14646:	pop	{r4, r5, r6, pc}
   14648:	.word	0x402c0000
   1464c:	.word	0x0cdb0000

00014650 <SDHC_CardReadBlock(void*, unsigned long)>:
{
  int result;
  uint32_t* pData = (uint32_t*)buff;

  // Check if this is ready
  if (sdCardDesc.status != 0)
   14650:	ldr	r3, [pc, #224]	; (14734 <SDHC_CardReadBlock(void*, unsigned long)+0xe4>)
   14652:	ldrb	r2, [r3, #0]
   14654:	cbz	r2, 1465a <SDHC_CardReadBlock(void*, unsigned long)+0xa>
     return SDHC_RESULT_NOT_READY;
   14656:	movs	r0, #3
   14658:	bx	lr
#if 1
// read a block from disk, using polling
//   buff - pointer on buffer where read data should be stored
//   sector - index of start sector
int SDHC_CardReadBlock(void * buff, uint32_t sector)
{
   1465a:	push	{r4, r5, r6, lr}
  // Check if this is ready
  if (sdCardDesc.status != 0)
     return SDHC_RESULT_NOT_READY;

  // Convert LBA to uint8_t address if needed
  if (!sdCardDesc.highCapacity)
   1465c:	ldrb	r3, [r3, #1]
   1465e:	mov	r6, r0
   14660:	cbnz	r3, 14664 <SDHC_CardReadBlock(void*, unsigned long)+0x14>
    sector *= 512;
   14662:	lsls	r1, r1, #9

  SDHC_IRQSTAT = 0xffff;
   14664:	ldr	r5, [pc, #208]	; (14738 <SDHC_CardReadBlock(void*, unsigned long)+0xe8>)
   14666:	movw	r3, #65535	; 0xffff
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = sector;

  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | 512;
   1466a:	mov.w	r2, #66048	; 0x10200

  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD17) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DTDSEL | SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
   1466e:	ldr	r0, [pc, #204]	; (1473c <SDHC_CardReadBlock(void*, unsigned long)+0xec>)

  // Convert LBA to uint8_t address if needed
  if (!sdCardDesc.highCapacity)
    sector *= 512;

  SDHC_IRQSTAT = 0xffff;
   14670:	str	r3, [r5, #48]	; 0x30
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL |= SDHC_MIX_CTRL_DTDSEL;
   14672:	ldr	r3, [r5, #72]	; 0x48
   14674:	orr.w	r3, r3, #16
   14678:	str	r3, [r5, #72]	; 0x48
static int SDHC_CMD17_ReadBlock(uint32_t sector)
{
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = sector;
   1467a:	str	r1, [r5, #8]

  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | 512;
   1467c:	str	r2, [r5, #4]

  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD17) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DTDSEL | SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
   1467e:	bl	14580 <SDHC_CMD_Do(unsigned long)>
  if (result == SDHC_RESULT_OK) { ( void)SDHC_CMDRSP0; }
   14682:	cmp	r0, #0
   14684:	bne.n	14722 <SDHC_CardReadBlock(void*, unsigned long)+0xd2>
{
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
		irqstat = SDHC_IRQSTAT;
   14686:	mov	r4, r5
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD17) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DTDSEL | SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
  if (result == SDHC_RESULT_OK) { ( void)SDHC_CMDRSP0; }
   14688:	ldr	r3, [r5, #16]
   1468a:	add.w	r2, r6, #64	; 0x40
   1468e:	add.w	r0, r6, #576	; 0x240
			SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR |
				SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE;
			SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) { };
   14692:	mov	r1, r5
{
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
		irqstat = SDHC_IRQSTAT;
   14694:	ldr	r3, [r4, #48]	; 0x30
   14696:	ldr	r6, [pc, #160]	; (14738 <SDHC_CardReadBlock(void*, unsigned long)+0xe8>)
		SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR;
   14698:	orr.w	r5, r3, #32
		if (irqstat & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
   1469c:	tst.w	r3, #7340032	; 0x700000
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
		irqstat = SDHC_IRQSTAT;
		SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR;
   146a0:	str	r5, [r4, #48]	; 0x30
		if (irqstat & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
   146a2:	bne.n	14724 <SDHC_CardReadBlock(void*, unsigned long)+0xd4>
			SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR |
				SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE;
			SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) { };
   146a4:	ldr	r3, [r4, #36]	; 0x24
   146a6:	lsls	r5, r3, #20
   146a8:	bpl.n	146a4 <SDHC_CardReadBlock(void*, unsigned long)+0x54>
		*pData++ = SDHC_DATPORT;
   146aa:	ldr	r3, [r1, #32]
   146ac:	adds	r2, #64	; 0x40
   146ae:	str.w	r3, [r2, #-128]
		*pData++ = SDHC_DATPORT;
   146b2:	ldr	r3, [r1, #32]
   146b4:	str.w	r3, [r2, #-124]
		*pData++ = SDHC_DATPORT;
   146b8:	ldr	r3, [r1, #32]
   146ba:	str.w	r3, [r2, #-120]
		*pData++ = SDHC_DATPORT;
   146be:	ldr	r3, [r1, #32]
   146c0:	str.w	r3, [r2, #-116]
		*pData++ = SDHC_DATPORT;
   146c4:	ldr	r3, [r1, #32]
   146c6:	str.w	r3, [r2, #-112]
		*pData++ = SDHC_DATPORT;
   146ca:	ldr	r3, [r1, #32]
   146cc:	str.w	r3, [r2, #-108]
		*pData++ = SDHC_DATPORT;
   146d0:	ldr	r3, [r1, #32]
   146d2:	str.w	r3, [r2, #-104]
		*pData++ = SDHC_DATPORT;
   146d6:	ldr	r3, [r1, #32]
   146d8:	str.w	r3, [r2, #-100]
		*pData++ = SDHC_DATPORT;
   146dc:	ldr	r3, [r1, #32]
   146de:	str.w	r3, [r2, #-96]
		*pData++ = SDHC_DATPORT;
   146e2:	ldr	r3, [r1, #32]
   146e4:	str.w	r3, [r2, #-92]
		*pData++ = SDHC_DATPORT;
   146e8:	ldr	r3, [r1, #32]
   146ea:	str.w	r3, [r2, #-88]
		*pData++ = SDHC_DATPORT;
   146ee:	ldr	r3, [r1, #32]
   146f0:	str.w	r3, [r2, #-84]
		*pData++ = SDHC_DATPORT;
   146f4:	ldr	r3, [r1, #32]
   146f6:	str.w	r3, [r2, #-80]
		*pData++ = SDHC_DATPORT;
   146fa:	ldr	r3, [r1, #32]
   146fc:	str.w	r3, [r2, #-76]
		*pData++ = SDHC_DATPORT;
   14700:	ldr	r3, [r1, #32]
   14702:	str.w	r3, [r2, #-72]
		*pData++ = SDHC_DATPORT;
   14706:	ldr	r3, [r1, #32]
   14708:	str.w	r3, [r2, #-68]
static int SDHC_ReadBlock(uint32_t* pData)
{
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
   1470c:	cmp	r2, r0
   1470e:	bne.n	14694 <SDHC_CardReadBlock(void*, unsigned long)+0x44>
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
	}
	return SDHC_RESULT_OK;
   14710:	movs	r0, #0
  result = SDHC_CMD17_ReadBlock(sector);
  if(result != SDHC_RESULT_OK) return result;
  result = SDHC_ReadBlock(pData);

  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
   14712:	ldr	r1, [pc, #36]	; (14738 <SDHC_CardReadBlock(void*, unsigned long)+0xe8>)
   14714:	ldr	r3, [r1, #48]	; 0x30
   14716:	ldr	r2, [pc, #32]	; (14738 <SDHC_CardReadBlock(void*, unsigned long)+0xe8>)
   14718:	lsls	r3, r3, #30
   1471a:	bpl.n	14714 <SDHC_CardReadBlock(void*, unsigned long)+0xc4>
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BRR | SDHC_IRQSTAT_AC12E);
   1471c:	ldr	r3, [pc, #32]	; (14740 <SDHC_CardReadBlock(void*, unsigned long)+0xf0>)
   1471e:	str	r3, [r2, #48]	; 0x30

  return result;
   14720:	pop	{r4, r5, r6, pc}
}
   14722:	pop	{r4, r5, r6, pc}
	for (i = 0; i < i_max; i++) {
		irqstat = SDHC_IRQSTAT;
		SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR;
		if (irqstat & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
			SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR |
				SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE;
   14724:	ldr	r2, [pc, #28]	; (14744 <SDHC_CardReadBlock(void*, unsigned long)+0xf4>)
   14726:	orrs	r2, r3
   14728:	str	r2, [r6, #48]	; 0x30
			SDHC_CMD12_StopTransferWaitForBusy();
   1472a:	bl	14610 <SDHC_CMD12_StopTransferWaitForBusy()>
			return SDHC_RESULT_ERROR;
   1472e:	movs	r0, #1
   14730:	b.n	14712 <SDHC_CardReadBlock(void*, unsigned long)+0xc2>
   14732:	nop
   14734:	.word	0x200581e8
   14738:	.word	0x402c0000
   1473c:	.word	0x113a0010
   14740:	.word	0x01000022
   14744:	.word	0x00700020

00014748 <SDHC_CardWriteBlock(void const*, unsigned long)>:
//
// RETURNS:     result of operation
//-----------------------------------------------------------------------------
#if 1
int SDHC_CardWriteBlock(const void * buff, uint32_t sector)
{
   14748:	push	{r3, r4, r5, r6, r7, lr}
  int result;
  const uint32_t *pData = (const uint32_t *)buff;

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;
   1474a:	ldr	r3, [pc, #160]	; (147ec <SDHC_CardWriteBlock(void const*, unsigned long)+0xa4>)
   1474c:	ldrb	r2, [r3, #0]
   1474e:	cbz	r2, 14754 <SDHC_CardWriteBlock(void const*, unsigned long)+0xc>
   14750:	movs	r0, #3
  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BWR | SDHC_IRQSTAT_AC12E);

  return result;
}
   14752:	pop	{r3, r4, r5, r6, r7, pc}

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;

  // Convert LBA to uint8_t address if needed
  if(!sdCardDesc.highCapacity)
   14754:	ldrb	r3, [r3, #1]
   14756:	mov	r4, r0
   14758:	cbnz	r3, 1475c <SDHC_CardWriteBlock(void const*, unsigned long)+0x14>
    sector *= 512;
   1475a:	lsls	r1, r1, #9

  //SDHC_IRQSTAT = 0xffff;
  SDHC_IRQSTAT = SDHC_IRQSTAT;
   1475c:	ldr	r5, [pc, #144]	; (147f0 <SDHC_CardWriteBlock(void const*, unsigned long)+0xa8>)
{
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = sector;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | 512;
   1475e:	mov.w	r2, #66048	; 0x10200

  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD24) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
   14762:	ldr	r0, [pc, #144]	; (147f4 <SDHC_CardWriteBlock(void const*, unsigned long)+0xac>)
  // Convert LBA to uint8_t address if needed
  if(!sdCardDesc.highCapacity)
    sector *= 512;

  //SDHC_IRQSTAT = 0xffff;
  SDHC_IRQSTAT = SDHC_IRQSTAT;
   14764:	ldr	r3, [r5, #48]	; 0x30
   14766:	str	r3, [r5, #48]	; 0x30
#if defined(__IMXRT1062__)
	SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_DTDSEL;
   14768:	ldr	r3, [r5, #72]	; 0x48
   1476a:	bic.w	r3, r3, #16
   1476e:	str	r3, [r5, #72]	; 0x48
static int SDHC_CMD24_WriteBlock(uint32_t sector)
{
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = sector;
   14770:	str	r1, [r5, #8]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | 512;
   14772:	str	r2, [r5, #4]

  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD24) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
   14774:	bl	14580 <SDHC_CMD_Do(unsigned long)>
  if (result == SDHC_RESULT_OK) { (void)SDHC_CMDRSP0; }
   14778:	cmp	r0, #0
   1477a:	bne.n	14752 <SDHC_CardWriteBlock(void const*, unsigned long)+0xa>
{
	uint32_t i, i_max, j;
	i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for(i = 0; i < i_max; i++) {
		while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_BWR)) ; // wait
   1477c:	mov	r2, r5
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD24) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
  if (result == SDHC_RESULT_OK) { (void)SDHC_CMDRSP0; }
   1477e:	ldr	r3, [r5, #16]
   14780:	add.w	r7, r4, #512	; 0x200
{
	uint32_t i, i_max, j;
	i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for(i = 0; i < i_max; i++) {
		while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_BWR)) ; // wait
   14784:	mov	r6, r5
   14786:	ldr	r3, [r2, #48]	; 0x30
   14788:	ldr	r1, [pc, #100]	; (147f0 <SDHC_CardWriteBlock(void const*, unsigned long)+0xa8>)
   1478a:	lsls	r0, r3, #27
   1478c:	bpl.n	14786 <SDHC_CardWriteBlock(void const*, unsigned long)+0x3e>
		if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
   1478e:	ldr	r3, [r6, #48]	; 0x30
   14790:	tst.w	r3, #7340032	; 0x700000
   14794:	bne.n	147ca <SDHC_CardWriteBlock(void const*, unsigned long)+0x82>
   14796:	add.w	r1, r4, #64	; 0x40
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
			(void)SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		for(j=0; j<SDHC_FIFO_BUFFER_SIZE; j++) {
			SDHC_DATPORT = *pData++;
   1479a:	ldr.w	r3, [r4], #4
   1479e:	ldr	r5, [pc, #80]	; (147f0 <SDHC_CardWriteBlock(void const*, unsigned long)+0xa8>)
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
			(void)SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		for(j=0; j<SDHC_FIFO_BUFFER_SIZE; j++) {
   147a0:	cmp	r1, r4
			SDHC_DATPORT = *pData++;
   147a2:	str	r3, [r2, #32]
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
			(void)SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		for(j=0; j<SDHC_FIFO_BUFFER_SIZE; j++) {
   147a4:	bne.n	1479a <SDHC_CardWriteBlock(void const*, unsigned long)+0x52>
			SDHC_DATPORT = *pData++;
		}
		SDHC_IRQSTAT |= SDHC_IRQSTAT_BWR;
   147a6:	ldr	r3, [r6, #48]	; 0x30
   147a8:	orr.w	r3, r3, #16
   147ac:	str	r3, [r6, #48]	; 0x30

		if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
   147ae:	ldr	r3, [r6, #48]	; 0x30
   147b0:	ands.w	r0, r3, #7340032	; 0x700000
   147b4:	bne.n	147da <SDHC_CardWriteBlock(void const*, unsigned long)+0x92>
static int SDHC_WriteBlock(const uint32_t* pData)
{
	uint32_t i, i_max, j;
	i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for(i = 0; i < i_max; i++) {
   147b6:	cmp	r7, r1
   147b8:	bne.n	14786 <SDHC_CardWriteBlock(void const*, unsigned long)+0x3e>
  result = SDHC_CMD24_WriteBlock(sector);
  if (result != SDHC_RESULT_OK) return result;
  result = SDHC_WriteBlock(pData);

  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
   147ba:	ldr	r1, [pc, #52]	; (147f0 <SDHC_CardWriteBlock(void const*, unsigned long)+0xa8>)
   147bc:	ldr	r3, [r1, #48]	; 0x30
   147be:	ldr	r2, [pc, #48]	; (147f0 <SDHC_CardWriteBlock(void const*, unsigned long)+0xa8>)
   147c0:	lsls	r3, r3, #30
   147c2:	bpl.n	147bc <SDHC_CardWriteBlock(void const*, unsigned long)+0x74>
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BWR | SDHC_IRQSTAT_AC12E);
   147c4:	ldr	r3, [pc, #48]	; (147f8 <SDHC_CardWriteBlock(void const*, unsigned long)+0xb0>)
   147c6:	str	r3, [r2, #48]	; 0x30

  return result;
   147c8:	pop	{r3, r4, r5, r6, r7, pc}

	for(i = 0; i < i_max; i++) {
		while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_BWR)) ; // wait
		if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
   147ca:	ldr	r2, [r1, #48]	; 0x30
   147cc:	ldr	r3, [pc, #44]	; (147fc <SDHC_CardWriteBlock(void const*, unsigned long)+0xb4>)
   147ce:	orrs	r3, r2
   147d0:	str	r3, [r1, #48]	; 0x30
			(void)SDHC_CMD12_StopTransferWaitForBusy();
   147d2:	bl	14610 <SDHC_CMD12_StopTransferWaitForBusy()>
			return SDHC_RESULT_ERROR;
   147d6:	movs	r0, #1
   147d8:	b.n	147ba <SDHC_CardWriteBlock(void const*, unsigned long)+0x72>
		}
		SDHC_IRQSTAT |= SDHC_IRQSTAT_BWR;

		if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
   147da:	ldr	r2, [r5, #48]	; 0x30
   147dc:	ldr	r3, [pc, #28]	; (147fc <SDHC_CardWriteBlock(void const*, unsigned long)+0xb4>)
   147de:	orrs	r3, r2
   147e0:	str	r3, [r5, #48]	; 0x30
			(void)SDHC_CMD12_StopTransferWaitForBusy();
   147e2:	bl	14610 <SDHC_CMD12_StopTransferWaitForBusy()>
			return SDHC_RESULT_ERROR;
   147e6:	movs	r0, #1
   147e8:	b.n	147ba <SDHC_CardWriteBlock(void const*, unsigned long)+0x72>
   147ea:	nop
   147ec:	.word	0x200581e8
   147f0:	.word	0x402c0000
   147f4:	.word	0x183a0000
   147f8:	.word	0x01000012
   147fc:	.word	0x00700010

00014800 <SdFile::sync() [clone .part.23] [clone .constprop.37]>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
   14800:	push	{r3, r4, r5, lr}
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
   14802:	ldrsb.w	r3, [r0, #5]
   14806:	cmp	r3, #0
   14808:	blt.n	14812 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x12>
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
}
   1480a:	ldmia.w	sp!, {r3, r4, r5, lr}
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
   1480e:	b.w	142b8 <SdVolume::cacheFlush()>
   14812:	mov	r4, r0
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
   14814:	movs	r1, #1
   14816:	ldr	r0, [r0, #16]
   14818:	bl	14338 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
   1481c:	cbz	r0, 14860 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x60>
  return SdVolume::cacheBuffer_.dir + dirIndex_;
   1481e:	ldrb	r5, [r4, #20]
   14820:	ldr	r3, [pc, #64]	; (14864 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x64>)
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;
   14822:	adds.w	r5, r3, r5, lsl #5
   14826:	beq.n	14860 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x60>

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
   14828:	ldrb	r3, [r4, #6]
   1482a:	cmp	r3, #1
   1482c:	bls.n	1485a <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x5a>

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
   1482e:	ldr	r3, [r4, #28]
    d->firstClusterHigh = firstCluster_ >> 16;

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
   14830:	ldr	r1, [pc, #52]	; (14868 <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x68>)
    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    d->firstClusterHigh = firstCluster_ >> 16;
   14832:	lsrs	r2, r3, #16

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
   14834:	strh	r3, [r5, #26]
    d->firstClusterHigh = firstCluster_ >> 16;

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
   14836:	ldr	r3, [r1, #0]
    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    d->firstClusterHigh = firstCluster_ >> 16;
   14838:	strh	r2, [r5, #20]

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
   1483a:	cbz	r3, 1484a <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x4a>
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
   1483c:	add.w	r1, r5, #22
   14840:	add.w	r0, r5, #24
   14844:	blx	r3
      d->lastAccessDate = d->lastWriteDate;
   14846:	ldrh	r3, [r5, #24]
   14848:	strh	r3, [r5, #18]
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
   1484a:	ldrb	r3, [r4, #5]
   1484c:	and.w	r3, r3, #127	; 0x7f
   14850:	strb	r3, [r4, #5]
  }
  return SdVolume::cacheFlush();
}
   14852:	ldmia.w	sp!, {r3, r4, r5, lr}
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
   14856:	b.w	142b8 <SdVolume::cacheFlush()>
  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
   1485a:	ldr	r3, [r4, #24]
   1485c:	str	r3, [r5, #28]
   1485e:	b.n	1482e <SdFile::sync() [clone .part.23] [clone .constprop.37]+0x2e>
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
}
   14860:	movs	r0, #0
   14862:	pop	{r3, r4, r5, pc}
   14864:	.word	0x20057fe4
   14868:	.word	0x200581f8

0001486c <SdFile::addCluster()>:
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
   1486c:	push	{r4, lr}
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
   1486e:	add.w	r2, r0, #8
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
   14872:	mov	r4, r0
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
   14874:	movs	r1, #1
   14876:	ldr	r0, [r0, #32]
   14878:	bl	1448c <SdVolume::allocContiguous(unsigned long, unsigned long*)>
   1487c:	cbz	r0, 14894 <SdFile::addCluster()+0x28>

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
   1487e:	ldr	r3, [r4, #28]
   14880:	cbnz	r3, 14892 <SdFile::addCluster()+0x26>
    firstCluster_ = curCluster_;
    flags_ |= F_FILE_DIR_DIRTY;
   14882:	ldrb	r3, [r4, #5]
   14884:	movs	r0, #1
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
   14886:	ldr	r2, [r4, #8]
    flags_ |= F_FILE_DIR_DIRTY;
   14888:	orn	r3, r3, #127	; 0x7f
uint8_t SdFile::addCluster() {
  if (!vol_->allocContiguous(1, &curCluster_)) return false;

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    firstCluster_ = curCluster_;
   1488c:	str	r2, [r4, #28]
    flags_ |= F_FILE_DIR_DIRTY;
   1488e:	strb	r3, [r4, #5]
   14890:	pop	{r4, pc}
  }
  return true;
   14892:	movs	r0, #1
}
   14894:	pop	{r4, pc}
   14896:	nop

00014898 <SdFile::seekSet(unsigned long)>:
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
   14898:	push	{r3, r4, r5, r6, r7, lr}
   1489a:	ldrb	r3, [r0, #6]
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
   1489c:	cbz	r3, 148a4 <SdFile::seekSet(unsigned long)+0xc>
   1489e:	ldr	r2, [r0, #24]
   148a0:	cmp	r2, r1
   148a2:	bcs.n	148a8 <SdFile::seekSet(unsigned long)+0x10>
   148a4:	movs	r0, #0
   148a6:	pop	{r3, r4, r5, r6, r7, pc}

  if (type_ == FAT_FILE_TYPE_ROOT16) {
   148a8:	cmp	r3, #2
   148aa:	mov	r7, r1
   148ac:	mov	r5, r0
   148ae:	beq.n	148ea <SdFile::seekSet(unsigned long)+0x52>
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
   148b0:	cbz	r7, 148f0 <SdFile::seekSet(unsigned long)+0x58>
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   148b2:	ldr	r3, [r5, #32]
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
   148b4:	subs	r4, r7, #1
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   148b6:	ldr	r1, [r5, #12]
   148b8:	ldrb	r3, [r3, #16]
   148ba:	subs	r2, r1, #1
   148bc:	adds	r3, #9
   148be:	lsrs	r2, r3
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
   148c0:	lsrs	r4, r3

  if (nNew < nCur || curPosition_ == 0) {
   148c2:	cmp	r2, r4
   148c4:	bhi.n	148cc <SdFile::seekSet(unsigned long)+0x34>
   148c6:	cbz	r1, 148cc <SdFile::seekSet(unsigned long)+0x34>
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
   148c8:	subs	r4, r4, r2
   148ca:	b.n	148d0 <SdFile::seekSet(unsigned long)+0x38>
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);

  if (nNew < nCur || curPosition_ == 0) {
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
   148cc:	ldr	r3, [r5, #28]
   148ce:	str	r3, [r5, #8]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
   148d0:	add.w	r6, r5, #8
   148d4:	b.n	148e4 <SdFile::seekSet(unsigned long)+0x4c>
   148d6:	ldr	r1, [r5, #8]
   148d8:	subs	r4, #1
   148da:	ldr	r0, [r5, #32]
   148dc:	bl	14418 <SdVolume::fatGet(unsigned long, unsigned long*) const>
   148e0:	cmp	r0, #0
   148e2:	beq.n	148a4 <SdFile::seekSet(unsigned long)+0xc>
   148e4:	mov	r2, r6
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
   148e6:	cmp	r4, #0
   148e8:	bne.n	148d6 <SdFile::seekSet(unsigned long)+0x3e>
uint8_t SdFile::seekSet(uint32_t pos) {
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;

  if (type_ == FAT_FILE_TYPE_ROOT16) {
    curPosition_ = pos;
   148ea:	str	r7, [r5, #12]
    return true;
   148ec:	movs	r0, #1
   148ee:	pop	{r3, r4, r5, r6, r7, pc}
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
   148f0:	str	r7, [r5, #8]
    curPosition_ = 0;
    return true;
   148f2:	movs	r0, #1
    return true;
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
    curPosition_ = 0;
   148f4:	str	r7, [r5, #12]
    return true;
   148f6:	pop	{r3, r4, r5, r6, r7, pc}

000148f8 <SdFile::write(void const*, unsigned int)>:
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
   148f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   148fc:	sub	sp, #20
   148fe:	mov	r7, r0
   14900:	str	r2, [sp, #4]

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
   14902:	ldrb	r2, [r0, #6]
   14904:	cmp	r2, #1
   14906:	beq.n	14914 <SdFile::write(void const*, unsigned int)+0x1c>
	int getWriteError() { return write_error; }
	void clearWriteError() { setWriteError(0); }
	int printf(const char *format, ...);
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
   14908:	movs	r3, #1

 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
   1490a:	movs	r0, #0
   1490c:	strb	r3, [r7, #4]
}
   1490e:	add	sp, #20
   14910:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
   14914:	ldrb	r2, [r0, #5]
   14916:	lsls	r4, r2, #30
   14918:	bpl.n	14908 <SdFile::write(void const*, unsigned int)+0x10>

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
   1491a:	lsls	r3, r2, #29
   1491c:	mov	fp, r1
   1491e:	bpl.n	14932 <SdFile::write(void const*, unsigned int)+0x3a>
   14920:	ldr	r1, [r7, #24]
   14922:	ldr	r3, [r7, #12]
   14924:	cmp	r3, r1
   14926:	beq.w	14aaa <SdFile::write(void const*, unsigned int)+0x1b2>
  }
  /**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */
  uint8_t seekEnd(void) {return seekSet(fileSize_);}
   1492a:	bl	14898 <SdFile::seekSet(unsigned long)>
    if (!seekEnd()) goto writeErrorReturn;
   1492e:	cmp	r0, #0
   14930:	beq.n	14908 <SdFile::write(void const*, unsigned int)+0x10>
  }

  while (nToWrite > 0) {
   14932:	ldr	r3, [sp, #4]
   14934:	ldr	r1, [r7, #12]
   14936:	cmp	r3, #0
   14938:	beq.w	14ac6 <SdFile::write(void const*, unsigned int)+0x1ce>
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
   1493c:	ldr.w	r8, [sp, #4]
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
   14940:	ldr.w	r9, [pc, #412]	; 14ae0 <SdFile::write(void const*, unsigned int)+0x1e8>
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
        SdVolume::cacheBlockNumber_ = block;
   14944:	ldr.w	sl, [pc, #412]	; 14ae4 <SdFile::write(void const*, unsigned int)+0x1ec>
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
   14948:	ldr	r0, [r7, #32]
    uint16_t blockOffset = curPosition_ & 0X1FF;
   1494a:	ubfx	r6, r1, #0, #9
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
   1494e:	ldrb	r2, [r0, #4]
   14950:	subs	r2, #1
   14952:	and.w	r5, r2, r1, lsr #9
    if (blockOfCluster == 0 && blockOffset == 0) {
   14956:	ands.w	r5, r5, #255	; 0xff
   1495a:	bne.n	14a04 <SdFile::write(void const*, unsigned int)+0x10c>
   1495c:	cmp	r6, #0
   1495e:	bne.n	14a04 <SdFile::write(void const*, unsigned int)+0x10c>
      // start of new cluster
      if (curCluster_ == 0) {
   14960:	ldr	r1, [r7, #8]
   14962:	cmp	r1, #0
   14964:	bne.n	14a5a <SdFile::write(void const*, unsigned int)+0x162>
        if (firstCluster_ == 0) {
   14966:	ldr	r2, [r7, #28]
   14968:	cmp	r2, #0
   1496a:	beq.w	14a80 <SdFile::write(void const*, unsigned int)+0x188>
        if (!vol_->fatGet(curCluster_, &next)) return false;
        if (vol_->isEOC(next)) {
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
        } else {
          curCluster_ = next;
   1496e:	str	r2, [r7, #8]
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
   14970:	rsb	r4, r6, #512	; 0x200

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   14974:	subs	r2, #2
   14976:	ldrb.w	lr, [r0, #16]
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
   1497a:	uxth	r4, r4

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   1497c:	ldr	r1, [r0, #20]
    }
    // max space in block
    uint16_t n = 512 - blockOffset;

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
   1497e:	cmp	r4, r8
   14980:	bls.n	14a08 <SdFile::write(void const*, unsigned int)+0x110>

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   14982:	lsl.w	r2, r2, lr
   14986:	add	r5, r1
    }
    // max space in block
    uint16_t n = 512 - blockOffset;

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
   14988:	uxth.w	r4, r8

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   1498c:	add	r5, r2
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
   1498e:	cbnz	r6, 14998 <SdFile::write(void const*, unsigned int)+0xa0>
   14990:	ldr	r0, [r7, #12]
   14992:	ldr	r2, [r7, #24]
   14994:	cmp	r0, r2
   14996:	bcs.n	14a40 <SdFile::write(void const*, unsigned int)+0x148>
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
        SdVolume::cacheBlockNumber_ = block;
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
   14998:	mov	r0, r5
   1499a:	movs	r1, #1
   1499c:	bl	14338 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
   149a0:	cmp	r0, #0
   149a2:	beq.n	14908 <SdFile::write(void const*, unsigned int)+0x10>
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
   149a4:	add	r6, r9
      uint8_t* end = dst + n;
   149a6:	add.w	lr, r6, r4
      while (dst != end) *dst++ = *src++;
   149aa:	cmp	r6, lr
   149ac:	beq.n	149ca <SdFile::write(void const*, unsigned int)+0xd2>
   149ae:	add.w	r1, fp, #4294967295
   149b2:	subs	r2, r6, #1
   149b4:	add.w	r5, lr, #4294967295
   149b8:	ldrb.w	r0, [r1, #1]!
   149bc:	strb.w	r0, [r2, #1]!
   149c0:	cmp	r5, r2
   149c2:	bne.n	149b8 <SdFile::write(void const*, unsigned int)+0xc0>
   149c4:	rsb	r6, r6, lr
   149c8:	add	fp, r6
    }
    nToWrite -= n;
    curPosition_ += n;
   149ca:	ldr	r5, [r7, #12]
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
   149cc:	subs.w	r8, r8, r4
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
      uint8_t* end = dst + n;
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
   149d0:	add.w	r1, r4, r5
   149d4:	str	r1, [r7, #12]
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
   149d6:	bne.n	14948 <SdFile::write(void const*, unsigned int)+0x50>
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
   149d8:	ldr	r3, [r7, #24]
   149da:	cmp	r1, r3
   149dc:	bls.n	14ab4 <SdFile::write(void const*, unsigned int)+0x1bc>
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
   149de:	ldrb	r2, [r7, #5]
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
   149e0:	str	r1, [r7, #24]
    flags_ |= F_FILE_DIR_DIRTY;
   149e2:	orr.w	r2, r2, #128	; 0x80
   149e6:	strb	r2, [r7, #5]
  } else if (dateTime_ && nbyte) {
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
   149e8:	lsls	r2, r2, #28
   149ea:	bpl.n	149fc <SdFile::write(void const*, unsigned int)+0x104>
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
  // only allow open files and directories
  if (!isOpen()) return false;
   149ec:	ldrb	r3, [r7, #6]
   149ee:	cmp	r3, #0
   149f0:	beq.n	14908 <SdFile::write(void const*, unsigned int)+0x10>
   149f2:	mov	r0, r7
   149f4:	bl	14800 <SdFile::sync() [clone .part.23] [clone .constprop.37]>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) goto writeErrorReturn;
   149f8:	cmp	r0, #0
   149fa:	beq.n	14908 <SdFile::write(void const*, unsigned int)+0x10>
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
   149fc:	ldr	r0, [sp, #4]
 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
}
   149fe:	add	sp, #20
   14a00:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14a04:	ldr	r2, [r7, #8]
   14a06:	b.n	14970 <SdFile::write(void const*, unsigned int)+0x78>

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   14a08:	lsl.w	r2, r2, lr
   14a0c:	add	r5, r1
    if (n == 512) {
   14a0e:	cmp.w	r4, #512	; 0x200

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   14a12:	add	r5, r2
    if (n == 512) {
   14a14:	bne.n	1498e <SdFile::write(void const*, unsigned int)+0x96>
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
   14a16:	ldr.w	r2, [sl]
   14a1a:	cmp	r5, r2
   14a1c:	beq.n	14a92 <SdFile::write(void const*, unsigned int)+0x19a>
  }
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    return sdCard_->readBlock(block, dst);
  }
  uint8_t writeBlock(uint32_t block, const uint8_t* dst) {
    return sdCard_->writeBlock(block, dst);
   14a1e:	ldr	r2, [pc, #176]	; (14ad0 <SdFile::write(void const*, unsigned int)+0x1d8>)
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
   14a20:	mov	r1, r5
   14a22:	ldr	r0, [r2, #0]
    return SD_readBlock(block, dst);
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
   14a24:	ldrb	r2, [r0, #0]
   14a26:	cmp	r2, #254	; 0xfe
   14a28:	beq.n	14a9c <SdFile::write(void const*, unsigned int)+0x1a4>
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    }
    #endif
    return SD_writeBlock(block, src);
   14a2a:	mov	r2, fp
   14a2c:	bl	14e84 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
   14a30:	cmp	r0, #0
   14a32:	beq.w	14908 <SdFile::write(void const*, unsigned int)+0x10>
      src += 512;
   14a36:	add.w	fp, fp, #512	; 0x200
   14a3a:	mov.w	r4, #512	; 0x200
   14a3e:	b.n	149ca <SdFile::write(void const*, unsigned int)+0xd2>
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
   14a40:	bl	142b8 <SdVolume::cacheFlush()>
   14a44:	cmp	r0, #0
   14a46:	beq.w	14908 <SdFile::write(void const*, unsigned int)+0x10>
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
   14a4a:	ldr	r1, [pc, #136]	; (14ad4 <SdFile::write(void const*, unsigned int)+0x1dc>)
        SdVolume::cacheBlockNumber_ = block;
   14a4c:	str.w	r5, [sl]
   14a50:	ldrb	r2, [r1, #0]
   14a52:	orr.w	r2, r2, #1
   14a56:	strb	r2, [r1, #0]
   14a58:	b.n	149a4 <SdFile::write(void const*, unsigned int)+0xac>
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
   14a5a:	add	r2, sp, #12
   14a5c:	bl	14418 <SdVolume::fatGet(unsigned long, unsigned long*) const>
   14a60:	cmp	r0, #0
   14a62:	beq.w	1490e <SdFile::write(void const*, unsigned int)+0x16>
        if (vol_->isEOC(next)) {
   14a66:	ldr	r0, [r7, #32]
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
   14a68:	movw	r1, #65528	; 0xfff8
   14a6c:	ldr	r3, [pc, #104]	; (14ad8 <SdFile::write(void const*, unsigned int)+0x1e0>)
   14a6e:	ldrb.w	r4, [r0, #32]
   14a72:	ldr	r2, [sp, #12]
   14a74:	cmp	r4, #16
   14a76:	it	ne
   14a78:	movne	r1, r3
   14a7a:	cmp	r2, r1
   14a7c:	bcc.w	1496e <SdFile::write(void const*, unsigned int)+0x76>
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
   14a80:	mov	r0, r7
   14a82:	bl	1486c <SdFile::addCluster()>
   14a86:	cmp	r0, #0
   14a88:	beq.w	14908 <SdFile::write(void const*, unsigned int)+0x10>
   14a8c:	ldr	r0, [r7, #32]
   14a8e:	ldr	r2, [r7, #8]
   14a90:	b.n	14970 <SdFile::write(void const*, unsigned int)+0x78>
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    if (n == 512) {
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
   14a92:	mov.w	r2, #4294967295
   14a96:	str.w	r2, [sl]
   14a9a:	b.n	14a1e <SdFile::write(void const*, unsigned int)+0x126>
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
   14a9c:	mov	r0, fp
   14a9e:	bl	14748 <SDHC_CardWriteBlock(void const*, unsigned long)>
   14aa2:	clz	r0, r0
   14aa6:	lsrs	r0, r0, #5
   14aa8:	b.n	14a30 <SdFile::write(void const*, unsigned int)+0x138>
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
   14aaa:	ldr	r3, [sp, #4]
   14aac:	cmp	r3, #0
   14aae:	bne.w	1493c <SdFile::write(void const*, unsigned int)+0x44>
   14ab2:	b.n	149e8 <SdFile::write(void const*, unsigned int)+0xf0>
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
  } else if (dateTime_ && nbyte) {
   14ab4:	ldr	r3, [pc, #36]	; (14adc <SdFile::write(void const*, unsigned int)+0x1e4>)
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
   14ab6:	ldrb	r2, [r7, #5]
  }
  if (curPosition_ > fileSize_) {
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    flags_ |= F_FILE_DIR_DIRTY;
  } else if (dateTime_ && nbyte) {
   14ab8:	ldr	r3, [r3, #0]
   14aba:	cmp	r3, #0
   14abc:	beq.n	149e8 <SdFile::write(void const*, unsigned int)+0xf0>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
   14abe:	orr.w	r2, r2, #128	; 0x80
   14ac2:	strb	r2, [r7, #5]
   14ac4:	b.n	149e8 <SdFile::write(void const*, unsigned int)+0xf0>
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
   14ac6:	ldr	r3, [r7, #24]
   14ac8:	cmp	r3, r1
   14aca:	bcc.n	149de <SdFile::write(void const*, unsigned int)+0xe6>
   14acc:	ldrb	r2, [r7, #5]
   14ace:	b.n	149e8 <SdFile::write(void const*, unsigned int)+0xf0>
   14ad0:	.word	0x20057fe0
   14ad4:	.word	0x200581e4
   14ad8:	.word	0x0ffffff8
   14adc:	.word	0x200581f8
   14ae0:	.word	0x20057fe4
   14ae4:	.word	0x200207cc

00014ae8 <SdFile::write(unsigned char)>:
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
size_t SdFile::write(uint8_t b) {
   14ae8:	push	{lr}
   14aea:	sub	sp, #12
  return write(&b, 1);
   14aec:	movs	r2, #1
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
size_t SdFile::write(uint8_t b) {
   14aee:	add	r3, sp, #8
   14af0:	strb.w	r1, [r3, #-1]!
  return write(&b, 1);
   14af4:	mov	r1, r3
   14af6:	bl	148f8 <SdFile::write(void const*, unsigned int)>
}
   14afa:	add	sp, #12
   14afc:	ldr.w	pc, [sp], #4

00014b00 <Sd2Card::cardCommand(unsigned char, unsigned long)>:


//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg)
{
   14b00:	push	{r4, r5, r6, r7, lr}
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
   14b02:	ldr	r6, [pc, #156]	; (14ba0 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xa0>)
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14b04:	movs	r7, #255	; 0xff
   14b06:	ldr	r5, [pc, #156]	; (14ba4 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xa4>)
   14b08:	ldr.w	lr, [r6]
   14b0c:	ldr	r3, [r5, #0]
   14b0e:	str	r7, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14b10:	ldr	r4, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14b12:	tst.w	r4, #2031616	; 0x1f0000
   14b16:	beq.n	14b10 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x10>
   14b18:	ldr	r4, [r3, #116]	; 0x74
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) return true;
   14b1a:	uxtb	r4, r4
   14b1c:	cmp	r4, #255	; 0xff
   14b1e:	beq.n	14b2c <Sd2Card::cardCommand(unsigned char, unsigned long)+0x2c>
   14b20:	ldr	r4, [r6, #0]
    d = millis() - t0;
  }
  while (d < timeoutMillis);
   14b22:	rsb	r4, lr, r4
   14b26:	cmp.w	r4, #300	; 0x12c
   14b2a:	bcc.n	14b0e <Sd2Card::cardCommand(unsigned char, unsigned long)+0xe>
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14b2c:	orr.w	r4, r1, #64	; 0x40
   14b30:	str	r4, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14b32:	ldr	r4, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14b34:	tst.w	r4, #2031616	; 0x1f0000
   14b38:	beq.n	14b32 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x32>
   14b3a:	ldr	r4, [r3, #116]	; 0x74
   14b3c:	movs	r6, #24
   14b3e:	lsr.w	r4, r2, r6
   14b42:	uxtb	r4, r4
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14b44:	str	r4, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14b46:	ldr	r4, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14b48:	tst.w	r4, #2031616	; 0x1f0000
   14b4c:	beq.n	14b46 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x46>
   14b4e:	subs	r6, #8
   14b50:	ldr	r4, [r3, #116]	; 0x74

  // send command
  spiSend(cmd | 0x40);

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
   14b52:	cmn.w	r6, #8
   14b56:	bne.n	14b3e <Sd2Card::cardCommand(unsigned char, unsigned long)+0x3e>

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
   14b58:	cbz	r1, 14b9a <Sd2Card::cardCommand(unsigned char, unsigned long)+0x9a>
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
   14b5a:	cmp	r1, #8
   14b5c:	ite	eq
   14b5e:	moveq	r2, #135	; 0x87
   14b60:	movne	r2, #255	; 0xff
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14b62:	str	r2, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14b64:	ldr	r2, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14b66:	tst.w	r2, #2031616	; 0x1f0000
   14b6a:	beq.n	14b64 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x64>
   14b6c:	ldr	r2, [r3, #116]	; 0x74
   14b6e:	movs	r1, #0
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14b70:	movs	r4, #255	; 0xff
   14b72:	str	r4, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14b74:	ldr	r2, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14b76:	tst.w	r2, #2031616	; 0x1f0000
   14b7a:	beq.n	14b74 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x74>
   14b7c:	ldr	r2, [r3, #116]	; 0x74
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
   14b7e:	uxtb	r3, r1
   14b80:	adds	r1, #1
   14b82:	subs	r3, #255	; 0xff
   14b84:	uxtb	r2, r2
   14b86:	it	ne
   14b88:	movne	r3, #1
   14b8a:	strb	r2, [r0, #1]
   14b8c:	ands.w	r3, r3, r2, lsr #7
   14b90:	beq.n	14b96 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x96>
   14b92:	ldr	r3, [r5, #0]
   14b94:	b.n	14b72 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x72>
  return status_;
}
   14b96:	mov	r0, r2
   14b98:	pop	{r4, r5, r6, r7, pc}
   14b9a:	movs	r2, #149	; 0x95
   14b9c:	b.n	14b62 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x62>
   14b9e:	nop
   14ba0:	.word	0x20058548
   14ba4:	.word	0x200207d0

00014ba8 <Sd2Card::chipSelectHigh()>:
//------------------------------------------------------------------------------
#ifdef SPI_HAS_TRANSACTION
static uint8_t chip_select_asserted = 0;
#endif
void Sd2Card::chipSelectHigh(void) {
   14ba8:	push	{r4, lr}
  digitalWrite(chipSelectPin_, HIGH);
   14baa:	movs	r1, #1
   14bac:	ldrb	r0, [r0, #0]
   14bae:	bl	16b60 <digitalWrite>
#ifdef SPI_HAS_TRANSACTION
  if (chip_select_asserted) {
   14bb2:	ldr	r1, [pc, #76]	; (14c00 <Sd2Card::chipSelectHigh()+0x58>)
   14bb4:	ldrb	r3, [r1, #0]
   14bb6:	cbz	r3, 14bf4 <Sd2Card::chipSelectHigh()+0x4c>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
   14bb8:	ldr	r2, [pc, #72]	; (14c04 <Sd2Card::chipSelectHigh()+0x5c>)
    chip_select_asserted = 0;
   14bba:	movs	r0, #0
   14bbc:	ldrb	r3, [r2, #19]
   14bbe:	strb	r0, [r1, #0]
   14bc0:	mov	r1, r3
   14bc2:	cbz	r3, 14bf4 <Sd2Card::chipSelectHigh()+0x4c>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
   14bc4:	lsls	r0, r3, #31
   14bc6:	bpl.n	14bce <Sd2Card::chipSelectHigh()+0x26>
   14bc8:	ldr	r4, [r2, #40]	; 0x28
   14bca:	ldr	r0, [pc, #60]	; (14c08 <Sd2Card::chipSelectHigh()+0x60>)
   14bcc:	str	r4, [r0, #0]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
   14bce:	lsls	r3, r3, #30
   14bd0:	bpl.n	14bda <Sd2Card::chipSelectHigh()+0x32>
   14bd2:	ldr	r0, [r2, #44]	; 0x2c
   14bd4:	ldr	r3, [pc, #52]	; (14c0c <Sd2Card::chipSelectHigh()+0x64>)
   14bd6:	ldrb	r1, [r2, #19]
   14bd8:	str	r0, [r3, #0]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
   14bda:	lsls	r4, r1, #29
   14bdc:	bpl.n	14be6 <Sd2Card::chipSelectHigh()+0x3e>
   14bde:	ldr	r0, [r2, #48]	; 0x30
   14be0:	ldr	r3, [pc, #44]	; (14c10 <Sd2Card::chipSelectHigh()+0x68>)
   14be2:	ldrb	r1, [r2, #19]
   14be4:	str	r0, [r3, #0]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
   14be6:	lsls	r0, r1, #28
   14be8:	bmi.n	14bf6 <Sd2Card::chipSelectHigh()+0x4e>
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
   14bea:	lsls	r3, r1, #27
   14bec:	bpl.n	14bf4 <Sd2Card::chipSelectHigh()+0x4c>
   14bee:	ldr	r2, [r2, #56]	; 0x38
   14bf0:	ldr	r3, [pc, #32]	; (14c14 <Sd2Card::chipSelectHigh()+0x6c>)
   14bf2:	str	r2, [r3, #0]
   14bf4:	pop	{r4, pc}
		#endif
		if (interruptMasksUsed) {
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
   14bf6:	ldr	r0, [r2, #52]	; 0x34
   14bf8:	ldr	r3, [pc, #28]	; (14c18 <Sd2Card::chipSelectHigh()+0x70>)
   14bfa:	ldrb	r1, [r2, #19]
   14bfc:	str	r0, [r3, #0]
   14bfe:	b.n	14bea <Sd2Card::chipSelectHigh()+0x42>
   14c00:	.word	0x20058204
   14c04:	.word	0x200207d0
   14c08:	.word	0xe000e100
   14c0c:	.word	0xe000e104
   14c10:	.word	0xe000e108
   14c14:	.word	0xe000e110
   14c18:	.word	0xe000e10c

00014c1c <Sd2Card::chipSelectLow()>:
#endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
#ifdef SPI_HAS_TRANSACTION
  if (!chip_select_asserted) {
   14c1c:	ldr	r2, [pc, #256]	; (14d20 <Sd2Card::chipSelectLow()+0x104>)
   14c1e:	ldrb	r3, [r2, #0]
   14c20:	cbz	r3, 14c2a <Sd2Card::chipSelectLow()+0xe>
    chip_select_asserted = 1;
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
   14c22:	ldrb	r0, [r0, #0]
   14c24:	movs	r1, #0
   14c26:	b.w	16b60 <digitalWrite>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
   14c2a:	ldr	r3, [pc, #248]	; (14d24 <Sd2Card::chipSelectLow()+0x108>)
   14c2c:	ldr	r1, [pc, #248]	; (14d28 <Sd2Card::chipSelectLow()+0x10c>)
    SPI.endTransaction();
  }
#endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
   14c2e:	push	{r4, r5, r6, r7, lr}
#ifdef SPI_HAS_TRANSACTION
  if (!chip_select_asserted) {
    chip_select_asserted = 1;
   14c30:	movs	r4, #1
   14c32:	ldrb	r6, [r3, #19]
   14c34:	ldr	r5, [r1, #0]
   14c36:	strb	r4, [r2, #0]
   14c38:	ldr	r4, [r1, #4]
   14c3a:	cmp	r6, #0
   14c3c:	beq.n	14ca2 <Sd2Card::chipSelectLow()+0x86>
			__disable_irq();
   14c3e:	cpsid	i
			if (interruptMasksUsed & 0x01) {
   14c40:	ldrb	r1, [r3, #19]
   14c42:	lsls	r6, r1, #31
   14c44:	mov	r2, r1
   14c46:	bpl.n	14c5a <Sd2Card::chipSelectLow()+0x3e>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
   14c48:	ldr.w	lr, [pc, #252]	; 14d48 <Sd2Card::chipSelectLow()+0x12c>
   14c4c:	ldr	r7, [r3, #20]
   14c4e:	ldr.w	r6, [lr]
   14c52:	ands	r6, r7
   14c54:	str	r6, [r3, #40]	; 0x28
				NVIC_ICER0 = interruptSave[0];
   14c56:	str.w	r6, [lr]
			}
			if (interruptMasksUsed & 0x02) {
   14c5a:	lsls	r7, r1, #30
   14c5c:	bpl.n	14c6c <Sd2Card::chipSelectLow()+0x50>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
   14c5e:	ldr	r6, [pc, #204]	; (14d2c <Sd2Card::chipSelectLow()+0x110>)
   14c60:	ldr	r1, [r3, #24]
   14c62:	ldr	r7, [r6, #0]
   14c64:	ldrb	r2, [r3, #19]
   14c66:	ands	r1, r7
   14c68:	str	r1, [r3, #44]	; 0x2c
				NVIC_ICER1 = interruptSave[1];
   14c6a:	str	r1, [r6, #0]
			}
			if (interruptMasksUsed & 0x04) {
   14c6c:	lsls	r6, r2, #29
   14c6e:	bpl.n	14c7e <Sd2Card::chipSelectLow()+0x62>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
   14c70:	ldr	r6, [pc, #188]	; (14d30 <Sd2Card::chipSelectLow()+0x114>)
   14c72:	ldr	r1, [r3, #28]
   14c74:	ldr	r7, [r6, #0]
   14c76:	ldrb	r2, [r3, #19]
   14c78:	ands	r1, r7
   14c7a:	str	r1, [r3, #48]	; 0x30
				NVIC_ICER2 = interruptSave[2];
   14c7c:	str	r1, [r6, #0]
			}
			if (interruptMasksUsed & 0x08) {
   14c7e:	lsls	r1, r2, #28
   14c80:	bpl.n	14c90 <Sd2Card::chipSelectLow()+0x74>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
   14c82:	ldr	r6, [pc, #176]	; (14d34 <Sd2Card::chipSelectLow()+0x118>)
   14c84:	ldr	r1, [r3, #32]
   14c86:	ldr	r7, [r6, #0]
   14c88:	ldrb	r2, [r3, #19]
   14c8a:	ands	r1, r7
   14c8c:	str	r1, [r3, #52]	; 0x34
				NVIC_ICER3 = interruptSave[3];
   14c8e:	str	r1, [r6, #0]
			}
			if (interruptMasksUsed & 0x10) {
   14c90:	lsls	r2, r2, #27
   14c92:	bpl.n	14ca0 <Sd2Card::chipSelectLow()+0x84>
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
   14c94:	ldr	r1, [pc, #160]	; (14d38 <Sd2Card::chipSelectLow()+0x11c>)
   14c96:	ldr	r2, [r3, #36]	; 0x24
   14c98:	ldr	r6, [r1, #0]
   14c9a:	ands	r2, r6
   14c9c:	str	r2, [r3, #56]	; 0x38
				NVIC_ICER4 = interruptSave[4];
   14c9e:	str	r2, [r1, #0]
			}
			__enable_irq();
   14ca0:	cpsie	i
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
   14ca2:	ldr	r2, [r3, #8]
   14ca4:	ldr	r1, [pc, #124]	; (14d24 <Sd2Card::chipSelectLow()+0x108>)
   14ca6:	cmp	r2, r5
   14ca8:	beq.n	14d02 <Sd2Card::chipSelectLow()+0xe6>
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
   14caa:	ldr	r2, [pc, #144]	; (14d3c <Sd2Card::chipSelectLow()+0x120>)
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
   14cac:	ldr	r6, [pc, #144]	; (14d40 <Sd2Card::chipSelectLow()+0x124>)
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();

			uint32_t cbcmr = CCM_CBCMR;
   14cae:	ldr	r2, [r2, #24]
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
   14cb0:	str	r5, [r1, #8]

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
   14cb2:	ubfx	r1, r2, #4, #2
   14cb6:	ubfx	r2, r2, #26, #3
   14cba:	ldr.w	r1, [r6, r1, lsl #2]
   14cbe:	adds	r2, #1
   14cc0:	udiv	r1, r1, r2
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
   14cc4:	cbz	r5, 14cfe <Sd2Card::chipSelectLow()+0xe2>
   14cc6:	udiv	r2, r1, r5

			if (d && clkhz/d > _clock) d++;
   14cca:	cbz	r2, 14cde <Sd2Card::chipSelectLow()+0xc2>
   14ccc:	udiv	r1, r1, r2
   14cd0:	cmp	r1, r5
   14cd2:	it	hi
   14cd4:	addhi	r2, #1
			if (d > 257) d= 257;  // max div
   14cd6:	cmp.w	r2, #258	; 0x102
   14cda:	bcc.n	14d06 <Sd2Card::chipSelectLow()+0xea>
   14cdc:	ldr	r2, [pc, #100]	; (14d44 <Sd2Card::chipSelectLow()+0x128>)
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
   14cde:	str	r2, [r3, #12]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
   14ce0:	ldr	r3, [r3, #0]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
   14ce2:	movs	r6, #0
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
   14ce4:	movs	r5, #3
		port().CCR = _ccr;
		port().TCR = settings.tcr;
		port().CR = LPSPI_CR_MEN;
   14ce6:	movs	r1, #1
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
   14ce8:	str	r6, [r3, #16]
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
   14cea:	str	r5, [r3, #36]	; 0x24
		port().CCR = _ccr;
   14cec:	str	r2, [r3, #64]	; 0x40
		port().TCR = settings.tcr;
   14cee:	str	r4, [r3, #96]	; 0x60
		port().CR = LPSPI_CR_MEN;
   14cf0:	str	r1, [r3, #16]
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
   14cf2:	movs	r1, #0
   14cf4:	ldrb	r0, [r0, #0]
}
   14cf6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  if (!chip_select_asserted) {
    chip_select_asserted = 1;
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
   14cfa:	b.w	16b60 <digitalWrite>

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
   14cfe:	mov	r2, r1
   14d00:	b.n	14cca <Sd2Card::chipSelectLow()+0xae>
   14d02:	ldr	r2, [r1, #12]
   14d04:	b.n	14ce0 <Sd2Card::chipSelectLow()+0xc4>

			if (d && clkhz/d > _clock) d++;
			if (d > 257) d= 257;  // max div
			if (d > 2) {
   14d06:	cmp	r2, #2
   14d08:	it	ls
   14d0a:	movls	r2, #0
   14d0c:	bls.n	14cde <Sd2Card::chipSelectLow()+0xc2>
   14d0e:	subs	r2, #2
   14d10:	lsrs	r5, r2, #1
   14d12:	lsls	r1, r5, #16
   14d14:	orr.w	r2, r2, r5, lsl #8
   14d18:	and.w	r1, r1, #16711680	; 0xff0000
   14d1c:	orrs	r2, r1
   14d1e:	b.n	14cde <Sd2Card::chipSelectLow()+0xc2>
   14d20:	.word	0x20058204
   14d24:	.word	0x200207d0
   14d28:	.word	0x200581fc
   14d2c:	.word	0xe000e184
   14d30:	.word	0xe000e188
   14d34:	.word	0xe000e18c
   14d38:	.word	0xe000e190
   14d3c:	.word	0x400fc000
   14d40:	.word	0x2001fa9c
   14d44:	.word	0x007f7fff
   14d48:	.word	0xe000e180

00014d4c <Sd2Card::waitStartBlock()>:
   14d4c:	ldr	r1, [pc, #60]	; (14d8c <Sd2Card::waitStartBlock()+0x40>)
  while (d < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
   14d4e:	push	{r4, r5, r6}
   14d50:	ldr	r5, [pc, #60]	; (14d90 <Sd2Card::waitStartBlock()+0x44>)
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14d52:	movs	r4, #255	; 0xff
   14d54:	ldr	r6, [r1, #0]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
   14d56:	ldr	r2, [r5, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14d58:	str	r4, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14d5a:	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14d5c:	tst.w	r3, #2031616	; 0x1f0000
   14d60:	beq.n	14d5a <Sd2Card::waitStartBlock()+0xe>
   14d62:	ldr	r3, [r2, #116]	; 0x74
   14d64:	uxtb	r3, r3
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
   14d66:	cmp	r3, #255	; 0xff
   14d68:	strb	r3, [r0, #1]
   14d6a:	bne.n	14d7c <Sd2Card::waitStartBlock()+0x30>
   14d6c:	ldr	r3, [r1, #0]
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
   14d6e:	subs	r3, r3, r6
   14d70:	cmp.w	r3, #300	; 0x12c
   14d74:	bls.n	14d56 <Sd2Card::waitStartBlock()+0xa>
      return false; // SD_CARD_ERROR_READ_TIMEOUT
   14d76:	movs	r0, #0
  }
  if (status_ != DATA_START_BLOCK) {
    return false; // SD_CARD_ERROR_READ
  }
  return true;
}
   14d78:	pop	{r4, r5, r6}
   14d7a:	bx	lr
uint8_t Sd2Card::waitStartBlock(void) {
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
      return false; // SD_CARD_ERROR_READ_TIMEOUT
   14d7c:	sub.w	r0, r3, #254	; 0xfe
   14d80:	clz	r0, r0
  }
  if (status_ != DATA_START_BLOCK) {
    return false; // SD_CARD_ERROR_READ
  }
  return true;
}
   14d84:	pop	{r4, r5, r6}
uint8_t Sd2Card::waitStartBlock(void) {
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
      return false; // SD_CARD_ERROR_READ_TIMEOUT
   14d86:	lsrs	r0, r0, #5
  }
  if (status_ != DATA_START_BLOCK) {
    return false; // SD_CARD_ERROR_READ
  }
  return true;
}
   14d88:	bx	lr
   14d8a:	nop
   14d8c:	.word	0x20058548
   14d90:	.word	0x200207d0

00014d94 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)>:

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_readBlock(uint32_t block, uint8_t* dst)
{
   14d94:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) block <<= 9;
   14d96:	ldrb	r3, [r0, #2]

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_readBlock(uint32_t block, uint8_t* dst)
{
   14d98:	mov	r5, r1
   14d9a:	mov	r4, r0
   14d9c:	mov	r6, r2
  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) block <<= 9;
   14d9e:	cmp	r3, #3
   14da0:	it	ne
   14da2:	lslne	r5, r1, #9
  chipSelectLow();
   14da4:	bl	14c1c <Sd2Card::chipSelectLow()>
  if (cardCommand(CMD17, block)) {
   14da8:	movs	r1, #17
   14daa:	mov	r2, r5
   14dac:	mov	r0, r4
   14dae:	bl	14b00 <Sd2Card::cardCommand(unsigned char, unsigned long)>
   14db2:	cbnz	r0, 14dbc <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x28>
    goto fail; // SD_CARD_ERROR_CMD17
  }
  if (!waitStartBlock()) {
   14db4:	mov	r0, r4
   14db6:	bl	14d4c <Sd2Card::waitStartBlock()>
   14dba:	cbnz	r0, 14dc6 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x32>
#endif
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
   14dbc:	mov	r0, r4
   14dbe:	bl	14ba8 <Sd2Card::chipSelectHigh()>
  return false;
   14dc2:	movs	r0, #0
}
   14dc4:	pop	{r4, r5, r6, pc}
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
		port().TCR = tcr;	// restore back
		return port().RDR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
   14dc6:	ldr	r5, [pc, #68]	; (14e0c <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x78>)
 static  uint8_t spiRec(void) {
	return SPI.transfer(0xff);
 }
 
 static void spiRec(uint8_t* buf, size_t len) {
	memset(buf, 0xFF, len);
   14dc8:	mov.w	r2, #512	; 0x200
   14dcc:	movs	r1, #255	; 0xff
   14dce:	mov	r0, r6
   14dd0:	bl	1b018 <memset>
   14dd4:	mov.w	r3, #512	; 0x200
   14dd8:	mov	r2, r6
   14dda:	mov	r0, r5
   14ddc:	mov	r1, r6
   14dde:	bl	15078 <SPIClass::transfer(void const*, void*, unsigned int)>
   14de2:	ldr	r3, [r5, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14de4:	movs	r2, #255	; 0xff
   14de6:	str	r2, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14de8:	ldr	r2, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14dea:	tst.w	r2, #2031616	; 0x1f0000
   14dee:	beq.n	14de8 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x54>
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14df0:	movs	r2, #255	; 0xff
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
			if (fifo > 0) return port().RDR;
   14df2:	ldr	r1, [r3, #116]	; 0x74
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14df4:	str	r2, [r3, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14df6:	ldr	r2, [r3, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14df8:	tst.w	r2, #2031616	; 0x1f0000
   14dfc:	beq.n	14df6 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x62>
  dst[511] = SPDR;
  // skip CRC bytes
  spiRec();
  spiRec();
#endif
  chipSelectHigh();
   14dfe:	mov	r0, r4
   14e00:	ldr	r3, [r3, #116]	; 0x74
   14e02:	bl	14ba8 <Sd2Card::chipSelectHigh()>
  return true;
   14e06:	movs	r0, #1
   14e08:	pop	{r4, r5, r6, pc}
   14e0a:	nop
   14e0c:	.word	0x200207d0

00014e10 <Sd2Card::writeData(unsigned char, unsigned char const*)>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   14e10:	ldr	r3, [pc, #108]	; (14e80 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x70>)
   14e12:	push	{r4}
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
   14e14:	ldr	r4, [r3, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e16:	str	r1, [r4, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14e18:	ldr	r3, [r4, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14e1a:	tst.w	r3, #2031616	; 0x1f0000
   14e1e:	beq.n	14e18 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x8>
   14e20:	subs	r1, r2, #1
   14e22:	ldr	r3, [r4, #116]	; 0x74
   14e24:	addw	r2, r2, #511	; 0x1ff
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e28:	ldrb.w	r3, [r1, #1]!
   14e2c:	str	r3, [r4, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14e2e:	ldr	r3, [r4, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14e30:	tst.w	r3, #2031616	; 0x1f0000
   14e34:	beq.n	14e2e <Sd2Card::writeData(unsigned char, unsigned char const*)+0x1e>
  // wait for last data byte
  while (!(SPSR & (1 << SPIF)));

#else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
  for (uint16_t i = 0; i < 512; i++) {
   14e36:	cmp	r1, r2
   14e38:	ldr	r3, [r4, #116]	; 0x74
   14e3a:	bne.n	14e28 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x18>
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e3c:	movs	r3, #255	; 0xff
   14e3e:	str	r3, [r4, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14e40:	ldr	r3, [r4, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14e42:	tst.w	r3, #2031616	; 0x1f0000
   14e46:	beq.n	14e40 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x30>
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e48:	movs	r3, #255	; 0xff
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
			if (fifo > 0) return port().RDR;
   14e4a:	ldr	r2, [r4, #116]	; 0x74
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e4c:	str	r3, [r4, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14e4e:	ldr	r3, [r4, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14e50:	tst.w	r3, #2031616	; 0x1f0000
   14e54:	beq.n	14e4e <Sd2Card::writeData(unsigned char, unsigned char const*)+0x3e>
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e56:	movs	r3, #255	; 0xff
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
			if (fifo > 0) return port().RDR;
   14e58:	ldr	r2, [r4, #116]	; 0x74
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14e5a:	str	r3, [r4, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14e5c:	ldr	r3, [r4, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14e5e:	tst.w	r3, #2031616	; 0x1f0000
   14e62:	beq.n	14e5c <Sd2Card::writeData(unsigned char, unsigned char const*)+0x4c>
   14e64:	ldr	r3, [r4, #116]	; 0x74
   14e66:	uxtb	r3, r3
   14e68:	and.w	r2, r3, #31
  }
#endif  // OPTIMIZE_HARDWARE_SPI
  spiSend(0xff);  // dummy crc
  spiSend(0xff);  // dummy crc

  status_ = spiRec();
   14e6c:	strb	r3, [r0, #1]
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    return false; // SD_CARD_ERROR_WRITE
  }
  return true;
}
   14e6e:	ldr.w	r4, [sp], #4
   14e72:	sub.w	r0, r2, #5
   14e76:	clz	r0, r0
   14e7a:	lsrs	r0, r0, #5
   14e7c:	bx	lr
   14e7e:	nop
   14e80:	.word	0x200207d0

00014e84 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>:
 * \param[in] blockNumber Logical block to be written.
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_writeBlock(uint32_t blockNumber, const uint8_t* src) {
   14e84:	push	{r3, r4, r5, r6, r7, lr}
   14e86:	mov	r5, r0
#if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
   14e88:	cbz	r1, 14ea6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x22>
    goto fail; // SD_CARD_ERROR_WRITE_BLOCK_ZERO
  }
#endif  // SD_PROTECT_BLOCK_ZERO

  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   14e8a:	ldrb	r3, [r0, #2]
   14e8c:	mov	r4, r1
   14e8e:	mov	r6, r2
   14e90:	cmp	r3, #3
   14e92:	it	ne
   14e94:	lslne	r4, r1, #9
  chipSelectLow();
   14e96:	bl	14c1c <Sd2Card::chipSelectLow()>
  if (cardCommand(CMD24, blockNumber)) {
   14e9a:	movs	r1, #24
   14e9c:	mov	r2, r4
   14e9e:	mov	r0, r5
   14ea0:	bl	14b00 <Sd2Card::cardCommand(unsigned char, unsigned long)>
   14ea4:	cbz	r0, 14eb0 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x2c>
  }
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
   14ea6:	mov	r0, r5
   14ea8:	bl	14ba8 <Sd2Card::chipSelectHigh()>
  return false;
   14eac:	movs	r0, #0
}
   14eae:	pop	{r3, r4, r5, r6, r7, pc}
  if (type_ != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
  chipSelectLow();
  if (cardCommand(CMD24, blockNumber)) {
    goto fail; // SD_CARD_ERROR_CMD24
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
   14eb0:	mov	r2, r6
   14eb2:	movs	r1, #254	; 0xfe
   14eb4:	mov	r0, r5
   14eb6:	bl	14e10 <Sd2Card::writeData(unsigned char, unsigned char const*)>
   14eba:	cmp	r0, #0
   14ebc:	beq.n	14ea6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x22>
   14ebe:	ldr	r1, [pc, #84]	; (14f14 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x90>)
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14ec0:	movs	r0, #255	; 0xff
   14ec2:	ldr	r6, [pc, #84]	; (14f18 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x94>)
   14ec4:	ldr	r7, [r1, #0]
   14ec6:	ldr	r2, [r6, #0]
   14ec8:	str	r0, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14eca:	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14ecc:	tst.w	r3, #2031616	; 0x1f0000
   14ed0:	beq.n	14eca <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x46>
   14ed2:	ldr	r4, [r2, #116]	; 0x74
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) return true;
   14ed4:	uxtb	r4, r4
   14ed6:	cmp	r4, #255	; 0xff
   14ed8:	beq.n	14ee6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x62>
   14eda:	ldr	r3, [r1, #0]
    d = millis() - t0;
  }
  while (d < timeoutMillis);
   14edc:	subs	r3, r3, r7
   14ede:	cmp.w	r3, #600	; 0x258
   14ee2:	bcc.n	14ec8 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x44>
   14ee4:	b.n	14ea6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x22>
  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    goto fail; // SD_CARD_ERROR_WRITE_TIMEOUT
  }
  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
   14ee6:	movs	r2, #0
   14ee8:	movs	r1, #13
   14eea:	mov	r0, r5
   14eec:	bl	14b00 <Sd2Card::cardCommand(unsigned char, unsigned long)>
   14ef0:	cmp	r0, #0
   14ef2:	bne.n	14ea6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x22>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
   14ef4:	ldr	r2, [r6, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
   14ef6:	str	r4, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
   14ef8:	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
   14efa:	tst.w	r3, #2031616	; 0x1f0000
   14efe:	beq.n	14ef8 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x74>
   14f00:	ldr	r3, [r2, #116]	; 0x74
   14f02:	tst.w	r3, #255	; 0xff
   14f06:	bne.n	14ea6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x22>
    goto fail; // SD_CARD_ERROR_WRITE_PROGRAMMING
  }
  chipSelectHigh();
   14f08:	mov	r0, r5
   14f0a:	bl	14ba8 <Sd2Card::chipSelectHigh()>
  return true;
   14f0e:	movs	r0, #1
   14f10:	pop	{r3, r4, r5, r6, r7, pc}
   14f12:	nop
   14f14:	.word	0x20058548
   14f18:	.word	0x200207d0

00014f1c <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm>:
public:
	SPISettings(uint32_t clockIn, uint8_t bitOrderIn, uint8_t dataModeIn) : _clock(clockIn) {
		init_AlwaysInline(bitOrderIn, dataModeIn);
	}

	SPISettings() : _clock(4000000) {
   14f1c:	ldr	r3, [pc, #8]	; (14f28 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0xc>)
   14f1e:	movs	r2, #7
   14f20:	ldr	r1, [pc, #8]	; (14f2c <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0x10>)
   14f22:	stmia.w	r3, {r1, r2}
   14f26:	bx	lr
   14f28:	.word	0x200581fc
   14f2c:	.word	0x003d0900

00014f30 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
   14f30:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
   14f32:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
   14f34:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
   14f36:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
   14f38:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
   14f3a:	beq.n	14f44 <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
   14f3c:	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
   14f40:	b.w	177ac <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
   14f44:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
   14f46:	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
   14f4a:	bx	r3

00014f4c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>:
	if (interruptMask[n >> 5] == 0) {
		interruptMasksUsed &= ~(1 << (n >> 5));
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
   14f4c:	push	{r4, r5, r6}
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 
   14f4e:	movw	r5, #513	; 0x201
   14f52:	ldr	r4, [r0, #0]
   14f54:	str	r5, [r4, #16]

	while (count > 0) {
   14f56:	cbz	r3, 14fa0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
   14f58:	mov	r6, r3
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
   14f5a:	cbz	r1, 14f9a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4e>
   14f5c:	ldrb	r5, [r1, #0]
   14f5e:	adds	r1, #1
		count--; // how many bytes left to output.
   14f60:	subs	r3, #1
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
   14f62:	str	r5, [r4, #100]	; 0x64
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
   14f64:	ldr	r5, [r4, #112]	; 0x70
   14f66:	lsls	r5, r5, #30
   14f68:	bmi.n	14f78 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
				uint8_t b = port().RDR;  // Read any pending RX bytes in
   14f6a:	ldr	r5, [r4, #116]	; 0x74
				if (p_read) *p_read++ = b; 
				count_read--;
   14f6c:	subs	r6, #1
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
				uint8_t b = port().RDR;  // Read any pending RX bytes in
   14f6e:	uxtb	r5, r5
				if (p_read) *p_read++ = b; 
   14f70:	cbz	r2, 14f78 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x2c>
   14f72:	strb	r5, [r2, #0]
   14f74:	adds	r2, #1
   14f76:	ldr	r4, [r0, #0]
				count_read--;
			}
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;
   14f78:	ldr	r5, [r4, #20]
	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
   14f7a:	lsls	r5, r5, #31
   14f7c:	bpl.n	14f64 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x18>

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
   14f7e:	cmp	r3, #0
   14f80:	bne.n	14f5a <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0xe>
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;

	}

	// now lets wait for all of the read bytes to be returned...
	while (count_read) {
   14f82:	cbz	r6, 14fa0 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x54>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
   14f84:	ldr	r1, [r0, #0]
		if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
   14f86:	ldr	r3, [r1, #112]	; 0x70
   14f88:	lsls	r3, r3, #30
   14f8a:	bmi.n	14f86 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x3a>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
   14f8c:	ldr	r3, [r1, #116]	; 0x74
   14f8e:	uxtb	r3, r3
			if (p_read) *p_read++ = b; 
   14f90:	cbz	r2, 14f96 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x4a>
   14f92:	strb	r3, [r2, #0]
   14f94:	adds	r2, #1
			count_read--;
   14f96:	subs	r6, #1
   14f98:	b.n	14f82 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x36>
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
   14f9a:	ldrb.w	r5, [r0, #60]	; 0x3c
   14f9e:	b.n	14f60 <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]+0x14>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
			if (p_read) *p_read++ = b; 
			count_read--;
		}
	}
}
   14fa0:	pop	{r4, r5, r6}
   14fa2:	bx	lr

00014fa4 <_spi_dma_rxISR0()>:
	// Save back out
	port().TCR = tcr;

}

void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
   14fa4:	push	{r4, r5, r6, r7, lr}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
   14fa6:	ldr	r4, [pc, #192]	; (15068 <_spi_dma_rxISR0()+0xc4>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
   14fa8:	ldr	r3, [pc, #192]	; (1506c <_spi_dma_rxISR0()+0xc8>)
   14faa:	ldr	r0, [r4, #72]	; 0x48
	_dmaTX->clearComplete();
   14fac:	ldr	r5, [r4, #68]	; 0x44
   14fae:	ldrb	r1, [r0, #4]
	_dmaRX->clearComplete();

	if (_dma_count_remaining) {
   14fb0:	ldr	r2, [r4, #64]	; 0x40
   14fb2:	strb	r1, [r3, #31]
   14fb4:	ldrb	r1, [r5, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
   14fb6:	strb	r1, [r3, #28]
   14fb8:	ldrb	r1, [r0, #4]
   14fba:	strb	r1, [r3, #28]
   14fbc:	cbz	r2, 14ffe <_spi_dma_rxISR0()+0x5a>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > MAX_DMA_COUNT) {
   14fbe:	cmp.w	r2, #32768	; 0x8000
   14fc2:	bcs.n	14ff6 <_spi_dma_rxISR0()+0x52>
   14fc4:	ldr	r3, [r5, #0]
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
   14fc6:	uxth	r2, r2
//=========================================================================
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
   14fc8:	ldrh	r1, [r3, #30]
   14fca:	lsls	r6, r1, #16
   14fcc:	bmi.n	15046 <_spi_dma_rxISR0()+0xa2>
		tcd->BITER = len & 0x7fff;
   14fce:	strh	r2, [r3, #30]
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
   14fd0:	ldrh	r1, [r3, #30]
   14fd2:	uxth	r1, r1
   14fd4:	strh	r1, [r3, #22]
   14fd6:	ldr	r3, [r0, #0]
//=========================================================================
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
   14fd8:	ldrh	r1, [r3, #30]
   14fda:	lsls	r1, r1, #16
   14fdc:	bmi.n	15038 <_spi_dma_rxISR0()+0x94>
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
   14fde:	strh	r2, [r3, #30]
			_dma_count_remaining -= MAX_DMA_COUNT;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);

			_dma_count_remaining = 0;
   14fe0:	movs	r1, #0
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
	}
	tcd->CITER = tcd->BITER; 
   14fe2:	ldrh	r2, [r3, #30]
   14fe4:	uxth	r2, r2
   14fe6:	strh	r2, [r3, #22]
			_dma_count_remaining -= MAX_DMA_COUNT;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);

			_dma_count_remaining = 0;
   14fe8:	str	r1, [r4, #64]	; 0x40
   14fea:	ldrb	r2, [r0, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
   14fec:	ldr	r3, [pc, #124]	; (1506c <_spi_dma_rxISR0()+0xc8>)
   14fee:	strb	r2, [r3, #27]
   14ff0:	ldrb	r2, [r5, #4]
   14ff2:	strb	r2, [r3, #27]
   14ff4:	pop	{r4, r5, r6, r7, pc}

	if (_dma_count_remaining) {
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > MAX_DMA_COUNT) {
			_dma_count_remaining -= MAX_DMA_COUNT;
   14ff6:	ldr	r3, [pc, #120]	; (15070 <_spi_dma_rxISR0()+0xcc>)
   14ff8:	add	r3, r2
   14ffa:	str	r3, [r4, #64]	; 0x40
   14ffc:	b.n	14fea <_spi_dma_rxISR0()+0x46>

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
   14ffe:	ldr	r0, [r4, #76]	; 0x4c
		}
		_dmaRX->enable();
		_dmaTX->enable();
	} else {

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
   15000:	movs	r5, #15
   15002:	ldr	r3, [r4, #0]
 		port().DER = 0;		// DMA no longer doing TX (or RX)

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
   15004:	movw	lr, #769	; 0x301
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
   15008:	ldr	r1, [r0, #0]

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
 		port().DER = 0;		// DMA no longer doing TX (or RX)

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...
   1500a:	mov.w	r7, #16128	; 0x3f00
		}
		_dmaRX->enable();
		_dmaTX->enable();
	} else {

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
   1500e:	str	r5, [r3, #88]	; 0x58
 		port().DER = 0;		// DMA no longer doing TX (or RX)

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
   15010:	movs	r6, #3
		_dma_event_responder->triggerEvent();
   15012:	ldr	r5, [r1, #0]
   15014:	ldr	r1, [pc, #92]	; (15074 <_spi_dma_rxISR0()+0xd0>)
		_dmaRX->enable();
		_dmaTX->enable();
	} else {

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
 		port().DER = 0;		// DMA no longer doing TX (or RX)
   15016:	str	r2, [r3, #28]
   15018:	cmp	r5, r1

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
   1501a:	str.w	lr, [r3, #16]
		port().SR = 0x3f00;	// clear out all of the other status...
   1501e:	str	r7, [r3, #20]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
   15020:	strb.w	r6, [r4, #61]	; 0x3d
   15024:	bne.n	15056 <_spi_dma_rxISR0()+0xb2>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
   15026:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
   15028:	str	r2, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
   1502a:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
   1502c:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
   1502e:	beq.n	15060 <_spi_dma_rxISR0()+0xbc>
	// Save back out
	port().TCR = tcr;

}

void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
   15030:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
   15034:	b.w	177ac <EventResponder::triggerEventNotImmediate()>
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
   15038:	ldrh	r1, [r3, #30]
   1503a:	ubfx	r2, r2, #0, #9
   1503e:	and.w	r1, r1, #65024	; 0xfe00
   15042:	orrs	r2, r1
   15044:	b.n	14fde <_spi_dma_rxISR0()+0x3a>
   15046:	ldrh	r1, [r3, #30]
   15048:	ubfx	r6, r2, #0, #9
   1504c:	and.w	r1, r1, #65024	; 0xfe00
   15050:	orrs	r1, r6
   15052:	strh	r1, [r3, #30]
   15054:	b.n	14fd0 <_spi_dma_rxISR0()+0x2c>

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
   15056:	mov	r3, r5
   15058:	mov	r1, r2
	// Save back out
	port().TCR = tcr;

}

void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
   1505a:	ldmia.w	sp!, {r4, r5, r6, r7, lr}

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
		port().SR = 0x3f00;	// clear out all of the other status...

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
   1505e:	bx	r3
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
   15060:	ldr	r3, [r0, #8]
	// Save back out
	port().TCR = tcr;

}

void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
   15062:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   15066:	bx	r3
   15068:	.word	0x200207d0
   1506c:	.word	0x400e8000
   15070:	.word	0xffff8001
   15074:	.word	0x00014f31

00015078 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
   15078:	cbz	r3, 1507e <SPIClass::transfer(void const*, void*, unsigned int)+0x6>
   1507a:	b.w	14f4c <SPIClass::transfer(void const*, void*, unsigned int) [clone .part.11]>
   1507e:	bx	lr

00015080 <AudioFilterBiquad_F32::update()>:


#include "AudioFilterBiquad_F32.h"

void AudioFilterBiquad_F32::update(void)
{
   15080:	push	{r3, r4, r5, lr}
  audio_block_f32_t *block;

  block = AudioStream_F32::receiveWritable_f32();
   15082:	movs	r1, #0


#include "AudioFilterBiquad_F32.h"

void AudioFilterBiquad_F32::update(void)
{
   15084:	mov	r5, r0
  audio_block_f32_t *block;

  block = AudioStream_F32::receiveWritable_f32();
   15086:	bl	152c4 <AudioStream_F32::receiveWritable_f32(unsigned int)>
  if (!block) return;
   1508a:	cbz	r0, 150ba <AudioFilterBiquad_F32::update()+0x3a>

  // If there's no coefficient table, give up.  
  if (coeff_p == NULL) {
   1508c:	ldr	r3, [r5, #68]	; 0x44
   1508e:	cbz	r3, 150b2 <AudioFilterBiquad_F32::update()+0x32>
    AudioStream_F32::release(block);
    return;
  }

  // do passthru
  if (coeff_p == IIR_F32_PASSTHRU) {
   15090:	cmp	r3, #1
   15092:	mov	r4, r0
   15094:	beq.n	150a6 <AudioFilterBiquad_F32::update()+0x26>
    AudioStream_F32::release(block);
    return;
  }

  // do IIR
  arm_biquad_cascade_df1_f32(&iir_inst, block->data, block->data, block->length);
   15096:	adds	r2, r0, #4
   15098:	ldr.w	r3, [r0, #520]	; 0x208
   1509c:	add.w	r0, r5, #72	; 0x48
   150a0:	mov	r1, r2
   150a2:	bl	17c2c <arm_biquad_cascade_df1_f32>
  
  //transmit the data
  AudioStream_F32::transmit(block); // send the IIR output
   150a6:	mov	r0, r5
   150a8:	movs	r2, #0
   150aa:	mov	r1, r4
   150ac:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
  AudioStream_F32::release(block);
   150b0:	mov	r0, r4
}
   150b2:	ldmia.w	sp!, {r3, r4, r5, lr}
  // do IIR
  arm_biquad_cascade_df1_f32(&iir_inst, block->data, block->data, block->length);
  
  //transmit the data
  AudioStream_F32::transmit(block); // send the IIR output
  AudioStream_F32::release(block);
   150b6:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>
   150ba:	pop	{r3, r4, r5, pc}

000150bc <allocate_f32_memory(int)>:
uint8_t AudioStream_F32::f32_memory_used_max = 0;

audio_block_f32_t* allocate_f32_memory(const int num) {
	static bool firstTime=true;
	static audio_block_f32_t *data_f32;
	if (firstTime == true) {
   150bc:	ldr	r3, [pc, #88]	; (15118 <allocate_f32_memory(int)+0x5c>)
   150be:	ldrb	r2, [r3, #0]
   150c0:	cbz	r2, 15110 <allocate_f32_memory(int)+0x54>
		firstTime = false;
   150c2:	movs	r2, #0
		data_f32 = new audio_block_f32_t[num];
   150c4:	cmp.w	r0, #4030464	; 0x3d8000
uint32_t AudioStream_F32::f32_memory_pool_available_mask[6];

uint8_t AudioStream_F32::f32_memory_used = 0;
uint8_t AudioStream_F32::f32_memory_used_max = 0;

audio_block_f32_t* allocate_f32_memory(const int num) {
   150c8:	push	{r4, r5, r6, lr}
	static bool firstTime=true;
	static audio_block_f32_t *data_f32;
	if (firstTime == true) {
		firstTime = false;
   150ca:	strb	r2, [r3, #0]
		data_f32 = new audio_block_f32_t[num];
   150cc:	bls.n	15106 <allocate_f32_memory(int)+0x4a>
   150ce:	mov.w	r3, #4294967295
   150d2:	mov	r4, r0
   150d4:	mov	r0, r3
   150d6:	bl	17c0c <operator new[](unsigned int)>
   150da:	mov	r6, r0
   150dc:	cbz	r4, 150fe <allocate_f32_memory(int)+0x42>
   150de:	add.w	r3, r0, #532	; 0x214
   150e2:	movs	r2, #0
//modeled on the existing teensy audio block struct, which uses Int16
//https://github.com/PaulStoffregen/cores/blob/268848cdb0121f26b7ef6b82b4fb54abbe465427/teensy3/AudioStream.h
// Added id, per Tympan.  Should not disturb existing programs.  Bob Larkin June 2020
class audio_block_f32_t {
	public:
		audio_block_f32_t(void) {};
   150e4:	movs	r1, #128	; 0x80
   150e6:	ldr	r5, [pc, #52]	; (1511c <allocate_f32_memory(int)+0x60>)
   150e8:	adds	r2, #1
   150ea:	str.w	r1, [r3, #-16]
   150ee:	str.w	r1, [r3, #-12]
   150f2:	cmp	r2, r4
   150f4:	str.w	r5, [r3, #-8]
   150f8:	add.w	r3, r3, #532	; 0x214
   150fc:	bne.n	150e8 <allocate_f32_memory(int)+0x2c>
   150fe:	ldr	r3, [pc, #32]	; (15120 <allocate_f32_memory(int)+0x64>)
   15100:	mov	r0, r6
   15102:	str	r6, [r3, #0]
   15104:	pop	{r4, r5, r6, pc}
   15106:	mov.w	r3, #532	; 0x214
   1510a:	mul.w	r3, r3, r0
   1510e:	b.n	150d2 <allocate_f32_memory(int)+0x16>
   15110:	ldr	r3, [pc, #12]	; (15120 <allocate_f32_memory(int)+0x64>)
   15112:	ldr	r0, [r3, #0]
	}
	return data_f32;
}
   15114:	bx	lr
   15116:	nop
   15118:	.word	0x20020820
   1511c:	.word	0x473b8000
   15120:	.word	0x20058220

00015124 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)>:
}

// Set up the pool of audio data blocks
// placing them all onto the free list
void AudioStream_F32::initialize_f32_memory(audio_block_f32_t *data, unsigned int num)
{
   15124:	cmp	r1, #192	; 0xc0
   15126:	push	{r4, r5, r6, r7}
   15128:	it	cs
   1512a:	movcs	r1, #192	; 0xc0
  unsigned int i;

  //Serial.println("AudioStream_F32 initialize_memory");
  //delay(10);
  if (num > 192) num = 192;
  __disable_irq();
   1512c:	cpsid	i
  f32_memory_pool = data;
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
   1512e:	movs	r3, #0
   15130:	ldr	r6, [pc, #68]	; (15178 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x54>)

  //Serial.println("AudioStream_F32 initialize_memory");
  //delay(10);
  if (num > 192) num = 192;
  __disable_irq();
  f32_memory_pool = data;
   15132:	ldr	r2, [pc, #72]	; (1517c <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x58>)
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
   15134:	str	r3, [r6, #0]

  //Serial.println("AudioStream_F32 initialize_memory");
  //delay(10);
  if (num > 192) num = 192;
  __disable_irq();
  f32_memory_pool = data;
   15136:	str	r0, [r2, #0]
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
   15138:	str	r3, [r6, #4]
   1513a:	str	r3, [r6, #8]
   1513c:	str	r3, [r6, #12]
   1513e:	str	r3, [r6, #16]
   15140:	str	r3, [r6, #20]
  }
  for (i=0; i < num; i++) {
   15142:	cbz	r1, 15170 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x4c>
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
   15144:	movs	r7, #1
   15146:	lsrs	r5, r3, #5
   15148:	and.w	r4, r3, #31
  __disable_irq();
  f32_memory_pool = data;
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
   1514c:	adds	r3, #1
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
   1514e:	ldr.w	r2, [r6, r5, lsl #2]
   15152:	lsl.w	r4, r7, r4
  __disable_irq();
  f32_memory_pool = data;
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
   15156:	cmp	r3, r1
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
   15158:	orr.w	r2, r2, r4
   1515c:	str.w	r2, [r6, r5, lsl #2]
  __disable_irq();
  f32_memory_pool = data;
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
   15160:	bne.n	15146 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x22>
   15162:	movs	r3, #0
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
  }
  for (i=0; i < num; i++) {
    data[i].memory_pool_index = i;
   15164:	strb	r3, [r0, #1]
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
  }
  for (i=0; i < num; i++) {
   15166:	adds	r3, #1
   15168:	add.w	r0, r0, #532	; 0x214
   1516c:	cmp	r3, r1
   1516e:	bne.n	15164 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x40>
    data[i].memory_pool_index = i;
  }
  __enable_irq();
   15170:	cpsie	i

} // end initialize_memory
   15172:	pop	{r4, r5, r6, r7}
   15174:	bx	lr
   15176:	nop
   15178:	.word	0x20058208
   1517c:	.word	0x20058228

00015180 <AudioMemory_F32(int)>:
		firstTime = false;
		data_f32 = new audio_block_f32_t[num];
	}
	return data_f32;
}
void AudioMemory_F32(const int num) {
   15180:	push	{r4, lr}
   15182:	mov	r4, r0
	audio_block_f32_t *data_f32 = allocate_f32_memory(num);
   15184:	bl	150bc <allocate_f32_memory(int)>
	if (data_f32 != NULL) AudioStream_F32::initialize_f32_memory(data_f32, num);
   15188:	cbz	r0, 15194 <AudioMemory_F32(int)+0x14>
   1518a:	mov	r1, r4
}
   1518c:	ldmia.w	sp!, {r4, lr}
	}
	return data_f32;
}
void AudioMemory_F32(const int num) {
	audio_block_f32_t *data_f32 = allocate_f32_memory(num);
	if (data_f32 != NULL) AudioStream_F32::initialize_f32_memory(data_f32, num);
   15190:	b.w	15124 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)>
   15194:	pop	{r4, pc}
   15196:	nop

00015198 <AudioStream_F32::allocate_f32()>:
} // end initialize_memory

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_f32_t * AudioStream_F32::allocate_f32(void)
{
   15198:	push	{r4, r5, r6}
  uint32_t *p;
  audio_block_f32_t *block;
  uint8_t used;

  p = f32_memory_pool_available_mask;
  __disable_irq();
   1519a:	cpsid	i
  do {
    avail = *p; if (avail) break;
   1519c:	ldr	r3, [pc, #128]	; (15220 <AudioStream_F32::allocate_f32()+0x88>)
   1519e:	ldr	r0, [r3, #0]
   151a0:	cbnz	r0, 151ac <AudioStream_F32::allocate_f32()+0x14>
    p++; avail = *p; if (avail) break;
   151a2:	ldr	r0, [r3, #4]
   151a4:	cbz	r0, 151f2 <AudioStream_F32::allocate_f32()+0x5a>
   151a6:	adds	r3, #4
   151a8:	movs	r1, #32
   151aa:	b.n	151ae <AudioStream_F32::allocate_f32()+0x16>
   151ac:	movs	r1, #0
    //Serial.println("alloc_f32:null");
    return NULL;
  } while (0);
  n = __builtin_clz(avail);
  *p = avail & ~(0x80000000 >> n);
  used = f32_memory_used + 1;
   151ae:	ldr	r6, [pc, #116]	; (15224 <AudioStream_F32::allocate_f32()+0x8c>)
    p++; avail = *p; if (avail) break;
    __enable_irq();
    //Serial.println("alloc_f32:null");
    return NULL;
  } while (0);
  n = __builtin_clz(avail);
   151b0:	clz	r5, r0
  *p = avail & ~(0x80000000 >> n);
   151b4:	mov.w	r4, #2147483648	; 0x80000000
  used = f32_memory_used + 1;
   151b8:	ldrb	r2, [r6, #0]
    __enable_irq();
    //Serial.println("alloc_f32:null");
    return NULL;
  } while (0);
  n = __builtin_clz(avail);
  *p = avail & ~(0x80000000 >> n);
   151ba:	lsrs	r4, r5
  used = f32_memory_used + 1;
   151bc:	adds	r2, #1
    __enable_irq();
    //Serial.println("alloc_f32:null");
    return NULL;
  } while (0);
  n = __builtin_clz(avail);
  *p = avail & ~(0x80000000 >> n);
   151be:	bic.w	r0, r0, r4
  used = f32_memory_used + 1;
   151c2:	uxtb	r2, r2
    __enable_irq();
    //Serial.println("alloc_f32:null");
    return NULL;
  } while (0);
  n = __builtin_clz(avail);
  *p = avail & ~(0x80000000 >> n);
   151c4:	str	r0, [r3, #0]
  used = f32_memory_used + 1;
  f32_memory_used = used;
   151c6:	strb	r2, [r6, #0]
  __enable_irq();
   151c8:	cpsie	i
  index = p - f32_memory_pool_available_mask;
  block = f32_memory_pool + ((index << 5) + (31 - n));
   151ca:	mov.w	r0, #532	; 0x214
   151ce:	subs	r1, r1, r5
   151d0:	movw	r3, #16492	; 0x406c
   151d4:	ldr	r5, [pc, #80]	; (15228 <AudioStream_F32::allocate_f32()+0x90>)
   151d6:	mul.w	r1, r0, r1
  block->ref_count = 1;
   151da:	movs	r4, #1
  *p = avail & ~(0x80000000 >> n);
  used = f32_memory_used + 1;
  f32_memory_used = used;
  __enable_irq();
  index = p - f32_memory_pool_available_mask;
  block = f32_memory_pool + ((index << 5) + (31 - n));
   151dc:	ldr	r0, [r5, #0]
   151de:	add	r3, r1
  block->ref_count = 1;
  if (used > f32_memory_used_max) f32_memory_used_max = used;
   151e0:	ldr	r1, [pc, #72]	; (1522c <AudioStream_F32::allocate_f32()+0x94>)
  used = f32_memory_used + 1;
  f32_memory_used = used;
  __enable_irq();
  index = p - f32_memory_pool_available_mask;
  block = f32_memory_pool + ((index << 5) + (31 - n));
  block->ref_count = 1;
   151e2:	strb	r4, [r0, r3]
  *p = avail & ~(0x80000000 >> n);
  used = f32_memory_used + 1;
  f32_memory_used = used;
  __enable_irq();
  index = p - f32_memory_pool_available_mask;
  block = f32_memory_pool + ((index << 5) + (31 - n));
   151e4:	add	r0, r3
  block->ref_count = 1;
  if (used > f32_memory_used_max) f32_memory_used_max = used;
   151e6:	ldrb	r3, [r1, #0]
   151e8:	cmp	r3, r2
   151ea:	it	cc
   151ec:	strbcc	r2, [r1, #0]
  //Serial.print("alloc_f32:");
  //Serial.println((uint32_t)block, HEX);
  return block;
}
   151ee:	pop	{r4, r5, r6}
   151f0:	bx	lr
  p = f32_memory_pool_available_mask;
  __disable_irq();
  do {
    avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
   151f2:	ldr	r0, [r3, #8]
   151f4:	cbnz	r0, 15200 <AudioStream_F32::allocate_f32()+0x68>
    p++; avail = *p; if (avail) break;
   151f6:	ldr	r0, [r3, #12]
   151f8:	cbz	r0, 15206 <AudioStream_F32::allocate_f32()+0x6e>
   151fa:	adds	r3, #12
   151fc:	movs	r1, #96	; 0x60
   151fe:	b.n	151ae <AudioStream_F32::allocate_f32()+0x16>
  p = f32_memory_pool_available_mask;
  __disable_irq();
  do {
    avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
   15200:	adds	r3, #8
   15202:	movs	r1, #64	; 0x40
   15204:	b.n	151ae <AudioStream_F32::allocate_f32()+0x16>
    p++; avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
   15206:	ldr	r0, [r3, #16]
   15208:	cbnz	r0, 15214 <AudioStream_F32::allocate_f32()+0x7c>
    p++; avail = *p; if (avail) break;
   1520a:	ldr	r0, [r3, #20]
   1520c:	cbz	r0, 1521a <AudioStream_F32::allocate_f32()+0x82>
   1520e:	adds	r3, #20
   15210:	movs	r1, #160	; 0xa0
   15212:	b.n	151ae <AudioStream_F32::allocate_f32()+0x16>
  do {
    avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
   15214:	adds	r3, #16
   15216:	movs	r1, #128	; 0x80
   15218:	b.n	151ae <AudioStream_F32::allocate_f32()+0x16>
    p++; avail = *p; if (avail) break;
    __enable_irq();
   1521a:	cpsie	i
    //Serial.println("alloc_f32:null");
    return NULL;
   1521c:	b.n	151ee <AudioStream_F32::allocate_f32()+0x56>
   1521e:	nop
   15220:	.word	0x20058208
   15224:	.word	0x20058224
   15228:	.word	0x20058228
   1522c:	.word	0x20058225

00015230 <AudioStream_F32::release(audio_block_f32_t*)>:
// Release ownership of a data block.  If no
// other streams have ownership, the block is
// returned to the free pool
void AudioStream_F32::release(audio_block_f32_t *block)
{
  uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
   15230:	ldrb	r2, [r0, #1]
  uint32_t index = block->memory_pool_index >> 5;

  __disable_irq();
   15232:	cpsid	i
  if (block->ref_count > 1) {
   15234:	ldrb	r3, [r0, #0]
   15236:	cmp	r3, #1
   15238:	bls.n	15242 <AudioStream_F32::release(audio_block_f32_t*)+0x12>
    block->ref_count--;
   1523a:	subs	r3, #1
   1523c:	strb	r3, [r0, #0]
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
    f32_memory_used--;
  }
  __enable_irq();
   1523e:	cpsie	i
   15240:	bx	lr
  if (block->ref_count > 1) {
    block->ref_count--;
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
   15242:	mvns	r0, r2
   15244:	mov.w	r3, #2147483648	; 0x80000000
// other streams have ownership, the block is
// returned to the free pool
void AudioStream_F32::release(audio_block_f32_t *block)
{
  uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
  uint32_t index = block->memory_pool_index >> 5;
   15248:	asrs	r2, r2, #5
  if (block->ref_count > 1) {
    block->ref_count--;
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
   1524a:	and.w	r0, r0, #31

// Release ownership of a data block.  If no
// other streams have ownership, the block is
// returned to the free pool
void AudioStream_F32::release(audio_block_f32_t *block)
{
   1524e:	push	{r4, r5}
  if (block->ref_count > 1) {
    block->ref_count--;
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
   15250:	ldr	r5, [pc, #28]	; (15270 <AudioStream_F32::release(audio_block_f32_t*)+0x40>)
   15252:	lsr.w	r0, r3, r0
    f32_memory_used--;
   15256:	ldr	r4, [pc, #28]	; (15274 <AudioStream_F32::release(audio_block_f32_t*)+0x44>)
  if (block->ref_count > 1) {
    block->ref_count--;
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
   15258:	ldr.w	r1, [r5, r2, lsl #2]
    f32_memory_used--;
   1525c:	ldrb	r3, [r4, #0]
  if (block->ref_count > 1) {
    block->ref_count--;
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
   1525e:	orrs	r1, r0
    f32_memory_used--;
   15260:	subs	r3, #1
  if (block->ref_count > 1) {
    block->ref_count--;
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
   15262:	str.w	r1, [r5, r2, lsl #2]
    f32_memory_used--;
   15266:	strb	r3, [r4, #0]
  }
  __enable_irq();
   15268:	cpsie	i
}
   1526a:	pop	{r4, r5}
   1526c:	bx	lr
   1526e:	nop
   15270:	.word	0x20058208
   15274:	.word	0x20058224

00015278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>:
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream_F32::transmit(audio_block_f32_t *block, unsigned char index)
{
  //Serial.print("AudioStream_F32: transmit().  start...index = ");Serial.println(index);
  for (AudioConnection_F32 *c = destination_list_f32; c != NULL; c = c->next_dest) {
   15278:	ldr	r3, [r0, #28]
   1527a:	cbz	r3, 152aa <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x32>
// owned by this object.  Normally, a block must be released
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream_F32::transmit(audio_block_f32_t *block, unsigned char index)
{
   1527c:	push	{r4, r5}
   1527e:	b.n	15284 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0xc>
  //Serial.print("AudioStream_F32: transmit().  start...index = ");Serial.println(index);
  for (AudioConnection_F32 *c = destination_list_f32; c != NULL; c = c->next_dest) {
   15280:	ldr	r3, [r3, #12]
   15282:	cbz	r3, 152a8 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x30>
  	  //Serial.print("  : loop1, c->src_index = ");Serial.println(c->src_index);
    if (c->src_index == index) {
   15284:	ldrb	r0, [r3, #8]
   15286:	cmp	r0, r2
   15288:	bne.n	15280 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x8>
    	//Serial.println("  : if1");
      if (c->dst.inputQueue_f32[c->dest_index] == NULL) {
   1528a:	ldr	r0, [r3, #4]
   1528c:	ldrb	r4, [r3, #9]
   1528e:	ldr	r0, [r0, #32]
   15290:	ldr.w	r5, [r0, r4, lsl #2]
   15294:	cmp	r5, #0
   15296:	bne.n	15280 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x8>
      	  //Serial.println("  : if2");
        c->dst.inputQueue_f32[c->dest_index] = block;
   15298:	str.w	r1, [r0, r4, lsl #2]
        block->ref_count++;
   1529c:	ldrb	r0, [r1, #0]
   1529e:	adds	r0, #1
   152a0:	strb	r0, [r1, #0]
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream_F32::transmit(audio_block_f32_t *block, unsigned char index)
{
  //Serial.print("AudioStream_F32: transmit().  start...index = ");Serial.println(index);
  for (AudioConnection_F32 *c = destination_list_f32; c != NULL; c = c->next_dest) {
   152a2:	ldr	r3, [r3, #12]
   152a4:	cmp	r3, #0
   152a6:	bne.n	15284 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0xc>
          //Serial.print("  : block->ref_count = "); Serial.println(block->ref_count);
      }
    }
  } 
  //Serial.println("AudioStream_F32: transmit(). finished.");
}
   152a8:	pop	{r4, r5}
   152aa:	bx	lr

000152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>:
// may be shared with other streams, so it must not be written
audio_block_f32_t * AudioStream_F32::receiveReadOnly_f32(unsigned int index)
{
  audio_block_f32_t *in;

  if (index >= num_inputs_f32) return NULL;
   152ac:	ldrb	r3, [r0, #24]
   152ae:	cmp	r3, r1
   152b0:	bls.n	152c0 <AudioStream_F32::receiveReadOnly_f32(unsigned int)+0x14>
  in = inputQueue_f32[index];
   152b2:	ldr	r3, [r0, #32]
  inputQueue_f32[index] = NULL;
   152b4:	movs	r2, #0
audio_block_f32_t * AudioStream_F32::receiveReadOnly_f32(unsigned int index)
{
  audio_block_f32_t *in;

  if (index >= num_inputs_f32) return NULL;
  in = inputQueue_f32[index];
   152b6:	ldr.w	r0, [r3, r1, lsl #2]
  inputQueue_f32[index] = NULL;
   152ba:	str.w	r2, [r3, r1, lsl #2]
  return in;
   152be:	bx	lr
// may be shared with other streams, so it must not be written
audio_block_f32_t * AudioStream_F32::receiveReadOnly_f32(unsigned int index)
{
  audio_block_f32_t *in;

  if (index >= num_inputs_f32) return NULL;
   152c0:	movs	r0, #0
  in = inputQueue_f32[index];
  inputQueue_f32[index] = NULL;
  return in;
}
   152c2:	bx	lr

000152c4 <AudioStream_F32::receiveWritable_f32(unsigned int)>:


// Receive block from an input.  The block will not
// be shared, so its contents may be changed.
audio_block_f32_t * AudioStream_F32::receiveWritable_f32(unsigned int index)
{
   152c4:	push	{r3, r4, r5, lr}
  audio_block_f32_t *in, *p;

  if (index >= num_inputs_f32) return NULL;
   152c6:	ldrb	r3, [r0, #24]
   152c8:	cmp	r3, r1
   152ca:	bls.n	15302 <AudioStream_F32::receiveWritable_f32(unsigned int)+0x3e>
  in = inputQueue_f32[index];
   152cc:	ldr	r3, [r0, #32]
  inputQueue_f32[index] = NULL;
   152ce:	movs	r2, #0
audio_block_f32_t * AudioStream_F32::receiveWritable_f32(unsigned int index)
{
  audio_block_f32_t *in, *p;

  if (index >= num_inputs_f32) return NULL;
  in = inputQueue_f32[index];
   152d0:	ldr.w	r4, [r3, r1, lsl #2]
  inputQueue_f32[index] = NULL;
   152d4:	str.w	r2, [r3, r1, lsl #2]
  if (in && in->ref_count > 1) {
   152d8:	cbz	r4, 15302 <AudioStream_F32::receiveWritable_f32(unsigned int)+0x3e>
   152da:	ldrb	r3, [r4, #0]
   152dc:	cmp	r3, #1
   152de:	bls.n	152fe <AudioStream_F32::receiveWritable_f32(unsigned int)+0x3a>
    p = allocate_f32();
   152e0:	bl	15198 <AudioStream_F32::allocate_f32()>
    if (p) memcpy(p->data, in->data, sizeof(p->data));
   152e4:	mov	r5, r0
   152e6:	cbz	r0, 152f4 <AudioStream_F32::receiveWritable_f32(unsigned int)+0x30>
   152e8:	mov.w	r2, #512	; 0x200
   152ec:	adds	r1, r4, #4
   152ee:	adds	r0, #4
   152f0:	bl	15578 <memcpy>
    in->ref_count--;
   152f4:	ldrb	r3, [r4, #0]

  if (index >= num_inputs_f32) return NULL;
  in = inputQueue_f32[index];
  inputQueue_f32[index] = NULL;
  if (in && in->ref_count > 1) {
    p = allocate_f32();
   152f6:	mov	r0, r5
    if (p) memcpy(p->data, in->data, sizeof(p->data));
    in->ref_count--;
   152f8:	subs	r3, #1
   152fa:	strb	r3, [r4, #0]
   152fc:	pop	{r3, r4, r5, pc}
   152fe:	mov	r0, r4
    in = p;
  }
  return in;
}
   15300:	pop	{r3, r4, r5, pc}
// be shared, so its contents may be changed.
audio_block_f32_t * AudioStream_F32::receiveWritable_f32(unsigned int index)
{
  audio_block_f32_t *in, *p;

  if (index >= num_inputs_f32) return NULL;
   15302:	movs	r0, #0
   15304:	pop	{r3, r4, r5, pc}
   15306:	nop

00015308 <AudioConnection_F32::connect()>:
}

void AudioConnection_F32::connect(void) {
  AudioConnection_F32 *p;
  
  if (dest_index > dst.num_inputs_f32) return;
   15308:	ldr	r3, [r0, #4]
   1530a:	ldrb	r2, [r0, #9]
   1530c:	ldrb	r3, [r3, #24]
   1530e:	cmp	r2, r3
   15310:	bhi.n	15330 <AudioConnection_F32::connect()+0x28>
  __disable_irq();
   15312:	cpsid	i
  p = src.destination_list_f32;
   15314:	ldr	r1, [r0, #0]
   15316:	ldr	r2, [r1, #28]
  if (p == NULL) {
   15318:	cbnz	r2, 1531e <AudioConnection_F32::connect()+0x16>
   1531a:	b.n	15332 <AudioConnection_F32::connect()+0x2a>
   1531c:	mov	r2, r3
    src.destination_list_f32 = this;
  } else {
    while (p->next_dest) p = p->next_dest;
   1531e:	ldr	r3, [r2, #12]
   15320:	cmp	r3, #0
   15322:	bne.n	1531c <AudioConnection_F32::connect()+0x14>
    p->next_dest = this;
   15324:	str	r0, [r2, #12]
  }
  src.active = true;
  dst.active = true;
   15326:	ldr	r2, [r0, #4]
    src.destination_list_f32 = this;
  } else {
    while (p->next_dest) p = p->next_dest;
    p->next_dest = this;
  }
  src.active = true;
   15328:	movs	r3, #1
   1532a:	strb	r3, [r1, #8]
  dst.active = true;
   1532c:	strb	r3, [r2, #8]
  __enable_irq();
   1532e:	cpsie	i
   15330:	bx	lr
  
  if (dest_index > dst.num_inputs_f32) return;
  __disable_irq();
  p = src.destination_list_f32;
  if (p == NULL) {
    src.destination_list_f32 = this;
   15332:	str	r0, [r1, #28]
   15334:	b.n	15326 <AudioConnection_F32::connect()+0x1e>
   15336:	nop

00015338 <AudioMixer4_F32::update()>:
 * MIT License.  use at your own risk.
*/

#include "AudioMixer_F32.h"

void AudioMixer4_F32::update(void) {
   15338:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1533c:	mov	r7, r0
  audio_block_f32_t *in, *out=NULL;
  int channel = 0;
   1533e:	movs	r4, #0
  
  //get the first available channel
  while  (channel < 4) {
	  out = receiveWritable_f32(channel);
   15340:	mov	r1, r4
   15342:	mov	r0, r7
   15344:	bl	152c4 <AudioStream_F32::receiveWritable_f32(unsigned int)>
	  if (out) break;
   15348:	mov	r9, r0
   1534a:	cbnz	r0, 15356 <AudioMixer4_F32::update()+0x1e>
	  channel++;
   1534c:	adds	r4, #1
void AudioMixer4_F32::update(void) {
  audio_block_f32_t *in, *out=NULL;
  int channel = 0;
  
  //get the first available channel
  while  (channel < 4) {
   1534e:	cmp	r4, #4
   15350:	bne.n	15340 <AudioMixer4_F32::update()+0x8>
   15352:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  out = receiveWritable_f32(channel);
	  if (out) break;
	  channel++;
  }
  if (!out) return;  //there was no data output array available, so exit.
  arm_scale_f32(out->data, multiplier[channel], out->data, out->length);
   15356:	add.w	r8, r0, #4
   1535a:	add.w	r3, r7, r4, lsl #2
  
  //add in the remaining channels, as available
  channel++;
   1535e:	adds	r5, r4, #1
	  out = receiveWritable_f32(channel);
	  if (out) break;
	  channel++;
  }
  if (!out) return;  //there was no data output array available, so exit.
  arm_scale_f32(out->data, multiplier[channel], out->data, out->length);
   15360:	ldr.w	r2, [r0, #520]	; 0x208
   15364:	mov	r1, r8
   15366:	mov	r0, r8
   15368:	vldr	s0, [r3, #56]	; 0x38
   1536c:	bl	17dc4 <arm_scale_f32>
  
  //add in the remaining channels, as available
  channel++;
  while  (channel < 4) {
   15370:	cmp	r5, #4
   15372:	beq.n	153c6 <AudioMixer4_F32::update()+0x8e>
   15374:	adds	r4, #15
   15376:	add.w	r4, r7, r4, lsl #2
    in = receiveReadOnly_f32(channel);
   1537a:	mov	r1, r5
   1537c:	mov	r0, r7
   1537e:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
		AudioStream_F32::release(tmp);
		AudioStream_F32::release(in);
	} else {
		//do nothing, this vector is empty
	}
	channel++;
   15382:	adds	r5, #1
  
  //add in the remaining channels, as available
  channel++;
  while  (channel < 4) {
    in = receiveReadOnly_f32(channel);
    if (in) {
   15384:	mov	sl, r0
   15386:	cbz	r0, 153be <AudioMixer4_F32::update()+0x86>
		audio_block_f32_t *tmp = allocate_f32();
   15388:	bl	15198 <AudioStream_F32::allocate_f32()>
   1538c:	mov	r6, r0

		arm_scale_f32(in->data, multiplier[channel], tmp->data, tmp->length);
   1538e:	vldr	s0, [r4]
   15392:	add.w	r0, sl, #4
   15396:	add.w	fp, r6, #4
   1539a:	ldr.w	r2, [r6, #520]	; 0x208
   1539e:	mov	r1, fp
   153a0:	bl	17dc4 <arm_scale_f32>
		arm_add_f32(out->data, tmp->data, out->data, tmp->length);
   153a4:	mov	r1, fp
   153a6:	ldr.w	r3, [r6, #520]	; 0x208
   153aa:	mov	r2, r8
   153ac:	mov	r0, r8
   153ae:	bl	17e30 <arm_add_f32>

		AudioStream_F32::release(tmp);
   153b2:	mov	r0, r6
   153b4:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
		AudioStream_F32::release(in);
   153b8:	mov	r0, sl
   153ba:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
  if (!out) return;  //there was no data output array available, so exit.
  arm_scale_f32(out->data, multiplier[channel], out->data, out->length);
  
  //add in the remaining channels, as available
  channel++;
  while  (channel < 4) {
   153be:	cmp	r5, #4
   153c0:	add.w	r4, r4, #4
   153c4:	bne.n	1537a <AudioMixer4_F32::update()+0x42>
	} else {
		//do nothing, this vector is empty
	}
	channel++;
  }
  AudioStream_F32::transmit(out);
   153c6:	mov	r0, r7
   153c8:	mov	r1, r9
   153ca:	movs	r2, #0
   153cc:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
  AudioStream_F32::release(out);
   153d0:	mov	r0, r9
}
   153d2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		//do nothing, this vector is empty
	}
	channel++;
  }
  AudioStream_F32::transmit(out);
  AudioStream_F32::release(out);
   153d6:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>
   153da:	nop

000153dc <AudioMixer8_F32::update()>:
}

void AudioMixer8_F32::update(void) {
   153dc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   153e0:	mov	r7, r0
  audio_block_f32_t *in, *out=NULL;

  //get the first available channel
  int channel = 0;
   153e2:	movs	r4, #0
  while  (channel < 8) {
	  out = receiveWritable_f32(channel);
   153e4:	mov	r1, r4
   153e6:	mov	r0, r7
   153e8:	bl	152c4 <AudioStream_F32::receiveWritable_f32(unsigned int)>
	  if (out) break;
   153ec:	mov	r8, r0
   153ee:	cbnz	r0, 153fa <AudioMixer8_F32::update()+0x1e>
	  channel++;
   153f0:	adds	r4, #1
void AudioMixer8_F32::update(void) {
  audio_block_f32_t *in, *out=NULL;

  //get the first available channel
  int channel = 0;
  while  (channel < 8) {
   153f2:	cmp	r4, #8
   153f4:	bne.n	153e4 <AudioMixer8_F32::update()+0x8>
   153f6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  out = receiveWritable_f32(channel);
	  if (out) break;
	  channel++;
  }
  if (!out) return;  //there was no data output array.  so exit.
  arm_scale_f32(out->data, multiplier[channel], out->data, out->length); 
   153fa:	add.w	r9, r0, #4
   153fe:	add.w	r3, r7, r4, lsl #2
  
  //add in the remaining channels, as available
  channel++;
   15402:	adds	r5, r4, #1
	  out = receiveWritable_f32(channel);
	  if (out) break;
	  channel++;
  }
  if (!out) return;  //there was no data output array.  so exit.
  arm_scale_f32(out->data, multiplier[channel], out->data, out->length); 
   15404:	ldr.w	r2, [r0, #520]	; 0x208
   15408:	mov	r1, r9
   1540a:	mov	r0, r9
   1540c:	vldr	s0, [r3, #72]	; 0x48
   15410:	bl	17dc4 <arm_scale_f32>
  
  //add in the remaining channels, as available
  channel++;
  while  (channel < 8) {
   15414:	cmp	r5, #8
   15416:	beq.n	1546a <AudioMixer8_F32::update()+0x8e>
   15418:	adds	r4, #19
   1541a:	add.w	r4, r7, r4, lsl #2
    in = receiveReadOnly_f32(channel);
   1541e:	mov	r1, r5
   15420:	mov	r0, r7
   15422:	bl	152ac <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
		AudioStream_F32::release(tmp);
		AudioStream_F32::release(in);
	} else {
		//do nothing, this vector is empty
	}
	channel++;
   15426:	adds	r5, #1
  
  //add in the remaining channels, as available
  channel++;
  while  (channel < 8) {
    in = receiveReadOnly_f32(channel);
    if (in) {
   15428:	mov	sl, r0
   1542a:	cbz	r0, 15462 <AudioMixer8_F32::update()+0x86>
		audio_block_f32_t *tmp = allocate_f32();
   1542c:	bl	15198 <AudioStream_F32::allocate_f32()>
   15430:	mov	r6, r0

		arm_scale_f32(in->data, multiplier[channel], tmp->data, tmp->length);
   15432:	vldr	s0, [r4]
   15436:	add.w	r0, sl, #4
   1543a:	add.w	fp, r6, #4
   1543e:	ldr.w	r2, [r6, #520]	; 0x208
   15442:	mov	r1, fp
   15444:	bl	17dc4 <arm_scale_f32>
		arm_add_f32(out->data, tmp->data, out->data, tmp->length);
   15448:	mov	r1, fp
   1544a:	ldr.w	r3, [r6, #520]	; 0x208
   1544e:	mov	r2, r9
   15450:	mov	r0, r9
   15452:	bl	17e30 <arm_add_f32>

		AudioStream_F32::release(tmp);
   15456:	mov	r0, r6
   15458:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
		AudioStream_F32::release(in);
   1545c:	mov	r0, sl
   1545e:	bl	15230 <AudioStream_F32::release(audio_block_f32_t*)>
  if (!out) return;  //there was no data output array.  so exit.
  arm_scale_f32(out->data, multiplier[channel], out->data, out->length); 
  
  //add in the remaining channels, as available
  channel++;
  while  (channel < 8) {
   15462:	cmp	r5, #8
   15464:	add.w	r4, r4, #4
   15468:	bne.n	1541e <AudioMixer8_F32::update()+0x42>
	} else {
		//do nothing, this vector is empty
	}
	channel++;
  }
  AudioStream_F32::transmit(out);
   1546a:	mov	r0, r7
   1546c:	mov	r1, r8
   1546e:	movs	r2, #0
   15470:	bl	15278 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
  AudioStream_F32::release(out);
   15474:	mov	r0, r8
}
   15476:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		//do nothing, this vector is empty
	}
	channel++;
  }
  AudioStream_F32::transmit(out);
  AudioStream_F32::release(out);
   1547a:	b.w	15230 <AudioStream_F32::release(audio_block_f32_t*)>
   1547e:	nop

00015480 <memcpy_tointerleaveLR>:
	@ r0: dst
	@ r1: srcL
	@ r2: srcR

#if AUDIO_BLOCK_SAMPLES > 8
	push	{r4-r11,r14}
   15480:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	add r14,r0,#(AUDIO_BLOCK_SAMPLES*2)
   15484:	add.w	lr, r0, #256	; 0x100

00015488 <.loopLR>:
	.align 2
.loopLR:
	//Load 2*4 words
	ldmia r1!, {r5,r7,r9,r11}  //1+4
   15488:	ldmia.w	r1!, {r5, r7, r9, fp}
	ldmia r2!, {r6,r8,r10,r12} //1+4	
   1548c:	ldmia.w	r2!, {r6, r8, sl, ip}

	pkhbt r3,r5,r6,LSL #16	//1
   15490:	pkhbt	r3, r5, r6, lsl #16
	pkhtb r4,r6,r5,ASR #16	//1
   15494:	pkhtb	r4, r6, r5, asr #16

	pkhbt r5,r7,r8,LSL #16	//1
   15498:	pkhbt	r5, r7, r8, lsl #16
	pkhtb r6,r8,r7,ASR #16	//1
   1549c:	pkhtb	r6, r8, r7, asr #16

	pkhbt r7,r9,r10,LSL #16	//1
   154a0:	pkhbt	r7, r9, sl, lsl #16
	pkhtb r8,r10,r9,ASR #16	//1
   154a4:	pkhtb	r8, sl, r9, asr #16

	pkhbt r9,r11,r12,LSL #16	//1
   154a8:	pkhbt	r9, fp, ip, lsl #16
	pkhtb r10,r12,r11,ASR #16	//1
   154ac:	pkhtb	sl, ip, fp, asr #16

	//Write 8 Words
	stmia r0!, {r3,r4,r5,r6,r7,r8,r9,r10}	//1+8 -> 5+5+8+9 = 27 Cycles to interleave 32 bytes. 
   154b0:	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	
	cmp r14, r0
   154b4:	cmp	lr, r0
	bne .loopLR
   154b6:	bne.n	15488 <.loopLR>

	pop	{r4-r11,r14}	
   154b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pkhtb r6,r8,r7,ASR #16

	stmia r0!, {r3,r4,r5,r6}
	pop	{r4-r8,r14}	
#endif
	BX lr
   154bc:	bx	lr

000154be <memcpy_tointerleaveL>:
	memcpy_tointerleaveL:

	@ r0: dst
	@ r1: srcL
	
	mov r2, #0
   154be:	mov.w	r2, #0
	
#if AUDIO_BLOCK_SAMPLES > 8
	push	{r4-r11}
   154c2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	add r12,r0,#(AUDIO_BLOCK_SAMPLES*2)
   154c6:	add.w	ip, r0, #256	; 0x100
   154ca:	nop

000154cc <.loopL>:
	.align 2
.loopL:

	//Load 4 words
	ldmia r1!, {r5,r7,r9,r11}  //1+4
   154cc:	ldmia.w	r1!, {r5, r7, r9, fp}

	pkhbt r3,r5,r2	//1
   154d0:	pkhbt	r3, r5, r2
	pkhtb r4,r2,r5,ASR #16	//1
   154d4:	pkhtb	r4, r2, r5, asr #16

	pkhbt r5,r7,r2	//1
   154d8:	pkhbt	r5, r7, r2
	pkhtb r6,r2,r7,ASR #16	//1
   154dc:	pkhtb	r6, r2, r7, asr #16

	pkhbt r7,r9,r2	//1
   154e0:	pkhbt	r7, r9, r2
	pkhtb r8,r2,r9,ASR #16	//1
   154e4:	pkhtb	r8, r2, r9, asr #16

	pkhbt r9,r11,r2	//1
   154e8:	pkhbt	r9, fp, r2
	pkhtb r10,r2,r11,ASR #16	//1
   154ec:	pkhtb	sl, r2, fp, asr #16

	//Write 8 Words
	stmia r0!, {r3,r4,r5,r6,r7,r8,r9,r10}	//1+8
   154f0:	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}

	cmp r12, r0
   154f4:	cmp	ip, r0
	bne .loopL
   154f6:	bne.n	154cc <.loopL>

	pop	{r4-r11}
   154f8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}

	stmia r0!, {r3,r4,r5,r6}
	
	pop	{r4-r7}
#endif	
	BX lr
   154fc:	bx	lr

000154fe <memcpy_tointerleaveR>:
	memcpy_tointerleaveR:

	@ r0: dst
	@ r1: srcR

	mov r2, #0
   154fe:	mov.w	r2, #0
#if AUDIO_BLOCK_SAMPLES > 8
	push	{r4-r11}
   15502:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	add r12,r0,#(AUDIO_BLOCK_SAMPLES*2)
   15506:	add.w	ip, r0, #256	; 0x100
   1550a:	nop

0001550c <.loopR>:
	.align 2
.loopR:

	//Load 4 words
	ldmia r1!, {r5,r7,r9,r11}
   1550c:	ldmia.w	r1!, {r5, r7, r9, fp}

	pkhbt r3,r2,r5,LSL #16
   15510:	pkhbt	r3, r2, r5, lsl #16
	pkhtb r4,r5,r2
   15514:	pkhbt	r4, r2, r5

	pkhbt r5,r2,r7,LSL #16
   15518:	pkhbt	r5, r2, r7, lsl #16
	pkhtb r6,r7,r2
   1551c:	pkhbt	r6, r2, r7

	pkhbt r7,r2,r9,LSL #16
   15520:	pkhbt	r7, r2, r9, lsl #16
	pkhtb r8,r9,r2
   15524:	pkhbt	r8, r2, r9

	pkhbt r9,r2,r11,LSL #16
   15528:	pkhbt	r9, r2, fp, lsl #16
	pkhtb r10,r11,r2
   1552c:	pkhbt	sl, r2, fp

	//Write 8 Words
	stmia r0!, {r3,r4,r5,r6,r7,r8,r9,r10}
   15530:	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}

	cmp r12, r0
   15534:	cmp	ip, r0
	bne .loopR
   15536:	bne.n	1550c <.loopR>

	pop	{r4-r11}
   15538:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	stmia r0!, {r3,r4,r5,r6}

	pop	{r4-r7}

#endif	
	BX lr
   1553c:	bx	lr

0001553e <memcpy_tointerleaveQuad>:
	@ r1: src1
	@ r2: src2
	@ r3: src3
	@ r4: src4

	push	{r4-r11}
   1553e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	ldr r4, [sp, #(0+32)] //5th parameter is saved on the stack
   15542:	ldr	r4, [sp, #32]
	add r11,r0,#(AUDIO_BLOCK_SAMPLES*4)
   15544:	add.w	fp, r0, #512	; 0x200

00015548 <.loopQuad>:
	.align 2
.loopQuad:

	ldr r5, [r1],4
   15548:	ldr.w	r5, [r1], #4
	ldr r6, [r3],4
   1554c:	ldr.w	r6, [r3], #4
	pkhbt r7,r5,r6,LSL #16
   15550:	pkhbt	r7, r5, r6, lsl #16
	pkhtb r9,r6,r5,ASR #16
   15554:	pkhtb	r9, r6, r5, asr #16
	ldr r5, [r2],4
   15558:	ldr.w	r5, [r2], #4
	ldr r6, [r4],4
   1555c:	ldr.w	r6, [r4], #4
	pkhbt r8,r5,r6,LSL #16
   15560:	pkhbt	r8, r5, r6, lsl #16
	pkhtb r10,r6,r5,ASR #16
   15564:	pkhtb	sl, r6, r5, asr #16

	stmia r0!, {r7-r10}
   15568:	stmia.w	r0!, {r7, r8, r9, sl}

	cmp r11, r0
   1556c:	cmp	fp, r0
	bne .loopQuad
   1556e:	bne.n	15548 <.loopQuad>

	pop	{r4-r11}
   15570:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	BX lr
   15574:	bx	lr
   15576:	nop

00015578 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
   15578:	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
   1557a:	orr.w	r3, r1, r0
	ands	r3, r3, #3
   1557e:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
   15582:	bne.n	15660 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
   15584:	subs	r2, #64	; 0x40
	blo	.Lmid_block
   15586:	bcc.n	1560c <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
   15588:	ldr.w	r3, [r1], #4
   1558c:	str.w	r3, [r0], #4
   15590:	ldr.w	r3, [r1], #4
   15594:	str.w	r3, [r0], #4
   15598:	ldr.w	r3, [r1], #4
   1559c:	str.w	r3, [r0], #4
   155a0:	ldr.w	r3, [r1], #4
   155a4:	str.w	r3, [r0], #4
   155a8:	ldr.w	r3, [r1], #4
   155ac:	str.w	r3, [r0], #4
   155b0:	ldr.w	r3, [r1], #4
   155b4:	str.w	r3, [r0], #4
   155b8:	ldr.w	r3, [r1], #4
   155bc:	str.w	r3, [r0], #4
   155c0:	ldr.w	r3, [r1], #4
   155c4:	str.w	r3, [r0], #4
   155c8:	ldr.w	r3, [r1], #4
   155cc:	str.w	r3, [r0], #4
   155d0:	ldr.w	r3, [r1], #4
   155d4:	str.w	r3, [r0], #4
   155d8:	ldr.w	r3, [r1], #4
   155dc:	str.w	r3, [r0], #4
   155e0:	ldr.w	r3, [r1], #4
   155e4:	str.w	r3, [r0], #4
   155e8:	ldr.w	r3, [r1], #4
   155ec:	str.w	r3, [r0], #4
   155f0:	ldr.w	r3, [r1], #4
   155f4:	str.w	r3, [r0], #4
   155f8:	ldr.w	r3, [r1], #4
   155fc:	str.w	r3, [r0], #4
   15600:	ldr.w	r3, [r1], #4
   15604:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
   15608:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
   1560a:	bcs.n	15588 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
   1560c:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
   1560e:	bcc.n	15634 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
   15610:	ldr.w	r3, [r1], #4
   15614:	str.w	r3, [r0], #4
   15618:	ldr.w	r3, [r1], #4
   1561c:	str.w	r3, [r0], #4
   15620:	ldr.w	r3, [r1], #4
   15624:	str.w	r3, [r0], #4
   15628:	ldr.w	r3, [r1], #4
   1562c:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
   15630:	subs	r2, #16
	bhs	.Lmid_block_loop
   15632:	bcs.n	15610 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
   15634:	adds	r2, #12
	blo	.Lcopy_less_than_4
   15636:	bcc.n	15644 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
   15638:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
   1563c:	str.w	r3, [r0], #4
	subs	r2, #4
   15640:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
   15642:	bcs.n	15638 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
   15644:	adds	r2, #4
	beq	.Ldone
   15646:	beq.n	1565a <memcpy+0xe2>

	lsls	r2, r2, #31
   15648:	lsls	r2, r2, #31
	itt ne
   1564a:	itt	ne
	ldrbne  r3, [r1], #1
   1564c:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
   15650:	strbne.w	r3, [r0], #1

	bcc	.Ldone
   15654:	bcc.n	1565a <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
   15656:	ldrh	r3, [r1, #0]
	strh	r3, [r0]
   15658:	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
   1565a:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
   1565c:	bx	lr
   1565e:	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
   15660:	cmp	r2, #8
	blo	.Lbyte_copy
   15662:	bcc.n	1568c <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
   15664:	lsls	r3, r1, #30
	beq	.Ldst_aligned
   15666:	beq.n	15584 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
   15668:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
   1566c:	beq.n	15584 <memcpy+0xc>

	rsb	r3, #4
   1566e:	rsb	r3, r3, #4
	subs	r2, r3
   15672:	subs	r2, r2, r3

	lsls    r3, r3, #31
   15674:	lsls	r3, r3, #31
	itt ne
   15676:	itt	ne
	ldrbne  r3, [r1], #1
   15678:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
   1567c:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
   15680:	bcc.n	15584 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
   15682:	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
   15686:	strh.w	r3, [r0], #2
	b	.Ldst_aligned
   1568a:	b.n	15584 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
   1568c:	subs	r2, #4
	blo	.Lcopy_less_than_4
   1568e:	bcc.n	15644 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
   15690:	subs	r2, #1
	ldrb    r3, [r1], #1
   15692:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
   15696:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
   1569a:	bcs.n	15690 <memcpy+0x118>

	ldrb	r3, [r1]
   1569c:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
   1569e:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
   156a0:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
   156a2:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
   156a4:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
   156a6:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
   156a8:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
   156aa:	bx	lr

000156ac <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
   156ac:	ldr	r2, [pc, #600]	; (15908 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
   156ae:	ldr	r3, [pc, #604]	; (1590c <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
   156b0:	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
   156b2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
   156b6:	ldr	r4, [pc, #600]	; (15910 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
   156b8:	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
   156bc:	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
   156be:	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
   156c0:	bls.n	156fc <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
   156c2:	ldr	r3, [pc, #592]	; (15914 <set_arm_clock+0x268>)
   156c4:	cmp	r0, r3
   156c6:	bls.w	158f4 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
   156ca:	ldr	r3, [pc, #588]	; (15918 <set_arm_clock+0x26c>)
   156cc:	movw	r5, #1575	; 0x627
   156d0:	ldr	r7, [pc, #584]	; (1591c <set_arm_clock+0x270>)
   156d2:	add	r3, r0
   156d4:	ldr	r4, [pc, #584]	; (15920 <set_arm_clock+0x274>)
   156d6:	lsrs	r2, r3, #8
   156d8:	umull	r3, r2, r7, r2
   156dc:	lsrs	r3, r2, #7
   156de:	add.w	r3, r3, r3, lsl #2
   156e2:	add.w	r2, r3, r3, lsl #2
   156e6:	addw	r3, r2, #1250	; 0x4e2
   156ea:	cmp	r3, r5
   156ec:	it	cs
   156ee:	movcs	r3, r5
   156f0:	sub.w	r3, r3, #800	; 0x320
   156f4:	umull	r3, r5, r4, r3
   156f8:	lsrs	r5, r5, #3
   156fa:	b.n	15706 <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
   156fc:	ldr	r5, [pc, #548]	; (15924 <set_arm_clock+0x278>)
   156fe:	cmp	r0, r5
   15700:	ite	ls
   15702:	movls	r5, #6
   15704:	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
   15706:	ldr	r2, [pc, #516]	; (1590c <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
   15708:	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
   1570c:	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
   15710:	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
   15712:	orr.w	r3, r3, #192	; 0xc0
   15716:	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
   1571a:	bcs.n	15732 <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
   1571c:	ldr	r3, [pc, #496]	; (15910 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
   1571e:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
   15722:	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
   15724:	orrs	r6, r5
		DCDC_REG3 = dcdc;
   15726:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
   15728:	ldr	r3, [r2, #0]
   1572a:	cmp	r3, #0
   1572c:	bge.n	15728 <set_arm_clock+0x7c>
   1572e:	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
   15732:	ands.w	r3, lr, #33554432	; 0x2000000
   15736:	bne.n	1579c <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
   15738:	ldr	r4, [pc, #492]	; (15928 <set_arm_clock+0x27c>)
   1573a:	ldr	r2, [pc, #496]	; (1592c <set_arm_clock+0x280>)
   1573c:	ldr.w	ip, [r4, #16]
   15740:	mov	r4, r2
   15742:	and.w	r2, ip, r2
   15746:	cmp	r2, r4
   15748:	itet	eq
   1574a:	moveq.w	r3, #402653184	; 0x18000000
   1574e:	movne.w	r2, #4096	; 0x1000
   15752:	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
   15754:	eor.w	r4, lr, r3
   15758:	tst.w	r4, #939524096	; 0x38000000
   1575c:	beq.n	15770 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
   1575e:	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
   15762:	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
   15766:	ldr	r4, [pc, #420]	; (1590c <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
   15768:	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
   1576c:	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
   15770:	eor.w	r3, r1, r2
   15774:	tst.w	r3, #12288	; 0x3000
   15778:	beq.n	1578c <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
   1577a:	ldr	r3, [pc, #400]	; (1590c <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
   1577c:	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
   15780:	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
   15782:	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
   15784:	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
   15786:	ldr	r3, [r2, #72]	; 0x48
   15788:	lsls	r4, r3, #28
   1578a:	bmi.n	15786 <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
   1578c:	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
   15790:	ldr	r2, [pc, #376]	; (1590c <set_arm_clock+0x260>)
   15792:	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
   15796:	ldr	r3, [r2, #72]	; 0x48
   15798:	lsls	r1, r3, #26
   1579a:	bmi.n	15796 <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
   1579c:	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
   1579e:	ldr	r4, [pc, #400]	; (15930 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
   157a0:	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
   157a2:	mul.w	r3, r1, r2
   157a6:	mul.w	r3, r0, r3
   157aa:	cmp	r3, r4
   157ac:	bhi.n	157c2 <set_arm_clock+0x116>
		if (div_arm < 8) {
   157ae:	cmp	r2, #7
   157b0:	bhi.w	158de <set_arm_clock+0x232>
			div_arm = div_arm + 1;
   157b4:	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
   157b6:	mul.w	r3, r1, r2
   157ba:	mul.w	r3, r0, r3
   157be:	cmp	r3, r4
   157c0:	bls.n	157ae <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
   157c2:	ldr	r0, [pc, #368]	; (15934 <set_arm_clock+0x288>)
   157c4:	ldr	r4, [pc, #368]	; (15938 <set_arm_clock+0x28c>)
   157c6:	add	r0, r3
   157c8:	umull	r0, r3, r4, r0
   157cc:	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
   157ce:	cmp	r3, #108	; 0x6c
   157d0:	bhi.w	158ea <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
   157d4:	cmp	r3, #53	; 0x35
   157d6:	bhi.w	158f8 <set_arm_clock+0x24c>
   157da:	ldr.w	r8, [pc, #392]	; 15964 <set_arm_clock+0x2b8>
   157de:	movs	r3, #54	; 0x36
   157e0:	ldr	r0, [pc, #344]	; (1593c <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
   157e2:	ldr.w	ip, [pc, #324]	; 15928 <set_arm_clock+0x27c>
   157e6:	ldr	r4, [pc, #344]	; (15940 <set_arm_clock+0x294>)
   157e8:	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
   157ec:	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
   157f0:	and.w	r4, r9, r4
   157f4:	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
   157f6:	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
   157fa:	beq.n	15814 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
   157fc:	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
   15800:	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
   15804:	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
   15806:	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
   1580a:	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
   1580e:	ldr	r3, [r4, #0]
   15810:	cmp	r3, #0
   15812:	bge.n	1580e <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
   15814:	ldr.w	ip, [pc, #244]	; 1590c <set_arm_clock+0x260>
   15818:	subs	r2, #1
   1581a:	ldr.w	r3, [ip, #16]
   1581e:	and.w	r3, r3, #7
   15822:	cmp	r3, r2
   15824:	beq.n	15836 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
   15826:	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
   1582a:	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
   1582c:	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
   15830:	ldr	r3, [r4, #72]	; 0x48
   15832:	lsls	r3, r3, #15
   15834:	bmi.n	15830 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
   15836:	subs	r1, #1
   15838:	lsls	r1, r1, #10
   1583a:	eor.w	r3, lr, r1
   1583e:	tst.w	r3, #7168	; 0x1c00
   15842:	beq.n	1585e <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
   15844:	ldr	r3, [pc, #196]	; (1590c <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
   15846:	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
   1584a:	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
   1584e:	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
   15850:	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
   15854:	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
   15858:	ldr	r3, [r2, #72]	; 0x48
   1585a:	lsls	r1, r3, #30
   1585c:	bmi.n	15858 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
   1585e:	ldr	r3, [pc, #228]	; (15944 <set_arm_clock+0x298>)
   15860:	ldr	r1, [pc, #228]	; (15948 <set_arm_clock+0x29c>)
   15862:	add	r3, r0
   15864:	lsrs	r3, r3, #7
   15866:	umull	r3, r1, r1, r3
   1586a:	lsrs	r1, r1, #12
   1586c:	cmp	r1, #4
   1586e:	it	cs
   15870:	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
   15872:	subs	r3, r1, #1
   15874:	lsls	r3, r3, #8
   15876:	eor.w	r2, lr, r3
   1587a:	tst.w	r2, #768	; 0x300
   1587e:	beq.n	15890 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
   15880:	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
   15884:	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
   15888:	ldr	r2, [pc, #128]	; (1590c <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
   1588a:	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
   1588e:	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
   15890:	ldr	r3, [pc, #120]	; (1590c <set_arm_clock+0x260>)
   15892:	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
   15894:	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
   15896:	bic.w	r4, r4, #33554432	; 0x2000000
   1589a:	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
   1589c:	ldr	r3, [r2, #72]	; 0x48
   1589e:	lsls	r3, r3, #26
   158a0:	bmi.n	1589c <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
   158a2:	ldr	r3, [pc, #168]	; (1594c <set_arm_clock+0x2a0>)
   158a4:	mov.w	r2, #4294967295
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
   158a8:	ldr	r4, [pc, #164]	; (15950 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
   158aa:	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
   158ac:	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
   158b0:	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
   158b2:	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
   158b6:	ldr	r4, [pc, #156]	; (15954 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
   158b8:	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
   158bc:	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
   158c0:	ldr	r2, [pc, #148]	; (15958 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
   158c2:	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
   158c4:	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
   158c6:	bcs.n	158da <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
   158c8:	ldr	r3, [pc, #68]	; (15910 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
   158ca:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
   158ce:	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
   158d0:	orrs	r6, r5
		DCDC_REG3 = dcdc;
   158d2:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
   158d4:	ldr	r3, [r2, #0]
   158d6:	cmp	r3, #0
   158d8:	bge.n	158d4 <set_arm_clock+0x228>
	}

	return frequency;
}
   158da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
   158de:	cmp	r1, #4
   158e0:	bhi.w	157c2 <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
   158e4:	adds	r1, #1
				div_arm = 1;
   158e6:	movs	r2, #1
   158e8:	b.n	157a2 <set_arm_clock+0xf6>
   158ea:	ldr.w	r8, [pc, #124]	; 15968 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
   158ee:	movs	r3, #108	; 0x6c
   158f0:	ldr	r0, [pc, #104]	; (1595c <set_arm_clock+0x2b0>)
   158f2:	b.n	157e2 <set_arm_clock+0x136>
   158f4:	movs	r5, #18
   158f6:	b.n	15706 <set_arm_clock+0x5a>
   158f8:	ldr	r0, [pc, #100]	; (15960 <set_arm_clock+0x2b4>)
   158fa:	ldr.w	r8, [pc, #112]	; 1596c <set_arm_clock+0x2c0>
   158fe:	mul.w	r0, r0, r3
   15902:	orr.w	r8, r3, r8
   15906:	b.n	157e2 <set_arm_clock+0x136>
   15908:	.word	0x1f78a400
   1590c:	.word	0x400fc000
   15910:	.word	0x40080000
   15914:	.word	0x23c34600
   15918:	.word	0xdc3cba00
   1591c:	.word	0x004cb223
   15920:	.word	0x51eb851f
   15924:	.word	0x016e3600
   15928:	.word	0x400d8000
   1592c:	.word	0x80003040
   15930:	.word	0x269fb1ff
   15934:	.word	0x005b8d80
   15938:	.word	0x165e9f81
   1593c:	.word	0x269fb200
   15940:	.word	0x8001307f
   15944:	.word	0x08f0d17f
   15948:	.word	0x00e5109f
   1594c:	.word	0x431bde83
   15950:	.word	0x20020828
   15954:	.word	0x20020824
   15958:	.word	0x20058544
   1595c:	.word	0x4d3f6400
   15960:	.word	0x00b71b00
   15964:	.word	0x80002036
   15968:	.word	0x8000206c
   1596c:	.word	0x80002000

00015970 <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
   15970:	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
   15972:	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
   15974:	cbz	r3, 1597e <schedule_transfer+0xe>
		transfer->status |= (1<<15);
   15976:	ldr	r3, [r2, #4]
   15978:	orr.w	r3, r3, #32768	; 0x8000
   1597c:	str	r3, [r2, #4]
	}
	__disable_irq();
   1597e:	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
   15980:	ldr	r4, [r0, #52]	; 0x34
	if (last) {
   15982:	cbz	r4, 159bc <schedule_transfer+0x4c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
   15984:	ldr	r3, [pc, #80]	; (159d8 <schedule_transfer+0x68>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
   15986:	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
   15988:	ldr.w	r4, [r3, #432]	; 0x1b0
   1598c:	tst	r4, r1
   1598e:	bne.n	159d0 <schedule_transfer+0x60>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
   15990:	ldr	r5, [pc, #72]	; (159dc <schedule_transfer+0x6c>)
   15992:	ldr	r7, [r5, #0]
   15994:	b.n	159a0 <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
   15996:	ldr	r4, [r5, #0]
   15998:	subs	r4, r4, r7
   1599a:	cmp.w	r4, #2400	; 0x960
   1599e:	bcs.n	159b8 <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
   159a0:	ldr.w	r4, [r3, #320]	; 0x140
   159a4:	orr.w	r4, r4, #16384	; 0x4000
   159a8:	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
   159ac:	ldr.w	r6, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
   159b0:	ldr.w	r4, [r3, #320]	; 0x140
   159b4:	lsls	r4, r4, #17
   159b6:	bpl.n	15996 <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
   159b8:	tst	r1, r6
   159ba:	bne.n	159d0 <schedule_transfer+0x60>
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
   159bc:	movs	r3, #0
	USB1_ENDPTPRIME |= epmask;
   159be:	ldr	r4, [pc, #24]	; (159d8 <schedule_transfer+0x68>)
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
   159c0:	str	r2, [r0, #8]
	endpoint->status = 0;
   159c2:	str	r3, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
   159c4:	ldr.w	r3, [r4, #432]	; 0x1b0
   159c8:	orrs	r1, r3
   159ca:	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
   159ce:	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
   159d0:	str	r2, [r0, #52]	; 0x34
	__enable_irq();
   159d2:	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
   159d4:	pop	{r4, r5, r6, r7}
   159d6:	bx	lr
   159d8:	.word	0x402e0000
   159dc:	.word	0xe0001004

000159e0 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
   159e0:	push	{r4, r5, r6, lr}
   159e2:	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
   159e4:	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
   159e6:	cbz	r0, 15a0e <run_callbacks+0x2e>
   159e8:	mov	r2, r0
   159ea:	movs	r4, #0
   159ec:	b.n	159f6 <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
   159ee:	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
   159f0:	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
   159f2:	cmp	r2, #1
   159f4:	beq.n	15a10 <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
   159f6:	ldr	r3, [r2, #4]
   159f8:	ands.w	r3, r3, #128	; 0x80
   159fc:	beq.n	159ee <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
   159fe:	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
   15a00:	cbz	r4, 15a0e <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
   15a02:	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
   15a04:	ldr	r5, [r0, #0]
		ep->callback_function(first);
   15a06:	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
   15a08:	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
   15a0a:	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
   15a0c:	bne.n	15a02 <run_callbacks+0x22>
   15a0e:	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
   15a10:	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
   15a12:	str	r3, [r6, #52]	; 0x34
			break;
   15a14:	b.n	15a00 <run_callbacks+0x20>
   15a16:	nop

00015a18 <endpoint0_transmit.constprop.1>:
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
   15a18:	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
   15a1a:	cbnz	r1, 15a56 <endpoint0_transmit.constprop.1+0x3e>
   15a1c:	ldr	r4, [pc, #132]	; (15aa4 <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15a1e:	ldr	r1, [pc, #136]	; (15aa8 <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15a20:	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15a22:	ldr	r3, [pc, #136]	; (15aac <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15a24:	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15a26:	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15a2a:	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15a2c:	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
   15a2e:	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
   15a30:	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15a32:	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
   15a34:	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15a36:	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
   15a3a:	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
   15a3e:	ldr	r5, [pc, #112]	; (15ab0 <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
   15a40:	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15a44:	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
   15a46:	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
   15a4a:	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
   15a4c:	ldr.w	r3, [r2, #432]	; 0x1b0
   15a50:	cmp	r3, #0
   15a52:	bne.n	15a4c <endpoint0_transmit.constprop.1+0x34>
}
   15a54:	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
   15a56:	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
   15a58:	ldr	r3, [pc, #88]	; (15ab4 <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
   15a5a:	ldr	r5, [pc, #80]	; (15aac <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
   15a5c:	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
   15a5e:	ldr	r4, [pc, #68]	; (15aa4 <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
   15a60:	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
   15a64:	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
   15a66:	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
   15a68:	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
   15a6a:	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
   15a6e:	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
   15a70:	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
   15a74:	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
   15a76:	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
   15a7a:	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
   15a7e:	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
   15a82:	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
   15a84:	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
   15a86:	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
   15a8a:	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
   15a8e:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
   15a92:	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
   15a94:	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
   15a96:	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
   15a9a:	ldr.w	r3, [r2, #432]	; 0x1b0
   15a9e:	cmp	r3, #0
   15aa0:	bne.n	15a9a <endpoint0_transmit.constprop.1+0x82>
   15aa2:	b.n	15a1e <endpoint0_transmit.constprop.1+0x6>
   15aa4:	.word	0x2005a000
   15aa8:	.word	0x20059020
   15aac:	.word	0x402e0000
   15ab0:	.word	0x20058240
   15ab4:	.word	0x20059000

00015ab8 <isr>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


static void isr(void)
{
   15ab8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
   15abc:	ldr	r4, [pc, #728]	; (15d98 <isr+0x2e0>)
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


static void isr(void)
{
   15abe:	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
   15ac0:	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
   15ac4:	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
   15ac8:	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
   15acc:	beq.n	15bae <isr+0xf6>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
   15ace:	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15ad2:	cmp	r3, #0
   15ad4:	beq.n	15ba4 <isr+0xec>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
   15ad6:	mov.w	fp, #65537	; 0x10001
   15ada:	ldr.w	r9, [pc, #740]	; 15dc0 <isr+0x308>
   15ade:	ldr	r7, [pc, #700]	; (15d9c <isr+0x2e4>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
   15ae0:	mov	r6, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
   15ae2:	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
   15ae4:	str.w	r3, [r4, #428]	; 0x1ac
   15ae8:	ldr	r0, [r7, #40]	; 0x28
   15aea:	ldr	r2, [r7, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
   15aec:	ldr.w	r3, [r4, #320]	; 0x140
   15af0:	orr.w	r3, r3, #8192	; 0x2000
   15af4:	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
   15af8:	ldr.w	r3, [r4, #320]	; 0x140
   15afc:	lsls	r5, r3, #18
   15afe:	bpl.n	15aec <isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
   15b00:	ldr.w	r3, [r6, #320]	; 0x140
   15b04:	bic.w	r3, r3, #8192	; 0x2000
   15b08:	str.w	r3, [r6, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
   15b0c:	str.w	sl, [r6, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
   15b10:	ldr.w	r3, [r4, #436]	; 0x1b4
   15b14:	ands.w	r3, r3, #65537	; 0x10001
   15b18:	bne.n	15b10 <isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
   15b1a:	uxth	r1, r0
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
   15b1c:	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
   15b20:	cmp.w	r1, #1280	; 0x500
   15b24:	beq.w	15dd4 <isr+0x31c>
   15b28:	bhi.w	15cba <isr+0x202>
   15b2c:	cmp	r1, #130	; 0x82
   15b2e:	beq.w	15e74 <isr+0x3bc>
   15b32:	bls.w	15cec <isr+0x234>
   15b36:	cmp.w	r1, #258	; 0x102
   15b3a:	beq.w	15e14 <isr+0x35c>
   15b3e:	movw	r3, #770	; 0x302
   15b42:	cmp	r1, r3
   15b44:	bne.w	15cdc <isr+0x224>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
   15b48:	uxth	r2, r2
   15b4a:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
   15b4e:	cmp	r3, #7
   15b50:	bhi.w	15cdc <isr+0x224>
		dir = setup.wIndex & 0x80;
		if (dir) {
   15b54:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
   15b58:	mov.w	r3, r3, lsl #2
   15b5c:	ldr	r2, [pc, #576]	; (15da0 <isr+0x2e8>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15b5e:	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15b62:	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
   15b66:	add	r2, r3
   15b68:	ldr	r3, [r2, #0]
   15b6a:	ite	ne
   15b6c:	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
   15b70:	orreq.w	r3, r3, #1
   15b74:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15b76:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15b78:	ldr	r3, [pc, #552]	; (15da4 <isr+0x2ec>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
   15b7a:	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
   15b7c:	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15b7e:	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15b80:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15b82:	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
   15b86:	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15b8a:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
   15b8c:	orr.w	r3, r2, #65536	; 0x10000
   15b90:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
   15b94:	ldr.w	r3, [r4, #432]	; 0x1b0
   15b98:	cmp	r3, #0
   15b9a:	bne.n	15b94 <isr+0xdc>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15b9c:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15ba0:	cmp	r3, #0
   15ba2:	bne.n	15ae4 <isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
   15ba4:	ldr	r2, [pc, #496]	; (15d98 <isr+0x2e0>)
   15ba6:	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
   15baa:	cmp	r3, #0
   15bac:	bne.n	15c56 <isr+0x19e>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
   15bae:	tst.w	r8, #64	; 0x40
   15bb2:	beq.n	15be2 <isr+0x12a>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
   15bb4:	ldr	r3, [pc, #480]	; (15d98 <isr+0x2e0>)
   15bb6:	ldr.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
   15bba:	mov	r1, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
   15bbc:	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
   15bc0:	ldr.w	r2, [r3, #444]	; 0x1bc
   15bc4:	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
   15bc8:	ldr.w	r3, [r1, #432]	; 0x1b0
   15bcc:	ldr	r2, [pc, #456]	; (15d98 <isr+0x2e0>)
   15bce:	cmp	r3, #0
   15bd0:	bne.n	15bc8 <isr+0x110>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
   15bd2:	mov.w	r0, #4294967295
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
   15bd6:	ldr	r1, [pc, #464]	; (15da8 <isr+0x2f0>)
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
   15bd8:	str.w	r0, [r2, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
   15bdc:	ldr.w	r2, [r2, #388]	; 0x184
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
		#endif
		endpointN_notify_mask = 0;
   15be0:	str	r3, [r1, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
   15be2:	tst.w	r8, #16777216	; 0x1000000
   15be6:	beq.n	15bf0 <isr+0x138>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
   15be8:	ldr	r3, [pc, #448]	; (15dac <isr+0x2f4>)
   15bea:	ldr	r3, [r3, #0]
   15bec:	cbz	r3, 15bf0 <isr+0x138>
   15bee:	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
   15bf0:	tst.w	r8, #33554432	; 0x2000000
   15bf4:	beq.n	15bfe <isr+0x146>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
   15bf6:	ldr	r3, [pc, #440]	; (15db0 <isr+0x2f8>)
   15bf8:	ldr	r3, [r3, #0]
   15bfa:	cbz	r3, 15bfe <isr+0x146>
   15bfc:	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
   15bfe:	tst.w	r8, #4
   15c02:	beq.n	15c16 <isr+0x15e>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
   15c04:	ldr	r3, [pc, #400]	; (15d98 <isr+0x2e0>)
   15c06:	ldr.w	r3, [r3, #388]	; 0x184
   15c0a:	ands.w	r3, r3, #512	; 0x200
   15c0e:	beq.n	15cb4 <isr+0x1fc>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
   15c10:	ldr	r3, [pc, #416]	; (15db4 <isr+0x2fc>)
   15c12:	movs	r2, #1
   15c14:	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
   15c16:	ldr	r3, [pc, #384]	; (15d98 <isr+0x2e0>)
   15c18:	ldr.w	r2, [r3, #328]	; 0x148
   15c1c:	lsls	r2, r2, #24
   15c1e:	bpl.n	15c50 <isr+0x198>
   15c20:	tst.w	r8, #128	; 0x80
   15c24:	beq.n	15c50 <isr+0x198>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
   15c26:	ldr	r1, [pc, #400]	; (15db8 <isr+0x300>)
   15c28:	ldrb	r2, [r1, #0]
   15c2a:	cbz	r2, 15c46 <isr+0x18e>
			if (--usb_reboot_timer == 0) {
   15c2c:	subs	r2, #1
   15c2e:	uxtb	r2, r2
   15c30:	strb	r2, [r1, #0]
   15c32:	cbnz	r2, 15c46 <isr+0x18e>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
   15c34:	ldr	r1, [pc, #388]	; (15dbc <isr+0x304>)
   15c36:	ldrb	r2, [r1, #0]
   15c38:	and.w	r2, r2, #251	; 0xfb
   15c3c:	strb	r2, [r1, #0]
	if (sof_usage == 0) {
   15c3e:	cmp	r2, #0
   15c40:	beq.w	16054 <isr+0x59c>
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				asm("bkpt #251"); // run bootloader
   15c44:	bkpt	0x00fb
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
   15c46:	add	sp, #12
   15c48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				usb_stop_sof_interrupts(NUM_INTERFACE);
				asm("bkpt #251"); // run bootloader
			}
		}
		#ifdef MIDI_INTERFACE
		usb_midi_flush_output();
   15c4c:	b.w	17090 <usb_midi_flush_output>
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
   15c50:	add	sp, #12
   15c52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
   15c56:	ldr	r1, [pc, #360]	; (15dc0 <isr+0x308>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
   15c58:	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
   15c5c:	ldr	r0, [r1, #0]
   15c5e:	tst	r3, r0
   15c60:	bne.w	15fc6 <isr+0x50e>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
   15c64:	ldr	r2, [pc, #320]	; (15da8 <isr+0x2f0>)
   15c66:	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
   15c68:	ands	r5, r3
   15c6a:	beq.n	15bae <isr+0xf6>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
   15c6c:	lsrs	r6, r5, #16
   15c6e:	beq.n	15c90 <isr+0x1d8>
   15c70:	ldr	r7, [pc, #296]	; (15d9c <isr+0x2e4>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
   15c72:	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
   15c76:	rbit	r4, r6
   15c7a:	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
   15c7e:	add.w	r0, r7, r4, lsl #7
					tx &= ~(1<<p);
   15c82:	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
   15c86:	adds	r0, #64	; 0x40
   15c88:	bl	159e0 <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
   15c8c:	bics	r6, r4
   15c8e:	bne.n	15c76 <isr+0x1be>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
   15c90:	uxth	r5, r5
				while(rx) {
   15c92:	cmp	r5, #0
   15c94:	beq.n	15bae <isr+0xf6>
   15c96:	ldr	r7, [pc, #260]	; (15d9c <isr+0x2e4>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
   15c98:	movs	r6, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
   15c9a:	rbit	r4, r5
   15c9e:	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
   15ca2:	add.w	r0, r7, r4, lsl #7
					rx &= ~(1<<p);
   15ca6:	lsl.w	r4, r6, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
   15caa:	bl	159e0 <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
   15cae:	bics	r5, r4
   15cb0:	bne.n	15c9a <isr+0x1e2>
   15cb2:	b.n	15bae <isr+0xf6>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
   15cb4:	ldr	r2, [pc, #252]	; (15db4 <isr+0x2fc>)
   15cb6:	strb	r3, [r2, #0]
   15cb8:	b.n	15c16 <isr+0x15e>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
   15cba:	cmp.w	r1, #2176	; 0x880
   15cbe:	beq.w	15eb0 <isr+0x3f8>
   15cc2:	bls.n	15d0a <isr+0x252>
   15cc4:	cmp.w	r1, #2304	; 0x900
   15cc8:	beq.w	15ecc <isr+0x414>
   15ccc:	movw	r5, #2337	; 0x921
   15cd0:	cmp	r1, r5
   15cd2:	bne.n	15cdc <isr+0x224>
		endpoint0_receive(endpoint0_buffer, 7, 1);
		return;
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
   15cd4:	lsrs	r1, r2, #16
   15cd6:	cmp	r1, #8
   15cd8:	bls.w	15f28 <isr+0x470>
			return;
		}
		break;
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
   15cdc:	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15ce0:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15ce4:	cmp	r3, #0
   15ce6:	bne.w	15ae4 <isr+0x2c>
   15cea:	b.n	15ba4 <isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
   15cec:	cmp	r1, #128	; 0x80
   15cee:	bne.n	15cdc <isr+0x224>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
   15cf0:	ldr	r2, [pc, #208]	; (15dc4 <isr+0x30c>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
   15cf2:	movs	r1, #2
   15cf4:	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
   15cf6:	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
   15cf8:	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
   15cfa:	bl	15a18 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15cfe:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15d02:	cmp	r3, #0
   15d04:	bne.w	15ae4 <isr+0x2c>
   15d08:	b.n	15ba4 <isr+0xec>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
   15d0a:	sub.w	r1, r1, #1664	; 0x680
   15d0e:	cmp	r1, #1
   15d10:	bhi.n	15cdc <isr+0x224>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
   15d12:	ldr	r3, [pc, #180]	; (15dc8 <isr+0x310>)
   15d14:	ldr	r1, [r3, #4]
   15d16:	cmp	r1, #0
   15d18:	beq.n	15cdc <isr+0x224>
   15d1a:	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
   15d1c:	uxth.w	lr, r2
   15d20:	b.n	15d2a <isr+0x272>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
   15d22:	adds	r3, #12
   15d24:	ldr	r1, [r3, #4]
   15d26:	cmp	r1, #0
   15d28:	beq.n	15cdc <isr+0x224>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
   15d2a:	ldrh	r5, [r3, #0]
   15d2c:	cmp	r5, r0
   15d2e:	bne.n	15d22 <isr+0x26a>
   15d30:	ldrh	r5, [r3, #2]
   15d32:	cmp	r5, lr
   15d34:	bne.n	15d22 <isr+0x26a>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
   15d36:	lsrs	r5, r0, #8
   15d38:	cmp	r5, #3
   15d3a:	beq.w	16080 <isr+0x5c8>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
   15d3e:	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
   15d40:	lsrs	r2, r2, #16
   15d42:	cmp	r3, r2
   15d44:	it	cs
   15d46:	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
   15d48:	cmp.w	r0, #512	; 0x200
   15d4c:	beq.w	16062 <isr+0x5aa>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
   15d50:	cmp.w	r0, #1792	; 0x700
   15d54:	beq.w	1602e <isr+0x576>
   15d58:	ldr	r5, [pc, #112]	; (15dcc <isr+0x314>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
   15d5a:	mov	r2, r3
   15d5c:	str	r3, [sp, #4]
   15d5e:	mov	r0, r5
   15d60:	bl	15578 <memcpy>
   15d64:	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
   15d66:	bic.w	r2, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
   15d6a:	add	r5, r3
	asm volatile("": : :"memory");
	asm("dsb");
   15d6c:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
   15d70:	ldr	r1, [pc, #92]	; (15dd0 <isr+0x318>)
   15d72:	str	r2, [r1, #0]
		location += 32;
   15d74:	adds	r2, #32
	} while (location < end_addr);
   15d76:	cmp	r5, r2
   15d78:	bhi.n	15d70 <isr+0x2b8>
	asm("dsb");
   15d7a:	dsb	sy
	asm("isb");
   15d7e:	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
   15d82:	ldr	r0, [pc, #72]	; (15dcc <isr+0x314>)
   15d84:	mov	r1, r3
   15d86:	bl	15a18 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15d8a:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15d8e:	cmp	r3, #0
   15d90:	bne.w	15ae4 <isr+0x2c>
   15d94:	b.n	15ba4 <isr+0xec>
   15d96:	nop
   15d98:	.word	0x402e0000
   15d9c:	.word	0x2005a000
   15da0:	.word	0x402e01c0
   15da4:	.word	0x20059020
   15da8:	.word	0x20058230
   15dac:	.word	0x2005822c
   15db0:	.word	0x20058238
   15db4:	.word	0x2005823c
   15db8:	.word	0x20058244
   15dbc:	.word	0x20058234
   15dc0:	.word	0x20058240
   15dc4:	.word	0x20058250
   15dc8:	.word	0x2001fb54
   15dcc:	.word	0x20200820
   15dd0:	.word	0xe000ef70
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15dd4:	ldr	r2, [pc, #692]	; (1608c <isr+0x5d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15dd6:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15dd8:	movs	r5, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
   15dda:	str	r3, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
   15ddc:	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15dde:	str	r5, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15de0:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15de2:	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
   15de6:	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15dea:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
   15dec:	orr.w	r3, r1, #65536	; 0x10000
   15df0:	str.w	r3, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
   15df4:	ldr.w	r3, [r4, #432]	; 0x1b0
   15df8:	cmp	r3, #0
   15dfa:	bne.n	15df4 <isr+0x33c>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
   15dfc:	lsrs	r3, r0, #16
   15dfe:	lsls	r3, r3, #25
   15e00:	orr.w	r3, r3, #16777216	; 0x1000000
   15e04:	str.w	r3, [r6, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15e08:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15e0c:	cmp	r3, #0
   15e0e:	bne.w	15ae4 <isr+0x2c>
   15e12:	b.n	15ba4 <isr+0xec>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
   15e14:	uxth	r2, r2
   15e16:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
   15e1a:	cmp	r3, #7
   15e1c:	bhi.w	15cdc <isr+0x224>
		dir = setup.wIndex & 0x80;
		if (dir) {
   15e20:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
   15e24:	mov.w	r3, r3, lsl #2
   15e28:	ldr	r2, [pc, #612]	; (16090 <isr+0x5d8>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15e2a:	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15e2e:	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
   15e32:	add	r2, r3
   15e34:	ldr	r3, [r2, #0]
   15e36:	ite	ne
   15e38:	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
   15e3c:	biceq.w	r3, r3, #1
   15e40:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15e42:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15e44:	ldr	r3, [pc, #580]	; (1608c <isr+0x5d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
   15e46:	str	r1, [r7, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
   15e48:	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15e4a:	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15e4c:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15e4e:	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
   15e52:	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15e56:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
   15e58:	orr.w	r3, r2, #65536	; 0x10000
   15e5c:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
   15e60:	ldr.w	r3, [r4, #432]	; 0x1b0
   15e64:	cmp	r3, #0
   15e66:	bne.n	15e60 <isr+0x3a8>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15e68:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15e6c:	cmp	r3, #0
   15e6e:	bne.w	15ae4 <isr+0x2c>
   15e72:	b.n	15ba4 <isr+0xec>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
   15e74:	uxth	r2, r2
   15e76:	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
   15e7a:	cmp	r1, #7
   15e7c:	bhi.w	15cdc <isr+0x224>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
   15e80:	lsls	r1, r1, #2
   15e82:	ldr	r0, [pc, #524]	; (16090 <isr+0x5d8>)
		reply_buffer[0] = 0;
   15e84:	ldr	r5, [pc, #524]	; (16094 <isr+0x5dc>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
   15e86:	add	r0, r1
   15e88:	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
   15e8a:	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
   15e8c:	strb	r3, [r5, #0]
		reply_buffer[1] = 0;
   15e8e:	strb	r3, [r5, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
   15e90:	bpl.w	15fbe <isr+0x506>
   15e94:	lsls	r2, r1, #15
   15e96:	bpl.n	15e9c <isr+0x3e4>
			reply_buffer[0] = 1;
   15e98:	movs	r3, #1
   15e9a:	strb	r3, [r5, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
   15e9c:	movs	r1, #2
   15e9e:	ldr	r0, [pc, #500]	; (16094 <isr+0x5dc>)
   15ea0:	bl	15a18 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15ea4:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15ea8:	cmp	r3, #0
   15eaa:	bne.w	15ae4 <isr+0x2c>
   15eae:	b.n	15ba4 <isr+0xec>
		usb_audio_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
   15eb0:	ldr	r2, [pc, #484]	; (16098 <isr+0x5e0>)
		endpoint0_transmit(reply_buffer, 1, 0);
   15eb2:	movs	r1, #1
		usb_audio_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
   15eb4:	ldr	r3, [pc, #476]	; (16094 <isr+0x5dc>)
   15eb6:	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
   15eb8:	mov	r0, r3
		usb_audio_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
   15eba:	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
   15ebc:	bl	15a18 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15ec0:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15ec4:	cmp	r3, #0
   15ec6:	bne.w	15ae4 <isr+0x2c>
   15eca:	b.n	15ba4 <isr+0xec>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
   15ecc:	ubfx	r0, r0, #16, #8
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
   15ed0:	mov.w	r1, #13369548	; 0xcc00cc
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
   15ed4:	mov.w	r2, #13107400	; 0xc800c8
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
   15ed8:	ldr	r5, [pc, #444]	; (16098 <isr+0x5e0>)
   15eda:	str	r3, [sp, #4]
   15edc:	strb	r0, [r5, #0]
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
   15ede:	str.w	r1, [r6, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
   15ee2:	str.w	r2, [r6, #460]	; 0x1cc
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
		#elif defined(SEREMU_INTERFACE)
		usb_seremu_configure();
   15ee6:	bl	16300 <usb_seremu_configure>
		#endif
		#if defined(MULTITOUCH_INTERFACE)
		usb_touchscreen_configure();
		#endif
		#if defined(MIDI_INTERFACE)
		usb_midi_configure();
   15eea:	bl	16fbc <usb_midi_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15eee:	ldr	r2, [pc, #412]	; (1608c <isr+0x5d4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
   15ef0:	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15ef2:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15ef4:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
   15ef6:	str	r2, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15ef8:	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15efa:	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
   15efc:	str	r3, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15efe:	str.w	fp, [r6, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
   15f02:	ldr.w	r1, [r6, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15f06:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
   15f08:	orr.w	r2, r1, #65536	; 0x10000
   15f0c:	str.w	r2, [r6, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
   15f10:	ldr	r2, [pc, #392]	; (1609c <isr+0x5e4>)
   15f12:	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
   15f14:	ldr.w	r3, [r4, #432]	; 0x1b0
   15f18:	cmp	r3, #0
   15f1a:	bne.n	15f14 <isr+0x45c>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15f1c:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15f20:	cmp	r3, #0
   15f22:	bne.w	15ae4 <isr+0x2c>
   15f26:	b.n	15ba4 <isr+0xec>
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
   15f28:	ldr.w	lr, [pc, #380]	; 160a8 <isr+0x5f0>
			endpoint0_buffer[0] = 0xE9;
   15f2c:	mov.w	ip, #233	; 0xe9
   15f30:	ldr	r5, [pc, #364]	; (160a0 <isr+0x5e8>)
#endif
#if defined(SEREMU_INTERFACE) || defined(KEYBOARD_INTERFACE)
	  case 0x0921: // HID SET_REPORT
		if (setup.wLength <= sizeof(endpoint0_buffer)) {
			//printf("hid set report %x %x\n", setup.word1, setup.word2);
			endpoint0_setupdata.bothwords = setup.bothwords;
   15f32:	stmia.w	lr, {r0, r2}
			endpoint0_buffer[0] = 0xE9;
   15f36:	strb.w	ip, [r5]
}

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
   15f3a:	cbz	r1, 15f7e <isr+0x4c6>
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
   15f3c:	lsls	r1, r1, #16
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
   15f3e:	ldr	r2, [pc, #356]	; (160a4 <isr+0x5ec>)
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
   15f40:	str	r3, [r7, #12]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
   15f42:	movs	r0, #1
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
   15f44:	orr.w	r3, r1, #128	; 0x80
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
   15f48:	str	r2, [r7, #8]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
   15f4a:	str	r0, [r2, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
   15f4c:	add.w	lr, r5, #8192	; 0x2000
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
   15f50:	str	r3, [r2, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
   15f52:	add.w	r0, r5, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
   15f56:	ldr.w	r3, [r6, #432]	; 0x1b0
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
   15f5a:	add.w	r1, r5, #12288	; 0x3000
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
   15f5e:	str	r5, [r2, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
   15f60:	add.w	r5, r5, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
   15f64:	orr.w	r3, r3, #1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
   15f68:	str	r0, [r2, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
   15f6a:	str.w	lr, [r2, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
   15f6e:	str	r1, [r2, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
   15f70:	str	r5, [r2, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
   15f72:	str.w	r3, [r6, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
   15f76:	ldr.w	r3, [r4, #432]	; 0x1b0
   15f7a:	cmp	r3, #0
   15f7c:	bne.n	15f76 <isr+0x4be>
	}
	endpoint0_transfer_ack.next = 1;
   15f7e:	ldr	r3, [pc, #268]	; (1608c <isr+0x5d4>)
   15f80:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15f82:	movw	r2, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
   15f86:	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
   15f88:	str	r0, [r3, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
   15f8a:	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
   15f8e:	str	r3, [r7, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
   15f90:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
   15f92:	str	r1, [r7, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
   15f94:	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
   15f98:	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
   15f9c:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
   15f9e:	orr.w	r3, r2, r0
   15fa2:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
   15fa6:	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
   15faa:	ldr.w	r3, [r4, #432]	; 0x1b0
   15fae:	cmp	r3, #0
   15fb0:	bne.n	15faa <isr+0x4f2>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
   15fb2:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
   15fb6:	cmp	r3, #0
   15fb8:	bne.w	15ae4 <isr+0x2c>
   15fbc:	b.n	15ba4 <isr+0xec>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
   15fbe:	lsls	r3, r1, #31
   15fc0:	bpl.w	15e9c <isr+0x3e4>
   15fc4:	b.n	15e98 <isr+0x3e0>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
   15fc6:	ldr	r0, [pc, #224]	; (160a8 <isr+0x5f0>)
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
   15fc8:	movs	r6, #0
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)
   15fca:	ldr	r4, [pc, #224]	; (160ac <isr+0x5f4>)

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
   15fcc:	ldr	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
   15fce:	str	r6, [r1, #0]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)
   15fd0:	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
   15fd2:	ldr	r0, [r0, #4]
		keyboard_leds = endpoint0_buffer[0];
		endpoint0_transmit(NULL, 0, 0);
	}
#endif
#ifdef SEREMU_INTERFACE
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)
   15fd4:	bne.w	15c64 <isr+0x1ac>
   15fd8:	ldr	r1, [pc, #212]	; (160b0 <isr+0x5f8>)
   15fda:	cmp	r0, r1
   15fdc:	bne.w	15c64 <isr+0x1ac>
	  && endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
   15fe0:	ldr	r1, [pc, #188]	; (160a0 <isr+0x5e8>)
   15fe2:	ldrb	r0, [r1, #0]
   15fe4:	cmp	r0, #169	; 0xa9
   15fe6:	bne.w	15c64 <isr+0x1ac>
   15fea:	ldrb	r0, [r1, #1]
   15fec:	cmp	r0, #69	; 0x45
   15fee:	bne.w	15c64 <isr+0x1ac>
	  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
   15ff2:	ldrb	r0, [r1, #2]
   15ff4:	cmp	r0, #194	; 0xc2
   15ff6:	bne.w	15c64 <isr+0x1ac>
   15ffa:	ldrb	r1, [r1, #3]
   15ffc:	cmp	r1, #107	; 0x6b
   15ffe:	bne.w	15c64 <isr+0x1ac>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
   16002:	cpsid	i
	sof_usage |= (1 << interface);
   16004:	ldr	r0, [pc, #172]	; (160b4 <isr+0x5fc>)
   16006:	ldrb	r1, [r0, #0]
   16008:	orr.w	r1, r1, #4
   1600c:	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
   1600e:	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
   16012:	lsls	r0, r1, #24
   16014:	bmi.n	16024 <isr+0x56c>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
   16016:	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
   1601a:	movs	r0, #128	; 0x80
   1601c:	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
   16020:	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
   16024:	cpsie	i
	if (setup.word1 == 0x03000921 && setup.word2 == ((4<<16)|SEREMU_INTERFACE)
	  && endpoint0_buffer[0] == 0xA9 && endpoint0_buffer[1] == 0x45
	  && endpoint0_buffer[2] == 0xC2 && endpoint0_buffer[3] == 0x6B) {
		printf("seremu reboot request\n");
		usb_start_sof_interrupts(NUM_INTERFACE);
		usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
   16026:	ldr	r2, [pc, #144]	; (160b8 <isr+0x600>)
   16028:	movs	r1, #80	; 0x50
   1602a:	strb	r1, [r2, #0]
   1602c:	b.n	15c64 <isr+0x1ac>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
   1602e:	ldr	r0, [pc, #140]	; (160bc <isr+0x604>)
					memcpy(usb_descriptor_buffer, src, datalen);
   16030:	mov	r2, r3
   16032:	ldr	r5, [pc, #140]	; (160c0 <isr+0x608>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
   16034:	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
   16038:	ldr	r1, [pc, #136]	; (160c4 <isr+0x60c>)
   1603a:	ldr	r0, [pc, #140]	; (160c8 <isr+0x610>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
   1603c:	str	r3, [sp, #4]
   1603e:	cmp.w	lr, #0
   16042:	it	eq
   16044:	moveq	r1, r0
   16046:	mov	r0, r5
   16048:	bl	15578 <memcpy>
					usb_descriptor_buffer[1] = 7;
   1604c:	movs	r2, #7
   1604e:	ldr	r3, [sp, #4]
   16050:	strb	r2, [r5, #1]
   16052:	b.n	15d66 <isr+0x2ae>

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
	if (sof_usage == 0) {
		USB1_USBINTR &= ~USB_USBINTR_SRE;
   16054:	ldr.w	r2, [r3, #328]	; 0x148
   16058:	bic.w	r2, r2, #128	; 0x80
   1605c:	str.w	r2, [r3, #328]	; 0x148
   16060:	b.n	15c44 <isr+0x18c>

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
   16062:	ldr	r0, [pc, #88]	; (160bc <isr+0x604>)
					memcpy(usb_descriptor_buffer, src, datalen);
   16064:	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
   16066:	ldr	r1, [pc, #96]	; (160c8 <isr+0x610>)
					if (usb_high_speed) src = usb_config_descriptor_480;
   16068:	ldrb	r5, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
   1606a:	ldr	r0, [pc, #88]	; (160c4 <isr+0x60c>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
   1606c:	str	r3, [sp, #4]
   1606e:	cmp	r5, #0
   16070:	it	eq
   16072:	moveq	r1, r0
   16074:	ldr	r0, [pc, #72]	; (160c0 <isr+0x608>)
   16076:	bl	15578 <memcpy>
   1607a:	ldr	r5, [pc, #68]	; (160c0 <isr+0x608>)
   1607c:	ldr	r3, [sp, #4]
   1607e:	b.n	15d66 <isr+0x2ae>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
   16080:	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
   16082:	ldrb	r3, [r1, #0]
   16084:	cmp	r3, r2
   16086:	it	cs
   16088:	movcs	r3, r2
   1608a:	b.n	15d50 <isr+0x298>
   1608c:	.word	0x20059020
   16090:	.word	0x402e01c0
   16094:	.word	0x20058250
   16098:	.word	0x20058260
   1609c:	.word	0x20058240
   160a0:	.word	0x20058258
   160a4:	.word	0x20059000
   160a8:	.word	0x20058248
   160ac:	.word	0x03000921
   160b0:	.word	0x00040001
   160b4:	.word	0x20058234
   160b8:	.word	0x20058244
   160bc:	.word	0x2005823c
   160c0:	.word	0x20200820
   160c4:	.word	0x60001760
   160c8:	.word	0x600017d4

000160cc <usb_stop_sof_interrupts>:
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
   160cc:	movs	r3, #1
   160ce:	ldr	r2, [pc, #32]	; (160f0 <usb_stop_sof_interrupts+0x24>)
   160d0:	lsl.w	r0, r3, r0
   160d4:	ldrb	r3, [r2, #0]
   160d6:	bic.w	r0, r3, r0
   160da:	strb	r0, [r2, #0]
	if (sof_usage == 0) {
   160dc:	cbnz	r0, 160ec <usb_stop_sof_interrupts+0x20>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
   160de:	ldr	r2, [pc, #20]	; (160f4 <usb_stop_sof_interrupts+0x28>)
   160e0:	ldr.w	r3, [r2, #328]	; 0x148
   160e4:	bic.w	r3, r3, #128	; 0x80
   160e8:	str.w	r3, [r2, #328]	; 0x148
   160ec:	bx	lr
   160ee:	nop
   160f0:	.word	0x20058234
   160f4:	.word	0x402e0000

000160f8 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
   160f8:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
   160fa:	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
   160fe:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
   16102:	ite	ne
   16104:	movne	r7, #0
   16106:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
   1610a:	cmp	r2, #2
   1610c:	bls.n	16112 <usb_config_rx+0x1a>
   1610e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
   16112:	mov.w	sl, r0, lsl #7
   16116:	ldr.w	r9, [pc, #64]	; 16158 <usb_config_rx+0x60>
   1611a:	mov	r5, r1
   1611c:	mov	r4, r0
   1611e:	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
   16122:	movs	r1, #0
   16124:	movs	r2, #64	; 0x40
   16126:	mov	r8, r3
   16128:	mov	r0, r6
   1612a:	bl	1b018 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
   1612e:	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
   16130:	orr.w	r1, r7, r5, lsl #16
   16134:	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
   16138:	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
   1613c:	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
   1613e:	cmp.w	r8, #0
   16142:	beq.n	1610e <usb_config_rx+0x16>
   16144:	ldr	r3, [pc, #12]	; (16154 <usb_config_rx+0x5c>)
   16146:	lsls	r0, r4
   16148:	ldr	r4, [r3, #0]
   1614a:	orrs	r0, r4
   1614c:	str	r0, [r3, #0]
   1614e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   16152:	nop
   16154:	.word	0x20058230
   16158:	.word	0x2005a000

0001615c <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
   1615c:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
   1615e:	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
   16162:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
   16166:	ite	ne
   16168:	movne	r7, #0
   1616a:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
   1616e:	cmp	r2, #2
   16170:	bls.n	16176 <usb_config_tx+0x1a>
   16172:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
   16176:	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
   16178:	lsls	r5, r0, #7
   1617a:	ldr.w	r9, [pc, #68]	; 161c0 <usb_config_tx+0x64>
   1617e:	mov	r8, r1
   16180:	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
   16182:	movs	r1, #0
   16184:	mov	r4, r0
   16186:	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
   16188:	add.w	sl, r5, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
   1618c:	mov	r0, sl
   1618e:	bl	1b018 <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
   16192:	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
   16194:	orr.w	r1, r7, r8, lsl #16
   16198:	str.w	r1, [r5, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
   1619c:	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
   161a0:	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
   161a4:	cmp	r6, #0
   161a6:	beq.n	16172 <usb_config_tx+0x16>
   161a8:	add.w	r0, r4, #16
   161ac:	ldr	r3, [pc, #12]	; (161bc <usb_config_tx+0x60>)
   161ae:	lsls	r2, r0
   161b0:	ldr	r0, [r3, #0]
   161b2:	orrs	r2, r0
   161b4:	str	r2, [r3, #0]
   161b6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   161ba:	nop
   161bc:	.word	0x20058230
   161c0:	.word	0x2005a000

000161c4 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
   161c4:	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
   161c6:	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
   161c8:	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
   161ca:	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
   161ce:	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
   161d0:	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
   161d2:	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
   161d4:	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
   161d8:	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
   161dc:	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
   161e0:	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
   161e4:	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
   161e6:	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
   161e8:	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
   161ea:	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
   161ec:	str	r2, [r0, #24]
	transfer->callback_param = param;
}
   161ee:	pop	{r4, r5, r6, r7}
   161f0:	bx	lr
   161f2:	nop

000161f4 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
   161f4:	subs	r3, r0, #2
   161f6:	cmp	r3, #2
   161f8:	bls.n	161fc <usb_transmit+0x8>
   161fa:	bx	lr
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
   161fc:	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
   161fe:	ldr	r3, [pc, #24]	; (16218 <usb_transmit+0x24>)
   16200:	add.w	r4, r0, #16
   16204:	movs	r5, #1
   16206:	mov	r2, r1
   16208:	add.w	r0, r3, r0, lsl #7
   1620c:	lsl.w	r1, r5, r4
}
   16210:	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
   16212:	b.w	15970 <schedule_transfer>
   16216:	nop
   16218:	.word	0x2005a040

0001621c <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
   1621c:	subs	r3, r0, #2
   1621e:	cmp	r3, #2
   16220:	bls.n	16224 <usb_receive+0x8>
   16222:	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
   16224:	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
   16226:	ldr	r3, [pc, #20]	; (1623c <usb_receive+0x20>)
   16228:	movs	r4, #1
   1622a:	mov	r2, r1
   1622c:	lsl.w	r1, r4, r0
   16230:	add.w	r0, r3, r0, lsl #7
}
   16234:	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
   16238:	b.w	15970 <schedule_transfer>
   1623c:	.word	0x2005a000

00016240 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
   16240:	ldr	r0, [r0, #4]
#endif
}
   16242:	bx	lr

00016244 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
   16244:	push	{r4, r5, r6, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
   16246:	lsls	r1, r0, #5
   16248:	ldr	r4, [pc, #72]	; (16294 <rx_queue_transfer+0x50>)
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
   1624a:	ldr	r5, [pc, #76]	; (16298 <rx_queue_transfer+0x54>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
   1624c:	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
   1624e:	add	r4, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
   16250:	mov.w	r6, #131072	; 0x20000
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
   16254:	add	r5, r1
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
   16256:	ldr	r0, [pc, #68]	; (1629c <rx_queue_transfer+0x58>)
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
   16258:	mov	r1, r4
   1625a:	movs	r2, #32
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
   1625c:	str	r6, [r0, #0]
	void *buffer = rx_buffer + i * SEREMU_RX_SIZE;
	usb_prepare_transfer(rx_transfer + i, buffer, SEREMU_RX_SIZE, i);
   1625e:	mov	r0, r5
   16260:	bl	161c4 <usb_prepare_transfer>
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
   16264:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
   16268:	add.w	r1, r4, #32
	asm volatile("": : :"memory");
	asm("dsb");
   1626c:	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
   16270:	ldr	r2, [pc, #44]	; (162a0 <rx_queue_transfer+0x5c>)
   16272:	str	r3, [r2, #0]
		location += 32;
   16274:	adds	r3, #32
	} while (location < end_addr);
   16276:	cmp	r1, r3
   16278:	bhi.n	16272 <rx_queue_transfer+0x2e>
	asm("dsb");
   1627a:	dsb	sy
	asm("isb");
   1627e:	isb	sy
	arm_dcache_delete(buffer, SEREMU_RX_SIZE);
	usb_receive(SEREMU_RX_ENDPOINT, rx_transfer + i);
   16282:	movs	r0, #2
   16284:	mov	r1, r5
   16286:	bl	1621c <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
   1628a:	ldr	r3, [pc, #24]	; (162a4 <rx_queue_transfer+0x60>)
   1628c:	mov.w	r2, #131072	; 0x20000
   16290:	str	r2, [r3, #0]
   16292:	pop	{r4, r5, r6, pc}
   16294:	.word	0x20200420
   16298:	.word	0x20058280
   1629c:	.word	0xe000e18c
   162a0:	.word	0xe000ef5c
   162a4:	.word	0xe000e10c

000162a8 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
   162a8:	ldr	r3, [r0, #4]
	int i = t->callback_param;
   162aa:	ldr	r0, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
   162ac:	ubfx	r3, r3, #16, #15
   162b0:	cbz	r3, 162b6 <rx_event+0xe>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
   162b2:	b.w	16244 <rx_queue_transfer>
static void rx_event(transfer_t *t)
{
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
   162b6:	ldr	r1, [pc, #52]	; (162ec <rx_event+0x44>)
   162b8:	lsls	r2, r0, #5
   162ba:	ldrb	r2, [r1, r2]
   162bc:	cmp	r2, #0
   162be:	beq.n	162b2 <rx_event+0xa>
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
   162c0:	ldr	r1, [pc, #44]	; (162f0 <rx_event+0x48>)
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
   162c2:	push	{r4}
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
   162c4:	ldr	r4, [pc, #44]	; (162f4 <rx_event+0x4c>)
		rx_index[i] = 0;
   162c6:	strh.w	r3, [r1, r0, lsl #1]
	int len = SEREMU_RX_SIZE - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
   162ca:	ldrb	r2, [r4, #0]
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
   162cc:	ldr	r1, [pc, #40]	; (162f8 <rx_event+0x50>)
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
   162ce:	adds	r2, #1
   162d0:	cmp	r2, #8
   162d2:	ite	ls
   162d4:	uxtbls	r3, r2
   162d6:	movhi	r2, r3
		rx_list[head] = i;
		rx_head = head;
   162d8:	strb	r3, [r4, #0]
		rx_available += len;
   162da:	ldr	r3, [r1, #0]
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
   162dc:	ldr	r4, [pc, #28]	; (162fc <rx_event+0x54>)
		rx_head = head;
		rx_available += len;
   162de:	adds	r3, #32
	if (len == SEREMU_RX_SIZE && rx_buffer[i * SEREMU_RX_SIZE] != 0) {
		// received a packet with data
		uint32_t head = rx_head;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
   162e0:	strb	r0, [r4, r2]
		rx_head = head;
		rx_available += len;
   162e2:	str	r3, [r1, #0]
		// TODO: trigger serialEvent
	} else {
		// received a short packet - should never happen with HID
		rx_queue_transfer(i);
	}
}
   162e4:	ldr.w	r4, [sp], #4
   162e8:	bx	lr
   162ea:	nop
   162ec:	.word	0x20200420
   162f0:	.word	0x20058380
   162f4:	.word	0x200583a0
   162f8:	.word	0x2005839c
   162fc:	.word	0x20058390

00016300 <usb_seremu_configure>:


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
   16300:	movs	r1, #0
   16302:	mov.w	r2, #384	; 0x180
   16306:	ldr	r0, [pc, #124]	; (16384 <usb_seremu_configure+0x84>)
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_seremu_configure(void)
{
   16308:	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
   1630a:	mov	r5, r1
   1630c:	ldr	r4, [pc, #120]	; (16388 <usb_seremu_configure+0x88>)


void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
   1630e:	bl	1b018 <memset>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
   16312:	ldr	r6, [pc, #120]	; (1638c <usb_seremu_configure+0x8c>)
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
   16314:	ldr	r3, [pc, #120]	; (16390 <usb_seremu_configure+0x90>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
   16316:	mov	r1, r5
   16318:	mov.w	r2, #256	; 0x100
   1631c:	ldr	r0, [pc, #116]	; (16394 <usb_seremu_configure+0x94>)

void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
   1631e:	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
   16320:	mov	r4, r5
void usb_seremu_configure(void)
{
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
   16322:	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
   16324:	bl	1b018 <memset>
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
   16328:	strb	r5, [r6, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
   1632a:	mov	r2, r5
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
   1632c:	ldr	r6, [pc, #104]	; (16398 <usb_seremu_configure+0x98>)
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
   1632e:	movs	r1, #32
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
   16330:	ldr	r3, [pc, #104]	; (1639c <usb_seremu_configure+0x9c>)
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
   16332:	movs	r0, #2
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
   16334:	ldr	r7, [pc, #104]	; (163a0 <usb_seremu_configure+0xa0>)
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
   16336:	strb	r5, [r3, #0]
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
   16338:	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
   1633a:	ldr	r3, [pc, #104]	; (163a4 <usb_seremu_configure+0xa4>)
	printf("usb_seremu_configure\n");
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_index, 0, sizeof(rx_index));
   1633c:	str	r5, [r6, #4]
   1633e:	str	r5, [r6, #8]
   16340:	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
   16342:	str	r5, [r7, #0]
	usb_config_rx(SEREMU_RX_ENDPOINT, SEREMU_RX_SIZE, 0, rx_event); // SEREMU_RX_SIZE = 32
   16344:	bl	160f8 <usb_config_rx>
	usb_config_tx(SEREMU_TX_ENDPOINT, SEREMU_TX_SIZE, 0, NULL);     // SEREMU_TX_SIZE = 64
   16348:	mov	r3, r5
   1634a:	mov	r2, r5
   1634c:	movs	r1, #64	; 0x40
   1634e:	movs	r0, #2
   16350:	bl	1615c <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
   16354:	mov	r0, r4
   16356:	adds	r4, #1
   16358:	bl	16244 <rx_queue_transfer>
   1635c:	cmp	r4, #8
   1635e:	bne.n	16354 <usb_seremu_configure+0x54>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
   16360:	ldr	r3, [pc, #68]	; (163a8 <usb_seremu_configure+0xa8>)
	USB1_GPTIMER0LD = microseconds - 1;
   16362:	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
   16364:	ldr	r0, [pc, #68]	; (163ac <usb_seremu_configure+0xac>)
	USB1_GPTIMER0CTRL = 0;
   16366:	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
   16368:	ldr	r4, [pc, #68]	; (163b0 <usb_seremu_configure+0xb0>)
   1636a:	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
   1636c:	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
   16370:	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
   16374:	ldr.w	r2, [r3, #328]	; 0x148
   16378:	orr.w	r2, r2, #16777216	; 0x1000000
   1637c:	str.w	r2, [r3, #328]	; 0x148
   16380:	pop	{r3, r4, r5, r6, r7, pc}
   16382:	nop
   16384:	.word	0x200583c0
   16388:	.word	0x20058263
   1638c:	.word	0x200583a0
   16390:	.word	0x2005839a
   16394:	.word	0x20058280
   16398:	.word	0x20058380
   1639c:	.word	0x20058261
   163a0:	.word	0x2005839c
   163a4:	.word	0x000162a9
   163a8:	.word	0x402e0000
   163ac:	.word	0x2005822c
   163b0:	.word	0x00016511

000163b4 <usb_seremu_getchar>:
	}
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
   163b4:	push	{r3, r4, r5, r6, r7, lr}
	uint32_t tail = rx_tail;
   163b6:	ldr	r5, [pc, #80]	; (16408 <usb_seremu_getchar+0x54>)

	if (tail == rx_head) return -1;
   163b8:	ldr	r2, [pc, #80]	; (1640c <usb_seremu_getchar+0x58>)
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
   163ba:	ldrb	r3, [r5, #0]

	if (tail == rx_head) return -1;
   163bc:	ldrb	r2, [r2, #0]
}

// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;
   163be:	uxtb	r3, r3

	if (tail == rx_head) return -1;
   163c0:	cmp	r3, r2
   163c2:	beq.n	16400 <usb_seremu_getchar+0x4c>
	if (++tail > RX_NUM) tail = 0;
   163c4:	adds	r3, #1
	uint32_t i = rx_list[tail];
   163c6:	ldr	r2, [pc, #72]	; (16410 <usb_seremu_getchar+0x5c>)
	uint32_t index = rx_index[i];
   163c8:	ldr	r6, [pc, #72]	; (16414 <usb_seremu_getchar+0x60>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
   163ca:	cmp	r3, #9
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
   163cc:	ldr	r4, [pc, #72]	; (16418 <usb_seremu_getchar+0x64>)
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
   163ce:	it	cs
   163d0:	movcs	r3, #0
	uint32_t i = rx_list[tail];
   163d2:	ldrb	r0, [r2, r3]
	uint32_t index = rx_index[i];
   163d4:	ldrh.w	r2, [r6, r0, lsl #1]
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
   163d8:	add.w	r1, r2, r0, lsl #5
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
   163dc:	adds	r2, #1
   163de:	cmp	r2, #31

	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
   163e0:	add.w	r7, r4, r1
	int c = *p;
   163e4:	ldrb	r4, [r4, r1]
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
   163e6:	bhi.n	163f4 <usb_seremu_getchar+0x40>
   163e8:	ldrb	r1, [r7, #1]
   163ea:	cbz	r1, 163f4 <usb_seremu_getchar+0x40>
		rx_tail = tail;
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
   163ec:	strh.w	r2, [r6, r0, lsl #1]
	}
	return c;
   163f0:	mov	r0, r4
   163f2:	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t i = rx_list[tail];
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
   163f4:	uxtb	r3, r3
   163f6:	strb	r3, [r5, #0]
		rx_queue_transfer(i);
   163f8:	bl	16244 <rx_queue_transfer>
	} else {
		rx_index[i] = index;
	}
	return c;
   163fc:	mov	r0, r4
	uint32_t index = rx_index[i];
	uint8_t *p = rx_buffer + i * SEREMU_RX_SIZE + index;
	int c = *p;
	if (++index >= SEREMU_RX_SIZE || *(p+1) == 0) {
		rx_tail = tail;
		rx_queue_transfer(i);
   163fe:	pop	{r3, r4, r5, r6, r7, pc}
// get the next character, or -1 if nothing received
int usb_seremu_getchar(void)
{
	uint32_t tail = rx_tail;

	if (tail == rx_head) return -1;
   16400:	mov.w	r0, #4294967295
		rx_queue_transfer(i);
	} else {
		rx_index[i] = index;
	}
	return c;
}
   16404:	pop	{r3, r4, r5, r6, r7, pc}
   16406:	nop
   16408:	.word	0x20058261
   1640c:	.word	0x200583a0
   16410:	.word	0x20058390
   16414:	.word	0x20058380
   16418:	.word	0x20200420

0001641c <usb_seremu_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
   1641c:	ldr	r3, [pc, #44]	; (1644c <usb_seremu_peekchar+0x30>)
	if (tail == rx_head) return -1;
   1641e:	ldr	r2, [pc, #48]	; (16450 <usb_seremu_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
   16420:	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
   16422:	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
   16424:	uxtb	r3, r3
	if (tail == rx_head) return -1;
   16426:	cmp	r3, r2
   16428:	beq.n	16446 <usb_seremu_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
   1642a:	adds	r3, #1
	uint32_t i = rx_list[tail];
   1642c:	ldr	r2, [pc, #36]	; (16454 <usb_seremu_peekchar+0x38>)
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
   1642e:	ldr	r0, [pc, #40]	; (16458 <usb_seremu_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
   16430:	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
   16432:	ldr	r1, [pc, #40]	; (1645c <usb_seremu_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
   16434:	it	cs
   16436:	movcs	r3, #0
	uint32_t i = rx_list[tail];
   16438:	ldrb	r2, [r2, r3]
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
   1643a:	ldrh.w	r3, [r0, r2, lsl #1]
   1643e:	add.w	r3, r3, r2, lsl #5
   16442:	ldrb	r0, [r1, r3]
   16444:	bx	lr

// peek at the next character, or -1 if nothing received
int usb_seremu_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
   16446:	mov.w	r0, #4294967295
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * SEREMU_RX_SIZE + rx_index[i]];
}
   1644a:	bx	lr
   1644c:	.word	0x20058261
   16450:	.word	0x200583a0
   16454:	.word	0x20058390
   16458:	.word	0x20058380
   1645c:	.word	0x20200420

00016460 <usb_seremu_available>:

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
   16460:	ldr	r2, [pc, #12]	; (16470 <usb_seremu_available+0x10>)
	if (tail == rx_head) return 0;
   16462:	ldr	r3, [pc, #16]	; (16474 <usb_seremu_available+0x14>)
}

// number of bytes available in the receive buffer
int usb_seremu_available(void)
{
	uint32_t tail = rx_tail;
   16464:	ldrb	r0, [r2, #0]
	if (tail == rx_head) return 0;
   16466:	ldrb	r3, [r3, #0]
	// TODO: how much is actually available?
	return 1;
}
   16468:	subs	r0, r0, r3
   1646a:	it	ne
   1646c:	movne	r0, #1
   1646e:	bx	lr
   16470:	.word	0x20058261
   16474:	.word	0x200583a0

00016478 <tx_zero_pad>:
	USB1_GPTIMER0CTRL = 0;
}


void tx_zero_pad(void)
{
   16478:	push	{r3, r4, r5, lr}
	if (!tx_available) return;
   1647a:	ldr	r4, [pc, #32]	; (1649c <tx_zero_pad+0x24>)
   1647c:	ldrh	r2, [r4, #0]
   1647e:	cbz	r2, 1649a <tx_zero_pad+0x22>
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
   16480:	ldr	r1, [pc, #28]	; (164a0 <tx_zero_pad+0x28>)
	memset(txdata, 0, tx_available);
   16482:	rsb	r3, r2, #64	; 0x40
   16486:	ldr	r0, [pc, #28]	; (164a4 <tx_zero_pad+0x2c>)


void tx_zero_pad(void)
{
	if (!tx_available) return;
	uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
   16488:	ldrb	r5, [r1, #0]
	memset(txdata, 0, tx_available);
   1648a:	movs	r1, #0
   1648c:	add.w	r3, r3, r5, lsl #6
   16490:	add	r0, r3
   16492:	bl	1b018 <memset>
	tx_available = 0;
   16496:	movs	r3, #0
   16498:	strh	r3, [r4, #0]
   1649a:	pop	{r3, r4, r5, pc}
   1649c:	.word	0x2005839a
   164a0:	.word	0x20058263
   164a4:	.word	0x20200520

000164a8 <tx_queue_transfer>:
}

void tx_queue_transfer(void)
{
   164a8:	push	{r4, r5, r6, lr}
	transfer_t *xfer = tx_transfer + tx_head;
   164aa:	ldr	r6, [pc, #84]	; (16500 <tx_queue_transfer+0x58>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
   164ac:	movs	r3, #0
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
   164ae:	ldr	r5, [pc, #84]	; (16504 <tx_queue_transfer+0x5c>)
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
   164b0:	movs	r2, #64	; 0x40
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
   164b2:	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
   164b4:	ldr	r4, [pc, #80]	; (16508 <tx_queue_transfer+0x60>)
	tx_available = 0;
}

void tx_queue_transfer(void)
{
	transfer_t *xfer = tx_transfer + tx_head;
   164b6:	add.w	r5, r5, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * SEREMU_TX_SIZE);
   164ba:	add.w	r4, r4, r1, lsl #6
	usb_prepare_transfer(xfer, txbuf, SEREMU_TX_SIZE, 0);
   164be:	mov	r0, r5
   164c0:	mov	r1, r4
   164c2:	bl	161c4 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
   164c6:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
   164ca:	add.w	r1, r4, #64	; 0x40
	asm volatile("": : :"memory");
	asm("dsb");
   164ce:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
   164d2:	ldr	r2, [pc, #56]	; (1650c <tx_queue_transfer+0x64>)
   164d4:	str	r3, [r2, #0]
		location += 32;
   164d6:	adds	r3, #32
	} while (location < end_addr);
   164d8:	cmp	r1, r3
   164da:	bhi.n	164d4 <tx_queue_transfer+0x2c>
	asm("dsb");
   164dc:	dsb	sy
	asm("isb");
   164e0:	isb	sy
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
   164e4:	movs	r0, #2
   164e6:	mov	r1, r5
   164e8:	bl	161f4 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
   164ec:	ldrb	r3, [r6, #0]
   164ee:	ldr	r2, [pc, #16]	; (16500 <tx_queue_transfer+0x58>)
   164f0:	adds	r3, #1
   164f2:	uxtb	r3, r3
   164f4:	cmp	r3, #11
   164f6:	it	hi
   164f8:	movhi	r3, #0
   164fa:	strb	r3, [r2, #0]
   164fc:	pop	{r4, r5, r6, pc}
   164fe:	nop
   16500:	.word	0x20058263
   16504:	.word	0x200583c0
   16508:	.word	0x20200520
   1650c:	.word	0xe000ef70

00016510 <usb_seremu_flush_callback>:
	tx_queue_transfer();
	tx_noautoflush = 0;
}

static void usb_seremu_flush_callback(void)
{
   16510:	push	{r3, lr}
	if (tx_noautoflush) return;
   16512:	ldr	r3, [pc, #20]	; (16528 <usb_seremu_flush_callback+0x18>)
   16514:	ldrb	r3, [r3, #0]
   16516:	cbz	r3, 1651a <usb_seremu_flush_callback+0xa>
   16518:	pop	{r3, pc}
	tx_zero_pad();
   1651a:	bl	16478 <tx_zero_pad>
	tx_queue_transfer();
}
   1651e:	ldmia.w	sp!, {r3, lr}

static void usb_seremu_flush_callback(void)
{
	if (tx_noautoflush) return;
	tx_zero_pad();
	tx_queue_transfer();
   16522:	b.w	164a8 <tx_queue_transfer>
   16526:	nop
   16528:	.word	0x20058262

0001652c <usb_seremu_write.part.0>:
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
   1652c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16530:	sub	sp, #20
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
   16532:	mov	fp, r1
	arm_dcache_flush_delete(txbuf, SEREMU_TX_SIZE);
	usb_transmit(SEREMU_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
}

int usb_seremu_write(const void *buffer, uint32_t size)
   16534:	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
   16536:	cmp	r1, #0
   16538:	beq.n	1662e <usb_seremu_write.part.0+0x102>
   1653a:	movs	r3, #0
   1653c:	ldr	r7, [pc, #244]	; (16634 <usb_seremu_write.part.0+0x108>)
   1653e:	ldr.w	r9, [pc, #260]	; 16644 <usb_seremu_write.part.0+0x118>
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
   16542:	ldr	r6, [pc, #244]	; (16638 <usb_seremu_write.part.0+0x10c>)
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
   16544:	ldr.w	sl, [pc, #264]	; 16650 <usb_seremu_write.part.0+0x124>
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
   16548:	str	r3, [sp, #4]
		transfer_t *xfer = tx_transfer + tx_head;
   1654a:	ldr	r3, [pc, #240]	; (1663c <usb_seremu_write.part.0+0x110>)
   1654c:	ldr	r1, [pc, #240]	; (16640 <usb_seremu_write.part.0+0x114>)
   1654e:	ldrb	r2, [r3, #0]
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
   16550:	ldrh	r3, [r7, #0]
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
   16552:	add.w	r8, r1, r2, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
   16556:	cmp	r3, #0
   16558:	bne.n	165e8 <usb_seremu_write.part.0+0xbc>
   1655a:	mov	r5, r3
   1655c:	mov	r4, r3
   1655e:	b.n	16584 <usb_seremu_write.part.0+0x58>
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
   16560:	ldrb.w	r3, [r9]
				}
				tx_available = SEREMU_TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			if (!waiting) {
   16564:	cbnz	r4, 16568 <usb_seremu_write.part.0+0x3c>
				wait_begin_at = systick_millis_count;
   16566:	ldr	r5, [r6, #0]
   16568:	movs	r4, #1
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
   1656a:	cmp	r3, #0
   1656c:	bne.n	165dc <usb_seremu_write.part.0+0xb0>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
   1656e:	ldr	r3, [r6, #0]
   16570:	subs	r3, r3, r5
   16572:	cmp	r3, #50	; 0x32
   16574:	bhi.n	16622 <usb_seremu_write.part.0+0xf6>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
				return sent;
			}
			if (!usb_configuration) return sent;
   16576:	ldrb.w	r3, [sl]
   1657a:	cbz	r3, 165dc <usb_seremu_write.part.0+0xb0>
			yield();
   1657c:	bl	175e8 <yield>
	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
   16580:	ldrh	r3, [r7, #0]
   16582:	cbnz	r3, 165e4 <usb_seremu_write.part.0+0xb8>
			uint32_t status = usb_transfer_status(xfer);
   16584:	mov	r0, r8
   16586:	bl	16240 <usb_transfer_status>
			if (!(status & 0x80)) {
   1658a:	ands.w	r0, r0, #128	; 0x80
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
   1658e:	ldr	r2, [pc, #180]	; (16644 <usb_seremu_write.part.0+0x118>)
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
   16590:	bne.n	16560 <usb_seremu_write.part.0+0x34>
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
   16592:	movs	r3, #64	; 0x40
   16594:	ldr	r2, [pc, #164]	; (1663c <usb_seremu_write.part.0+0x110>)
				transmit_previous_timeout = 0;
   16596:	strb.w	r0, [r9]
   1659a:	ldrb	r2, [r2, #0]
   1659c:	mov	r4, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = SEREMU_TX_SIZE;
   1659e:	strh	r3, [r7, #0]
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
   165a0:	add.w	r0, r0, r2, lsl #6
		if (size >= tx_available) {
   165a4:	cmp	fp, r4
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
   165a6:	ldr	r2, [pc, #160]	; (16648 <usb_seremu_write.part.0+0x11c>)
   165a8:	add	r0, r2
		if (size >= tx_available) {
   165aa:	bcc.n	165fa <usb_seremu_write.part.0+0xce>
			memcpy(txdata, data, tx_available);
   165ac:	ldr.w	r8, [sp, #8]
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
   165b0:	movs	r5, #0
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
   165b2:	mov	r2, r4
			size -= tx_available;
   165b4:	rsb	fp, r4, fp
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
   165b8:	mov	r1, r8
   165ba:	bl	15578 <memcpy>
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
   165be:	strh	r5, [r7, #0]
			tx_queue_transfer();
   165c0:	bl	164a8 <tx_queue_transfer>
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
   165c4:	ldr	r2, [sp, #4]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
   165c6:	ldr	r3, [pc, #132]	; (1664c <usb_seremu_write.part.0+0x120>)
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
			size -= tx_available;
			sent += tx_available;
   165c8:	add	r2, r4
   165ca:	str	r2, [sp, #4]
			data += tx_available;
   165cc:	mov	r2, r8
   165ce:	add	r2, r4
   165d0:	str	r2, [sp, #8]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
   165d2:	str.w	r5, [r3, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
   165d6:	cmp.w	fp, #0
   165da:	bne.n	1654a <usb_seremu_write.part.0+0x1e>
   165dc:	ldr	r0, [sp, #4]
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
   165de:	add	sp, #20
   165e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   165e4:	ldr	r2, [pc, #84]	; (1663c <usb_seremu_write.part.0+0x110>)
   165e6:	ldrb	r2, [r2, #0]
   165e8:	mov	r4, r3
   165ea:	rsb	r0, r3, #64	; 0x40
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
		if (size >= tx_available) {
   165ee:	cmp	fp, r4
				return sent;
			}
			if (!usb_configuration) return sent;
			yield();
		}
		uint8_t *txdata = txbuffer + (tx_head * SEREMU_TX_SIZE) + (SEREMU_TX_SIZE - tx_available);
   165f0:	add.w	r0, r0, r2, lsl #6
   165f4:	ldr	r2, [pc, #80]	; (16648 <usb_seremu_write.part.0+0x11c>)
   165f6:	add	r0, r2
		if (size >= tx_available) {
   165f8:	bcs.n	165ac <usb_seremu_write.part.0+0x80>
			data += tx_available;
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
   165fa:	ldr	r1, [sp, #8]
   165fc:	mov	r2, fp
   165fe:	str	r3, [sp, #12]
   16600:	bl	15578 <memcpy>
			tx_available -= size;
   16604:	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
   16606:	mov.w	r1, #3221225472	; 0xc0000000
   1660a:	ldr	r2, [pc, #64]	; (1664c <usb_seremu_write.part.0+0x120>)
			tx_available = 0;
			tx_queue_transfer();
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
   1660c:	rsb	r3, fp, r3
   16610:	strh	r3, [r7, #0]
   16612:	ldr	r3, [sp, #4]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
   16614:	str.w	r1, [r2, #132]	; 0x84
   16618:	add	r3, fp
   1661a:	mov	r0, r3
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
   1661c:	add	sp, #20
   1661e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
   16622:	movs	r3, #1
				return sent;
   16624:	ldr	r0, [sp, #4]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
   16626:	strb	r3, [r2, #0]
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
   16628:	add	sp, #20
   1662a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
   1662e:	mov	r0, r1
   16630:	b.n	165de <usb_seremu_write.part.0+0xb2>
   16632:	nop
   16634:	.word	0x2005839a
   16638:	.word	0x20058548
   1663c:	.word	0x20058263
   16640:	.word	0x200583c0
   16644:	.word	0x200583a1
   16648:	.word	0x20200520
   1664c:	.word	0x402e0000
   16650:	.word	0x20058260

00016654 <usb_seremu_putchar>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
   16654:	ldr	r3, [pc, #36]	; (1667c <usb_seremu_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
   16656:	push	{lr}
   16658:	sub	sp, #12
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
   1665a:	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
   1665c:	strb.w	r0, [sp, #7]
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
   16660:	cbnz	r3, 1666c <usb_seremu_putchar+0x18>
   16662:	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_seremu_putchar(uint8_t c)
{
	return usb_seremu_write(&c, 1);
}
   16666:	add	sp, #12
   16668:	ldr.w	pc, [sp], #4
   1666c:	movs	r1, #1
   1666e:	add.w	r0, sp, #7
   16672:	bl	1652c <usb_seremu_write.part.0>
   16676:	add	sp, #12
   16678:	ldr.w	pc, [sp], #4
   1667c:	.word	0x20058260

00016680 <usb_seremu_write>:
int usb_seremu_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
   16680:	ldr	r3, [pc, #16]	; (16694 <usb_seremu_write+0x14>)
   16682:	ldrb	r3, [r3, #0]
   16684:	and.w	r2, r3, #255	; 0xff
   16688:	cbz	r3, 1668e <usb_seremu_write+0xe>
   1668a:	b.w	1652c <usb_seremu_write.part.0>
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
   1668e:	mov	r0, r2
   16690:	bx	lr
   16692:	nop
   16694:	.word	0x20058260

00016698 <usb_seremu_write_buffer_free>:

int usb_seremu_write_buffer_free(void)
{
	return 1;
}
   16698:	movs	r0, #1
   1669a:	bx	lr

0001669c <usb_seremu_flush_output>:

void usb_seremu_flush_output(void)
{
	if (!usb_configuration) return;
   1669c:	ldr	r3, [pc, #32]	; (166c0 <usb_seremu_flush_output+0x24>)
   1669e:	ldrb	r3, [r3, #0]
   166a0:	cbz	r3, 166a8 <usb_seremu_flush_output+0xc>
	if (tx_available == 0) return;
   166a2:	ldr	r3, [pc, #32]	; (166c4 <usb_seremu_flush_output+0x28>)
   166a4:	ldrh	r3, [r3, #0]
   166a6:	cbnz	r3, 166aa <usb_seremu_flush_output+0xe>
   166a8:	bx	lr
{
	return 1;
}

void usb_seremu_flush_output(void)
{
   166aa:	push	{r4, lr}
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
   166ac:	movs	r3, #1
   166ae:	ldr	r4, [pc, #24]	; (166c8 <usb_seremu_flush_output+0x2c>)
   166b0:	strb	r3, [r4, #0]
	tx_zero_pad();
   166b2:	bl	16478 <tx_zero_pad>
	tx_queue_transfer();
   166b6:	bl	164a8 <tx_queue_transfer>
	tx_noautoflush = 0;
   166ba:	movs	r3, #0
   166bc:	strb	r3, [r4, #0]
   166be:	pop	{r4, pc}
   166c0:	.word	0x20058260
   166c4:	.word	0x2005839a
   166c8:	.word	0x20058262

000166cc <delay>:

void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
   166cc:	cmp	r0, #0
   166ce:	beq.n	16780 <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
   166d0:	movs	r2, #1
{

}*/

void delay(uint32_t msec)
{
   166d2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   166d6:	sub	sp, #20
   166d8:	mov	fp, r0
   166da:	ldr	r4, [pc, #168]	; (16784 <delay+0xb8>)
   166dc:	ldr	r5, [pc, #168]	; (16788 <delay+0xbc>)
   166de:	ldr	r6, [pc, #172]	; (1678c <delay+0xc0>)
   166e0:	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
   166e4:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
   166e8:	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
   166ea:	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
   166ec:	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
   166f0:	cmp	r1, #0
   166f2:	bne.n	166e4 <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
   166f4:	ldr	r7, [pc, #152]	; (16790 <delay+0xc4>)
   166f6:	strd	r8, r9, [sp, #8]
   166fa:	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
   166fc:	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   166fe:	ldr	r2, [pc, #148]	; (16794 <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
   16700:	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
   16704:	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16706:	ldr	r2, [r2, #0]
   16708:	movs	r7, #1
   1670a:	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
   1670e:	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16712:	mov	r8, r3
	if (frac > 1000) frac = 1000;
   16714:	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16716:	cmp	r3, r1
   16718:	it	eq
   1671a:	cmpeq	r2, r8
   1671c:	ite	cs
   1671e:	movcs	sl, r8
   16720:	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
   16722:	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
   16726:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
   1672a:	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
   1672c:	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
   1672e:	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
   16732:	cmp	r3, #0
   16734:	bne.n	16726 <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
   16736:	ldr	r0, [sp, #4]
   16738:	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
   1673a:	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   1673c:	ldr	r0, [pc, #84]	; (16794 <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
   1673e:	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16742:	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
   16744:	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16748:	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
   1674c:	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
   16750:	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16754:	mov	r8, r1
	if (frac > 1000) frac = 1000;
   16756:	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
   16758:	cmp	r1, r3
   1675a:	it	eq
   1675c:	cmpeq	r0, r8
   1675e:	ite	cs
   16760:	movcs	r3, r8
   16762:	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
   16764:	add	r2, r3
   16766:	cmp	r2, lr
   16768:	bcc.n	1677a <delay+0xae>
			if (--msec == 0) return;
   1676a:	subs.w	fp, fp, #1
			start += 1000;
   1676e:	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
   16772:	bne.n	16726 <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
   16774:	add	sp, #20
   16776:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
   1677a:	bl	175e8 <yield>
	}
   1677e:	b.n	16726 <delay+0x5a>
   16780:	bx	lr
   16782:	nop
   16784:	.word	0x2005a280
   16788:	.word	0x20058548
   1678c:	.word	0x20058540
   16790:	.word	0xe0001004
   16794:	.word	0x20058544

00016798 <analogRead>:
}


int analogRead(uint8_t pin)
{
	if (pin > sizeof(pin_to_channel)) return 0;
   16798:	cmp	r0, #28
   1679a:	bhi.n	167d4 <analogRead+0x3c>
	if (calibrating) wait_for_cal();
   1679c:	ldr	r1, [pc, #80]	; (167f0 <analogRead+0x58>)
   1679e:	ldrb	r3, [r1, #0]
   167a0:	cbz	r3, 167b6 <analogRead+0x1e>


static void wait_for_cal(void)
{
	//printf("wait_for_cal\n");
	while (ADC1_GC & ADC_GC_CAL) ;
   167a2:	ldr	r2, [pc, #80]	; (167f4 <analogRead+0x5c>)
   167a4:	ldr	r3, [r2, #72]	; 0x48
   167a6:	lsls	r3, r3, #24
   167a8:	bmi.n	167a4 <analogRead+0xc>
	while (ADC2_GC & ADC_GC_CAL) ;
   167aa:	ldr	r2, [pc, #76]	; (167f8 <analogRead+0x60>)
   167ac:	ldr	r3, [r2, #72]	; 0x48
   167ae:	ands.w	r3, r3, #128	; 0x80
   167b2:	bne.n	167ac <analogRead+0x14>
	// TODO: check CALF, but what do to about CAL failure?
	calibrating = 0;
   167b4:	strb	r3, [r1, #0]

int analogRead(uint8_t pin)
{
	if (pin > sizeof(pin_to_channel)) return 0;
	if (calibrating) wait_for_cal();
	uint8_t ch = pin_to_channel[pin];
   167b6:	ldr	r3, [pc, #68]	; (167fc <analogRead+0x64>)
   167b8:	ldrb	r3, [r3, r0]
	if (ch == 255) return 0;
   167ba:	cmp	r3, #255	; 0xff
   167bc:	beq.n	167d4 <analogRead+0x3c>
//	printf("%d\n", ch);
//	if (ch > 15) return 0;
	if(!(ch & 0x80)) {
   167be:	lsls	r2, r3, #24
   167c0:	bmi.n	167d8 <analogRead+0x40>
		ADC1_HC0 = ch;
   167c2:	ldr	r2, [pc, #48]	; (167f4 <analogRead+0x5c>)
		while (!(ADC1_HS & ADC_HS_COCO0)) ; // wait
   167c4:	mov	r1, r2
	uint8_t ch = pin_to_channel[pin];
	if (ch == 255) return 0;
//	printf("%d\n", ch);
//	if (ch > 15) return 0;
	if(!(ch & 0x80)) {
		ADC1_HC0 = ch;
   167c6:	str	r3, [r2, #0]
		while (!(ADC1_HS & ADC_HS_COCO0)) ; // wait
   167c8:	ldr	r3, [r1, #32]
   167ca:	ldr	r2, [pc, #40]	; (167f4 <analogRead+0x5c>)
   167cc:	lsls	r0, r3, #31
   167ce:	bpl.n	167c8 <analogRead+0x30>
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
		while (!(ADC2_HS & ADC_HS_COCO0)) ; // wait
		return ADC2_R0;
   167d0:	ldr	r0, [r2, #36]	; 0x24
	}
}
   167d2:	bx	lr
}


int analogRead(uint8_t pin)
{
	if (pin > sizeof(pin_to_channel)) return 0;
   167d4:	movs	r0, #0
   167d6:	bx	lr
	if(!(ch & 0x80)) {
		ADC1_HC0 = ch;
		while (!(ADC1_HS & ADC_HS_COCO0)) ; // wait
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
   167d8:	ldr	r2, [pc, #28]	; (167f8 <analogRead+0x60>)
   167da:	and.w	r3, r3, #127	; 0x7f
		while (!(ADC2_HS & ADC_HS_COCO0)) ; // wait
   167de:	mov	r1, r2
	if(!(ch & 0x80)) {
		ADC1_HC0 = ch;
		while (!(ADC1_HS & ADC_HS_COCO0)) ; // wait
		return ADC1_R0;
	} else {
		ADC2_HC0 = ch & 0x7f;
   167e0:	str	r3, [r2, #0]
		while (!(ADC2_HS & ADC_HS_COCO0)) ; // wait
   167e2:	ldr	r3, [r1, #32]
   167e4:	ldr	r2, [pc, #16]	; (167f8 <analogRead+0x60>)
   167e6:	lsls	r3, r3, #31
   167e8:	bpl.n	167e2 <analogRead+0x4a>
		return ADC2_R0;
   167ea:	ldr	r0, [r2, #36]	; 0x24
	}
}
   167ec:	bx	lr
   167ee:	nop
   167f0:	.word	0x2005854c
   167f4:	.word	0x400c4000
   167f8:	.word	0x400c8000
   167fc:	.word	0x2001fb38

00016800 <dummy_isr>:
#define ICR2  4
#define IMR   5
#define ISR   6
#define EDGE  7

static void dummy_isr() {};
   16800:	bx	lr
   16802:	nop

00016804 <attachInterrupt>:

#endif

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
   16804:	cmp	r0, #39	; 0x27
   16806:	bhi.n	16850 <attachInterrupt+0x4c>
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
   16808:	lsls	r0, r0, #4
}

#endif

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
   1680a:	push	{r4, r5, r6, r7, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
   1680c:	ldr	r4, [pc, #300]	; (1693c <attachInterrupt+0x138>)

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
   1680e:	ldr	r5, [pc, #304]	; (16940 <attachInterrupt+0x13c>)

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
   16810:	ldr	r3, [r4, r0]

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
   16812:	cmp	r3, r5
   16814:	beq.n	168a4 <attachInterrupt+0xa0>
   16816:	bls.n	1690e <attachInterrupt+0x10a>
   16818:	ldr	r5, [pc, #296]	; (16944 <attachInterrupt+0x140>)
   1681a:	cmp	r3, r5
   1681c:	beq.n	168a8 <attachInterrupt+0xa4>
   1681e:	add.w	r5, r5, #16384	; 0x4000
   16822:	cmp	r3, r5
   16824:	bne.w	16932 <attachInterrupt+0x12e>
			break;
		case (uint32_t)&GPIO8_DR:
			table = isr_table_gpio3;
			break;
		case (uint32_t)&GPIO9_DR:
			table = isr_table_gpio4;
   16828:	ldr	r7, [pc, #284]	; (16948 <attachInterrupt+0x144>)
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	if (pin >= CORE_NUM_DIGITAL) return;
	//printf("attachInterrupt, pin=%u\n", pin);
	volatile uint32_t *gpio = portOutputRegister(pin);
	volatile uint32_t *mux = portConfigRegister(pin);
   1682a:	add	r0, r4
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
   1682c:	ldr	r6, [pc, #284]	; (1694c <attachInterrupt+0x148>)
   1682e:	ldr	r4, [pc, #288]	; (16950 <attachInterrupt+0x14c>)
   16830:	ldr.w	lr, [r0, #4]
	//volatile uint32_t *pad = portControlRegister(pin);
	uint32_t mask = digitalPinToBitMask(pin);
   16834:	ldr	r5, [r0, #12]
   16836:	str.w	r6, [r4, #692]	; 0x2b4
		default:
			return;
	}

	attachInterruptVector(IRQ_GPIO6789, &irq_gpio6789);
	NVIC_ENABLE_IRQ(IRQ_GPIO6789);
   1683a:	ldr	r0, [pc, #280]	; (16954 <attachInterrupt+0x150>)
   1683c:	mov.w	r4, #536870912	; 0x20000000
   16840:	str	r4, [r0, #0]

#endif

	uint32_t icr;
	switch (mode) {
   16842:	cmp	r2, #4
   16844:	bhi.n	1690c <attachInterrupt+0x108>
   16846:	tbb	[pc, r2]
   1684a:	.short	0x4648
   1684c:	.short	0x3104
   1684e:	.byte	0x48
   1684f:	.byte	0x00
   16850:	bx	lr
		case CHANGE:  icr = 0; break;
		case RISING:  icr = 2; break;
		case FALLING: icr = 3; break;
   16852:	movs	r6, #3
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   16854:	ldr	r2, [r3, #20]
   16856:	mvn.w	ip, r5
	*mux = 5;		// pin is GPIO
   1685a:	movs	r4, #5
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
   1685c:	rbit	r0, r5
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   16860:	and.w	r2, ip, r2
	*mux = 5;		// pin is GPIO
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
   16864:	clz	r0, r0
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   16868:	str	r2, [r3, #20]
	*mux = 5;		// pin is GPIO
   1686a:	str.w	r4, [lr]
	gpio[GDIR] &= ~mask;	// pin to input mode
   1686e:	ldr	r2, [r3, #4]
   16870:	and.w	r2, r2, ip
   16874:	str	r2, [r3, #4]
	uint32_t index = __builtin_ctz(mask);
	table[index] = function;
   16876:	str.w	r1, [r7, r0, lsl #2]
	if (mode == CHANGE) {
		gpio[EDGE] |= mask;
	} else {
		gpio[EDGE] &= ~mask;
   1687a:	ldr	r4, [r3, #28]
		if (index < 15) {
   1687c:	cmp	r0, #14
	uint32_t index = __builtin_ctz(mask);
	table[index] = function;
	if (mode == CHANGE) {
		gpio[EDGE] |= mask;
	} else {
		gpio[EDGE] &= ~mask;
   1687e:	and.w	r4, r4, ip
   16882:	str	r4, [r3, #28]
		if (index < 15) {
   16884:	bgt.n	16918 <attachInterrupt+0x114>
			uint32_t shift = index * 2;
   16886:	lsls	r0, r0, #1
			gpio[ICR1] = (gpio[ICR1] & ~(3 << shift)) | (icr << shift);
   16888:	movs	r1, #3
   1688a:	ldr	r2, [r3, #12]
   1688c:	lsls	r1, r0
   1688e:	lsl.w	r0, r6, r0
   16892:	bic.w	r1, r2, r1
   16896:	orrs	r0, r1
   16898:	str	r0, [r3, #12]
		} else {
			uint32_t shift = (index - 16) * 2;
			gpio[ICR2] = (gpio[ICR2] & ~(3 << shift)) | (icr << shift);
		}
	}
	gpio[ISR] = mask;  // clear any prior pending interrupt
   1689a:	str	r5, [r3, #24]
	gpio[IMR] |= mask; // enable interrupt
   1689c:	ldr	r2, [r3, #20]
   1689e:	orrs	r2, r5
   168a0:	str	r2, [r3, #20]
   168a2:	pop	{r4, r5, r6, r7, pc}
	switch((uint32_t)gpio) {
		case (uint32_t)&GPIO6_DR:
			table = isr_table_gpio1;
			break;
		case (uint32_t)&GPIO7_DR:
			table = isr_table_gpio2;
   168a4:	ldr	r7, [pc, #176]	; (16958 <attachInterrupt+0x154>)
   168a6:	b.n	1682a <attachInterrupt+0x26>
			break;
		case (uint32_t)&GPIO8_DR:
			table = isr_table_gpio3;
   168a8:	ldr	r7, [pc, #176]	; (1695c <attachInterrupt+0x158>)
			break;
   168aa:	b.n	1682a <attachInterrupt+0x26>
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   168ac:	ldr	r2, [r3, #20]
   168ae:	mvn.w	ip, r5
	*mux = 5;		// pin is GPIO
   168b2:	movs	r4, #5
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
   168b4:	rbit	r0, r5
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   168b8:	and.w	r2, r2, ip
#endif

	uint32_t icr;
	switch (mode) {
		case CHANGE:  icr = 0; break;
		case RISING:  icr = 2; break;
   168bc:	movs	r6, #2

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
	*mux = 5;		// pin is GPIO
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
   168be:	clz	r0, r0
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   168c2:	str	r2, [r3, #20]
	*mux = 5;		// pin is GPIO
   168c4:	str.w	r4, [lr]
	gpio[GDIR] &= ~mask;	// pin to input mode
   168c8:	ldr	r2, [r3, #4]
   168ca:	and.w	r2, ip, r2
   168ce:	str	r2, [r3, #4]
	uint32_t index = __builtin_ctz(mask);
	table[index] = function;
   168d0:	str.w	r1, [r7, r0, lsl #2]
   168d4:	b.n	1687a <attachInterrupt+0x76>
	switch (mode) {
		case CHANGE:  icr = 0; break;
		case RISING:  icr = 2; break;
		case FALLING: icr = 3; break;
		case LOW:     icr = 0; break;
		case HIGH:    icr = 1; break;
   168d6:	movs	r6, #1
   168d8:	b.n	16854 <attachInterrupt+0x50>
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   168da:	ldr	r4, [r3, #20]
   168dc:	mvn.w	ip, r5
	*mux = 5;		// pin is GPIO
   168e0:	movs	r6, #5
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
   168e2:	rbit	r0, r5
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   168e6:	and.w	r4, r4, ip
	*mux = 5;		// pin is GPIO
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
	table[index] = function;
	if (mode == CHANGE) {
   168ea:	cmp	r2, #4

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
	*mux = 5;		// pin is GPIO
	gpio[GDIR] &= ~mask;	// pin to input mode
	uint32_t index = __builtin_ctz(mask);
   168ec:	clz	r0, r0
		case HIGH:    icr = 1; break;
		default: return;
	}

	// TODO: global interrupt disable to protect these read-modify-write accesses?
	gpio[IMR] &= ~mask;	// disable interrupt
   168f0:	str	r4, [r3, #20]
	*mux = 5;		// pin is GPIO
   168f2:	str.w	r6, [lr]
	gpio[GDIR] &= ~mask;	// pin to input mode
   168f6:	ldr	r4, [r3, #4]
   168f8:	and.w	r4, ip, r4
   168fc:	str	r4, [r3, #4]
	uint32_t index = __builtin_ctz(mask);
	table[index] = function;
   168fe:	str.w	r1, [r7, r0, lsl #2]
	if (mode == CHANGE) {
   16902:	bne.n	16936 <attachInterrupt+0x132>
		gpio[EDGE] |= mask;
   16904:	ldr	r2, [r3, #28]
   16906:	orrs	r2, r5
   16908:	str	r2, [r3, #28]
   1690a:	b.n	1689a <attachInterrupt+0x96>
   1690c:	pop	{r4, r5, r6, r7, pc}

	voidFuncPtr *table;

#if defined(__IMXRT1062__)

	switch((uint32_t)gpio) {
   1690e:	cmp.w	r3, #1107296256	; 0x42000000
   16912:	bne.n	16934 <attachInterrupt+0x130>
		case (uint32_t)&GPIO6_DR:
			table = isr_table_gpio1;
   16914:	ldr	r7, [pc, #72]	; (16960 <attachInterrupt+0x15c>)
   16916:	b.n	1682a <attachInterrupt+0x26>
		gpio[EDGE] &= ~mask;
		if (index < 15) {
			uint32_t shift = index * 2;
			gpio[ICR1] = (gpio[ICR1] & ~(3 << shift)) | (icr << shift);
		} else {
			uint32_t shift = (index - 16) * 2;
   16918:	ldr	r1, [pc, #72]	; (16964 <attachInterrupt+0x160>)
			gpio[ICR2] = (gpio[ICR2] & ~(3 << shift)) | (icr << shift);
   1691a:	movs	r2, #3
   1691c:	ldr	r4, [r3, #16]
		gpio[EDGE] &= ~mask;
		if (index < 15) {
			uint32_t shift = index * 2;
			gpio[ICR1] = (gpio[ICR1] & ~(3 << shift)) | (icr << shift);
		} else {
			uint32_t shift = (index - 16) * 2;
   1691e:	add	r1, r0
   16920:	lsls	r1, r1, #1
			gpio[ICR2] = (gpio[ICR2] & ~(3 << shift)) | (icr << shift);
   16922:	lsls	r2, r1
   16924:	lsl.w	r1, r6, r1
   16928:	bic.w	r2, r4, r2
   1692c:	orrs	r1, r2
   1692e:	str	r1, [r3, #16]
   16930:	b.n	1689a <attachInterrupt+0x96>
   16932:	pop	{r4, r5, r6, r7, pc}
   16934:	pop	{r4, r5, r6, r7, pc}

#endif

	uint32_t icr;
	switch (mode) {
		case CHANGE:  icr = 0; break;
   16936:	movs	r6, #0
   16938:	b.n	1687a <attachInterrupt+0x76>
   1693a:	nop
   1693c:	.word	0x2001fbd8
   16940:	.word	0x42004000
   16944:	.word	0x42008000
   16948:	.word	0x200209ac
   1694c:	.word	0x00000021
   16950:	.word	0x2005a400
   16954:	.word	0xe000e110
   16958:	.word	0x200208ac
   1695c:	.word	0x2002092c
   16960:	.word	0x2002082c
   16964:	.word	0x7ffffff0

00016968 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
   16968:	ldr	r2, [pc, #72]	; (169b4 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
   1696a:	ldr	r3, [pc, #76]	; (169b8 <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
   1696c:	ldr.w	r0, [r2, #544]	; 0x220
   16970:	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
   16974:	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
   16976:	push	{r4, lr}
   16978:	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
   1697a:	bhi.n	16982 <usb_init_serialnumber+0x1a>
   1697c:	add.w	r0, r0, r0, lsl #2
   16980:	lsls	r0, r0, #1
   16982:	ldr	r4, [pc, #56]	; (169bc <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
   16984:	add	r1, sp, #4
   16986:	movs	r2, #10
   16988:	bl	16aa0 <ultoa>
   1698c:	add	r1, sp, #4
	for (i=0; i<10; i++) {
   1698e:	movs	r3, #0
   16990:	mov	r0, r4
		char c = buf[i];
   16992:	ldrb.w	r2, [r1], #1
   16996:	adds	r3, #1
		if (!c) break;
   16998:	cbz	r2, 169aa <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
   1699a:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
   1699c:	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
   169a0:	bne.n	16992 <usb_init_serialnumber+0x2a>
   169a2:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
   169a4:	strb	r3, [r4, #0]
}
   169a6:	add	sp, #16
   169a8:	pop	{r4, pc}
   169aa:	lsls	r3, r3, #1
   169ac:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
   169ae:	strb	r3, [r4, #0]
}
   169b0:	add	sp, #16
   169b2:	pop	{r4, pc}
   169b4:	.word	0x401f4400
   169b8:	.word	0x0098967f
   169bc:	.word	0x20020a64

000169c0 <unused_interrupt_vector>:
//  R0
// Code from :: https://community.nxp.com/thread/389002
__attribute__((naked))
void unused_interrupt_vector(void)
{
  __asm( ".syntax unified\n"
   169c0:	movs	r0, #4
   169c2:	mov	r1, lr
   169c4:	tst	r0, r1
   169c6:	beq.n	169d0 <_MSP>
   169c8:	mrs	r0, PSP
   169cc:	b.w	169e0 <HardFault_HandlerC>

000169d0 <_MSP>:
   169d0:	mrs	r0, MSP
   169d4:	b.w	169e0 <HardFault_HandlerC>

000169d8 <startup_default_early_hook>:
         "B HardFault_HandlerC \n"
         "_MSP: \n"
         "MRS R0, MSP \n"
         "B HardFault_HandlerC \n"
         ".syntax divided\n") ;
}
   169d8:	bx	lr
   169da:	nop

000169dc <startup_default_late_hook>:
uint8_t external_psram_size = 0;

extern int main (void);
void startup_default_early_hook(void) {}
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
   169dc:	bx	lr
   169de:	nop

000169e0 <HardFault_HandlerC>:
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
   169e0:	ldr	r3, [pc, #108]	; (16a50 <HardFault_HandlerC+0x70>)
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
   169e2:	movs	r1, #5
   169e4:	ldr	r2, [pc, #108]	; (16a54 <HardFault_HandlerC+0x74>)
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
   169e6:	movs	r0, #56	; 0x38
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
   169e8:	push	{r4, r5, lr}
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
   169ea:	str.w	r1, [r2, #328]	; 0x148
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
  GPIO2_DR_SET = (1 << 3);
   169ee:	movs	r1, #8
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
   169f0:	str.w	r0, [r2, #824]	; 0x338
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
   169f4:	sub	sp, #12
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
   169f6:	ldr	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
   169f8:	ldr	r4, [pc, #92]	; (16a58 <HardFault_HandlerC+0x78>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
   169fa:	orrs	r2, r1
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
   169fc:	ldr	r0, [pc, #92]	; (16a5c <HardFault_HandlerC+0x7c>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
   169fe:	str	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
   16a00:	str.w	r1, [r3, #132]	; 0x84
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
   16a04:	str.w	r1, [r3, #136]	; 0x88

  if ( F_CPU_ACTUAL >= 600000000 )
   16a08:	ldr	r3, [r4, #0]
   16a0a:	cmp	r3, r0
   16a0c:	bls.n	16a14 <HardFault_HandlerC+0x34>
    set_arm_clock(300000000);
   16a0e:	ldr	r0, [pc, #80]	; (16a60 <HardFault_HandlerC+0x80>)
   16a10:	bl	156ac <set_arm_clock>

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
   16a14:	ldr	r5, [pc, #56]	; (16a50 <HardFault_HandlerC+0x70>)
   16a16:	movs	r4, #8
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
   16a18:	movs	r0, #0
   16a1a:	ldr	r2, [pc, #72]	; (16a64 <HardFault_HandlerC+0x84>)
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
   16a1c:	ldr	r1, [pc, #72]	; (16a68 <HardFault_HandlerC+0x88>)
  if ( F_CPU_ACTUAL >= 600000000 )
    set_arm_clock(300000000);

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
   16a1e:	str.w	r4, [r5, #132]	; 0x84
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
   16a22:	str	r0, [sp, #4]
   16a24:	ldr	r3, [sp, #4]
   16a26:	cmp	r3, r2
   16a28:	bhi.n	16a36 <HardFault_HandlerC+0x56>
   16a2a:	ldr	r3, [sp, #4]
   16a2c:	adds	r3, #1
   16a2e:	str	r3, [sp, #4]
   16a30:	ldr	r3, [sp, #4]
   16a32:	cmp	r3, r2
   16a34:	bls.n	16a2a <HardFault_HandlerC+0x4a>
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
   16a36:	str.w	r4, [r5, #136]	; 0x88
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
   16a3a:	str	r0, [sp, #4]
   16a3c:	ldr	r3, [sp, #4]
   16a3e:	cmp	r3, r1
   16a40:	bhi.n	16a1e <HardFault_HandlerC+0x3e>
   16a42:	ldr	r3, [sp, #4]
   16a44:	adds	r3, #1
   16a46:	str	r3, [sp, #4]
   16a48:	ldr	r3, [sp, #4]
   16a4a:	cmp	r3, r1
   16a4c:	bls.n	16a42 <HardFault_HandlerC+0x62>
   16a4e:	b.n	16a1e <HardFault_HandlerC+0x3e>
   16a50:	.word	0x401bc000
   16a54:	.word	0x401f8000
   16a58:	.word	0x20020828
   16a5c:	.word	0x23c345ff
   16a60:	.word	0x11e1a300
   16a64:	.word	0x000f423f
   16a68:	.word	0x0089543f

00016a6c <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
   16a6c:	ldr	r2, [pc, #36]	; (16a94 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
   16a6e:	push	{r3, lr}
        char *prev = __brkval;
   16a70:	ldr	r3, [r2, #0]
        if (incr != 0) {
   16a72:	cbz	r0, 16a7e <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
   16a74:	add	r0, r3
   16a76:	ldr	r1, [pc, #32]	; (16a98 <_sbrk+0x2c>)
   16a78:	cmp	r0, r1
   16a7a:	bhi.n	16a82 <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
   16a7c:	str	r0, [r2, #0]
        }
        return prev;
}
   16a7e:	mov	r0, r3
   16a80:	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
   16a82:	bl	1aa3c <__errno>
   16a86:	movs	r2, #12
                        return (void *)-1;
   16a88:	mov.w	r3, #4294967295
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
   16a8c:	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
   16a8e:	mov	r0, r3
   16a90:	pop	{r3, pc}
   16a92:	nop
   16a94:	.word	0x20020a7c
   16a98:	.word	0x20280000

00016a9c <__cxa_pure_virtual>:
}

__attribute__((weak))
void __cxa_pure_virtual()
{
	while (1) asm ("WFI");
   16a9c:	wfi
   16a9e:	b.n	16a9c <__cxa_pure_virtual>

00016aa0 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
   16aa0:	push	{r4, r5, r6, r7}
   16aa2:	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
   16aa4:	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
   16aa6:	mov	r7, r6
   16aa8:	b.n	16aac <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
   16aaa:	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
   16aac:	udiv	r3, r0, r2
   16ab0:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
   16ab4:	add.w	r4, r0, #55	; 0x37
   16ab8:	cmp	r0, #9
   16aba:	add.w	r0, r0, #48	; 0x30
   16abe:	uxtb	r4, r4
   16ac0:	it	ls
   16ac2:	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
   16ac4:	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
   16ac6:	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
   16aca:	cmp	r3, #0
   16acc:	bne.n	16aaa <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
   16ace:	adds	r2, r1, r5
   16ad0:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
   16ad2:	cbz	r5, 16ae8 <ultoa+0x48>
   16ad4:	adds	r3, #1
		t = buf[j];
   16ad6:	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
   16ada:	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
   16adc:	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
   16ade:	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
   16ae0:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
   16ae2:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
   16ae6:	blt.n	16ad4 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
   16ae8:	mov	r0, r1
   16aea:	pop	{r4, r5, r6, r7}
   16aec:	bx	lr
   16aee:	nop

00016af0 <Panic_Temp_isr>:

static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
   16af0:	cpsid	i
  IOMUXC_GPR_GPR16 = 0x00000007;
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
   16af2:	ldr	r2, [pc, #24]	; (16b0c <Panic_Temp_isr+0x1c>)
static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
  IOMUXC_GPR_GPR16 = 0x00000007;
   16af4:	movs	r1, #7
   16af6:	ldr	r3, [pc, #24]	; (16b10 <Panic_Temp_isr+0x20>)
   16af8:	str	r1, [r3, #64]	; 0x40
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
   16afa:	ldr	r3, [r2, #56]	; 0x38
   16afc:	orr.w	r3, r3, #64	; 0x40
   16b00:	str	r3, [r2, #56]	; 0x38
  asm volatile ("dsb":::"memory");
   16b02:	dsb	sy
  while (1) asm ("wfi");
   16b06:	wfi
   16b08:	b.n	16b06 <Panic_Temp_isr+0x16>
   16b0a:	nop
   16b0c:	.word	0x400d4000
   16b10:	.word	0x400ac000

00016b14 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
   16b14:	lsls	r0, r0, #4
   16b16:	ldr	r3, [pc, #60]	; (16b54 <digitalWrite.part.0+0x40>)
   16b18:	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
   16b1a:	ldr	r3, [r3, r0]
	{&CORE_PIN53_PORTREG, &CORE_PIN53_CONFIG, &CORE_PIN53_PADCONFIG, CORE_PIN53_BITMASK},
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
   16b1c:	push	{r4}
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
	mask = p->mask;
   16b1e:	ldr	r0, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
   16b20:	ldr	r4, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
   16b22:	tst	r4, r0
   16b24:	beq.n	16b32 <digitalWrite.part.0+0x1e>
		// pin is configured for output mode
		if (val) {
   16b26:	cbz	r1, 16b40 <digitalWrite.part.0+0x2c>
			*(p->reg + 0x21) = mask; // set register
   16b28:	str.w	r0, [r3, #132]	; 0x84
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
   16b2c:	ldr.w	r4, [sp], #4
   16b30:	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
   16b32:	ldr	r3, [r2, #8]
			*(p->reg + 0x22) = mask; // clear register
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
   16b34:	cbnz	r1, 16b4a <digitalWrite.part.0+0x36>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
   16b36:	ldr	r2, [pc, #32]	; (16b58 <digitalWrite.part.0+0x44>)
		}
	}
}
   16b38:	ldr.w	r4, [sp], #4
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
   16b3c:	str	r2, [r3, #0]
		}
	}
}
   16b3e:	bx	lr
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
   16b40:	str.w	r0, [r3, #136]	; 0x88
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
   16b44:	ldr.w	r4, [sp], #4
   16b48:	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
   16b4a:	ldr	r2, [pc, #16]	; (16b5c <digitalWrite.part.0+0x48>)
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
   16b4c:	ldr.w	r4, [sp], #4
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
   16b50:	str	r2, [r3, #0]
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
   16b52:	bx	lr
   16b54:	.word	0x2001fbd8
   16b58:	.word	0x00013038
   16b5c:	.word	0x0001f038

00016b60 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
   16b60:	cmp	r0, #39	; 0x27
   16b62:	bhi.n	16b68 <digitalWrite+0x8>
   16b64:	b.w	16b14 <digitalWrite.part.0>
   16b68:	bx	lr
   16b6a:	nop

00016b6c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
   16b6c:	cmp	r0, #39	; 0x27
   16b6e:	bhi.n	16baa <pinMode+0x3e>
	p = digital_pin_to_info_PGM + pin;
   16b70:	lsls	r0, r0, #4
   16b72:	ldr	r2, [pc, #104]	; (16bdc <pinMode+0x70>)
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
   16b74:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
   16b76:	add.w	r3, r2, r0
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
   16b7a:	ldr	r0, [r2, r0]
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}

void pinMode(uint8_t pin, uint8_t mode)
{
   16b7c:	push	{r4}
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
   16b7e:	beq.n	16bac <pinMode+0x40>
   16b80:	cmp	r1, #4
   16b82:	beq.n	16bac <pinMode+0x40>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
   16b84:	ldr	r4, [r3, #12]
   16b86:	ldr	r2, [r0, #4]
   16b88:	bic.w	r2, r2, r4
   16b8c:	str	r2, [r0, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
   16b8e:	ldr	r2, [r3, #8]
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
   16b90:	cbz	r1, 16bce <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
   16b92:	cmp	r1, #2
   16b94:	beq.n	16bd4 <pinMode+0x68>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
   16b96:	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
   16b98:	ldr	r3, [r3, #4]
}
   16b9a:	ldr.w	r4, [sp], #4
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
   16b9e:	ite	eq
   16ba0:	ldreq	r1, [pc, #60]	; (16be0 <pinMode+0x74>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
   16ba2:	ldrne	r1, [pc, #64]	; (16be4 <pinMode+0x78>)
   16ba4:	str	r1, [r2, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
   16ba6:	movs	r2, #21
   16ba8:	str	r2, [r3, #0]
}
   16baa:	bx	lr
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
   16bac:	ldr	r2, [r3, #12]
		if (mode == OUTPUT) {
   16bae:	cmp	r1, #1
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
   16bb0:	ldr	r4, [r0, #4]
   16bb2:	orr.w	r2, r2, r4
   16bb6:	str	r2, [r0, #4]
		if (mode == OUTPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
   16bb8:	ldr	r2, [r3, #8]

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
		if (mode == OUTPUT) {
   16bba:	beq.n	16bce <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
   16bbc:	movw	r1, #2104	; 0x838
   16bc0:	str	r1, [r2, #0]
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
   16bc2:	ldr	r3, [r3, #4]
   16bc4:	movs	r2, #21
}
   16bc6:	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
   16bca:	str	r2, [r3, #0]
}
   16bcc:	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
   16bce:	movs	r1, #56	; 0x38
   16bd0:	str	r1, [r2, #0]
   16bd2:	b.n	16bc2 <pinMode+0x56>
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
   16bd4:	ldr	r1, [pc, #16]	; (16be8 <pinMode+0x7c>)
   16bd6:	str	r1, [r2, #0]
   16bd8:	b.n	16bc2 <pinMode+0x56>
   16bda:	nop
   16bdc:	.word	0x2001fbd8
   16be0:	.word	0x00013038
   16be4:	.word	0x00010038
   16be8:	.word	0x0001f038

00016bec <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
   16bec:	ldr	r0, [pc, #656]	; (16e80 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16bee:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16bf2:	ldr	r3, [pc, #656]	; (16e84 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
   16bf4:	ldr	r2, [r0, #120]	; 0x78
   16bf6:	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
   16bfa:	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
   16bfc:	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
   16bfe:	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
   16c00:	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16c04:	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
   16c08:	ldr	r4, [pc, #636]	; (16e88 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16c0a:	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16c0e:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16c10:	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
   16c14:	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16c16:	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
   16c18:	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16c1c:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
   16c20:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16c24:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
   16c28:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
   16c2c:	ldrh.w	r0, [r3, #392]	; 0x188
   16c30:	uxth	r0, r0
   16c32:	orr.w	r0, r0, #240	; 0xf0
   16c36:	strh.w	r0, [r3, #392]	; 0x188
   16c3a:	add.w	r0, r1, r1, lsl #1
   16c3e:	ldr	r3, [pc, #580]	; (16e84 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
   16c40:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16c42:	movs	r5, #0
   16c44:	lsls	r0, r0, #5
   16c46:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16c48:	cmp	r1, #4
   16c4a:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16c4c:	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16c50:	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
   16c52:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
   16c54:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
   16c56:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
   16c58:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
   16c5a:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
   16c5c:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
   16c5e:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
   16c60:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
   16c62:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16c64:	bne.n	16c3a <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16c66:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16c6a:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16c6e:	ldr	r3, [pc, #540]	; (16e8c <pwm_init+0x2a0>)
   16c70:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16c74:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16c76:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16c78:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16c7c:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16c7e:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16c82:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16c86:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
   16c8a:	ldrh.w	r0, [r4, #392]	; 0x188
   16c8e:	uxth	r0, r0
   16c90:	orr.w	r0, r0, #3840	; 0xf00
   16c94:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16c98:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
   16c9c:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16ca0:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
   16ca4:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
   16ca8:	ldrh.w	r0, [r3, #392]	; 0x188
   16cac:	uxth	r0, r0
   16cae:	orr.w	r0, r0, #240	; 0xf0
   16cb2:	strh.w	r0, [r3, #392]	; 0x188
   16cb6:	add.w	r0, r1, r1, lsl #1
   16cba:	ldr	r3, [pc, #464]	; (16e8c <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
   16cbc:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16cbe:	movs	r5, #0
   16cc0:	lsls	r0, r0, #5
   16cc2:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16cc4:	cmp	r1, #4
   16cc6:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16cc8:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16cca:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
   16cce:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
   16cd0:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
   16cd2:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
   16cd4:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
   16cd6:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
   16cd8:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
   16cda:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
   16cdc:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
   16cde:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16ce0:	bne.n	16cb6 <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16ce2:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16ce6:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16cea:	ldr	r3, [pc, #420]	; (16e90 <pwm_init+0x2a4>)
   16cec:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16cf0:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16cf2:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16cf4:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16cf8:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16cfa:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16cfe:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16d02:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
   16d06:	ldrh.w	r0, [r4, #392]	; 0x188
   16d0a:	uxth	r0, r0
   16d0c:	orr.w	r0, r0, #3840	; 0xf00
   16d10:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16d14:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
   16d18:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16d1c:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
   16d20:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
   16d24:	ldrh.w	r0, [r3, #392]	; 0x188
   16d28:	uxth	r0, r0
   16d2a:	orr.w	r0, r0, #240	; 0xf0
   16d2e:	strh.w	r0, [r3, #392]	; 0x188
   16d32:	add.w	r0, r1, r1, lsl #1
   16d36:	ldr	r3, [pc, #344]	; (16e90 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
   16d38:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16d3a:	movs	r5, #0
   16d3c:	lsls	r0, r0, #5
   16d3e:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16d40:	cmp	r1, #4
   16d42:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16d44:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16d46:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
   16d4a:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
   16d4c:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
   16d4e:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
   16d50:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
   16d52:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
   16d54:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
   16d56:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
   16d58:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
   16d5a:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16d5c:	bne.n	16d32 <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16d5e:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16d62:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16d66:	ldr	r3, [pc, #300]	; (16e94 <pwm_init+0x2a8>)
   16d68:	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16d6c:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16d6e:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16d70:	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
   16d74:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16d76:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16d7a:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16d7e:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
   16d82:	ldrh.w	r0, [r4, #392]	; 0x188
   16d86:	uxth	r0, r0
   16d88:	orr.w	r0, r0, #3840	; 0xf00
   16d8c:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
   16d90:	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
   16d94:	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
   16d98:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
   16d9c:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
   16da0:	ldrh.w	r0, [r3, #392]	; 0x188
   16da4:	uxth	r0, r0
   16da6:	orr.w	r0, r0, #240	; 0xf0
   16daa:	strh.w	r0, [r3, #392]	; 0x188
   16dae:	add.w	r0, r1, r1, lsl #1
   16db2:	ldr	r3, [pc, #224]	; (16e94 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
   16db4:	adds	r1, #1
   16db6:	lsls	r0, r0, #5
   16db8:	mov	r4, r3
   16dba:	cmp	r1, #4
   16dbc:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
   16dbe:	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
   16dc0:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
   16dc4:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
   16dc6:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
   16dc8:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
   16dca:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
   16dcc:	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
   16dce:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
   16dd0:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
   16dd2:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
   16dd4:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
   16dd6:	bne.n	16dae <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16dd8:	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
   16ddc:	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16dde:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
   16de0:	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16de4:	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
   16de6:	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
   16dea:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
   16dec:	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
   16df0:	orrs	r3, r7
   16df2:	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
   16df6:	ldrh.w	r3, [r4, #392]	; 0x188
   16dfa:	uxth	r3, r3
   16dfc:	orr.w	r3, r3, #3840	; 0xf00
   16e00:	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
   16e04:	lsls	r0, r2, #5
   16e06:	ldr	r3, [pc, #144]	; (16e98 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e08:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
   16e0a:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e0c:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
   16e0e:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
   16e10:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
   16e12:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
   16e14:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
   16e16:	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
   16e1a:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
   16e1c:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
   16e1e:	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e20:	bne.n	16e04 <pwm_init+0x218>
   16e22:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
   16e24:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
   16e26:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
   16e2a:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
   16e2e:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
   16e30:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
   16e34:	lsls	r0, r2, #5
   16e36:	ldr	r3, [pc, #100]	; (16e9c <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e38:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
   16e3a:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e3c:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
   16e3e:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
   16e40:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
   16e42:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
   16e44:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
   16e46:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
   16e48:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
   16e4a:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
   16e4c:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e4e:	bne.n	16e34 <pwm_init+0x248>
   16e50:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
   16e52:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
   16e54:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
   16e58:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
   16e5c:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
   16e5e:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
   16e62:	lsls	r0, r2, #5
   16e64:	ldr	r3, [pc, #56]	; (16ea0 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e66:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
   16e68:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e6a:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
   16e6c:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
   16e6e:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
   16e70:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
   16e72:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
   16e74:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
   16e76:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
   16e78:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
   16e7a:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
   16e7c:	bne.n	16e62 <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
   16e7e:	pop	{r4, r5, r6, r7, pc}
   16e80:	.word	0x400fc000
   16e84:	.word	0x403dc000
   16e88:	.word	0xfc030000
   16e8c:	.word	0x403e0000
   16e90:	.word	0x403e4000
   16e94:	.word	0x403e8000
   16e98:	.word	0x401dc000
   16e9c:	.word	0x401e0000
   16ea0:	.word	0x401e4000

00016ea4 <sysex_byte>:
                usb_midi_write_packed(0x05 | cable | (0xF7 << 8));
	}
}

void static sysex_byte(uint8_t b)
{
   16ea4:	push	{r3, r4, r5, lr}
	if (usb_midi_handleSysExPartial && usb_midi_msg_sysex_len >= USB_MIDI_SYSEX_MAX) {
   16ea6:	ldr	r3, [pc, #56]	; (16ee0 <sysex_byte+0x3c>)
                usb_midi_write_packed(0x05 | cable | (0xF7 << 8));
	}
}

void static sysex_byte(uint8_t b)
{
   16ea8:	mov	r5, r0
	if (usb_midi_handleSysExPartial && usb_midi_msg_sysex_len >= USB_MIDI_SYSEX_MAX) {
   16eaa:	ldr	r4, [pc, #56]	; (16ee4 <sysex_byte+0x40>)
   16eac:	ldr	r3, [r3, #0]
   16eae:	ldrh	r1, [r4, #0]
   16eb0:	cbz	r3, 16ed6 <sysex_byte+0x32>
   16eb2:	cmp.w	r1, #290	; 0x122
   16eb6:	bcs.n	16ec4 <sysex_byte+0x20>
   16eb8:	adds	r3, r1, #1
		// when buffer is full, send another chunk to partial handler.
		(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, usb_midi_msg_sysex_len, 0);
		usb_midi_msg_sysex_len = 0;
	}
	if (usb_midi_msg_sysex_len < USB_MIDI_SYSEX_MAX) {
		usb_midi_msg_sysex[usb_midi_msg_sysex_len++] = b;
   16eba:	ldr	r2, [pc, #44]	; (16ee8 <sysex_byte+0x44>)
   16ebc:	uxth	r3, r3
   16ebe:	strb	r5, [r2, r1]
   16ec0:	strh	r3, [r4, #0]
	}
}
   16ec2:	pop	{r3, r4, r5, pc}

void static sysex_byte(uint8_t b)
{
	if (usb_midi_handleSysExPartial && usb_midi_msg_sysex_len >= USB_MIDI_SYSEX_MAX) {
		// when buffer is full, send another chunk to partial handler.
		(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, usb_midi_msg_sysex_len, 0);
   16ec4:	movs	r2, #0
   16ec6:	ldr	r0, [pc, #32]	; (16ee8 <sysex_byte+0x44>)
   16ec8:	blx	r3
   16eca:	movs	r1, #0
   16ecc:	movs	r3, #1
		usb_midi_msg_sysex_len = 0;
	}
	if (usb_midi_msg_sysex_len < USB_MIDI_SYSEX_MAX) {
		usb_midi_msg_sysex[usb_midi_msg_sysex_len++] = b;
   16ece:	ldr	r2, [pc, #24]	; (16ee8 <sysex_byte+0x44>)
   16ed0:	strh	r3, [r4, #0]
   16ed2:	strb	r5, [r2, r1]
	}
}
   16ed4:	pop	{r3, r4, r5, pc}
	if (usb_midi_handleSysExPartial && usb_midi_msg_sysex_len >= USB_MIDI_SYSEX_MAX) {
		// when buffer is full, send another chunk to partial handler.
		(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, usb_midi_msg_sysex_len, 0);
		usb_midi_msg_sysex_len = 0;
	}
	if (usb_midi_msg_sysex_len < USB_MIDI_SYSEX_MAX) {
   16ed6:	cmp.w	r1, #290	; 0x122
   16eda:	bcc.n	16eb8 <sysex_byte+0x14>
   16edc:	pop	{r3, r4, r5, pc}
   16ede:	nop
   16ee0:	.word	0x20058578
   16ee4:	.word	0x2005a6c2
   16ee8:	.word	0x2005a6c8

00016eec <rx_queue_transfer>:




static void rx_queue_transfer(int i)
{
   16eec:	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * MIDI_RX_SIZE_480;
   16eee:	ldr	r1, [pc, #80]	; (16f40 <rx_queue_transfer+0x54>)



static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
   16ef0:	mov.w	r7, #131072	; 0x20000
	void *buffer = rx_buffer + i * MIDI_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
   16ef4:	ldr	r5, [pc, #76]	; (16f44 <rx_queue_transfer+0x58>)




static void rx_queue_transfer(int i)
{
   16ef6:	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	void *buffer = rx_buffer + i * MIDI_RX_SIZE_480;
   16ef8:	add.w	r4, r1, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
   16efc:	ldr	r6, [pc, #72]	; (16f48 <rx_queue_transfer+0x5c>)



static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
   16efe:	ldr	r2, [pc, #76]	; (16f4c <rx_queue_transfer+0x60>)
	void *buffer = rx_buffer + i * MIDI_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
   16f00:	add.w	r5, r5, r0, lsl #5
   16f04:	mov	r1, r4



static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
   16f06:	str	r7, [r2, #0]
	void *buffer = rx_buffer + i * MIDI_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
   16f08:	mov	r0, r5
   16f0a:	ldrh	r2, [r6, #0]
   16f0c:	bl	161c4 <usb_prepare_transfer>
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
   16f10:	ldrh	r1, [r6, #0]
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
   16f12:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
   16f16:	add	r1, r4
	asm volatile("": : :"memory");
	asm("dsb");
   16f18:	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
   16f1c:	ldr	r2, [pc, #48]	; (16f50 <rx_queue_transfer+0x64>)
   16f1e:	str	r3, [r2, #0]
		location += 32;
   16f20:	adds	r3, #32
	} while (location < end_addr);
   16f22:	cmp	r1, r3
   16f24:	bhi.n	16f1e <rx_queue_transfer+0x32>
	asm("dsb");
   16f26:	dsb	sy
	asm("isb");
   16f2a:	isb	sy
	arm_dcache_delete(buffer, rx_packet_size);
	usb_receive(MIDI_RX_ENDPOINT, rx_transfer + i);
   16f2e:	movs	r0, #3
   16f30:	mov	r1, r5
   16f32:	bl	1621c <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
   16f36:	ldr	r3, [pc, #28]	; (16f54 <rx_queue_transfer+0x68>)
   16f38:	mov.w	r2, #131072	; 0x20000
   16f3c:	str	r2, [r3, #0]
   16f3e:	pop	{r3, r4, r5, r6, r7, pc}
   16f40:	.word	0x202008a0
   16f44:	.word	0x200585c0
   16f48:	.word	0x2005856c
   16f4c:	.word	0xe000e18c
   16f50:	.word	0xe000ef5c
   16f54:	.word	0xe000e10c

00016f58 <rx_event>:


// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
   16f58:	ldr	r2, [r0, #4]
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
   16f5a:	movw	r3, #65532	; 0xfffc


// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
   16f5e:	ldr	r1, [pc, #68]	; (16fa4 <rx_event+0x4c>)
   16f60:	ubfx	r2, r2, #16, #15
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
	int i = t->callback_param;
   16f64:	ldr	r0, [r0, #28]


// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
   16f66:	ldrh	r1, [r1, #0]
   16f68:	subs	r2, r1, r2
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
   16f6a:	ands	r3, r2
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
   16f6c:	cbz	r3, 16f9e <rx_event+0x46>
		uint32_t head = rx_head;
		rx_count[i] = len;
		rx_index[i] = 0;
   16f6e:	movs	r1, #0



// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
   16f70:	push	{r4, r5, r6}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		uint32_t head = rx_head;
   16f72:	ldr	r5, [pc, #52]	; (16fa8 <rx_event+0x50>)
		rx_count[i] = len;
		rx_index[i] = 0;
   16f74:	ldr	r4, [pc, #52]	; (16fac <rx_event+0x54>)
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		uint32_t head = rx_head;
   16f76:	ldrb	r2, [r5, #0]
		rx_count[i] = len;
		rx_index[i] = 0;
   16f78:	strh.w	r1, [r4, r0, lsl #1]
		if (++head > RX_NUM) head = 0;
   16f7c:	adds	r2, #1
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
   16f7e:	ldr	r4, [pc, #48]	; (16fb0 <rx_event+0x58>)
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		uint32_t head = rx_head;
		rx_count[i] = len;
   16f80:	ldr	r6, [pc, #48]	; (16fb4 <rx_event+0x5c>)
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
   16f82:	cmp	r2, #6
	len &= 0xFFFC; // MIDI packets must be multiple of 4 bytes
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		uint32_t head = rx_head;
		rx_count[i] = len;
   16f84:	strh.w	r3, [r6, r0, lsl #1]
   16f88:	ite	ls
   16f8a:	uxtbls	r1, r2
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
   16f8c:	movhi	r2, r1
		rx_list[head] = i;
		rx_head = head;
   16f8e:	strb	r1, [r5, #0]
		rx_available += len;
   16f90:	ldr	r1, [r4, #0]
	if (len > 0) {
		uint32_t head = rx_head;
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
   16f92:	ldr	r5, [pc, #36]	; (16fb8 <rx_event+0x60>)
		rx_head = head;
		rx_available += len;
   16f94:	add	r3, r1
	if (len > 0) {
		uint32_t head = rx_head;
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
   16f96:	strb	r0, [r5, r2]
		rx_head = head;
		rx_available += len;
   16f98:	str	r3, [r4, #0]
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
   16f9a:	pop	{r4, r5, r6}
   16f9c:	bx	lr
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
   16f9e:	b.w	16eec <rx_queue_transfer>
   16fa2:	nop
   16fa4:	.word	0x2005856c
   16fa8:	.word	0x20058598
   16fac:	.word	0x20058688
   16fb0:	.word	0x20058684
   16fb4:	.word	0x200585a4
   16fb8:	.word	0x20058730

00016fbc <usb_midi_configure>:
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_midi_configure(void)
{
   16fbc:	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_midi_configure\n");
	if (usb_high_speed) {
   16fbe:	ldr	r3, [pc, #148]	; (17054 <usb_midi_configure+0x98>)
   16fc0:	ldrb	r3, [r3, #0]
   16fc2:	cmp	r3, #0
   16fc4:	beq.n	17044 <usb_midi_configure+0x88>
		tx_packet_size = MIDI_TX_SIZE_480;
   16fc6:	mov.w	r3, #512	; 0x200
   16fca:	ldr	r7, [pc, #140]	; (17058 <usb_midi_configure+0x9c>)
		rx_packet_size = MIDI_RX_SIZE_480;
   16fcc:	ldr	r2, [pc, #140]	; (1705c <usb_midi_configure+0xa0>)
   16fce:	mov	r6, r3

void usb_midi_configure(void)
{
	printf("usb_midi_configure\n");
	if (usb_high_speed) {
		tx_packet_size = MIDI_TX_SIZE_480;
   16fd0:	strh	r3, [r7, #0]
		rx_packet_size = MIDI_RX_SIZE_480;
   16fd2:	strh	r3, [r2, #0]
	} else {
		tx_packet_size = MIDI_TX_SIZE_12;
		rx_packet_size = MIDI_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
   16fd4:	movs	r1, #0
   16fd6:	movs	r2, #128	; 0x80
   16fd8:	ldr	r0, [pc, #132]	; (17060 <usb_midi_configure+0xa4>)
	tx_head = 0;
   16fda:	mov	r5, r1
   16fdc:	ldr	r4, [pc, #132]	; (17064 <usb_midi_configure+0xa8>)
		rx_packet_size = MIDI_RX_SIZE_480;
	} else {
		tx_packet_size = MIDI_TX_SIZE_12;
		rx_packet_size = MIDI_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
   16fde:	bl	1b018 <memset>
	tx_head = 0;
	tx_available = 0;
   16fe2:	ldr	r3, [pc, #132]	; (17068 <usb_midi_configure+0xac>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
   16fe4:	mov	r1, r5
   16fe6:	movs	r2, #192	; 0xc0
   16fe8:	ldr	r0, [pc, #128]	; (1706c <usb_midi_configure+0xb0>)
	} else {
		tx_packet_size = MIDI_TX_SIZE_12;
		rx_packet_size = MIDI_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
   16fea:	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
	usb_config_tx(MIDI_TX_ENDPOINT, tx_packet_size, 0, NULL); // TODO: is ZLP needed?
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
   16fec:	mov	r4, r5
		tx_packet_size = MIDI_TX_SIZE_12;
		rx_packet_size = MIDI_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
   16fee:	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
   16ff0:	bl	1b018 <memset>
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
   16ff4:	mov	r1, r6
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
   16ff6:	ldr.w	lr, [pc, #148]	; 1708c <usb_midi_configure+0xd0>
	rx_tail = 0;
   16ffa:	ldr	r3, [pc, #116]	; (17070 <usb_midi_configure+0xb4>)
	rx_available = 0;
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
   16ffc:	mov	r2, r5
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
   16ffe:	ldr	r6, [pc, #116]	; (17074 <usb_midi_configure+0xb8>)
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
   17000:	movs	r0, #3
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
   17002:	strb.w	r5, [lr]
	rx_tail = 0;
   17006:	strb	r5, [r3, #0]
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
   17008:	ldr	r3, [pc, #108]	; (17078 <usb_midi_configure+0xbc>)
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
   1700a:	str	r5, [r6, #0]
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
   1700c:	ldr	r6, [pc, #108]	; (1707c <usb_midi_configure+0xc0>)
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
   1700e:	str	r5, [r3, #0]
   17010:	str	r5, [r3, #4]
   17012:	str	r5, [r3, #8]
	memset(rx_index, 0, sizeof(rx_index));
   17014:	str	r5, [r6, #0]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
   17016:	ldr	r3, [pc, #104]	; (17080 <usb_midi_configure+0xc4>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
   17018:	str	r5, [r6, #4]
   1701a:	str	r5, [r6, #8]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
   1701c:	bl	160f8 <usb_config_rx>
	usb_config_tx(MIDI_TX_ENDPOINT, tx_packet_size, 0, NULL); // TODO: is ZLP needed?
   17020:	mov	r3, r5
   17022:	mov	r2, r5
   17024:	ldrh	r1, [r7, #0]
   17026:	movs	r0, #3
   17028:	bl	1615c <usb_config_tx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
   1702c:	mov	r0, r4
   1702e:	adds	r4, #1
   17030:	bl	16eec <rx_queue_transfer>
   17034:	cmp	r4, #6
   17036:	bne.n	1702c <usb_midi_configure+0x70>
	transmit_previous_timeout = 0;
   17038:	movs	r3, #0
   1703a:	ldr	r1, [pc, #72]	; (17084 <usb_midi_configure+0xc8>)
	tx_noautoflush = 0;
   1703c:	ldr	r2, [pc, #72]	; (17088 <usb_midi_configure+0xcc>)
	rx_available = 0;
	usb_config_rx(MIDI_RX_ENDPOINT, rx_packet_size, 0, rx_event);
	usb_config_tx(MIDI_TX_ENDPOINT, tx_packet_size, 0, NULL); // TODO: is ZLP needed?
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
	transmit_previous_timeout = 0;
   1703e:	strb	r3, [r1, #0]
	tx_noautoflush = 0;
   17040:	strb	r3, [r2, #0]
   17042:	pop	{r3, r4, r5, r6, r7, pc}
	printf("usb_midi_configure\n");
	if (usb_high_speed) {
		tx_packet_size = MIDI_TX_SIZE_480;
		rx_packet_size = MIDI_RX_SIZE_480;
	} else {
		tx_packet_size = MIDI_TX_SIZE_12;
   17044:	movs	r3, #64	; 0x40
		rx_packet_size = MIDI_RX_SIZE_12;
   17046:	ldr	r2, [pc, #20]	; (1705c <usb_midi_configure+0xa0>)
	printf("usb_midi_configure\n");
	if (usb_high_speed) {
		tx_packet_size = MIDI_TX_SIZE_480;
		rx_packet_size = MIDI_RX_SIZE_480;
	} else {
		tx_packet_size = MIDI_TX_SIZE_12;
   17048:	ldr	r7, [pc, #12]	; (17058 <usb_midi_configure+0x9c>)
		rx_packet_size = MIDI_RX_SIZE_12;
   1704a:	mov	r6, r3
   1704c:	strh	r3, [r2, #0]
	printf("usb_midi_configure\n");
	if (usb_high_speed) {
		tx_packet_size = MIDI_TX_SIZE_480;
		rx_packet_size = MIDI_RX_SIZE_480;
	} else {
		tx_packet_size = MIDI_TX_SIZE_12;
   1704e:	strh	r3, [r7, #0]
   17050:	b.n	16fd4 <usb_midi_configure+0x18>
   17052:	nop
   17054:	.word	0x2005823c
   17058:	.word	0x20058584
   1705c:	.word	0x2005856c
   17060:	.word	0x200586a0
   17064:	.word	0x20058728
   17068:	.word	0x2005856e
   1706c:	.word	0x200585c0
   17070:	.word	0x2005859a
   17074:	.word	0x20058684
   17078:	.word	0x200585a4
   1707c:	.word	0x20058688
   17080:	.word	0x00016f59
   17084:	.word	0x2005859b
   17088:	.word	0x20058599
   1708c:	.word	0x20058598

00017090 <usb_midi_flush_output>:
	}
	tx_noautoflush = 0;
}

void usb_midi_flush_output(void)
{
   17090:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	//printf("usb_midi_flush_output\n");
	if (tx_noautoflush == 0 && tx_available > 0) {
   17094:	ldr	r3, [pc, #120]	; (17110 <usb_midi_flush_output+0x80>)
   17096:	ldrb	r5, [r3, #0]
   17098:	cbnz	r5, 170a0 <usb_midi_flush_output+0x10>
   1709a:	ldr	r7, [pc, #120]	; (17114 <usb_midi_flush_output+0x84>)
   1709c:	ldrh	r2, [r7, #0]
   1709e:	cbnz	r2, 170a4 <usb_midi_flush_output+0x14>
   170a0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		printf(" tx, %d %d\n", tx_packet_size, tx_available);
		uint32_t head = tx_head;
   170a4:	ldr.w	r9, [pc, #128]	; 17128 <usb_midi_flush_output+0x98>
		transfer_t *xfer = tx_transfer + head;
		uint8_t *txbuf = txbuffer + (head * TX_SIZE);
		uint32_t len = tx_packet_size - tx_available;
		usb_prepare_transfer(xfer, txbuf, len, 0);
   170a8:	mov	r3, r5
{
	//printf("usb_midi_flush_output\n");
	if (tx_noautoflush == 0 && tx_available > 0) {
		printf(" tx, %d %d\n", tx_packet_size, tx_available);
		uint32_t head = tx_head;
		transfer_t *xfer = tx_transfer + head;
   170aa:	ldr	r4, [pc, #108]	; (17118 <usb_midi_flush_output+0x88>)
void usb_midi_flush_output(void)
{
	//printf("usb_midi_flush_output\n");
	if (tx_noautoflush == 0 && tx_available > 0) {
		printf(" tx, %d %d\n", tx_packet_size, tx_available);
		uint32_t head = tx_head;
   170ac:	ldrb.w	r6, [r9]
		transfer_t *xfer = tx_transfer + head;
		uint8_t *txbuf = txbuffer + (head * TX_SIZE);
   170b0:	ldr	r1, [pc, #104]	; (1711c <usb_midi_flush_output+0x8c>)
		uint32_t len = tx_packet_size - tx_available;
   170b2:	ldr	r0, [pc, #108]	; (17120 <usb_midi_flush_output+0x90>)
{
	//printf("usb_midi_flush_output\n");
	if (tx_noautoflush == 0 && tx_available > 0) {
		printf(" tx, %d %d\n", tx_packet_size, tx_available);
		uint32_t head = tx_head;
		transfer_t *xfer = tx_transfer + head;
   170b4:	add.w	r8, r4, r6, lsl #5
		uint8_t *txbuf = txbuffer + (head * TX_SIZE);
   170b8:	add.w	r4, r1, r6, lsl #9
		uint32_t len = tx_packet_size - tx_available;
		usb_prepare_transfer(xfer, txbuf, len, 0);
   170bc:	ldrh.w	lr, [r0]
   170c0:	mov	r0, r8
   170c2:	mov	r1, r4
   170c4:	rsb	r2, r2, lr
   170c8:	bl	161c4 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
   170cc:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
   170d0:	add.w	r1, r4, #512	; 0x200
	asm volatile("": : :"memory");
	asm("dsb");
   170d4:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
   170d8:	ldr	r2, [pc, #72]	; (17124 <usb_midi_flush_output+0x94>)
   170da:	str	r3, [r2, #0]
		location += 32;
   170dc:	adds	r3, #32
	} while (location < end_addr);
   170de:	cmp	r1, r3
   170e0:	bhi.n	170da <usb_midi_flush_output+0x4a>
	asm("dsb");
   170e2:	dsb	sy
	asm("isb");
   170e6:	isb	sy
		arm_dcache_flush_delete(txbuf, TX_SIZE);
		usb_transmit(MIDI_TX_ENDPOINT, xfer);
		if (++head >= TX_NUM) head = 0;
   170ea:	adds	r6, #1
		transfer_t *xfer = tx_transfer + head;
		uint8_t *txbuf = txbuffer + (head * TX_SIZE);
		uint32_t len = tx_packet_size - tx_available;
		usb_prepare_transfer(xfer, txbuf, len, 0);
		arm_dcache_flush_delete(txbuf, TX_SIZE);
		usb_transmit(MIDI_TX_ENDPOINT, xfer);
   170ec:	movs	r0, #3
   170ee:	mov	r1, r8
   170f0:	bl	161f4 <usb_transmit>
		if (++head >= TX_NUM) head = 0;
   170f4:	cmp	r6, #3
		tx_head = head;
		tx_available = 0;
   170f6:	mov.w	r3, #0
   170fa:	it	ls
   170fc:	uxtbls	r5, r6
		usb_stop_sof_interrupts(MIDI_INTERFACE);
   170fe:	mov	r0, r3
		usb_prepare_transfer(xfer, txbuf, len, 0);
		arm_dcache_flush_delete(txbuf, TX_SIZE);
		usb_transmit(MIDI_TX_ENDPOINT, xfer);
		if (++head >= TX_NUM) head = 0;
		tx_head = head;
		tx_available = 0;
   17100:	strh	r3, [r7, #0]
		uint32_t len = tx_packet_size - tx_available;
		usb_prepare_transfer(xfer, txbuf, len, 0);
		arm_dcache_flush_delete(txbuf, TX_SIZE);
		usb_transmit(MIDI_TX_ENDPOINT, xfer);
		if (++head >= TX_NUM) head = 0;
		tx_head = head;
   17102:	strb.w	r5, [r9]
		tx_available = 0;
		usb_stop_sof_interrupts(MIDI_INTERFACE);
	}
}
   17106:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		arm_dcache_flush_delete(txbuf, TX_SIZE);
		usb_transmit(MIDI_TX_ENDPOINT, xfer);
		if (++head >= TX_NUM) head = 0;
		tx_head = head;
		tx_available = 0;
		usb_stop_sof_interrupts(MIDI_INTERFACE);
   1710a:	b.w	160cc <usb_stop_sof_interrupts>
   1710e:	nop
   17110:	.word	0x20058599
   17114:	.word	0x2005856e
   17118:	.word	0x200586a0
   1711c:	.word	0x202014a0
   17120:	.word	0x20058584
   17124:	.word	0xe000ef70
   17128:	.word	0x20058728

0001712c <usb_midi_read_message>:
{
	return rx_available / 4;
}

uint32_t usb_midi_read_message(void)
{
   1712c:	push	{r3, r4, r5, r6, r7, lr}
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
   1712e:	mov.w	r2, #131072	; 0x20000
   17132:	ldr	r3, [pc, #100]	; (17198 <usb_midi_read_message+0x6c>)
	uint32_t tail = rx_tail;
   17134:	ldr	r6, [pc, #100]	; (1719c <usb_midi_read_message+0x70>)
}

uint32_t usb_midi_read_message(void)
{
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
   17136:	str	r2, [r3, #0]
	uint32_t tail = rx_tail;
	if (tail != rx_head) {
   17138:	ldr	r2, [pc, #100]	; (171a0 <usb_midi_read_message+0x74>)

uint32_t usb_midi_read_message(void)
{
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
	uint32_t tail = rx_tail;
   1713a:	ldrb	r3, [r6, #0]
	if (tail != rx_head) {
   1713c:	ldrb	r2, [r2, #0]

uint32_t usb_midi_read_message(void)
{
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
	uint32_t tail = rx_tail;
   1713e:	uxtb	r3, r3
	if (tail != rx_head) {
   17140:	cmp	r3, r2
   17142:	beq.n	17192 <usb_midi_read_message+0x66>
		if (++tail > RX_NUM) tail = 0;
   17144:	adds	r3, #1
		uint32_t i = rx_list[tail];
   17146:	ldr	r1, [pc, #92]	; (171a4 <usb_midi_read_message+0x78>)
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
   17148:	ldr	r7, [pc, #92]	; (171a8 <usb_midi_read_message+0x7c>)
{
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
	uint32_t tail = rx_tail;
	if (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
   1714a:	cmp	r3, #7
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
		rx_available -= 4;
		rx_index[i] += 4;
		if (rx_index[i] >= rx_count[i]) {
   1714c:	ldr	r2, [pc, #92]	; (171ac <usb_midi_read_message+0x80>)
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
		rx_available -= 4;
   1714e:	ldr	r5, [pc, #96]	; (171b0 <usb_midi_read_message+0x84>)
{
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
	uint32_t tail = rx_tail;
	if (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
   17150:	it	cs
   17152:	movcs	r3, #0
		uint32_t i = rx_list[tail];
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
   17154:	ldr	r4, [pc, #92]	; (171b4 <usb_midi_read_message+0x88>)
	uint32_t n = 0;
	NVIC_DISABLE_IRQ(IRQ_USB1);
	uint32_t tail = rx_tail;
	if (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
   17156:	ldrb	r0, [r1, r3]
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
		rx_available -= 4;
   17158:	ldr	r1, [r5, #0]
	uint32_t tail = rx_tail;
	if (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
   1715a:	ldrh.w	lr, [r7, r0, lsl #1]
		n = *(uint32_t *)p;
   1715e:	add.w	r4, r4, r0, lsl #9
		rx_available -= 4;
		rx_index[i] += 4;
		if (rx_index[i] >= rx_count[i]) {
   17162:	ldrh.w	ip, [r2, r0, lsl #1]
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
		rx_available -= 4;
   17166:	subs	r1, #4
		rx_index[i] += 4;
   17168:	add.w	r2, lr, #4
	if (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
   1716c:	ldr.w	r4, [r4, lr]
		rx_available -= 4;
   17170:	str	r1, [r5, #0]
		rx_index[i] += 4;
   17172:	uxth	r2, r2
		if (rx_index[i] >= rx_count[i]) {
   17174:	cmp	ip, r2
		uint32_t i = rx_list[tail];
		//uint32_t avail = (rx_count[i] - rx_index[i]) / 4;
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
		rx_available -= 4;
		rx_index[i] += 4;
   17176:	strh.w	r2, [r7, r0, lsl #1]
		if (rx_index[i] >= rx_count[i]) {
   1717a:	bls.n	17188 <usb_midi_read_message+0x5c>
			rx_tail = tail;
			rx_queue_transfer(i);
		}
	}
	NVIC_ENABLE_IRQ(IRQ_USB1);
   1717c:	ldr	r3, [pc, #56]	; (171b8 <usb_midi_read_message+0x8c>)
   1717e:	mov.w	r2, #131072	; 0x20000
	return n;
}
   17182:	mov	r0, r4
		if (rx_index[i] >= rx_count[i]) {
			rx_tail = tail;
			rx_queue_transfer(i);
		}
	}
	NVIC_ENABLE_IRQ(IRQ_USB1);
   17184:	str	r2, [r3, #0]
	return n;
}
   17186:	pop	{r3, r4, r5, r6, r7, pc}
		void *p = rx_buffer + i * MIDI_RX_SIZE_480 + rx_index[i];
		n = *(uint32_t *)p;
		rx_available -= 4;
		rx_index[i] += 4;
		if (rx_index[i] >= rx_count[i]) {
			rx_tail = tail;
   17188:	uxtb	r3, r3
   1718a:	strb	r3, [r6, #0]
			rx_queue_transfer(i);
   1718c:	bl	16eec <rx_queue_transfer>
   17190:	b.n	1717c <usb_midi_read_message+0x50>
	return rx_available / 4;
}

uint32_t usb_midi_read_message(void)
{
	uint32_t n = 0;
   17192:	movs	r4, #0
   17194:	b.n	1717c <usb_midi_read_message+0x50>
   17196:	nop
   17198:	.word	0xe000e18c
   1719c:	.word	0x2005859a
   171a0:	.word	0x20058598
   171a4:	.word	0x20058730
   171a8:	.word	0x20058688
   171ac:	.word	0x200585a4
   171b0:	.word	0x20058684
   171b4:	.word	0x202008a0
   171b8:	.word	0xe000e10c

000171bc <usb_midi_read>:
	NVIC_ENABLE_IRQ(IRQ_USB1);
	return n;
}

int usb_midi_read(uint32_t channel)
{
   171bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   171c0:	mov	r7, r0
	uint32_t n, ch, type1, type2, b1;
	
	n = usb_midi_read_message();
   171c2:	bl	1712c <usb_midi_read_message>
	if (n == 0) return 0;
   171c6:	cbz	r0, 171ee <usb_midi_read+0x32>
	type1 = n & 15;
   171c8:	and.w	r5, r0, #15
	type2 = (n >> 12) & 15;
	b1 = (n >> 8) & 0xFF;
   171cc:	lsrs	r6, r0, #8
	ch = (b1 & 15) + 1;
	usb_midi_msg_cable = (n >> 4) & 15;
   171ce:	ubfx	r3, r0, #4, #4
   171d2:	mov	r4, r0
	if (type1 >= 0x08 && type1 <= 0x0E) {
   171d4:	sub.w	r2, r5, #8
	if (n == 0) return 0;
	type1 = n & 15;
	type2 = (n >> 12) & 15;
	b1 = (n >> 8) & 0xFF;
	ch = (b1 & 15) + 1;
	usb_midi_msg_cable = (n >> 4) & 15;
   171d8:	ldr	r1, [pc, #652]	; (17468 <usb_midi_read+0x2ac>)
	n = usb_midi_read_message();
	if (n == 0) return 0;
	type1 = n & 15;
	type2 = (n >> 12) & 15;
	b1 = (n >> 8) & 0xFF;
	ch = (b1 & 15) + 1;
   171da:	and.w	r0, r6, #15
	usb_midi_msg_cable = (n >> 4) & 15;
	if (type1 >= 0x08 && type1 <= 0x0E) {
   171de:	cmp	r2, #6
	if (n == 0) return 0;
	type1 = n & 15;
	type2 = (n >> 12) & 15;
	b1 = (n >> 8) & 0xFF;
	ch = (b1 & 15) + 1;
	usb_midi_msg_cable = (n >> 4) & 15;
   171e0:	strb	r3, [r1, #0]
	n = usb_midi_read_message();
	if (n == 0) return 0;
	type1 = n & 15;
	type2 = (n >> 12) & 15;
	b1 = (n >> 8) & 0xFF;
	ch = (b1 & 15) + 1;
   171e2:	add.w	r8, r0, #1
	usb_midi_msg_cable = (n >> 4) & 15;
	if (type1 >= 0x08 && type1 <= 0x0E) {
   171e6:	bhi.n	171f4 <usb_midi_read+0x38>
		if (channel && channel != ch) {
   171e8:	cbz	r7, 17250 <usb_midi_read+0x94>
   171ea:	cmp	r8, r7
   171ec:	beq.n	17250 <usb_midi_read+0x94>
			// OSX sometimes uses Single Byte Unparsed to
			// send bytes in the middle of a SYSEX message.
			sysex_byte(b1);
		}
	}
	return 0;
   171ee:	movs	r0, #0
   171f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		usb_midi_msg_channel = ch;
		usb_midi_msg_data1 = (n >> 16);
		usb_midi_msg_data2 = (n >> 24);
		return 1;
	}
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
   171f4:	subs	r3, r5, #2
	
	n = usb_midi_read_message();
	if (n == 0) return 0;
	type1 = n & 15;
	type2 = (n >> 12) & 15;
	b1 = (n >> 8) & 0xFF;
   171f6:	uxtb	r0, r6
		usb_midi_msg_channel = ch;
		usb_midi_msg_data1 = (n >> 16);
		usb_midi_msg_data2 = (n >> 24);
		return 1;
	}
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
   171f8:	cmp	r3, #1
   171fa:	bls.n	17208 <usb_midi_read+0x4c>
   171fc:	cmp	r5, #5
   171fe:	bne.n	1728e <usb_midi_read+0xd2>
   17200:	cmp	r0, #240	; 0xf0
   17202:	bls.n	1728e <usb_midi_read+0xd2>
   17204:	cmp	r0, #247	; 0xf7
   17206:	beq.n	17294 <usb_midi_read+0xd8>
		// system common or system realtime message
		system_common_or_realtime:
		switch (b1) {
   17208:	subs	r0, #241	; 0xf1
   1720a:	cmp	r0, #14
   1720c:	bhi.n	171ee <usb_midi_read+0x32>
   1720e:	add	r3, pc, #4	; (adr r3, 17214 <usb_midi_read+0x58>)
   17210:	ldr.w	pc, [r3, r0, lsl #2]
   17214:	.word	0x000173cf
   17218:	.word	0x000173b3
   1721c:	.word	0x000173a1
   17220:	.word	0x000171ef
   17224:	.word	0x000171ef
   17228:	.word	0x00017397
   1722c:	.word	0x000171ef
   17230:	.word	0x0001737d
   17234:	.word	0x000171ef
   17238:	.word	0x00017363
   1723c:	.word	0x00017349
   17240:	.word	0x0001732f
   17244:	.word	0x000171ef
   17248:	.word	0x00017315
   1724c:	.word	0x000172f9
	if (type1 >= 0x08 && type1 <= 0x0E) {
		if (channel && channel != ch) {
			// ignore other channels when user wants single channel read
			return 0;
		}
		if (type1 == 0x08 && type2 == 0x08) {
   17250:	cmp	r5, #8
	uint32_t n, ch, type1, type2, b1;
	
	n = usb_midi_read_message();
	if (n == 0) return 0;
	type1 = n & 15;
	type2 = (n >> 12) & 15;
   17252:	ubfx	r3, r4, #12, #4
	if (type1 >= 0x08 && type1 <= 0x0E) {
		if (channel && channel != ch) {
			// ignore other channels when user wants single channel read
			return 0;
		}
		if (type1 == 0x08 && type2 == 0x08) {
   17256:	bne.n	172b6 <usb_midi_read+0xfa>
   17258:	cmp	r3, #8
   1725a:	bne.n	172b6 <usb_midi_read+0xfa>
			usb_midi_msg_type = 0x80;		// 0x80 = usbMIDI.NoteOff
			if (usb_midi_handleNoteOff)
   1725c:	ldr	r3, [pc, #524]	; (1746c <usb_midi_read+0x2b0>)
		if (channel && channel != ch) {
			// ignore other channels when user wants single channel read
			return 0;
		}
		if (type1 == 0x08 && type2 == 0x08) {
			usb_midi_msg_type = 0x80;		// 0x80 = usbMIDI.NoteOff
   1725e:	movs	r1, #128	; 0x80
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
			if (usb_midi_handleVelocityChange)
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0B && type2 == 0x0B) {
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
   17260:	ldr	r2, [pc, #524]	; (17470 <usb_midi_read+0x2b4>)
			if (usb_midi_handleControlChange)
				(*usb_midi_handleControlChange)(ch, (n >> 16), (n >> 24));
   17262:	ubfx	r5, r4, #16, #8
			if (usb_midi_handleVelocityChange)
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0B && type2 == 0x0B) {
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
			if (usb_midi_handleControlChange)
   17266:	ldr	r3, [r3, #0]
				(*usb_midi_handleControlChange)(ch, (n >> 16), (n >> 24));
   17268:	uxtb.w	r8, r8
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
			if (usb_midi_handleVelocityChange)
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0B && type2 == 0x0B) {
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
   1726c:	strb	r1, [r2, #0]
			if (usb_midi_handleControlChange)
				(*usb_midi_handleControlChange)(ch, (n >> 16), (n >> 24));
   1726e:	lsrs	r4, r4, #24
			if (usb_midi_handleVelocityChange)
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0B && type2 == 0x0B) {
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
			if (usb_midi_handleControlChange)
   17270:	cbz	r3, 1727a <usb_midi_read+0xbe>
				(*usb_midi_handleControlChange)(ch, (n >> 16), (n >> 24));
   17272:	mov	r0, r8
   17274:	mov	r1, r5
   17276:	mov	r2, r4
   17278:	blx	r3
			}
		} else {
			return 0;
		}
		return_message:
		usb_midi_msg_channel = ch;
   1727a:	ldr	r1, [pc, #504]	; (17474 <usb_midi_read+0x2b8>)
		usb_midi_msg_data1 = (n >> 16);
		usb_midi_msg_data2 = (n >> 24);
		return 1;
   1727c:	movs	r0, #1
		} else {
			return 0;
		}
		return_message:
		usb_midi_msg_channel = ch;
		usb_midi_msg_data1 = (n >> 16);
   1727e:	ldr	r2, [pc, #504]	; (17478 <usb_midi_read+0x2bc>)
		usb_midi_msg_data2 = (n >> 24);
   17280:	ldr	r3, [pc, #504]	; (1747c <usb_midi_read+0x2c0>)
			}
		} else {
			return 0;
		}
		return_message:
		usb_midi_msg_channel = ch;
   17282:	strb.w	r8, [r1]
		usb_midi_msg_data1 = (n >> 16);
   17286:	strb	r5, [r2, #0]
		usb_midi_msg_data2 = (n >> 24);
   17288:	strb	r4, [r3, #0]
		return 1;
   1728a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return 0; // unknown message, ignore it
		}
		usb_midi_msg_type = b1;
		goto return_message;
	}
	if (type1 == 0x04) {
   1728e:	cmp	r5, #4
   17290:	beq.w	17450 <usb_midi_read+0x294>
		sysex_byte(n >> 8);
		sysex_byte(n >> 16);
		sysex_byte(n >> 24);
		return 0;
	}
	if (type1 >= 0x05 && type1 <= 0x07) {
   17294:	subs	r3, r5, #5
   17296:	cmp	r3, #2
   17298:	bls.w	173dc <usb_midi_read+0x220>
		} else if (usb_midi_handleSysExComplete) {
			(*usb_midi_handleSysExComplete)(usb_midi_msg_sysex, len);
		}
		return 1;
	}
	if (type1 == 0x0F) {
   1729c:	cmp	r5, #15
   1729e:	bne.n	171ee <usb_midi_read+0x32>
		if (b1 >= 0xF8) {
   172a0:	cmp	r0, #247	; 0xf7
   172a2:	bhi.n	17208 <usb_midi_read+0x4c>
			// From Sebastian Tomczak, seb.tomczak at gmail.com
			// http://little-scale.blogspot.com/2011/08/usb-midi-game-boy-sync-for-16.html
			goto system_common_or_realtime;
		}
		if (b1 == 0xF0 || usb_midi_msg_sysex_len > 0) {
   172a4:	cmp	r0, #240	; 0xf0
   172a6:	beq.n	172b0 <usb_midi_read+0xf4>
   172a8:	ldr	r3, [pc, #468]	; (17480 <usb_midi_read+0x2c4>)
   172aa:	ldrh	r3, [r3, #0]
   172ac:	cmp	r3, #0
   172ae:	beq.n	171ee <usb_midi_read+0x32>
			// From David Sorlien, dsorlien at gmail.com, http://axe4live.wordpress.com
			// OSX sometimes uses Single Byte Unparsed to
			// send bytes in the middle of a SYSEX message.
			sysex_byte(b1);
   172b0:	bl	16ea4 <sysex_byte>
   172b4:	b.n	171ee <usb_midi_read+0x32>
		if (type1 == 0x08 && type2 == 0x08) {
			usb_midi_msg_type = 0x80;		// 0x80 = usbMIDI.NoteOff
			if (usb_midi_handleNoteOff)
				(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x09 && type2 == 0x09) {
   172b6:	cmp	r5, #9
   172b8:	bne.n	172e6 <usb_midi_read+0x12a>
   172ba:	cmp	r3, #9
   172bc:	bne.n	172e6 <usb_midi_read+0x12a>
			if ((n >> 24) > 0) {
   172be:	lsrs	r2, r4, #24
   172c0:	beq.w	17410 <usb_midi_read+0x254>
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
   172c4:	ldr	r3, [pc, #444]	; (17484 <usb_midi_read+0x2c8>)
			if (usb_midi_handleNoteOff)
				(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x09 && type2 == 0x09) {
			if ((n >> 24) > 0) {
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
   172c6:	movs	r0, #144	; 0x90
   172c8:	ldr	r1, [pc, #420]	; (17470 <usb_midi_read+0x2b4>)
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
   172ca:	ubfx	r5, r4, #16, #8
				(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x09 && type2 == 0x09) {
			if ((n >> 24) > 0) {
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
   172ce:	ldr	r3, [r3, #0]
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
   172d0:	uxtb.w	r8, r8
			if (usb_midi_handleNoteOff)
				(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x09 && type2 == 0x09) {
			if ((n >> 24) > 0) {
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
   172d4:	strb	r0, [r1, #0]
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
   172d6:	uxtb	r4, r2
				(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x09 && type2 == 0x09) {
			if ((n >> 24) > 0) {
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
   172d8:	cmp	r3, #0
   172da:	beq.n	1727a <usb_midi_read+0xbe>
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
   172dc:	mov	r1, r5
   172de:	mov	r0, r8
   172e0:	mov	r2, r4
   172e2:	blx	r3
   172e4:	b.n	1727a <usb_midi_read+0xbe>
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
				if (usb_midi_handleNoteOff)
					(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
			}
		} else
		if (type1 == 0x0A && type2 == 0x0A) {
   172e6:	cmp	r5, #10
   172e8:	bne.w	17430 <usb_midi_read+0x274>
   172ec:	cmp	r3, #10
   172ee:	bne.w	17430 <usb_midi_read+0x274>
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
			if (usb_midi_handleVelocityChange)
   172f2:	ldr	r3, [pc, #404]	; (17488 <usb_midi_read+0x2cc>)
				if (usb_midi_handleNoteOff)
					(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
			}
		} else
		if (type1 == 0x0A && type2 == 0x0A) {
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
   172f4:	movs	r1, #160	; 0xa0
   172f6:	b.n	17260 <usb_midi_read+0xa4>
			} else if (usb_midi_handleRealTimeSystem) {
				(*usb_midi_handleRealTimeSystem)(0xFE);
			}
			break;
		  case 0xFF: // usbMIDI.SystemReset
			if (usb_midi_handleSystemReset) {
   172f8:	ldr	r3, [pc, #400]	; (1748c <usb_midi_read+0x2d0>)
   172fa:	ldr	r3, [r3, #0]
   172fc:	cmp	r3, #0
   172fe:	beq.w	1751a <usb_midi_read+0x35e>
				(*usb_midi_handleTuneRequest)();
			}
			break;
		  case 0xF8: // usbMIDI.Clock
			if (usb_midi_handleClock) {
				(*usb_midi_handleClock)();
   17302:	blx	r3
   17304:	ubfx	r5, r4, #16, #8
			}
			break;
		  default:
			return 0; // unknown message, ignore it
		}
		usb_midi_msg_type = b1;
   17308:	ldr	r3, [pc, #356]	; (17470 <usb_midi_read+0x2b4>)
   1730a:	uxtb.w	r8, r8
   1730e:	lsrs	r4, r4, #24
   17310:	strb	r6, [r3, #0]
		goto return_message;
   17312:	b.n	1727a <usb_midi_read+0xbe>
			} else if (usb_midi_handleRealTimeSystem) {
				(*usb_midi_handleRealTimeSystem)(0xFC);
			}
			break;
		  case 0xFE: // usbMIDI.ActiveSensing
			if (usb_midi_handleActiveSensing) {
   17314:	ldr	r3, [pc, #376]	; (17490 <usb_midi_read+0x2d4>)
   17316:	ldr	r3, [r3, #0]
   17318:	cmp	r3, #0
   1731a:	bne.n	17302 <usb_midi_read+0x146>
				(*usb_midi_handleActiveSensing)();
			} else if (usb_midi_handleRealTimeSystem) {
   1731c:	ldr	r3, [pc, #372]	; (17494 <usb_midi_read+0x2d8>)
   1731e:	ldr	r3, [r3, #0]
   17320:	cmp	r3, #0
   17322:	beq.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleRealTimeSystem)(0xFE);
   17324:	movs	r0, #254	; 0xfe
   17326:	ubfx	r5, r4, #16, #8
   1732a:	blx	r3
   1732c:	b.n	17308 <usb_midi_read+0x14c>
			} else if (usb_midi_handleRealTimeSystem) {
				(*usb_midi_handleRealTimeSystem)(0xFB);
			}
			break;
		  case 0xFC: // usbMIDI.Stop
			if (usb_midi_handleStop) {
   1732e:	ldr	r3, [pc, #360]	; (17498 <usb_midi_read+0x2dc>)
   17330:	ldr	r3, [r3, #0]
   17332:	cmp	r3, #0
   17334:	bne.n	17302 <usb_midi_read+0x146>
				(*usb_midi_handleStop)();
			} else if (usb_midi_handleRealTimeSystem) {
   17336:	ldr	r3, [pc, #348]	; (17494 <usb_midi_read+0x2d8>)
   17338:	ldr	r3, [r3, #0]
   1733a:	cmp	r3, #0
   1733c:	beq.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleRealTimeSystem)(0xFC);
   1733e:	movs	r0, #252	; 0xfc
   17340:	ubfx	r5, r4, #16, #8
   17344:	blx	r3
   17346:	b.n	17308 <usb_midi_read+0x14c>
			} else if (usb_midi_handleRealTimeSystem) {
				(*usb_midi_handleRealTimeSystem)(0xFA);
			}
			break;
		  case 0xFB: // usbMIDI.Continue
			if (usb_midi_handleContinue) {
   17348:	ldr	r3, [pc, #336]	; (1749c <usb_midi_read+0x2e0>)
   1734a:	ldr	r3, [r3, #0]
   1734c:	cmp	r3, #0
   1734e:	bne.n	17302 <usb_midi_read+0x146>
				(*usb_midi_handleContinue)();
			} else if (usb_midi_handleRealTimeSystem) {
   17350:	ldr	r3, [pc, #320]	; (17494 <usb_midi_read+0x2d8>)
   17352:	ldr	r3, [r3, #0]
   17354:	cmp	r3, #0
   17356:	beq.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleRealTimeSystem)(0xFB);
   17358:	movs	r0, #251	; 0xfb
   1735a:	ubfx	r5, r4, #16, #8
   1735e:	blx	r3
   17360:	b.n	17308 <usb_midi_read+0x14c>
			} else if (usb_midi_handleRealTimeSystem) {
				(*usb_midi_handleRealTimeSystem)(0xF8);
			}
			break;
		  case 0xFA: // usbMIDI.Start
			if (usb_midi_handleStart) {
   17362:	ldr	r3, [pc, #316]	; (174a0 <usb_midi_read+0x2e4>)
   17364:	ldr	r3, [r3, #0]
   17366:	cmp	r3, #0
   17368:	bne.n	17302 <usb_midi_read+0x146>
				(*usb_midi_handleStart)();
			} else if (usb_midi_handleRealTimeSystem) {
   1736a:	ldr	r3, [pc, #296]	; (17494 <usb_midi_read+0x2d8>)
   1736c:	ldr	r3, [r3, #0]
   1736e:	cmp	r3, #0
   17370:	beq.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleRealTimeSystem)(0xFA);
   17372:	movs	r0, #250	; 0xfa
   17374:	ubfx	r5, r4, #16, #8
   17378:	blx	r3
   1737a:	b.n	17308 <usb_midi_read+0x14c>
			if (usb_midi_handleTuneRequest) {
				(*usb_midi_handleTuneRequest)();
			}
			break;
		  case 0xF8: // usbMIDI.Clock
			if (usb_midi_handleClock) {
   1737c:	ldr	r3, [pc, #292]	; (174a4 <usb_midi_read+0x2e8>)
   1737e:	ldr	r3, [r3, #0]
   17380:	cmp	r3, #0
   17382:	bne.n	17302 <usb_midi_read+0x146>
				(*usb_midi_handleClock)();
			} else if (usb_midi_handleRealTimeSystem) {
   17384:	ldr	r3, [pc, #268]	; (17494 <usb_midi_read+0x2d8>)
   17386:	ldr	r3, [r3, #0]
   17388:	cmp	r3, #0
   1738a:	beq.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleRealTimeSystem)(0xF8);
   1738c:	movs	r0, #248	; 0xf8
   1738e:	ubfx	r5, r4, #16, #8
   17392:	blx	r3
   17394:	b.n	17308 <usb_midi_read+0x14c>
			if (usb_midi_handleSongSelect) {
				(*usb_midi_handleSongSelect)(n >> 16);
			}
			break;
		  case 0xF6: // usbMIDI.TuneRequest
			if (usb_midi_handleTuneRequest) {
   17396:	ldr	r3, [pc, #272]	; (174a8 <usb_midi_read+0x2ec>)
   17398:	ldr	r3, [r3, #0]
   1739a:	cmp	r3, #0
   1739c:	bne.n	17302 <usb_midi_read+0x146>
   1739e:	b.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleSongPosition)(
				  ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80));
			}
			break;
		  case 0xF3: // usbMIDI.SongSelect
			if (usb_midi_handleSongSelect) {
   173a0:	ldr	r3, [pc, #264]	; (174ac <usb_midi_read+0x2f0>)
				(*usb_midi_handleSongSelect)(n >> 16);
   173a2:	ubfx	r5, r4, #16, #8
				(*usb_midi_handleSongPosition)(
				  ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80));
			}
			break;
		  case 0xF3: // usbMIDI.SongSelect
			if (usb_midi_handleSongSelect) {
   173a6:	ldr	r3, [r3, #0]
   173a8:	cmp	r3, #0
   173aa:	beq.n	17308 <usb_midi_read+0x14c>
				(*usb_midi_handleSongSelect)(n >> 16);
   173ac:	mov	r0, r5
   173ae:	blx	r3
   173b0:	b.n	17308 <usb_midi_read+0x14c>
			if (usb_midi_handleTimeCodeQuarterFrame) {
				(*usb_midi_handleTimeCodeQuarterFrame)(n >> 16);
			}
			break;
		  case 0xF2: // usbMIDI.SongPosition
			if (usb_midi_handleSongPosition) {
   173b2:	ldr	r3, [pc, #252]	; (174b0 <usb_midi_read+0x2f4>)
   173b4:	ldr	r2, [r3, #0]
   173b6:	cmp	r2, #0
   173b8:	beq.n	17304 <usb_midi_read+0x148>
				(*usb_midi_handleSongPosition)(
				  ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80));
   173ba:	lsrs	r5, r4, #16
				(*usb_midi_handleTimeCodeQuarterFrame)(n >> 16);
			}
			break;
		  case 0xF2: // usbMIDI.SongPosition
			if (usb_midi_handleSongPosition) {
				(*usb_midi_handleSongPosition)(
   173bc:	lsrs	r3, r4, #17
   173be:	and.w	r0, r5, #127	; 0x7f
   173c2:	uxtb	r5, r5
   173c4:	and.w	r3, r3, #16256	; 0x3f80
   173c8:	orrs	r0, r3
   173ca:	blx	r2
   173cc:	b.n	17308 <usb_midi_read+0x14c>
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
		// system common or system realtime message
		system_common_or_realtime:
		switch (b1) {
		  case 0xF1: // usbMIDI.TimeCodeQuarterFrame
			if (usb_midi_handleTimeCodeQuarterFrame) {
   173ce:	ldr	r3, [pc, #228]	; (174b4 <usb_midi_read+0x2f8>)
				(*usb_midi_handleTimeCodeQuarterFrame)(n >> 16);
   173d0:	ubfx	r5, r4, #16, #8
	if (type1 == 0x02 || type1 == 0x03 || (type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7)) {
		// system common or system realtime message
		system_common_or_realtime:
		switch (b1) {
		  case 0xF1: // usbMIDI.TimeCodeQuarterFrame
			if (usb_midi_handleTimeCodeQuarterFrame) {
   173d4:	ldr	r3, [r3, #0]
   173d6:	cmp	r3, #0
   173d8:	bne.n	173ac <usb_midi_read+0x1f0>
   173da:	b.n	17308 <usb_midi_read+0x14c>
		sysex_byte(n >> 16);
		sysex_byte(n >> 24);
		return 0;
	}
	if (type1 >= 0x05 && type1 <= 0x07) {
		sysex_byte(b1);
   173dc:	bl	16ea4 <sysex_byte>
		if (type1 >= 0x06) sysex_byte(n >> 16);
   173e0:	cmp	r5, #5
   173e2:	bne.w	174f2 <usb_midi_read+0x336>
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
   173e6:	ldr	r3, [pc, #152]	; (17480 <usb_midi_read+0x2c4>)
		usb_midi_msg_data1 = len;
		usb_midi_msg_data2 = len >> 8;
		usb_midi_msg_sysex_len = 0;
   173e8:	movs	r7, #0
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
		if (usb_midi_handleSysExPartial) {
   173ea:	ldr	r0, [pc, #204]	; (174b8 <usb_midi_read+0x2fc>)
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
		usb_midi_msg_data1 = len;
		usb_midi_msg_data2 = len >> 8;
		usb_midi_msg_sysex_len = 0;
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
   173ec:	movs	r2, #240	; 0xf0
	}
	if (type1 >= 0x05 && type1 <= 0x07) {
		sysex_byte(b1);
		if (type1 >= 0x06) sysex_byte(n >> 16);
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
   173ee:	ldrh	r1, [r3, #0]
		usb_midi_msg_data1 = len;
		usb_midi_msg_data2 = len >> 8;
		usb_midi_msg_sysex_len = 0;
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
		if (usb_midi_handleSysExPartial) {
   173f0:	ldr	r4, [r0, #0]
		if (type1 >= 0x06) sysex_byte(n >> 16);
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
		usb_midi_msg_data1 = len;
		usb_midi_msg_data2 = len >> 8;
		usb_midi_msg_sysex_len = 0;
   173f2:	strh	r7, [r3, #0]
		sysex_byte(b1);
		if (type1 >= 0x06) sysex_byte(n >> 16);
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
		usb_midi_msg_data1 = len;
		usb_midi_msg_data2 = len >> 8;
   173f4:	lsrs	r5, r1, #8
	if (type1 >= 0x05 && type1 <= 0x07) {
		sysex_byte(b1);
		if (type1 >= 0x06) sysex_byte(n >> 16);
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
		usb_midi_msg_data1 = len;
   173f6:	ldr	r6, [pc, #128]	; (17478 <usb_midi_read+0x2bc>)
		usb_midi_msg_data2 = len >> 8;
   173f8:	ldr	r0, [pc, #128]	; (1747c <usb_midi_read+0x2c0>)
		usb_midi_msg_sysex_len = 0;
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
   173fa:	ldr	r3, [pc, #116]	; (17470 <usb_midi_read+0x2b4>)
	if (type1 >= 0x05 && type1 <= 0x07) {
		sysex_byte(b1);
		if (type1 >= 0x06) sysex_byte(n >> 16);
		if (type1 == 0x07) sysex_byte(n >> 24);
		uint16_t len = usb_midi_msg_sysex_len;
		usb_midi_msg_data1 = len;
   173fc:	strb	r1, [r6, #0]
		usb_midi_msg_data2 = len >> 8;
   173fe:	strb	r5, [r0, #0]
		usb_midi_msg_sysex_len = 0;
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
   17400:	strb	r2, [r3, #0]
		if (usb_midi_handleSysExPartial) {
   17402:	cbz	r4, 1743e <usb_midi_read+0x282>
			(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, len, 1);
   17404:	movs	r2, #1
   17406:	ldr	r0, [pc, #180]	; (174bc <usb_midi_read+0x300>)
   17408:	blx	r4
		} else if (usb_midi_handleSysExComplete) {
			(*usb_midi_handleSysExComplete)(usb_midi_msg_sysex, len);
		}
		return 1;
   1740a:	movs	r0, #1
   1740c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
			} else {
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
				if (usb_midi_handleNoteOff)
   17410:	ldr	r3, [pc, #88]	; (1746c <usb_midi_read+0x2b0>)
			if ((n >> 24) > 0) {
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
			} else {
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
   17412:	movs	r0, #128	; 0x80
   17414:	ldr	r1, [pc, #88]	; (17470 <usb_midi_read+0x2b4>)
				if (usb_midi_handleNoteOff)
					(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
   17416:	uxtb.w	r8, r8
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
			} else {
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
				if (usb_midi_handleNoteOff)
   1741a:	ldr	r3, [r3, #0]
					(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
   1741c:	ubfx	r5, r4, #16, #8
			if ((n >> 24) > 0) {
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
			} else {
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
   17420:	strb	r0, [r1, #0]
				if (usb_midi_handleNoteOff)
   17422:	cmp	r3, #0
   17424:	beq.n	17516 <usb_midi_read+0x35a>
					(*usb_midi_handleNoteOff)(ch, (n >> 16), (n >> 24));
   17426:	mov	r1, r5
   17428:	mov	r0, r8
   1742a:	mov	r4, r2
   1742c:	blx	r3
   1742e:	b.n	1727a <usb_midi_read+0xbe>
		if (type1 == 0x0A && type2 == 0x0A) {
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
			if (usb_midi_handleVelocityChange)
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0B && type2 == 0x0B) {
   17430:	cmp	r5, #11
   17432:	bne.n	174c8 <usb_midi_read+0x30c>
   17434:	cmp	r3, #11
   17436:	bne.n	174c8 <usb_midi_read+0x30c>
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
			if (usb_midi_handleControlChange)
   17438:	ldr	r3, [pc, #132]	; (174c0 <usb_midi_read+0x304>)
			usb_midi_msg_type = 0xA0;		// 0xA0 = usbMIDI.AfterTouchPoly
			if (usb_midi_handleVelocityChange)
				(*usb_midi_handleVelocityChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0B && type2 == 0x0B) {
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
   1743a:	movs	r1, #176	; 0xb0
   1743c:	b.n	17260 <usb_midi_read+0xa4>
		usb_midi_msg_data2 = len >> 8;
		usb_midi_msg_sysex_len = 0;
		usb_midi_msg_type = 0xF0;			// 0xF0 = usbMIDI.SystemExclusive
		if (usb_midi_handleSysExPartial) {
			(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, len, 1);
		} else if (usb_midi_handleSysExComplete) {
   1743e:	ldr	r3, [pc, #132]	; (174c4 <usb_midi_read+0x308>)
   17440:	ldr	r3, [r3, #0]
   17442:	cmp	r3, #0
   17444:	beq.n	1752e <usb_midi_read+0x372>
			(*usb_midi_handleSysExComplete)(usb_midi_msg_sysex, len);
   17446:	ldr	r0, [pc, #116]	; (174bc <usb_midi_read+0x300>)
   17448:	blx	r3
		}
		return 1;
   1744a:	movs	r0, #1
   1744c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		}
		usb_midi_msg_type = b1;
		goto return_message;
	}
	if (type1 == 0x04) {
		sysex_byte(n >> 8);
   17450:	bl	16ea4 <sysex_byte>
		sysex_byte(n >> 16);
   17454:	ubfx	r0, r4, #16, #8
   17458:	bl	16ea4 <sysex_byte>
		sysex_byte(n >> 24);
   1745c:	lsrs	r0, r4, #24
   1745e:	bl	16ea4 <sysex_byte>
		return 0;
   17462:	movs	r0, #0
   17464:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17468:	.word	0x2005a6c6
   1746c:	.word	0x2005858c
   17470:	.word	0x2005a6c0
   17474:	.word	0x2005a6c7
   17478:	.word	0x2005a6c4
   1747c:	.word	0x2005a6c5
   17480:	.word	0x2005a6c2
   17484:	.word	0x2005857c
   17488:	.word	0x20058588
   1748c:	.word	0x20058570
   17490:	.word	0x200585a0
   17494:	.word	0x20058720
   17498:	.word	0x20058568
   1749c:	.word	0x20058564
   174a0:	.word	0x20058590
   174a4:	.word	0x2005859c
   174a8:	.word	0x2005872c
   174ac:	.word	0x20058680
   174b0:	.word	0x20058560
   174b4:	.word	0x20058574
   174b8:	.word	0x20058578
   174bc:	.word	0x2005a6c8
   174c0:	.word	0x20058694
   174c4:	.word	0x20058594
		if (type1 == 0x0B && type2 == 0x0B) {
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
			if (usb_midi_handleControlChange)
				(*usb_midi_handleControlChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0C && type2 == 0x0C) {
   174c8:	cmp	r5, #12
   174ca:	bne.n	17508 <usb_midi_read+0x34c>
   174cc:	cmp	r3, #12
   174ce:	bne.n	17508 <usb_midi_read+0x34c>
			usb_midi_msg_type = 0xC0;		// 0xC0 = usbMIDI.ProgramChange
			if (usb_midi_handleProgramChange)
   174d0:	ldr	r3, [pc, #164]	; (17578 <usb_midi_read+0x3bc>)
			usb_midi_msg_type = 0xB0;		// 0xB0 = usbMIDI.ControlChange
			if (usb_midi_handleControlChange)
				(*usb_midi_handleControlChange)(ch, (n >> 16), (n >> 24));
		} else
		if (type1 == 0x0C && type2 == 0x0C) {
			usb_midi_msg_type = 0xC0;		// 0xC0 = usbMIDI.ProgramChange
   174d2:	movs	r1, #192	; 0xc0
			if (usb_midi_handleProgramChange)
				(*usb_midi_handleProgramChange)(ch, (n >> 16));
		} else
		if (type1 == 0x0D && type2 == 0x0D) {
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
   174d4:	ldr	r2, [pc, #164]	; (1757c <usb_midi_read+0x3c0>)
			if (usb_midi_handleAfterTouch)
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
   174d6:	ubfx	r5, r4, #16, #8
			if (usb_midi_handleProgramChange)
				(*usb_midi_handleProgramChange)(ch, (n >> 16));
		} else
		if (type1 == 0x0D && type2 == 0x0D) {
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
			if (usb_midi_handleAfterTouch)
   174da:	ldr	r3, [r3, #0]
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
   174dc:	uxtb.w	r8, r8
			usb_midi_msg_type = 0xC0;		// 0xC0 = usbMIDI.ProgramChange
			if (usb_midi_handleProgramChange)
				(*usb_midi_handleProgramChange)(ch, (n >> 16));
		} else
		if (type1 == 0x0D && type2 == 0x0D) {
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
   174e0:	strb	r1, [r2, #0]
   174e2:	lsrs	r4, r4, #24
			if (usb_midi_handleAfterTouch)
   174e4:	cmp	r3, #0
   174e6:	beq.w	1727a <usb_midi_read+0xbe>
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
   174ea:	mov	r0, r8
   174ec:	mov	r1, r5
   174ee:	blx	r3
   174f0:	b.n	1727a <usb_midi_read+0xbe>
		sysex_byte(n >> 24);
		return 0;
	}
	if (type1 >= 0x05 && type1 <= 0x07) {
		sysex_byte(b1);
		if (type1 >= 0x06) sysex_byte(n >> 16);
   174f2:	ubfx	r0, r4, #16, #8
   174f6:	bl	16ea4 <sysex_byte>
		if (type1 == 0x07) sysex_byte(n >> 24);
   174fa:	cmp	r5, #7
   174fc:	bne.w	173e6 <usb_midi_read+0x22a>
   17500:	lsrs	r0, r4, #24
   17502:	bl	16ea4 <sysex_byte>
   17506:	b.n	173e6 <usb_midi_read+0x22a>
		if (type1 == 0x0C && type2 == 0x0C) {
			usb_midi_msg_type = 0xC0;		// 0xC0 = usbMIDI.ProgramChange
			if (usb_midi_handleProgramChange)
				(*usb_midi_handleProgramChange)(ch, (n >> 16));
		} else
		if (type1 == 0x0D && type2 == 0x0D) {
   17508:	cmp	r5, #13
   1750a:	bne.n	17534 <usb_midi_read+0x378>
   1750c:	cmp	r3, #13
   1750e:	bne.n	17534 <usb_midi_read+0x378>
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
			if (usb_midi_handleAfterTouch)
   17510:	ldr	r3, [pc, #108]	; (17580 <usb_midi_read+0x3c4>)
			usb_midi_msg_type = 0xC0;		// 0xC0 = usbMIDI.ProgramChange
			if (usb_midi_handleProgramChange)
				(*usb_midi_handleProgramChange)(ch, (n >> 16));
		} else
		if (type1 == 0x0D && type2 == 0x0D) {
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
   17512:	movs	r1, #208	; 0xd0
   17514:	b.n	174d4 <usb_midi_read+0x318>
				usb_midi_msg_type = 0x90;	// 0x90 = usbMIDI.NoteOn
				if (usb_midi_handleNoteOn)
					(*usb_midi_handleNoteOn)(ch, (n >> 16), (n >> 24));
			} else {
				usb_midi_msg_type = 0x80;	// 0x80 = usbMIDI.NoteOff
				if (usb_midi_handleNoteOff)
   17516:	mov	r4, r3
   17518:	b.n	1727a <usb_midi_read+0xbe>
			}
			break;
		  case 0xFF: // usbMIDI.SystemReset
			if (usb_midi_handleSystemReset) {
				(*usb_midi_handleSystemReset)();
			} else if (usb_midi_handleRealTimeSystem) {
   1751a:	ldr	r3, [pc, #104]	; (17584 <usb_midi_read+0x3c8>)
   1751c:	ubfx	r5, r4, #16, #8
   17520:	ldr	r3, [r3, #0]
   17522:	cmp	r3, #0
   17524:	beq.w	17308 <usb_midi_read+0x14c>
				(*usb_midi_handleRealTimeSystem)(0xFF);
   17528:	movs	r0, #255	; 0xff
   1752a:	blx	r3
   1752c:	b.n	17308 <usb_midi_read+0x14c>
		if (usb_midi_handleSysExPartial) {
			(*usb_midi_handleSysExPartial)(usb_midi_msg_sysex, len, 1);
		} else if (usb_midi_handleSysExComplete) {
			(*usb_midi_handleSysExComplete)(usb_midi_msg_sysex, len);
		}
		return 1;
   1752e:	movs	r0, #1
			// send bytes in the middle of a SYSEX message.
			sysex_byte(b1);
		}
	}
	return 0;
}
   17530:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (type1 == 0x0D && type2 == 0x0D) {
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
			if (usb_midi_handleAfterTouch)
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
		} else
		if (type1 == 0x0E && type2 == 0x0E) {
   17534:	cmp	r5, #14
   17536:	bne.w	171ee <usb_midi_read+0x32>
   1753a:	cmp	r3, #14
   1753c:	bne.w	171ee <usb_midi_read+0x32>
			usb_midi_msg_type = 0xE0;		// 0xE0 = usbMIDI.PitchBend
			if (usb_midi_handlePitchChange) {
   17540:	ldr	r2, [pc, #68]	; (17588 <usb_midi_read+0x3cc>)
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
			if (usb_midi_handleAfterTouch)
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
		} else
		if (type1 == 0x0E && type2 == 0x0E) {
			usb_midi_msg_type = 0xE0;		// 0xE0 = usbMIDI.PitchBend
   17542:	movs	r1, #224	; 0xe0
   17544:	ldr	r3, [pc, #52]	; (1757c <usb_midi_read+0x3c0>)
			if (usb_midi_handlePitchChange) {
   17546:	ldr	r2, [r2, #0]
			usb_midi_msg_type = 0xD0;		// 0xD0 = usbMIDI.AfterTouchChannel
			if (usb_midi_handleAfterTouch)
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
		} else
		if (type1 == 0x0E && type2 == 0x0E) {
			usb_midi_msg_type = 0xE0;		// 0xE0 = usbMIDI.PitchBend
   17548:	strb	r1, [r3, #0]
			if (usb_midi_handlePitchChange) {
   1754a:	cbz	r2, 1756c <usb_midi_read+0x3b0>
				int value = ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80);
   1754c:	lsrs	r5, r4, #16
   1754e:	lsrs	r1, r4, #17
   17550:	and.w	r3, r5, #127	; 0x7f
				value -= 8192; // 0 to 16383 --> -8192 to +8191
				(*usb_midi_handlePitchChange)(ch, value);
   17554:	uxtb.w	r8, r8
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
		} else
		if (type1 == 0x0E && type2 == 0x0E) {
			usb_midi_msg_type = 0xE0;		// 0xE0 = usbMIDI.PitchBend
			if (usb_midi_handlePitchChange) {
				int value = ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80);
   17558:	and.w	r1, r1, #16256	; 0x3f80
   1755c:	uxtb	r5, r5
				value -= 8192; // 0 to 16383 --> -8192 to +8191
				(*usb_midi_handlePitchChange)(ch, value);
   1755e:	mov	r0, r8
   17560:	lsrs	r4, r4, #24
				(*usb_midi_handleAfterTouch)(ch, (n >> 16));
		} else
		if (type1 == 0x0E && type2 == 0x0E) {
			usb_midi_msg_type = 0xE0;		// 0xE0 = usbMIDI.PitchBend
			if (usb_midi_handlePitchChange) {
				int value = ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80);
   17562:	orrs	r1, r3
				value -= 8192; // 0 to 16383 --> -8192 to +8191
				(*usb_midi_handlePitchChange)(ch, value);
   17564:	sub.w	r1, r1, #8192	; 0x2000
   17568:	blx	r2
   1756a:	b.n	1727a <usb_midi_read+0xbe>
   1756c:	ubfx	r5, r4, #16, #8
   17570:	uxtb.w	r8, r8
   17574:	lsrs	r4, r4, #24
   17576:	b.n	1727a <usb_midi_read+0xbe>
   17578:	.word	0x20058580
   1757c:	.word	0x2005a6c0
   17580:	.word	0x20058738
   17584:	.word	0x20058720
   17588:	.word	0x20058724

0001758c <IntervalTimer::end()>:
}


void IntervalTimer::end() {
#if 1
	if (channel) {
   1758c:	ldr	r2, [r0, #0]
   1758e:	cbz	r2, 175d4 <IntervalTimer::end()+0x48>
		int index = channel - IMXRT_PIT_CHANNELS;
   17590:	ldr	r3, [pc, #68]	; (175d8 <IntervalTimer::end()+0x4c>)
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
   17592:	ldr	r1, [pc, #72]	; (175dc <IntervalTimer::end()+0x50>)


void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
   17594:	add	r3, r2
	NVIC_ENABLE_IRQ(IRQ_PIT);
	return true;
}


void IntervalTimer::end() {
   17596:	push	{r4, r5, r6, r7, lr}
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
   17598:	asrs	r3, r3, #4
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
   1759a:	movs	r5, #255	; 0xff
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
   1759c:	movs	r4, #0
   1759e:	ldr.w	lr, [pc, #68]	; 175e4 <IntervalTimer::end()+0x58>
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
   175a2:	strb	r5, [r1, r3]
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
   175a4:	ldrb	r6, [r1, #0]
   175a6:	ldrb	r5, [r1, #1]
   175a8:	cmp	r6, #255	; 0xff
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
		channel->TCTRL = 0;
   175aa:	str	r4, [r2, #8]
void IntervalTimer::end() {
#if 1
	if (channel) {
		int index = channel - IMXRT_PIT_CHANNELS;
		// TODO: disable IRQ_PIT, but only if all instances ended
		funct_table[index] = nullptr;
   175ac:	str.w	r4, [lr, r3, lsl #2]
   175b0:	it	cs
   175b2:	movcs	r6, #255	; 0xff
		channel->TCTRL = 0;
		nvic_priorites[index] = 255;
		uint8_t top_priority = 255;
		for (int i=0; i < NUM_CHANNELS; i++) {
			if (top_priority > nvic_priorites[i]) top_priority = nvic_priorites[i];
   175b4:	ldrb	r2, [r1, #2]
   175b6:	ldrb	r1, [r1, #3]
   175b8:	cmp	r6, r5
   175ba:	mov	r3, r6
		}
		NVIC_SET_PRIORITY(IRQ_PIT, top_priority);
   175bc:	ldr	r7, [pc, #32]	; (175e0 <IntervalTimer::end()+0x54>)
   175be:	it	cs
   175c0:	movcs	r3, r5
   175c2:	cmp	r3, r2
   175c4:	it	cs
   175c6:	movcs	r3, r2
   175c8:	cmp	r3, r1
   175ca:	it	cs
   175cc:	movcs	r3, r1
   175ce:	strb	r3, [r7, #0]
		channel = 0;
   175d0:	str	r4, [r0, #0]
   175d2:	pop	{r4, r5, r6, r7, pc}
   175d4:	bx	lr
   175d6:	nop
   175d8:	.word	0xbff7bf00
   175dc:	.word	0x20020a80
   175e0:	.word	0xe000e47a
   175e4:	.word	0x20058740

000175e8 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
   175e8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
   175ec:	ldr	r6, [pc, #200]	; (176b8 <yield+0xd0>)
   175ee:	ldrb	r3, [r6, #0]
   175f0:	cbz	r3, 17618 <yield+0x30>
	if (running) return; // TODO: does this need to be atomic?
   175f2:	ldr	r7, [pc, #200]	; (176bc <yield+0xd4>)
   175f4:	ldrb	r2, [r7, #0]
   175f6:	cbnz	r2, 17618 <yield+0x30>
	running = 1;
   175f8:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
   175fa:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
   175fc:	strb	r2, [r7, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
   175fe:	bmi.n	17670 <yield+0x88>
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
   17600:	lsls	r2, r3, #30
   17602:	bmi.n	17638 <yield+0x50>

	running = 0;
   17604:	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
   17606:	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
   17608:	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
   1760a:	bpl.n	17618 <yield+0x30>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
   1760c:	ldr	r3, [pc, #176]	; (176c0 <yield+0xd8>)
   1760e:	ldr	r2, [r3, #0]
   17610:	cbz	r2, 17618 <yield+0x30>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
   17612:	mrs	r2, IPSR
		if (ipsr != 0) return;
   17616:	cbz	r2, 1761c <yield+0x34>
   17618:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
   1761c:	mrs	r0, PRIMASK
		__disable_irq();
   17620:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
   17622:	ldr	r2, [r3, #0]
		if (first == nullptr) {
   17624:	cbz	r2, 1762e <yield+0x46>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
   17626:	ldr	r4, [pc, #156]	; (176c4 <yield+0xdc>)
   17628:	ldrb	r1, [r4, #0]
   1762a:	cmp	r1, #0
   1762c:	beq.n	1768e <yield+0xa6>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
   1762e:	cmp	r0, #0
   17630:	bne.n	17618 <yield+0x30>
   17632:	cpsie	i
   17634:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
   17638:	ldr.w	r8, [pc, #148]	; 176d0 <yield+0xe8>
   1763c:	ldrb.w	r2, [r8]
   17640:	cmp	r2, #0
   17642:	beq.n	17604 <yield+0x1c>
   17644:	movs	r4, #0
   17646:	ldr.w	r9, [pc, #140]	; 176d4 <yield+0xec>
   1764a:	b.n	17658 <yield+0x70>
   1764c:	adds	r4, #1
   1764e:	ldrb.w	r3, [r8]
   17652:	uxtb	r4, r4
   17654:	cmp	r3, r4
   17656:	bls.n	17680 <yield+0x98>
			s_serials_with_serial_events[i]->doYieldCode();
   17658:	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
   1765c:	ldr	r3, [r5, #0]
   1765e:	mov	r0, r5
   17660:	ldr	r3, [r3, #16]
   17662:	blx	r3
   17664:	cmp	r0, #0
   17666:	beq.n	1764c <yield+0x64>
   17668:	ldr	r3, [r5, #20]
   1766a:	ldr	r3, [r3, #8]
   1766c:	blx	r3
   1766e:	b.n	1764c <yield+0x64>
{
public:
	constexpr usb_seremu_class() {}
        void begin(long) { /* TODO: call a function that tries to wait for enumeration */ };
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
   17670:	bl	16460 <usb_seremu_available>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
   17674:	cbnz	r0, 176ac <yield+0xc4>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
   17676:	ldr	r3, [pc, #80]	; (176c8 <yield+0xe0>)
   17678:	ldrb	r3, [r3, #0]
   1767a:	cbnz	r3, 17684 <yield+0x9c>
   1767c:	ldrb	r3, [r6, #0]
   1767e:	b.n	17600 <yield+0x18>
   17680:	ldrb	r3, [r6, #0]
   17682:	b.n	17604 <yield+0x1c>
   17684:	ldrb	r3, [r6, #0]
   17686:	and.w	r3, r3, #254	; 0xfe
   1768a:	strb	r3, [r6, #0]
   1768c:	b.n	17600 <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
   1768e:	movs	r6, #1
		firstYield = first->_next;
   17690:	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
   17692:	strb	r6, [r4, #0]
		firstYield = first->_next;
   17694:	str	r5, [r3, #0]
		if (firstYield) {
   17696:	cbz	r5, 176b2 <yield+0xca>
			firstYield->_prev = nullptr;
   17698:	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
   1769a:	cbnz	r0, 1769e <yield+0xb6>
   1769c:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
   1769e:	movs	r5, #0
		(*(first->_function))(*first);
   176a0:	ldr	r3, [r2, #8]
   176a2:	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
   176a4:	strb	r5, [r2, #29]
		(*(first->_function))(*first);
   176a6:	blx	r3
		runningFromYield = false;
   176a8:	strb	r5, [r4, #0]
   176aa:	b.n	17618 <yield+0x30>
	running = 1;


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
		if (Serial.available()) serialEvent();
   176ac:	bl	17c04 <serialEvent()>
   176b0:	b.n	17676 <yield+0x8e>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
   176b2:	ldr	r3, [pc, #24]	; (176cc <yield+0xe4>)
   176b4:	str	r5, [r3, #0]
   176b6:	b.n	1769a <yield+0xb2>
   176b8:	.word	0x20020a84
   176bc:	.word	0x20058750
   176c0:	.word	0x20058760
   176c4:	.word	0x20058764
   176c8:	.word	0x60001852
   176cc:	.word	0x2005875c
   176d0:	.word	0x20058808
   176d4:	.word	0x200587ec

000176d8 <DMAChannel::begin(bool)>:
#warning "CR is defined as something?"
#endif


void DMAChannel::begin(bool force_initialization)
{
   176d8:	push	{r4, r5, r6, r7}
	uint32_t ch = 0;

	__disable_irq();
   176da:	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
   176dc:	cbnz	r1, 17702 <DMAChannel::begin(bool)+0x2a>
   176de:	ldr	r2, [r0, #0]
   176e0:	cbz	r2, 17702 <DMAChannel::begin(bool)+0x2a>
   176e2:	ldrb	r3, [r0, #4]
   176e4:	cmp	r3, #15
   176e6:	bhi.n	17702 <DMAChannel::begin(bool)+0x2a>
	  && (dma_channel_allocated_mask & (1 << channel))
   176e8:	ldr	r4, [pc, #124]	; (17768 <DMAChannel::begin(bool)+0x90>)
   176ea:	ldrh	r1, [r4, #0]
   176ec:	asr.w	r5, r1, r3
   176f0:	lsls	r5, r5, #31
   176f2:	bpl.n	17706 <DMAChannel::begin(bool)+0x2e>
	  && (uint32_t)TCD == (uint32_t)(0x400E9000 + channel * 32)) {
   176f4:	ldr	r5, [pc, #116]	; (1776c <DMAChannel::begin(bool)+0x94>)
   176f6:	add	r5, r3
   176f8:	cmp.w	r2, r5, lsl #5
   176fc:	bne.n	17706 <DMAChannel::begin(bool)+0x2e>
		// DMA channel already allocated
		__enable_irq();
   176fe:	cpsie	i
		return;
   17700:	b.n	17720 <DMAChannel::begin(bool)+0x48>
   17702:	ldr	r4, [pc, #100]	; (17768 <DMAChannel::begin(bool)+0x90>)
   17704:	ldrh	r1, [r4, #0]
#warning "CR is defined as something?"
#endif


void DMAChannel::begin(bool force_initialization)
{
   17706:	movs	r3, #0
		// DMA channel already allocated
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
   17708:	asr.w	r2, r1, r3
   1770c:	ands.w	r2, r2, #1
   17710:	beq.n	17724 <DMAChannel::begin(bool)+0x4c>
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
   17712:	adds	r3, #1
   17714:	cmp	r3, #16
   17716:	bne.n	17708 <DMAChannel::begin(bool)+0x30>
			__enable_irq();
   17718:	cpsie	i
			TCD = (TCD_t *)0;
   1771a:	movs	r2, #0
			channel = DMA_MAX_CHANNELS;
   1771c:	strb	r3, [r0, #4]
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
			__enable_irq();
			TCD = (TCD_t *)0;
   1771e:	str	r2, [r0, #0]
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
}
   17720:	pop	{r4, r5, r6, r7}
   17722:	bx	lr
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
   17724:	movs	r5, #1
   17726:	lsls	r5, r3
   17728:	orrs	r1, r5
   1772a:	strh	r1, [r4, #0]
			__enable_irq();
   1772c:	cpsie	i
			// attempts to use this object will hardfault
		}
	}
	channel = ch;

	CCM_CCGR5 |= CCM_CCGR5_DMA(CCM_CCGR_ON);
   1772e:	ldr	r6, [pc, #64]	; (17770 <DMAChannel::begin(bool)+0x98>)
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
   17730:	uxtb	r4, r3
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x400E9000 + ch * 32);
   17732:	ldr	r1, [pc, #56]	; (1776c <DMAChannel::begin(bool)+0x94>)
		}
	}
	channel = ch;

	CCM_CCGR5 |= CCM_CCGR5_DMA(CCM_CCGR_ON);
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
   17734:	movw	r7, #1154	; 0x482
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
   17738:	strb	r4, [r0, #4]
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x400E9000 + ch * 32);
   1773a:	add	r1, r3
			// attempts to use this object will hardfault
		}
	}
	channel = ch;

	CCM_CCGR5 |= CCM_CCGR5_DMA(CCM_CCGR_ON);
   1773c:	ldr	r5, [r6, #124]	; 0x7c
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x400E9000 + ch * 32);
   1773e:	lsls	r3, r1, #5
			// attempts to use this object will hardfault
		}
	}
	channel = ch;

	CCM_CCGR5 |= CCM_CCGR5_DMA(CCM_CCGR_ON);
   17740:	orr.w	r5, r5, #192	; 0xc0
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
   17744:	ldr	r1, [pc, #44]	; (17774 <DMAChannel::begin(bool)+0x9c>)
			// attempts to use this object will hardfault
		}
	}
	channel = ch;

	CCM_CCGR5 |= CCM_CCGR5_DMA(CCM_CCGR_ON);
   17746:	str	r5, [r6, #124]	; 0x7c
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
   17748:	str	r7, [r1, #0]
	DMA_CERQ = ch;
   1774a:	strb	r4, [r1, #26]
	DMA_CERR = ch;
   1774c:	strb	r4, [r1, #30]
	DMA_CEEI = ch;
   1774e:	strb	r4, [r1, #24]
	DMA_CINT = ch;
   17750:	strb	r4, [r1, #31]
	TCD = (TCD_t *)(0x400E9000 + ch * 32);
   17752:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
   17754:	str	r2, [r3, #0]
	*p++ = 0;
   17756:	str	r2, [r3, #4]
	*p++ = 0;
   17758:	str	r2, [r3, #8]
	*p++ = 0;
   1775a:	str	r2, [r3, #12]
	*p++ = 0;
   1775c:	str	r2, [r3, #16]
	*p++ = 0;
   1775e:	str	r2, [r3, #20]
	*p++ = 0;
   17760:	str	r2, [r3, #24]
	*p++ = 0;
   17762:	str	r2, [r3, #28]
}
   17764:	pop	{r4, r5, r6, r7}
   17766:	bx	lr
   17768:	.word	0x20058752
   1776c:	.word	0x02007480
   17770:	.word	0x400fc000
   17774:	.word	0x400e8000

00017778 <DMAChannel::release()>:

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
   17778:	ldrb	r3, [r0, #4]
   1777a:	cmp	r3, #15
   1777c:	bhi.n	177a0 <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
   1777e:	ldr	r2, [pc, #36]	; (177a4 <DMAChannel::release()+0x2c>)
   17780:	strb	r3, [r2, #26]
	__disable_irq();
   17782:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
   17784:	ldr	r1, [pc, #32]	; (177a8 <DMAChannel::release()+0x30>)
   17786:	movs	r3, #1
   17788:	ldrb	r2, [r0, #4]
   1778a:	lsl.w	r2, r3, r2
   1778e:	ldrh	r3, [r1, #0]
   17790:	bic.w	r3, r3, r2
   17794:	strh	r3, [r1, #0]
	__enable_irq();
   17796:	cpsie	i
	channel = DMA_MAX_CHANNELS;
   17798:	movs	r2, #16
	TCD = (TCD_t *)0;
   1779a:	movs	r3, #0
	if (channel >= DMA_MAX_CHANNELS) return;
	DMA_CERQ = channel;
	__disable_irq();
	dma_channel_allocated_mask &= ~(1 << channel);
	__enable_irq();
	channel = DMA_MAX_CHANNELS;
   1779c:	strb	r2, [r0, #4]
	TCD = (TCD_t *)0;
   1779e:	str	r3, [r0, #0]
   177a0:	bx	lr
   177a2:	nop
   177a4:	.word	0x400e8000
   177a8:	.word	0x20058752

000177ac <EventResponder::triggerEventNotImmediate()>:
uint8_t _serialEvent_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB1_default __attribute__((weak)) PROGMEM = 0 ;	
uint8_t _serialEventUSB2_default __attribute__((weak)) PROGMEM = 0 ;	

void EventResponder::triggerEventNotImmediate()
{
   177ac:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
   177ae:	mrs	r2, PRIMASK
		__disable_irq();
   177b2:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
   177b4:	ldrb	r3, [r0, #29]
   177b6:	cbnz	r3, 177c6 <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
   177b8:	ldrb	r1, [r0, #28]
   177ba:	cmp	r1, #1
   177bc:	beq.n	177d0 <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
   177be:	cmp	r1, #3
   177c0:	beq.n	177e4 <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
   177c2:	movs	r3, #1
   177c4:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
   177c6:	cbnz	r2, 177ca <EventResponder::triggerEventNotImmediate()+0x1e>
   177c8:	cpsie	i
	}
	enableInterrupts(irq);
}
   177ca:	ldr.w	r4, [sp], #4
   177ce:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
   177d0:	ldr	r4, [pc, #68]	; (17818 <EventResponder::triggerEventNotImmediate()+0x6c>)
   177d2:	ldr	r1, [r4, #0]
   177d4:	cbz	r1, 17800 <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
   177d6:	ldr	r1, [pc, #68]	; (1781c <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
   177d8:	str	r3, [r0, #20]
				_prev = lastYield;
   177da:	ldr	r3, [r1, #0]
				_prev->_next = this;
				lastYield = this;
   177dc:	str	r0, [r1, #0]
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
   177de:	str	r3, [r0, #24]
				_prev->_next = this;
   177e0:	str	r0, [r3, #20]
   177e2:	b.n	177c2 <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
   177e4:	ldr	r4, [pc, #56]	; (17820 <EventResponder::triggerEventNotImmediate()+0x74>)
   177e6:	ldr	r1, [r4, #0]
   177e8:	cbz	r1, 1780c <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
   177ea:	ldr	r1, [pc, #56]	; (17824 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
   177ec:	str	r3, [r0, #20]
				_prev = lastInterrupt;
   177ee:	ldr	r3, [r1, #0]
				_prev->_next = this;
				lastInterrupt = this;
   177f0:	str	r0, [r1, #0]
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
   177f2:	str	r3, [r0, #24]
				_prev->_next = this;
   177f4:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
   177f6:	ldr	r3, [pc, #48]	; (17828 <EventResponder::triggerEventNotImmediate()+0x7c>)
   177f8:	mov.w	r1, #268435456	; 0x10000000
   177fc:	str	r1, [r3, #0]
   177fe:	b.n	177c2 <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
   17800:	ldr	r3, [pc, #24]	; (1781c <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
   17802:	str	r1, [r0, #20]
				_prev = nullptr;
   17804:	str	r1, [r0, #24]
				firstYield = this;
   17806:	str	r0, [r4, #0]
				lastYield = this;
   17808:	str	r0, [r3, #0]
   1780a:	b.n	177c2 <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
   1780c:	ldr	r3, [pc, #20]	; (17824 <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
   1780e:	str	r1, [r0, #20]
				_prev = nullptr;
   17810:	str	r1, [r0, #24]
				firstInterrupt = this;
   17812:	str	r0, [r4, #0]
				lastInterrupt = this;
   17814:	str	r0, [r3, #0]
   17816:	b.n	177f6 <EventResponder::triggerEventNotImmediate()+0x4a>
   17818:	.word	0x20058760
   1781c:	.word	0x2005875c
   17820:	.word	0x20058754
   17824:	.word	0x20058758
   17828:	.word	0xe000ed04

0001782c <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
   1782c:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
   1782e:	mrs	r1, PRIMASK
		__disable_irq();
   17832:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
   17834:	ldr	r4, [pc, #48]	; (17868 <EventResponder::runFromInterrupt()+0x3c>)
   17836:	ldr	r3, [r4, #0]
		if (first) {
   17838:	cbz	r3, 1785e <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
   1783a:	ldr	r6, [pc, #48]	; (1786c <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
   1783c:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
   1783e:	ldr	r2, [r3, #20]
   17840:	str	r2, [r4, #0]
			if (firstInterrupt) {
   17842:	cbz	r2, 17864 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
   17844:	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
   17846:	cbnz	r1, 1784a <EventResponder::runFromInterrupt()+0x1e>
   17848:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
   1784a:	strb	r5, [r3, #29]
			(*(first->_function))(*first);
   1784c:	mov	r0, r3
   1784e:	ldr	r3, [r3, #8]
   17850:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
   17852:	mrs	r1, PRIMASK
		__disable_irq();
   17856:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
   17858:	ldr	r3, [r4, #0]
		if (first) {
   1785a:	cmp	r3, #0
   1785c:	bne.n	1783e <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
   1785e:	cbnz	r1, 17862 <EventResponder::runFromInterrupt()+0x36>
   17860:	cpsie	i
   17862:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
   17864:	str	r2, [r6, #0]
   17866:	b.n	17846 <EventResponder::runFromInterrupt()+0x1a>
   17868:	.word	0x20058754
   1786c:	.word	0x20058758

00017870 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
   17870:	b.w	1782c <EventResponder::runFromInterrupt()>

00017874 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
   17874:	ldr	r2, [pc, #16]	; (17888 <systick_isr+0x14>)
   17876:	ldr	r3, [pc, #20]	; (1788c <systick_isr+0x18>)
   17878:	ldr	r1, [r2, #0]
	systick_millis_count++;
   1787a:	ldr	r2, [pc, #20]	; (17890 <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
   1787c:	str	r1, [r3, #0]
	systick_millis_count++;
   1787e:	ldr	r3, [r2, #0]
   17880:	adds	r3, #1
   17882:	str	r3, [r2, #0]
   17884:	bx	lr
   17886:	nop
   17888:	.word	0xe0001004
   1788c:	.word	0x20058540
   17890:	.word	0x20058548

00017894 <usb_seremu_class::peek()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
   17894:	b.w	1641c <usb_seremu_peekchar>

00017898 <usb_seremu_class::read()>:
public:
	constexpr usb_seremu_class() {}
        void begin(long) { /* TODO: call a function that tries to wait for enumeration */ };
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
   17898:	b.w	163b4 <usb_seremu_getchar>

0001789c <usb_seremu_class::available()>:
{
public:
	constexpr usb_seremu_class() {}
        void begin(long) { /* TODO: call a function that tries to wait for enumeration */ };
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
   1789c:	b.w	16460 <usb_seremu_available>

000178a0 <usb_seremu_class::flush()>:
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
   178a0:	b.w	1669c <usb_seremu_flush_output>

000178a4 <usb_seremu_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
        size_t write(unsigned long n) { return write((uint8_t)n); }
        size_t write(long n) { return write((uint8_t)n); }
        size_t write(unsigned int n) { return write((uint8_t)n); }
        size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_seremu_write_buffer_free(); }
   178a4:	b.w	16698 <usb_seremu_write_buffer_free>

000178a8 <usb_seremu_class::write(unsigned char const*, unsigned int)>:
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_seremu_write(buffer, size); }
   178a8:	mov	r0, r1
   178aa:	mov	r1, r2
   178ac:	b.w	16680 <usb_seremu_write>

000178b0 <usb_seremu_class::write(unsigned char)>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_seremu_available(); }
        virtual int read() { return usb_seremu_getchar(); }
        virtual int peek() { return usb_seremu_peekchar(); }
        virtual void flush() { usb_seremu_flush_output(); }
        virtual size_t write(uint8_t c) { return usb_seremu_putchar(c); }
   178b0:	mov	r0, r1
   178b2:	b.w	16654 <usb_seremu_putchar>
   178b6:	nop

000178b8 <Print::write(unsigned char const*, unsigned int)>:

#include "debug/printf.h"
#undef printf

size_t Print::write(const uint8_t *buffer, size_t size)
{
   178b8:	push	{r3, r4, r5, r6, r7, lr}
	if (buffer == nullptr) return 0;
   178ba:	mov	r6, r1
   178bc:	cbz	r1, 178dc <Print::write(unsigned char const*, unsigned int)+0x24>
	size_t count = 0;
	while (size--) count += write(*buffer++);
   178be:	cbz	r2, 178e0 <Print::write(unsigned char const*, unsigned int)+0x28>
   178c0:	mov	r7, r0
   178c2:	mov	r4, r2
   178c4:	movs	r5, #0
   178c6:	ldr	r3, [r7, #0]
   178c8:	mov	r0, r7
   178ca:	ldrb.w	r1, [r6], #1
   178ce:	ldr	r3, [r3, #0]
   178d0:	blx	r3
   178d2:	subs	r4, #1
   178d4:	add	r5, r0
   178d6:	bne.n	178c6 <Print::write(unsigned char const*, unsigned int)+0xe>
   178d8:	mov	r0, r5
   178da:	pop	{r3, r4, r5, r6, r7, pc}
#include "debug/printf.h"
#undef printf

size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
   178dc:	mov	r0, r1
   178de:	pop	{r3, r4, r5, r6, r7, pc}
   178e0:	mov	r0, r2
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
   178e2:	pop	{r3, r4, r5, r6, r7, pc}

000178e4 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
   178e4:	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
   178e6:	ldr	r4, [pc, #24]	; (17900 <Print::println()+0x1c>)
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
   178e8:	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
   178ea:	ldr	r3, [r0, #0]
   178ec:	movs	r2, #2
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
   178ee:	ldrh	r4, [r4, #0]
	return write(buf, 2);
   178f0:	add	r1, sp, #4
   178f2:	ldr	r3, [r3, #4]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
   178f4:	strh.w	r4, [sp, #4]
	return write(buf, 2);
   178f8:	blx	r3
}
   178fa:	add	sp, #8
   178fc:	pop	{r4, pc}
   178fe:	nop
   17900:	.word	0x2001fe7c

00017904 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	return vdprintf((int)this, (const char *)format, ap);
#endif
}

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
   17904:	push	{r4, r5, r6, r7, lr}
   17906:	mov	r6, r0
   17908:	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
   1790a:	cmp	r2, #0
   1790c:	beq.n	17976 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
   1790e:	cmp	r2, #1
   17910:	it	eq
   17912:	moveq	r2, #10
	}


	if (n == 0) {
   17914:	cbz	r1, 1796c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
   17916:	movs	r5, #33	; 0x21
   17918:	b.n	1791c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
   1791a:	uxtb	r5, r7
   1791c:	subs	r7, r5, #1
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
   1791e:	udiv	r4, r1, r2
   17922:	mls	r1, r2, r4, r1
   17926:	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
   17928:	cmp	r1, #9
   1792a:	add.w	r1, r0, #55	; 0x37
   1792e:	add.w	r0, r0, #48	; 0x30
   17932:	it	hi
   17934:	uxtbhi	r0, r1
			n /= base;
			if (n == 0) break;
   17936:	mov	r1, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
   17938:	add	r4, sp, #40	; 0x28
   1793a:	it	ls
   1793c:	uxtbls	r0, r0
   1793e:	add	r4, r5
   17940:	strb.w	r0, [r4, #-36]
			n /= base;
			if (n == 0) break;
   17944:	cmp	r1, #0
   17946:	bne.n	1791a <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
   17948:	cbz	r3, 17958 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
   1794a:	subs	r5, #1
		buf[i] = '-';
   1794c:	add	r3, sp, #40	; 0x28
   1794e:	movs	r2, #45	; 0x2d
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
		i--;
   17950:	uxtb	r5, r5
		buf[i] = '-';
   17952:	add	r3, r5
   17954:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
   17958:	ldr	r3, [r6, #0]
   1795a:	add	r1, sp, #4
   1795c:	rsb	r2, r5, #34	; 0x22
   17960:	mov	r0, r6
   17962:	add	r1, r5
   17964:	ldr	r3, [r3, #4]
   17966:	blx	r3
}
   17968:	add	sp, #44	; 0x2c
   1796a:	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
   1796c:	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
   1796e:	movs	r5, #33	; 0x21
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
   17970:	strb.w	r2, [sp, #37]	; 0x25
   17974:	b.n	17948 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
   17976:	ldr	r3, [r0, #0]
   17978:	uxtb	r1, r1
   1797a:	ldr	r3, [r3, #0]
   1797c:	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
   1797e:	add	sp, #44	; 0x2c
   17980:	pop	{r4, r5, r6, r7, pc}
   17982:	nop

00017984 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
   17984:	cmp	r1, #0
   17986:	blt.n	17990 <Print::print(long)+0xc>
}


size_t Print::print(long n)
{
	uint8_t sign=0;
   17988:	movs	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
   1798a:	movs	r2, #10
   1798c:	b.w	17904 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
		n = -n;
   17990:	negs	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
   17992:	movs	r3, #45	; 0x2d
		n = -n;
	}
	return printNumber(n, 10, sign);
   17994:	movs	r2, #10
   17996:	b.w	17904 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
   1799a:	nop

0001799c <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
   1799c:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
   1799e:	bl	aac <setup>
	while (1) {
		loop();
   179a2:	bl	b34 <loop>
		yield();
   179a6:	bl	175e8 <yield>
   179aa:	b.n	179a2 <main+0x6>

000179ac <software_isr()>:
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
   179ac:	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
   179ae:	ldr	r3, [pc, #84]	; (17a04 <software_isr()+0x58>)

void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

	uint32_t totalcycles = ARM_DWT_CYCCNT;
   179b0:	ldr	r5, [pc, #84]	; (17a08 <software_isr()+0x5c>)
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
   179b2:	ldr	r4, [r3, #0]

void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

	uint32_t totalcycles = ARM_DWT_CYCCNT;
   179b4:	ldr	r6, [r5, #0]
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
   179b6:	cbnz	r4, 179be <software_isr()+0x12>
   179b8:	b.n	179e6 <software_isr()+0x3a>
   179ba:	ldr	r4, [r4, #20]
   179bc:	cbz	r4, 179e6 <software_isr()+0x3a>
		if (p->active) {
   179be:	ldrb	r3, [r4, #8]
   179c0:	cmp	r3, #0
   179c2:	beq.n	179ba <software_isr()+0xe>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
   179c4:	ldr	r3, [r4, #0]
   179c6:	mov	r0, r4

	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
   179c8:	ldr	r7, [r5, #0]
			p->update();
   179ca:	ldr	r3, [r3, #0]
   179cc:	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 6;
   179ce:	ldr	r3, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
   179d0:	ldrh	r1, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 6;
   179d2:	subs	r3, r3, r7
   179d4:	lsrs	r3, r3, #6
			p->cpu_cycles = cycles;
   179d6:	uxth	r2, r3
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
   179d8:	cmp	r3, r1
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 6;
			p->cpu_cycles = cycles;
   179da:	strh	r2, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
   179dc:	it	hi
   179de:	strhhi	r2, [r4, #6]
{
	AudioStream *p;

	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
   179e0:	ldr	r4, [r4, #20]
   179e2:	cmp	r4, #0
   179e4:	bne.n	179be <software_isr()+0x12>
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 6;
   179e6:	ldr	r3, [pc, #32]	; (17a08 <software_isr()+0x5c>)
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
   179e8:	ldr	r2, [pc, #32]	; (17a0c <software_isr()+0x60>)
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 6;
   179ea:	ldr	r3, [r3, #0]
	AudioStream::cpu_cycles_total = totalcycles;
	if (totalcycles > AudioStream::cpu_cycles_total_max)
   179ec:	ldrh	r0, [r2, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 6;
   179ee:	subs	r3, r3, r6
	AudioStream::cpu_cycles_total = totalcycles;
   179f0:	ldr	r4, [pc, #28]	; (17a10 <software_isr()+0x64>)
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 6;
   179f2:	lsrs	r3, r3, #6
	AudioStream::cpu_cycles_total = totalcycles;
   179f4:	uxth	r1, r3
	if (totalcycles > AudioStream::cpu_cycles_total_max)
   179f6:	cmp	r3, r0
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 6;
	AudioStream::cpu_cycles_total = totalcycles;
   179f8:	strh	r1, [r4, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
   179fa:	bls.n	179fe <software_isr()+0x52>
		AudioStream::cpu_cycles_total_max = totalcycles;
   179fc:	strh	r1, [r2, #0]

	asm("DSB");
   179fe:	dsb	sy
   17a02:	pop	{r3, r4, r5, r6, r7, pc}
   17a04:	.word	0x2005876c
   17a08:	.word	0xe0001004
   17a0c:	.word	0x20058768
   17a10:	.word	0x200587ea

00017a14 <AudioStream::allocate()>:
}

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_t * AudioStream::allocate(void)
{
   17a14:	push	{r4, r5, r6, r7}
	audio_block_t *block;
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
   17a16:	cpsid	i
	index = memory_pool_first_mask;
   17a18:	ldr	r7, [pc, #140]	; (17aa8 <AudioStream::allocate()+0x94>)
	p += index;
   17a1a:	ldr	r6, [pc, #144]	; (17aac <AudioStream::allocate()+0x98>)
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
   17a1c:	ldrh	r4, [r7, #0]
	p += index;
	while (1) {
		if (p >= end) {
   17a1e:	add.w	r3, r6, #112	; 0x70

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
   17a22:	add.w	r0, r6, r4, lsl #2
	while (1) {
		if (p >= end) {
   17a26:	cmp	r0, r3
   17a28:	bcs.n	17a52 <AudioStream::allocate()+0x3e>
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
   17a2a:	ldr.w	r1, [r6, r4, lsl #2]
		if (avail) break;
   17a2e:	cbnz	r1, 17a5a <AudioStream::allocate()+0x46>
   17a30:	adds	r2, r0, #4
   17a32:	add.w	r5, r6, #115	; 0x73
   17a36:	adds	r3, r4, #1
   17a38:	subs	r5, r5, r2
   17a3a:	add.w	r5, r3, r5, lsr #2
   17a3e:	b.n	17a46 <AudioStream::allocate()+0x32>
		if (p >= end) {
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
   17a40:	ldr.w	r1, [r2], #4
		if (avail) break;
   17a44:	cbnz	r1, 17a5a <AudioStream::allocate()+0x46>
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
		if (p >= end) {
   17a46:	cmp	r3, r5
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
		if (avail) break;
		index++;
   17a48:	mov	r4, r3
		p++;
   17a4a:	mov	r0, r2
   17a4c:	add.w	r3, r3, #1
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
		if (p >= end) {
   17a50:	bne.n	17a40 <AudioStream::allocate()+0x2c>
			__enable_irq();
   17a52:	cpsie	i
			//Serial.println("alloc:null");
			return NULL;
   17a54:	movs	r0, #0
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
   17a56:	pop	{r4, r5, r6, r7}
   17a58:	bx	lr
		avail = *p;
		if (avail) break;
		index++;
		p++;
	}
	n = __builtin_clz(avail);
   17a5a:	clz	r2, r1
	avail &= ~(0x80000000 >> n);
   17a5e:	mov.w	r3, #2147483648	; 0x80000000
   17a62:	lsrs	r3, r2
   17a64:	bic.w	r1, r1, r3
	*p = avail;
   17a68:	str	r1, [r0, #0]
	if (!avail) index++;
   17a6a:	cbnz	r1, 17a6e <AudioStream::allocate()+0x5a>
   17a6c:	adds	r4, #1
	memory_pool_first_mask = index;
	used = memory_used + 1;
   17a6e:	ldr	r3, [pc, #64]	; (17ab0 <AudioStream::allocate()+0x9c>)
	}
	n = __builtin_clz(avail);
	avail &= ~(0x80000000 >> n);
	*p = avail;
	if (!avail) index++;
	memory_pool_first_mask = index;
   17a70:	strh	r4, [r7, #0]
	used = memory_used + 1;
   17a72:	ldrh	r1, [r3, #0]
   17a74:	adds	r1, #1
	memory_used = used;
   17a76:	uxth	r5, r1
   17a78:	strh	r5, [r3, #0]
	__enable_irq();
   17a7a:	cpsie	i
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
   17a7c:	subs	r0, r0, r6
   17a7e:	movw	r3, #8060	; 0x1f7c
   17a82:	ldr	r4, [pc, #48]	; (17ab4 <AudioStream::allocate()+0xa0>)
	block->ref_count = 1;
   17a84:	movs	r7, #1
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
   17a86:	asrs	r0, r0, #2
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
   17a88:	ldr	r6, [pc, #44]	; (17ab8 <AudioStream::allocate()+0xa4>)
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
   17a8a:	ldr	r4, [r4, #0]
   17a8c:	rsb	r2, r2, r0, lsl #5
   17a90:	add.w	r2, r2, r2, lsl #6
   17a94:	lsls	r2, r2, #2
   17a96:	add	r3, r2
	block->ref_count = 1;
   17a98:	strb	r7, [r4, r3]
	memory_pool_first_mask = index;
	used = memory_used + 1;
	memory_used = used;
	__enable_irq();
	index = p - memory_pool_available_mask;
	block = memory_pool + ((index << 5) + (31 - n));
   17a9a:	adds	r0, r4, r3
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
   17a9c:	ldrh	r3, [r6, #0]
   17a9e:	cmp	r1, r3
   17aa0:	it	hi
   17aa2:	strhhi	r5, [r6, #0]
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
   17aa4:	pop	{r4, r5, r6, r7}
   17aa6:	bx	lr
   17aa8:	.word	0x200587e6
   17aac:	.word	0x20058770
   17ab0:	.word	0x200587e8
   17ab4:	.word	0x200587e0
   17ab8:	.word	0x20058766

00017abc <AudioStream::release(audio_block_struct*)>:
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
   17abc:	ldrh	r2, [r0, #2]
	uint32_t index = block->memory_pool_index >> 5;

	__disable_irq();
   17abe:	cpsid	i
	if (block->ref_count > 1) {
   17ac0:	ldrb	r3, [r0, #0]
   17ac2:	cmp	r3, #1
   17ac4:	bls.n	17ace <AudioStream::release(audio_block_struct*)+0x12>
		block->ref_count--;
   17ac6:	subs	r3, #1
   17ac8:	strb	r3, [r0, #0]
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
		memory_used--;
	}
	__enable_irq();
   17aca:	cpsie	i
   17acc:	bx	lr
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
   17ace:	mvns	r1, r2
   17ad0:	mov.w	r0, #2147483648	; 0x80000000
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
	uint32_t index = block->memory_pool_index >> 5;
   17ad4:	asrs	r2, r2, #5
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
   17ad6:	and.w	r1, r1, #31

// Release ownership of a data block.  If no
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
   17ada:	push	{r4, r5}
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
   17adc:	ldr	r4, [pc, #36]	; (17b04 <AudioStream::release(audio_block_struct*)+0x48>)
   17ade:	lsr.w	r1, r0, r1
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
   17ae2:	ldr	r5, [pc, #36]	; (17b08 <AudioStream::release(audio_block_struct*)+0x4c>)
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
   17ae4:	ldr.w	r3, [r4, r2, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
   17ae8:	ldrh	r0, [r5, #0]
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
   17aea:	orrs	r3, r1
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
   17aec:	cmp	r2, r0
	if (block->ref_count > 1) {
		block->ref_count--;
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
   17aee:	str.w	r3, [r4, r2, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
   17af2:	it	cc
   17af4:	strhcc	r2, [r5, #0]
		memory_used--;
   17af6:	ldr	r2, [pc, #20]	; (17b0c <AudioStream::release(audio_block_struct*)+0x50>)
   17af8:	ldrh	r3, [r2, #0]
   17afa:	subs	r3, #1
   17afc:	strh	r3, [r2, #0]
	}
	__enable_irq();
   17afe:	cpsie	i
}
   17b00:	pop	{r4, r5}
   17b02:	bx	lr
   17b04:	.word	0x20058770
   17b08:	.word	0x200587e6
   17b0c:	.word	0x200587e8

00017b10 <AudioStream::transmit(audio_block_struct*, unsigned char)>:
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
   17b10:	ldr	r3, [r0, #12]
   17b12:	cbz	r3, 17b42 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x32>
// owned by this object.  Normally, a block must be released
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
   17b14:	push	{r4, r5}
   17b16:	b.n	17b1c <AudioStream::transmit(audio_block_struct*, unsigned char)+0xc>
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
   17b18:	ldr	r3, [r3, #12]
   17b1a:	cbz	r3, 17b40 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x30>
		if (c->src_index == index) {
   17b1c:	ldrb	r0, [r3, #8]
   17b1e:	cmp	r0, r2
   17b20:	bne.n	17b18 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x8>
			if (c->dst.inputQueue[c->dest_index] == NULL) {
   17b22:	ldr	r0, [r3, #4]
   17b24:	ldrb	r4, [r3, #9]
   17b26:	ldr	r0, [r0, #16]
   17b28:	ldr.w	r5, [r0, r4, lsl #2]
   17b2c:	cmp	r5, #0
   17b2e:	bne.n	17b18 <AudioStream::transmit(audio_block_struct*, unsigned char)+0x8>
				c->dst.inputQueue[c->dest_index] = block;
   17b30:	str.w	r1, [r0, r4, lsl #2]
				block->ref_count++;
   17b34:	ldrb	r0, [r1, #0]
   17b36:	adds	r0, #1
   17b38:	strb	r0, [r1, #0]
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream::transmit(audio_block_t *block, unsigned char index)
{
	for (AudioConnection *c = destination_list; c != NULL; c = c->next_dest) {
   17b3a:	ldr	r3, [r3, #12]
   17b3c:	cmp	r3, #0
   17b3e:	bne.n	17b1c <AudioStream::transmit(audio_block_struct*, unsigned char)+0xc>
				c->dst.inputQueue[c->dest_index] = block;
				block->ref_count++;
			}
		}
	}
}
   17b40:	pop	{r4, r5}
   17b42:	bx	lr

00017b44 <AudioStream::receiveReadOnly(unsigned int)>:
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
   17b44:	ldrb	r3, [r0, #9]
   17b46:	cmp	r3, r1
   17b48:	bls.n	17b58 <AudioStream::receiveReadOnly(unsigned int)+0x14>
	in = inputQueue[index];
   17b4a:	ldr	r3, [r0, #16]
	inputQueue[index] = NULL;
   17b4c:	movs	r2, #0
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
	in = inputQueue[index];
   17b4e:	ldr.w	r0, [r3, r1, lsl #2]
	inputQueue[index] = NULL;
   17b52:	str.w	r2, [r3, r1, lsl #2]
	return in;
   17b56:	bx	lr
// may be shared with other streams, so it must not be written
audio_block_t * AudioStream::receiveReadOnly(unsigned int index)
{
	audio_block_t *in;

	if (index >= num_inputs) return NULL;
   17b58:	movs	r0, #0
	in = inputQueue[index];
	inputQueue[index] = NULL;
	return in;
}
   17b5a:	bx	lr

00017b5c <AudioConnection::connect()>:

void AudioConnection::connect(void)
{
	AudioConnection *p;

	if (isConnected) return;
   17b5c:	ldrb	r3, [r0, #16]
   17b5e:	cbnz	r3, 17baa <AudioConnection::connect()+0x4e>
	if (dest_index > dst.num_inputs) return;
   17b60:	ldr	r3, [r0, #4]
   17b62:	ldrb	r2, [r0, #9]
   17b64:	ldrb	r3, [r3, #9]
   17b66:	cmp	r2, r3
   17b68:	bhi.n	17baa <AudioConnection::connect()+0x4e>
	return in;
}


void AudioConnection::connect(void)
{
   17b6a:	push	{r4, r5}
	AudioConnection *p;

	if (isConnected) return;
	if (dest_index > dst.num_inputs) return;
	__disable_irq();
   17b6c:	cpsid	i
	p = src.destination_list;
   17b6e:	ldr	r4, [r0, #0]
   17b70:	ldr	r3, [r4, #12]
	if (p == NULL) {
   17b72:	cbz	r3, 17bc0 <AudioConnection::connect()+0x64>
		src.destination_list = this;
	} else {
		while (p->next_dest) {
   17b74:	ldr	r2, [r3, #12]
   17b76:	cbz	r2, 17b86 <AudioConnection::connect()+0x2a>
			if (&p->src == &this->src && &p->dst == &this->dst
   17b78:	ldr	r1, [r3, #0]
   17b7a:	cmp	r4, r1
   17b7c:	beq.n	17bac <AudioConnection::connect()+0x50>
	return in;
}


void AudioConnection::connect(void)
{
   17b7e:	mov	r3, r2
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
   17b80:	ldr	r2, [r3, #12]
   17b82:	cmp	r2, #0
   17b84:	bne.n	17b78 <AudioConnection::connect()+0x1c>
				__enable_irq();
				return;
			}
			p = p->next_dest;
		}
		p->next_dest = this;
   17b86:	str	r0, [r3, #12]
	}
	this->next_dest = NULL;
   17b88:	movs	r2, #0
	src.numConnections++;
	src.active = true;
   17b8a:	movs	r3, #1
			}
			p = p->next_dest;
		}
		p->next_dest = this;
	}
	this->next_dest = NULL;
   17b8c:	str	r2, [r0, #12]
	src.numConnections++;
   17b8e:	ldrb	r2, [r4, #10]
   17b90:	add	r2, r3
   17b92:	strb	r2, [r4, #10]
	src.active = true;
   17b94:	ldr	r2, [r0, #0]

	dst.numConnections++;
   17b96:	ldr	r1, [r0, #4]
		}
		p->next_dest = this;
	}
	this->next_dest = NULL;
	src.numConnections++;
	src.active = true;
   17b98:	strb	r3, [r2, #8]

	dst.numConnections++;
   17b9a:	ldrb	r2, [r1, #10]
   17b9c:	add	r2, r3
   17b9e:	strb	r2, [r1, #10]
	dst.active = true;
   17ba0:	ldr	r2, [r0, #4]
   17ba2:	strb	r3, [r2, #8]

	isConnected = true;
   17ba4:	strb	r3, [r0, #16]

	__enable_irq();
   17ba6:	cpsie	i
}
   17ba8:	pop	{r4, r5}
   17baa:	bx	lr
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
	} else {
		while (p->next_dest) {
			if (&p->src == &this->src && &p->dst == &this->dst
   17bac:	ldr	r5, [r3, #4]
   17bae:	ldr	r1, [r0, #4]
   17bb0:	cmp	r5, r1
   17bb2:	bne.n	17b7e <AudioConnection::connect()+0x22>
				&& p->src_index == this->src_index && p->dest_index == this->dest_index) {
   17bb4:	ldrh	r1, [r3, #8]
   17bb6:	ldrh	r3, [r0, #8]
   17bb8:	cmp	r1, r3
   17bba:	beq.n	17ba6 <AudioConnection::connect()+0x4a>
	return in;
}


void AudioConnection::connect(void)
{
   17bbc:	mov	r3, r2
   17bbe:	b.n	17b80 <AudioConnection::connect()+0x24>
	if (isConnected) return;
	if (dest_index > dst.num_inputs) return;
	__disable_irq();
	p = src.destination_list;
	if (p == NULL) {
		src.destination_list = this;
   17bc0:	str	r0, [r4, #12]
   17bc2:	b.n	17b88 <AudioConnection::connect()+0x2c>

00017bc4 <AudioStream::update_setup()>:
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
   17bc4:	ldr	r3, [pc, #40]	; (17bf0 <AudioStream::update_setup()+0x2c>)
   17bc6:	ldrb	r2, [r3, #0]
   17bc8:	cbnz	r2, 17bea <AudioStream::update_setup()+0x26>
#define DMA_NUM_CHANNELS        32

#ifdef __cplusplus
extern "C" void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
   17bca:	ldr	r2, [pc, #40]	; (17bf4 <AudioStream::update_setup()+0x30>)
   17bcc:	ldr	r1, [pc, #40]	; (17bf8 <AudioStream::update_setup()+0x34>)
// input and output based on interrupts, must check this variable in
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
   17bce:	push	{r4, r5}
   17bd0:	str.w	r1, [r2, #344]	; 0x158
	if (update_scheduled) return false;
	attachInterruptVector(IRQ_SOFTWARE, software_isr);
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
   17bd4:	ldr	r4, [pc, #36]	; (17bfc <AudioStream::update_setup()+0x38>)
   17bd6:	movs	r5, #208	; 0xd0
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
   17bd8:	movs	r0, #64	; 0x40
	update_scheduled = true;
   17bda:	movs	r2, #1
bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
	attachInterruptVector(IRQ_SOFTWARE, software_isr);
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
   17bdc:	ldr	r1, [pc, #32]	; (17c00 <AudioStream::update_setup()+0x3c>)

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
	attachInterruptVector(IRQ_SOFTWARE, software_isr);
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
   17bde:	strb	r5, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
   17be0:	str	r0, [r1, #0]
	update_scheduled = true;
	return true;
   17be2:	mov	r0, r2
{
	if (update_scheduled) return false;
	attachInterruptVector(IRQ_SOFTWARE, software_isr);
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
	update_scheduled = true;
   17be4:	strb	r2, [r3, #0]
	return true;
}
   17be6:	pop	{r4, r5}
   17be8:	bx	lr
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
   17bea:	movs	r0, #0
   17bec:	bx	lr
   17bee:	nop
   17bf0:	.word	0x200587e4
   17bf4:	.word	0x2005a400
   17bf8:	.word	0x000179ad
   17bfc:	.word	0xe000e446
   17c00:	.word	0xe000e108

00017c04 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
   17c04:	bx	lr
   17c06:	nop

00017c08 <operator new(unsigned int)>:
   17c08:	b.w	1aa98 <malloc>

00017c0c <operator new[](unsigned int)>:
	return malloc(size);
}

void * operator new[](size_t size)
{
	return malloc(size);
   17c0c:	b.w	1aa98 <malloc>

00017c10 <arm_biquad_cascade_df1_init_f32>:
   17c10:	push	{r3, r4, r5, lr}
   17c12:	mov	r4, r0
   17c14:	mov	r0, r1
   17c16:	mov	r5, r3
   17c18:	movs	r1, #0
   17c1a:	str	r2, [r4, #8]
   17c1c:	lsls	r2, r0, #4
   17c1e:	str	r0, [r4, #0]
   17c20:	mov	r0, r3
   17c22:	bl	1b018 <memset>
   17c26:	str	r5, [r4, #4]
   17c28:	pop	{r3, r4, r5, pc}
   17c2a:	nop

00017c2c <arm_biquad_cascade_df1_f32>:
   17c2c:	mov.w	ip, r3, lsr #2
   17c30:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   17c34:	mov	lr, r2
   17c36:	ldr	r6, [r0, #8]
   17c38:	ldr	r5, [r0, #4]
   17c3a:	mov.w	r8, ip, lsl #4
   17c3e:	and.w	r2, r3, #3
   17c42:	adds	r6, #20
   17c44:	adds	r5, #16
   17c46:	ldr	r7, [r0, #0]
   17c48:	add.w	r9, lr, r8
   17c4c:	vldr	s7, [r6, #-20]	; 0xffffffec
   17c50:	vldr	s6, [r6, #-16]
   17c54:	vldr	s5, [r6, #-12]
   17c58:	vldr	s4, [r6, #-8]
   17c5c:	vldr	s3, [r6, #-4]
   17c60:	vldr	s2, [r5, #-16]
   17c64:	vldr	s1, [r5, #-12]
   17c68:	vldr	s15, [r5, #-8]
   17c6c:	vldr	s12, [r5, #-4]
   17c70:	cmp.w	ip, #0
   17c74:	beq.w	17dbe <arm_biquad_cascade_df1_f32+0x192>
   17c78:	add.w	r0, r1, #16
   17c7c:	add.w	r3, lr, #16
   17c80:	mov	r4, ip
   17c82:	vldr	s8, [r0, #-16]
   17c86:	vmul.f32	s14, s6, s2
   17c8a:	vmul.f32	s1, s5, s1
   17c8e:	subs	r4, #1
   17c90:	vmul.f32	s10, s7, s8
   17c94:	add.w	r0, r0, #16
   17c98:	vmul.f32	s0, s4, s15
   17c9c:	add.w	r3, r3, #16
   17ca0:	vmul.f32	s12, s3, s12
   17ca4:	vadd.f32	s9, s10, s14
   17ca8:	vmul.f32	s13, s3, s15
   17cac:	vmul.f32	s11, s6, s8
   17cb0:	vadd.f32	s14, s9, s1
   17cb4:	vmul.f32	s2, s5, s2
   17cb8:	vmul.f32	s8, s5, s8
   17cbc:	vadd.f32	s14, s14, s0
   17cc0:	vadd.f32	s12, s14, s12
   17cc4:	vstr	s12, [r3, #-32]	; 0xffffffe0
   17cc8:	vmul.f32	s14, s4, s12
   17ccc:	vldr	s15, [r0, #-28]	; 0xffffffe4
   17cd0:	vmul.f32	s12, s3, s12
   17cd4:	vmul.f32	s10, s7, s15
   17cd8:	vmul.f32	s0, s6, s15
   17cdc:	vmul.f32	s9, s5, s15
   17ce0:	vadd.f32	s10, s10, s11
   17ce4:	vadd.f32	s11, s10, s2
   17ce8:	vadd.f32	s11, s11, s14
   17cec:	vadd.f32	s13, s11, s13
   17cf0:	vstr	s13, [r3, #-28]	; 0xffffffe4
   17cf4:	vmul.f32	s15, s4, s13
   17cf8:	vldr	s1, [r0, #-24]	; 0xffffffe8
   17cfc:	vmul.f32	s11, s3, s13
   17d00:	vmul.f32	s10, s7, s1
   17d04:	vmul.f32	s14, s6, s1
   17d08:	vadd.f32	s10, s10, s0
   17d0c:	vadd.f32	s13, s10, s8
   17d10:	vadd.f32	s13, s13, s15
   17d14:	vadd.f32	s12, s13, s12
   17d18:	vstr	s12, [r3, #-24]	; 0xffffffe8
   17d1c:	vmul.f32	s15, s4, s12
   17d20:	vldr	s2, [r0, #-20]	; 0xffffffec
   17d24:	vmul.f32	s13, s7, s2
   17d28:	vadd.f32	s14, s13, s14
   17d2c:	vadd.f32	s14, s14, s9
   17d30:	vadd.f32	s15, s14, s15
   17d34:	vadd.f32	s15, s11, s15
   17d38:	vstr	s15, [r3, #-20]	; 0xffffffec
   17d3c:	bne.n	17c82 <arm_biquad_cascade_df1_f32+0x56>
   17d3e:	add	r1, r8
   17d40:	mov	r0, r9
   17d42:	cbz	r2, 17dac <arm_biquad_cascade_df1_f32+0x180>
   17d44:	mov	r3, r2
   17d46:	b.n	17d50 <arm_biquad_cascade_df1_f32+0x124>
   17d48:	vmov.f32	s15, s10
   17d4c:	vmov.f32	s2, s14
   17d50:	vldmia	r1!, {s14}
   17d54:	vmul.f32	s9, s6, s2
   17d58:	vmul.f32	s11, s5, s1
   17d5c:	subs	r3, #1
   17d5e:	vmul.f32	s8, s7, s14
   17d62:	vmul.f32	s10, s4, s15
   17d66:	vmul.f32	s13, s3, s12
   17d6a:	vadd.f32	s9, s8, s9
   17d6e:	vmov.f32	s1, s2
   17d72:	vmov.f32	s12, s15
   17d76:	vadd.f32	s9, s9, s11
   17d7a:	vadd.f32	s10, s9, s10
   17d7e:	vadd.f32	s10, s10, s13
   17d82:	vstmia	r0!, {s10}
   17d86:	bne.n	17d48 <arm_biquad_cascade_df1_f32+0x11c>
   17d88:	subs	r7, #1
   17d8a:	vstr	s14, [r5, #-16]
   17d8e:	vstr	s2, [r5, #-12]
   17d92:	add.w	r6, r6, #20
   17d96:	vstr	s10, [r5, #-8]
   17d9a:	mov	r1, lr
   17d9c:	vstr	s15, [r5, #-4]
   17da0:	add.w	r5, r5, #16
   17da4:	bne.w	17c4c <arm_biquad_cascade_df1_f32+0x20>
   17da8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   17dac:	vmov.f32	s10, s15
   17db0:	vmov.f32	s14, s2
   17db4:	vmov.f32	s15, s12
   17db8:	vmov.f32	s2, s1
   17dbc:	b.n	17d88 <arm_biquad_cascade_df1_f32+0x15c>
   17dbe:	mov	r0, lr
   17dc0:	b.n	17d42 <arm_biquad_cascade_df1_f32+0x116>
   17dc2:	nop

00017dc4 <arm_scale_f32>:
   17dc4:	push	{r4, r5, r6}
   17dc6:	lsrs	r6, r2, #2
   17dc8:	beq.n	17e16 <arm_scale_f32+0x52>
   17dca:	add.w	r4, r0, #16
   17dce:	add.w	r3, r1, #16
   17dd2:	mov	r5, r6
   17dd4:	vldr	s12, [r4, #-16]
   17dd8:	subs	r5, #1
   17dda:	vldr	s13, [r4, #-12]
   17dde:	add.w	r3, r3, #16
   17de2:	vldr	s14, [r4, #-8]
   17de6:	vmul.f32	s12, s12, s0
   17dea:	vldr	s15, [r4, #-4]
   17dee:	vmul.f32	s13, s13, s0
   17df2:	vmul.f32	s14, s0, s14
   17df6:	add.w	r4, r4, #16
   17dfa:	vmul.f32	s15, s0, s15
   17dfe:	vstr	s12, [r3, #-32]	; 0xffffffe0
   17e02:	vstr	s13, [r3, #-28]	; 0xffffffe4
   17e06:	vstr	s14, [r3, #-24]	; 0xffffffe8
   17e0a:	vstr	s15, [r3, #-20]	; 0xffffffec
   17e0e:	bne.n	17dd4 <arm_scale_f32+0x10>
   17e10:	lsls	r6, r6, #4
   17e12:	add	r0, r6
   17e14:	add	r1, r6
   17e16:	ands.w	r2, r2, #3
   17e1a:	beq.n	17e2c <arm_scale_f32+0x68>
   17e1c:	vldmia	r0!, {s15}
   17e20:	subs	r2, #1
   17e22:	vmul.f32	s15, s15, s0
   17e26:	vstmia	r1!, {s15}
   17e2a:	bne.n	17e1c <arm_scale_f32+0x58>
   17e2c:	pop	{r4, r5, r6}
   17e2e:	bx	lr

00017e30 <arm_add_f32>:
   17e30:	push	{r4, r5, r6, r7, lr}
   17e32:	movs.w	lr, r3, lsr #2
   17e36:	beq.n	17ea0 <arm_add_f32+0x70>
   17e38:	add.w	r6, r0, #16
   17e3c:	add.w	r5, r1, #16
   17e40:	add.w	r4, r2, #16
   17e44:	mov	r7, lr
   17e46:	vldr	s14, [r6, #-12]
   17e4a:	subs	r7, #1
   17e4c:	vldr	s15, [r6, #-8]
   17e50:	add.w	r5, r5, #16
   17e54:	vldr	s12, [r5, #-28]	; 0xffffffe4
   17e58:	add.w	r6, r6, #16
   17e5c:	vldr	s13, [r5, #-24]	; 0xffffffe8
   17e60:	add.w	r4, r4, #16
   17e64:	vldr	s10, [r5, #-20]	; 0xffffffec
   17e68:	vadd.f32	s12, s14, s12
   17e6c:	vldr	s11, [r5, #-32]	; 0xffffffe0
   17e70:	vadd.f32	s13, s15, s13
   17e74:	vldr	s14, [r6, #-20]	; 0xffffffec
   17e78:	vldr	s15, [r6, #-32]	; 0xffffffe0
   17e7c:	vadd.f32	s14, s14, s10
   17e80:	vstr	s12, [r4, #-28]	; 0xffffffe4
   17e84:	vadd.f32	s15, s15, s11
   17e88:	vstr	s13, [r4, #-24]	; 0xffffffe8
   17e8c:	vstr	s14, [r4, #-20]	; 0xffffffec
   17e90:	vstr	s15, [r4, #-32]	; 0xffffffe0
   17e94:	bne.n	17e46 <arm_add_f32+0x16>
   17e96:	mov.w	r4, lr, lsl #4
   17e9a:	add	r0, r4
   17e9c:	add	r1, r4
   17e9e:	add	r2, r4
   17ea0:	ands.w	r3, r3, #3
   17ea4:	beq.n	17eba <arm_add_f32+0x8a>
   17ea6:	vldmia	r0!, {s15}
   17eaa:	subs	r3, #1
   17eac:	vldmia	r1!, {s14}
   17eb0:	vadd.f32	s15, s15, s14
   17eb4:	vstmia	r2!, {s15}
   17eb8:	bne.n	17ea6 <arm_add_f32+0x76>
   17eba:	pop	{r4, r5, r6, r7, pc}
   17ebc:	movs	r0, r0
	...

00017ec0 <sin>:
   17ec0:	push	{lr}
   17ec2:	vmov.f64	d7, d0
   17ec6:	vmov	r3, s15
   17eca:	ldr	r2, [pc, #140]	; (17f58 <sin+0x98>)
   17ecc:	bic.w	r3, r3, #2147483648	; 0x80000000
   17ed0:	cmp	r3, r2
   17ed2:	sub	sp, #20
   17ed4:	ble.n	17f0c <sin+0x4c>
   17ed6:	ldr	r2, [pc, #132]	; (17f5c <sin+0x9c>)
   17ed8:	cmp	r3, r2
   17eda:	ble.n	17ee6 <sin+0x26>
   17edc:	vsub.f64	d0, d0, d0
   17ee0:	add	sp, #20
   17ee2:	ldr.w	pc, [sp], #4
   17ee6:	mov	r0, sp
   17ee8:	bl	184a8 <__ieee754_rem_pio2>
   17eec:	and.w	r0, r0, #3
   17ef0:	cmp	r0, #1
   17ef2:	beq.n	17f30 <sin+0x70>
   17ef4:	cmp	r0, #2
   17ef6:	beq.n	17f1c <sin+0x5c>
   17ef8:	cbz	r0, 17f3e <sin+0x7e>
   17efa:	vldr	d1, [sp, #8]
   17efe:	vldr	d0, [sp]
   17f02:	bl	19230 <__kernel_cos>
   17f06:	vneg.f64	d0, d0
   17f0a:	b.n	17ee0 <sin+0x20>
   17f0c:	movs	r0, #0
   17f0e:	vldr	d1, [pc, #64]	; 17f50 <sin+0x90>
   17f12:	bl	199d0 <__kernel_sin>
   17f16:	add	sp, #20
   17f18:	ldr.w	pc, [sp], #4
   17f1c:	movs	r0, #1
   17f1e:	vldr	d1, [sp, #8]
   17f22:	vldr	d0, [sp]
   17f26:	bl	199d0 <__kernel_sin>
   17f2a:	vneg.f64	d0, d0
   17f2e:	b.n	17ee0 <sin+0x20>
   17f30:	vldr	d1, [sp, #8]
   17f34:	vldr	d0, [sp]
   17f38:	bl	19230 <__kernel_cos>
   17f3c:	b.n	17ee0 <sin+0x20>
   17f3e:	movs	r0, #1
   17f40:	vldr	d1, [sp, #8]
   17f44:	vldr	d0, [sp]
   17f48:	bl	199d0 <__kernel_sin>
   17f4c:	b.n	17ee0 <sin+0x20>
   17f4e:	nop
	...
   17f58:	.word	0x3fe921fb
   17f5c:	.word	0x7fefffff

00017f60 <tanf>:
   17f60:	push	{lr}
   17f62:	vmov	r3, s0
   17f66:	ldr	r2, [pc, #76]	; (17fb4 <tanf+0x54>)
   17f68:	bic.w	r3, r3, #2147483648	; 0x80000000
   17f6c:	cmp	r3, r2
   17f6e:	sub	sp, #12
   17f70:	ble.n	17fa4 <tanf+0x44>
   17f72:	cmp.w	r3, #2139095040	; 0x7f800000
   17f76:	blt.n	17f82 <tanf+0x22>
   17f78:	vsub.f32	s0, s0, s0
   17f7c:	add	sp, #12
   17f7e:	ldr.w	pc, [sp], #4
   17f82:	mov	r0, sp
   17f84:	bl	18ef0 <__ieee754_rem_pio2f>
   17f88:	lsls	r0, r0, #1
   17f8a:	and.w	r0, r0, #2
   17f8e:	rsb	r0, r0, #1
   17f92:	vldr	s1, [sp, #4]
   17f96:	vldr	s0, [sp]
   17f9a:	bl	1a0b0 <__kernel_tanf>
   17f9e:	add	sp, #12
   17fa0:	ldr.w	pc, [sp], #4
   17fa4:	movs	r0, #1
   17fa6:	vldr	s1, [pc, #16]	; 17fb8 <tanf+0x58>
   17faa:	bl	1a0b0 <__kernel_tanf>
   17fae:	add	sp, #12
   17fb0:	ldr.w	pc, [sp], #4
   17fb4:	.word	0x3f490fda
   17fb8:	.word	0x00000000

00017fbc <tanhf>:
   17fbc:	push	{r4, lr}
   17fbe:	sub	sp, #8
   17fc0:	vstr	s0, [sp, #4]
   17fc4:	ldr	r4, [sp, #4]
   17fc6:	bic.w	r3, r4, #2147483648	; 0x80000000
   17fca:	cmp.w	r3, #2139095040	; 0x7f800000
   17fce:	blt.n	17fec <tanhf+0x30>
   17fd0:	vldr	s14, [sp, #4]
   17fd4:	vmov.f32	s0, #112	; 0x3f800000  1.0
   17fd8:	vdiv.f32	s15, s0, s14
   17fdc:	cmp	r4, #0
   17fde:	ite	ge
   17fe0:	vaddge.f32	s0, s15, s0
   17fe4:	vsublt.f32	s0, s15, s0
   17fe8:	add	sp, #8
   17fea:	pop	{r4, pc}
   17fec:	ldr	r2, [pc, #116]	; (18064 <tanhf+0xa8>)
   17fee:	cmp	r3, r2
   17ff0:	ble.n	18002 <tanhf+0x46>
   17ff2:	vmov.f32	s0, #112	; 0x3f800000  1.0
   17ff6:	cmp	r4, #0
   17ff8:	it	lt
   17ffa:	vneglt.f32	s0, s0
   17ffe:	add	sp, #8
   18000:	pop	{r4, pc}
   18002:	cmp.w	r3, #603979776	; 0x24000000
   18006:	blt.n	18030 <tanhf+0x74>
   18008:	cmp.w	r3, #1065353216	; 0x3f800000
   1800c:	blt.n	18042 <tanhf+0x86>
   1800e:	bl	1a860 <fabsf>
   18012:	vadd.f32	s0, s0, s0
   18016:	bl	1a5ec <expm1f>
   1801a:	vmov.f32	s14, #0	; 0x40000000  2.0
   1801e:	vadd.f32	s13, s0, s14
   18022:	vmov.f32	s15, #112	; 0x3f800000  1.0
   18026:	vdiv.f32	s0, s14, s13
   1802a:	vsub.f32	s0, s15, s0
   1802e:	b.n	17ff6 <tanhf+0x3a>
   18030:	vldr	s15, [sp, #4]
   18034:	vmov.f32	s0, #112	; 0x3f800000  1.0
   18038:	vadd.f32	s0, s15, s0
   1803c:	vmul.f32	s0, s0, s15
   18040:	b.n	17fe8 <tanhf+0x2c>
   18042:	bl	1a860 <fabsf>
   18046:	vmov.f32	s15, #128	; 0xc0000000 -2.0
   1804a:	vmul.f32	s0, s0, s15
   1804e:	bl	1a5ec <expm1f>
   18052:	vmov.f32	s14, #0	; 0x40000000  2.0
   18056:	vadd.f32	s14, s0, s14
   1805a:	vneg.f32	s15, s0
   1805e:	vdiv.f32	s0, s15, s14
   18062:	b.n	17ff6 <tanhf+0x3a>
   18064:	.word	0x41afffff

00018068 <expf>:
   18068:	push	{r4, r6, r7, lr}
   1806a:	vpush	{d8}
   1806e:	ldr	r4, [pc, #212]	; (18144 <expf+0xdc>)
   18070:	sub	sp, #40	; 0x28
   18072:	vmov.f32	s17, s0
   18076:	bl	18744 <__ieee754_expf>
   1807a:	ldrsb.w	r3, [r4]
   1807e:	adds	r3, #1
   18080:	vmov.f32	s16, s0
   18084:	beq.n	180f8 <expf+0x90>
   18086:	vmov.f32	s0, s17
   1808a:	bl	1a870 <finitef>
   1808e:	cbz	r0, 180f8 <expf+0x90>
   18090:	vldr	s15, [pc, #180]	; 18148 <expf+0xe0>
   18094:	vcmpe.f32	s17, s15
   18098:	vmrs	APSR_nzcv, fpscr
   1809c:	bgt.n	18104 <expf+0x9c>
   1809e:	vldr	s15, [pc, #172]	; 1814c <expf+0xe4>
   180a2:	vcmpe.f32	s17, s15
   180a6:	vmrs	APSR_nzcv, fpscr
   180aa:	bpl.n	180f8 <expf+0x90>
   180ac:	ldrsb.w	r3, [r4]
   180b0:	ldr	r2, [pc, #156]	; (18150 <expf+0xe8>)
   180b2:	str	r2, [sp, #4]
   180b4:	vcvt.f64.f32	d0, s17
   180b8:	movs	r6, #0
   180ba:	movs	r7, #0
   180bc:	movs	r1, #4
   180be:	movs	r2, #0
   180c0:	cmp	r3, #2
   180c2:	strd	r6, r7, [sp, #24]
   180c6:	vstr	d0, [sp, #16]
   180ca:	vstr	d0, [sp, #8]
   180ce:	str	r1, [sp, #0]
   180d0:	str	r2, [sp, #32]
   180d2:	beq.n	1813a <expf+0xd2>
   180d4:	mov	r0, sp
   180d6:	bl	1a3b0 <matherr>
   180da:	cbz	r0, 1813a <expf+0xd2>
   180dc:	ldr	r3, [sp, #32]
   180de:	cbz	r3, 180e8 <expf+0x80>
   180e0:	bl	1aa3c <__errno>
   180e4:	ldr	r3, [sp, #32]
   180e6:	str	r3, [r0, #0]
   180e8:	vldr	d0, [sp, #24]
   180ec:	vcvt.f32.f64	s0, d0
   180f0:	add	sp, #40	; 0x28
   180f2:	vpop	{d8}
   180f6:	pop	{r4, r6, r7, pc}
   180f8:	vmov.f32	s0, s16
   180fc:	add	sp, #40	; 0x28
   180fe:	vpop	{d8}
   18102:	pop	{r4, r6, r7, pc}
   18104:	ldr	r2, [pc, #72]	; (18150 <expf+0xe8>)
   18106:	ldrsb.w	r3, [r4]
   1810a:	str	r2, [sp, #4]
   1810c:	vcvt.f64.f32	d0, s17
   18110:	movs	r1, #3
   18112:	movs	r2, #0
   18114:	vstr	d0, [sp, #16]
   18118:	vstr	d0, [sp, #8]
   1811c:	str	r1, [sp, #0]
   1811e:	str	r2, [sp, #32]
   18120:	cbnz	r3, 1812e <expf+0xc6>
   18122:	ldr	r3, [pc, #48]	; (18154 <expf+0xec>)
   18124:	mov.w	r2, #3758096384	; 0xe0000000
   18128:	strd	r2, r3, [sp, #24]
   1812c:	b.n	180d4 <expf+0x6c>
   1812e:	ldr	r1, [pc, #40]	; (18158 <expf+0xf0>)
   18130:	movs	r0, #0
   18132:	cmp	r3, #2
   18134:	strd	r0, r1, [sp, #24]
   18138:	bne.n	180d4 <expf+0x6c>
   1813a:	bl	1aa3c <__errno>
   1813e:	movs	r3, #34	; 0x22
   18140:	str	r3, [r0, #0]
   18142:	b.n	180dc <expf+0x74>
   18144:	.word	0x20020a98
   18148:	.word	0x42b17180
   1814c:	.word	0xc2cff1b5
   18150:	.word	0x2001fe80
   18154:	.word	0x47efffff
   18158:	.word	0x7ff00000

0001815c <exp2f>:
   1815c:	vmov.f32	s1, s0
   18160:	vmov.f32	s0, #0	; 0x40000000  2.0
   18164:	b.w	18168 <powf>

00018168 <powf>:
   18168:	push	{r4, r5, r6, r7, lr}
   1816a:	vpush	{d8-d9}
   1816e:	ldr	r4, [pc, #716]	; (1843c <powf+0x2d4>)
   18170:	sub	sp, #44	; 0x2c
   18172:	vmov.f32	s17, s0
   18176:	vmov.f32	s16, s1
   1817a:	bl	188f4 <__ieee754_powf>
   1817e:	ldrsb.w	r3, [r4]
   18182:	adds	r2, r3, #1
   18184:	vmov.f32	s18, s0
   18188:	beq.n	181fc <powf+0x94>
   1818a:	vcmp.f32	s16, s16
   1818e:	vmrs	APSR_nzcv, fpscr
   18192:	bvs.n	181fc <powf+0x94>
   18194:	vcmp.f32	s17, s17
   18198:	vmrs	APSR_nzcv, fpscr
   1819c:	bvs.n	18276 <powf+0x10e>
   1819e:	vcmp.f32	s17, #0.0
   181a2:	vmrs	APSR_nzcv, fpscr
   181a6:	bne.n	18208 <powf+0xa0>
   181a8:	vcmp.f32	s16, #0.0
   181ac:	vmrs	APSR_nzcv, fpscr
   181b0:	bne.n	181e6 <powf+0x7e>
   181b2:	movs	r2, #1
   181b4:	vcvt.f64.f32	d0, s17
   181b8:	vcvt.f64.f32	d7, s16
   181bc:	movs	r4, #0
   181be:	movs	r5, #0
   181c0:	ldr	r1, [pc, #636]	; (18440 <powf+0x2d8>)
   181c2:	str	r2, [sp, #0]
   181c4:	movs	r2, #0
   181c6:	strd	r4, r5, [sp, #24]
   181ca:	vstr	d0, [sp, #8]
   181ce:	vstr	d7, [sp, #16]
   181d2:	str	r1, [sp, #4]
   181d4:	str	r2, [sp, #32]
   181d6:	cmp	r3, #0
   181d8:	beq.n	182a8 <powf+0x140>
   181da:	vmov.f32	s0, #112	; 0x3f800000  1.0
   181de:	add	sp, #44	; 0x2c
   181e0:	vpop	{d8-d9}
   181e4:	pop	{r4, r5, r6, r7, pc}
   181e6:	vmov.f32	s0, s16
   181ea:	bl	1a870 <finitef>
   181ee:	cbz	r0, 181fc <powf+0x94>
   181f0:	vcmpe.f32	s16, #0.0
   181f4:	vmrs	APSR_nzcv, fpscr
   181f8:	bmi.w	18348 <powf+0x1e0>
   181fc:	vmov.f32	s0, s18
   18200:	add	sp, #44	; 0x2c
   18202:	vpop	{d8-d9}
   18206:	pop	{r4, r5, r6, r7, pc}
   18208:	bl	1a870 <finitef>
   1820c:	mov	r5, r0
   1820e:	cmp	r0, #0
   18210:	beq.n	182d0 <powf+0x168>
   18212:	vcmp.f32	s18, #0.0
   18216:	vmrs	APSR_nzcv, fpscr
   1821a:	bne.n	181fc <powf+0x94>
   1821c:	vmov.f32	s0, s17
   18220:	bl	1a870 <finitef>
   18224:	cmp	r0, #0
   18226:	beq.n	181fc <powf+0x94>
   18228:	vmov.f32	s0, s16
   1822c:	bl	1a870 <finitef>
   18230:	cmp	r0, #0
   18232:	beq.n	181fc <powf+0x94>
   18234:	ldrsb.w	r3, [r4]
   18238:	ldr	r2, [pc, #516]	; (18440 <powf+0x2d8>)
   1823a:	str	r2, [sp, #4]
   1823c:	vcvt.f64.f32	d0, s17
   18240:	vcvt.f64.f32	d7, s16
   18244:	movs	r6, #0
   18246:	movs	r7, #0
   18248:	movs	r1, #4
   1824a:	movs	r2, #0
   1824c:	cmp	r3, #2
   1824e:	strd	r6, r7, [sp, #24]
   18252:	vstr	d0, [sp, #8]
   18256:	vstr	d7, [sp, #16]
   1825a:	str	r1, [sp, #0]
   1825c:	str	r2, [sp, #32]
   1825e:	beq.n	1826c <powf+0x104>
   18260:	mov	r0, sp
   18262:	bl	1a3b0 <matherr>
   18266:	cmp	r0, #0
   18268:	bne.w	1837a <powf+0x212>
   1826c:	bl	1aa3c <__errno>
   18270:	movs	r3, #34	; 0x22
   18272:	str	r3, [r0, #0]
   18274:	b.n	1837a <powf+0x212>
   18276:	vcmp.f32	s16, #0.0
   1827a:	vmrs	APSR_nzcv, fpscr
   1827e:	bne.n	181fc <powf+0x94>
   18280:	movs	r2, #1
   18282:	ldr	r1, [pc, #448]	; (18444 <powf+0x2dc>)
   18284:	ldr	r4, [pc, #440]	; (18440 <powf+0x2d8>)
   18286:	str	r2, [sp, #0]
   18288:	vcvt.f64.f32	d0, s17
   1828c:	vcvt.f64.f32	d7, s16
   18290:	movs	r0, #0
   18292:	movs	r2, #0
   18294:	cmp	r3, #2
   18296:	vstr	d0, [sp, #8]
   1829a:	vstr	d7, [sp, #16]
   1829e:	str	r4, [sp, #4]
   182a0:	str	r2, [sp, #32]
   182a2:	strd	r0, r1, [sp, #24]
   182a6:	beq.n	181da <powf+0x72>
   182a8:	mov	r0, sp
   182aa:	bl	1a3b0 <matherr>
   182ae:	cmp	r0, #0
   182b0:	beq.n	18390 <powf+0x228>
   182b2:	ldr	r3, [sp, #32]
   182b4:	cmp	r3, #0
   182b6:	beq.n	1833e <powf+0x1d6>
   182b8:	bl	1aa3c <__errno>
   182bc:	vldr	d0, [sp, #24]
   182c0:	ldr	r3, [sp, #32]
   182c2:	str	r3, [r0, #0]
   182c4:	vcvt.f32.f64	s0, d0
   182c8:	add	sp, #44	; 0x2c
   182ca:	vpop	{d8-d9}
   182ce:	pop	{r4, r5, r6, r7, pc}
   182d0:	vmov.f32	s0, s17
   182d4:	bl	1a870 <finitef>
   182d8:	cmp	r0, #0
   182da:	beq.n	18212 <powf+0xaa>
   182dc:	vmov.f32	s0, s16
   182e0:	bl	1a870 <finitef>
   182e4:	cmp	r0, #0
   182e6:	beq.n	18212 <powf+0xaa>
   182e8:	vcmp.f32	s18, s18
   182ec:	vmrs	APSR_nzcv, fpscr
   182f0:	bvs.n	183d0 <powf+0x268>
   182f2:	vcvt.f64.f32	d6, s17
   182f6:	vcvt.f64.f32	d7, s16
   182fa:	ldr	r2, [pc, #324]	; (18440 <powf+0x2d8>)
   182fc:	ldrsb.w	r3, [r4]
   18300:	str	r5, [sp, #32]
   18302:	movs	r1, #3
   18304:	vstr	d6, [sp, #8]
   18308:	vstr	d7, [sp, #16]
   1830c:	stmia.w	sp, {r1, r2}
   18310:	cmp	r3, #0
   18312:	bne.n	183b0 <powf+0x248>
   18314:	ldr	r3, [pc, #304]	; (18448 <powf+0x2e0>)
   18316:	vcmpe.f32	s17, #0.0
   1831a:	mov.w	r2, #3758096384	; 0xe0000000
   1831e:	vmrs	APSR_nzcv, fpscr
   18322:	strd	r2, r3, [sp, #24]
   18326:	bmi.n	1840e <powf+0x2a6>
   18328:	mov	r0, sp
   1832a:	bl	1a3b0 <matherr>
   1832e:	cmp	r0, #0
   18330:	beq.n	183c6 <powf+0x25e>
   18332:	ldr	r3, [sp, #32]
   18334:	cbz	r3, 1833e <powf+0x1d6>
   18336:	bl	1aa3c <__errno>
   1833a:	ldr	r3, [sp, #32]
   1833c:	str	r3, [r0, #0]
   1833e:	vldr	d7, [sp, #24]
   18342:	vcvt.f32.f64	s0, d7
   18346:	b.n	18200 <powf+0x98>
   18348:	ldr	r2, [pc, #244]	; (18440 <powf+0x2d8>)
   1834a:	ldrsb.w	r3, [r4]
   1834e:	str	r2, [sp, #4]
   18350:	vcvt.f64.f32	d0, s17
   18354:	vcvt.f64.f32	d7, s16
   18358:	movs	r1, #1
   1835a:	movs	r2, #0
   1835c:	vstr	d0, [sp, #8]
   18360:	vstr	d7, [sp, #16]
   18364:	str	r1, [sp, #0]
   18366:	str	r2, [sp, #32]
   18368:	cbnz	r3, 1839a <powf+0x232>
   1836a:	movs	r2, #0
   1836c:	movs	r3, #0
   1836e:	strd	r2, r3, [sp, #24]
   18372:	mov	r0, sp
   18374:	bl	1a3b0 <matherr>
   18378:	cbz	r0, 183a6 <powf+0x23e>
   1837a:	ldr	r3, [sp, #32]
   1837c:	cbz	r3, 18386 <powf+0x21e>
   1837e:	bl	1aa3c <__errno>
   18382:	ldr	r3, [sp, #32]
   18384:	str	r3, [r0, #0]
   18386:	vldr	d0, [sp, #24]
   1838a:	vcvt.f32.f64	s0, d0
   1838e:	b.n	18200 <powf+0x98>
   18390:	bl	1aa3c <__errno>
   18394:	movs	r3, #33	; 0x21
   18396:	str	r3, [r0, #0]
   18398:	b.n	182b2 <powf+0x14a>
   1839a:	ldr	r1, [pc, #176]	; (1844c <powf+0x2e4>)
   1839c:	movs	r0, #0
   1839e:	cmp	r3, #2
   183a0:	strd	r0, r1, [sp, #24]
   183a4:	bne.n	18372 <powf+0x20a>
   183a6:	bl	1aa3c <__errno>
   183aa:	movs	r3, #33	; 0x21
   183ac:	str	r3, [r0, #0]
   183ae:	b.n	1837a <powf+0x212>
   183b0:	ldr	r1, [pc, #156]	; (18450 <powf+0x2e8>)
   183b2:	vcmpe.f32	s17, #0.0
   183b6:	movs	r0, #0
   183b8:	vmrs	APSR_nzcv, fpscr
   183bc:	strd	r0, r1, [sp, #24]
   183c0:	bmi.n	18458 <powf+0x2f0>
   183c2:	cmp	r3, #2
   183c4:	bne.n	18328 <powf+0x1c0>
   183c6:	bl	1aa3c <__errno>
   183ca:	movs	r3, #34	; 0x22
   183cc:	str	r3, [r0, #0]
   183ce:	b.n	18332 <powf+0x1ca>
   183d0:	ldr	r2, [pc, #108]	; (18440 <powf+0x2d8>)
   183d2:	ldrsb.w	r3, [r4]
   183d6:	str	r5, [sp, #32]
   183d8:	vcvt.f64.f32	d6, s17
   183dc:	vcvt.f64.f32	d7, s16
   183e0:	movs	r1, #1
   183e2:	vstr	d6, [sp, #8]
   183e6:	vstr	d7, [sp, #16]
   183ea:	stmia.w	sp, {r1, r2}
   183ee:	cmp	r3, #0
   183f0:	bne.n	18484 <powf+0x31c>
   183f2:	movs	r2, #0
   183f4:	movs	r3, #0
   183f6:	strd	r2, r3, [sp, #24]
   183fa:	mov	r0, sp
   183fc:	bl	1a3b0 <matherr>
   18400:	cmp	r0, #0
   18402:	bne.n	18332 <powf+0x1ca>
   18404:	bl	1aa3c <__errno>
   18408:	movs	r3, #33	; 0x21
   1840a:	str	r3, [r0, #0]
   1840c:	b.n	18332 <powf+0x1ca>
   1840e:	vmov.f32	s14, #96	; 0x3f000000  0.5
   18412:	vmul.f32	s14, s16, s14
   18416:	vcvt.f64.f32	d8, s14
   1841a:	vmov.f64	d0, d8
   1841e:	bl	1a3b4 <rint>
   18422:	vcmp.f64	d8, d0
   18426:	vmrs	APSR_nzcv, fpscr
   1842a:	beq.n	1847e <powf+0x316>
   1842c:	ldr	r1, [pc, #36]	; (18454 <powf+0x2ec>)
   1842e:	ldrsb.w	r3, [r4]
   18432:	mov.w	r0, #3758096384	; 0xe0000000
   18436:	strd	r0, r1, [sp, #24]
   1843a:	b.n	183c2 <powf+0x25a>
   1843c:	.word	0x20020a98
   18440:	.word	0x2001fe88
   18444:	.word	0x3ff00000
   18448:	.word	0x47efffff
   1844c:	.word	0xfff00000
   18450:	.word	0x7ff00000
   18454:	.word	0xc7efffff
   18458:	vmov.f32	s14, #96	; 0x3f000000  0.5
   1845c:	vmul.f32	s14, s16, s14
   18460:	vcvt.f64.f32	d8, s14
   18464:	vmov.f64	d0, d8
   18468:	bl	1a3b4 <rint>
   1846c:	vcmp.f64	d8, d0
   18470:	vmrs	APSR_nzcv, fpscr
   18474:	beq.n	1847e <powf+0x316>
   18476:	ldr	r3, [pc, #40]	; (184a0 <powf+0x338>)
   18478:	movs	r2, #0
   1847a:	strd	r2, r3, [sp, #24]
   1847e:	ldrsb.w	r3, [r4]
   18482:	b.n	183c2 <powf+0x25a>
   18484:	vldr	d7, [pc, #16]	; 18498 <powf+0x330>
   18488:	cmp	r3, #2
   1848a:	vdiv.f64	d6, d7, d7
   1848e:	vstr	d6, [sp, #24]
   18492:	beq.n	18404 <powf+0x29c>
   18494:	b.n	183fa <powf+0x292>
   18496:	nop
	...
   184a0:	.word	0xfff00000
   184a4:	.word	0x00000000

000184a8 <__ieee754_rem_pio2>:
   184a8:	push	{r4, r5, r6, lr}
   184aa:	vmov	r2, r3, d0
   184ae:	ldr	r1, [pc, #632]	; (18728 <__ieee754_rem_pio2+0x280>)
   184b0:	bic.w	r6, r3, #2147483648	; 0x80000000
   184b4:	cmp	r6, r1
   184b6:	sub	sp, #32
   184b8:	ble.n	18580 <__ieee754_rem_pio2+0xd8>
   184ba:	ldr	r1, [pc, #624]	; (1872c <__ieee754_rem_pio2+0x284>)
   184bc:	cmp	r6, r1
   184be:	mov	r5, r3
   184c0:	bgt.n	184fc <__ieee754_rem_pio2+0x54>
   184c2:	cmp	r3, #0
   184c4:	vldr	d7, [pc, #544]	; 186e8 <__ieee754_rem_pio2+0x240>
   184c8:	ble.w	1868a <__ieee754_rem_pio2+0x1e2>
   184cc:	vsub.f64	d7, d0, d7
   184d0:	sub.w	r1, r1, #634880	; 0x9b000
   184d4:	sub.w	r1, r1, #1920	; 0x780
   184d8:	cmp	r6, r1
   184da:	beq.n	185a4 <__ieee754_rem_pio2+0xfc>
   184dc:	vldr	d6, [pc, #528]	; 186f0 <__ieee754_rem_pio2+0x248>
   184e0:	vsub.f64	d5, d7, d6
   184e4:	vsub.f64	d7, d7, d5
   184e8:	movs	r3, #1
   184ea:	vstr	d5, [r0]
   184ee:	vsub.f64	d7, d7, d6
   184f2:	vstr	d7, [r0, #8]
   184f6:	mov	r0, r3
   184f8:	add	sp, #32
   184fa:	pop	{r4, r5, r6, pc}
   184fc:	ldr	r1, [pc, #560]	; (18730 <__ieee754_rem_pio2+0x288>)
   184fe:	cmp	r6, r1
   18500:	mov	r4, r0
   18502:	ble.n	185b2 <__ieee754_rem_pio2+0x10a>
   18504:	ldr	r1, [pc, #556]	; (18734 <__ieee754_rem_pio2+0x28c>)
   18506:	cmp	r6, r1
   18508:	bgt.n	18594 <__ieee754_rem_pio2+0xec>
   1850a:	mov	r0, r2
   1850c:	asrs	r2, r6, #20
   1850e:	subw	r2, r2, #1046	; 0x416
   18512:	sub.w	r1, r6, r2, lsl #20
   18516:	vmov	d6, r0, r1
   1851a:	vldr	d7, [pc, #476]	; 186f8 <__ieee754_rem_pio2+0x250>
   1851e:	vcvt.s32.f64	s8, d6
   18522:	movs	r3, #0
   18524:	vcvt.f64.s32	d4, s8
   18528:	vsub.f64	d6, d6, d4
   1852c:	vmul.f64	d6, d6, d7
   18530:	vcvt.s32.f64	s10, d6
   18534:	vstr	d4, [sp, #8]
   18538:	vcvt.f64.s32	d5, s10
   1853c:	vsub.f64	d6, d6, d5
   18540:	vmul.f64	d7, d6, d7
   18544:	vcmp.f64	d7, #0.0
   18548:	vmrs	APSR_nzcv, fpscr
   1854c:	vstr	d5, [sp, #16]
   18550:	vstr	d7, [sp, #24]
   18554:	bne.w	186ce <__ieee754_rem_pio2+0x226>
   18558:	vcmp.f64	d5, #0.0
   1855c:	vmrs	APSR_nzcv, fpscr
   18560:	ite	eq
   18562:	moveq	r3, #1
   18564:	movne	r3, #2
   18566:	ldr	r1, [pc, #464]	; (18738 <__ieee754_rem_pio2+0x290>)
   18568:	str	r1, [sp, #4]
   1856a:	movs	r1, #2
   1856c:	str	r1, [sp, #0]
   1856e:	add	r0, sp, #8
   18570:	mov	r1, r4
   18572:	bl	19350 <__kernel_rem_pio2>
   18576:	cmp	r5, #0
   18578:	blt.w	186b2 <__ieee754_rem_pio2+0x20a>
   1857c:	mov	r3, r0
   1857e:	b.n	1858e <__ieee754_rem_pio2+0xe6>
   18580:	movs	r4, #0
   18582:	movs	r5, #0
   18584:	vstr	d0, [r0]
   18588:	strd	r4, r5, [r0, #8]
   1858c:	movs	r3, #0
   1858e:	mov	r0, r3
   18590:	add	sp, #32
   18592:	pop	{r4, r5, r6, pc}
   18594:	vsub.f64	d7, d0, d0
   18598:	movs	r3, #0
   1859a:	vstr	d7, [r0, #8]
   1859e:	vstr	d7, [r0]
   185a2:	b.n	1858e <__ieee754_rem_pio2+0xe6>
   185a4:	vldr	d5, [pc, #344]	; 18700 <__ieee754_rem_pio2+0x258>
   185a8:	vldr	d6, [pc, #348]	; 18708 <__ieee754_rem_pio2+0x260>
   185ac:	vsub.f64	d7, d7, d5
   185b0:	b.n	184e0 <__ieee754_rem_pio2+0x38>
   185b2:	bl	1a284 <fabs>
   185b6:	vmov.f64	d7, #96	; 0x3f000000  0.5
   185ba:	vldr	d6, [pc, #340]	; 18710 <__ieee754_rem_pio2+0x268>
   185be:	vfma.f64	d7, d0, d6
   185c2:	vcvt.s32.f64	s15, d7
   185c6:	vldr	d3, [pc, #288]	; 186e8 <__ieee754_rem_pio2+0x240>
   185ca:	vmov	r3, s15
   185ce:	vldr	d6, [pc, #288]	; 186f0 <__ieee754_rem_pio2+0x248>
   185d2:	cmp	r3, #31
   185d4:	vcvt.f64.s32	d5, s15
   185d8:	vneg.f64	d4, d5
   185dc:	vmul.f64	d7, d5, d6
   185e0:	vfma.f64	d0, d4, d3
   185e4:	bgt.n	1861e <__ieee754_rem_pio2+0x176>
   185e6:	ldr	r2, [pc, #340]	; (1873c <__ieee754_rem_pio2+0x294>)
   185e8:	subs	r1, r3, #1
   185ea:	ldr.w	r2, [r2, r1, lsl #2]
   185ee:	cmp	r6, r2
   185f0:	beq.n	1861e <__ieee754_rem_pio2+0x176>
   185f2:	vsub.f64	d6, d0, d7
   185f6:	vstr	d6, [r4]
   185fa:	vsub.f64	d0, d0, d6
   185fe:	vsub.f64	d0, d0, d7
   18602:	cmp	r5, #0
   18604:	vstr	d0, [r4, #8]
   18608:	bge.n	1858e <__ieee754_rem_pio2+0xe6>
   1860a:	vneg.f64	d6, d6
   1860e:	vneg.f64	d0, d0
   18612:	vstr	d6, [r4]
   18616:	vstr	d0, [r4, #8]
   1861a:	negs	r3, r3
   1861c:	b.n	1858e <__ieee754_rem_pio2+0xe6>
   1861e:	vsub.f64	d6, d0, d7
   18622:	vmov	r2, s13
   18626:	asrs	r6, r6, #20
   18628:	ubfx	r2, r2, #20, #11
   1862c:	subs	r2, r6, r2
   1862e:	cmp	r2, #16
   18630:	vstr	d6, [r4]
   18634:	ble.n	185fa <__ieee754_rem_pio2+0x152>
   18636:	vmov.f64	d3, d0
   1863a:	vldr	d7, [pc, #196]	; 18700 <__ieee754_rem_pio2+0x258>
   1863e:	vldr	d6, [pc, #200]	; 18708 <__ieee754_rem_pio2+0x260>
   18642:	vfma.f64	d3, d4, d7
   18646:	vsub.f64	d0, d0, d3
   1864a:	vfma.f64	d0, d4, d7
   1864e:	vmov.f64	d7, d0
   18652:	vfnms.f64	d7, d5, d6
   18656:	vsub.f64	d6, d3, d7
   1865a:	vmov	r2, s13
   1865e:	ubfx	r2, r2, #20, #11
   18662:	subs	r6, r6, r2
   18664:	cmp	r6, #49	; 0x31
   18666:	vstr	d6, [r4]
   1866a:	ble.n	186e0 <__ieee754_rem_pio2+0x238>
   1866c:	vmov.f64	d0, d3
   18670:	vldr	d6, [pc, #164]	; 18718 <__ieee754_rem_pio2+0x270>
   18674:	vldr	d2, [pc, #168]	; 18720 <__ieee754_rem_pio2+0x278>
   18678:	vfma.f64	d0, d4, d6
   1867c:	vsub.f64	d7, d3, d0
   18680:	vfma.f64	d7, d4, d6
   18684:	vfnms.f64	d7, d5, d2
   18688:	b.n	185f2 <__ieee754_rem_pio2+0x14a>
   1868a:	ldr	r1, [pc, #180]	; (18740 <__ieee754_rem_pio2+0x298>)
   1868c:	vadd.f64	d7, d0, d7
   18690:	cmp	r6, r1
   18692:	beq.n	186d2 <__ieee754_rem_pio2+0x22a>
   18694:	vldr	d6, [pc, #88]	; 186f0 <__ieee754_rem_pio2+0x248>
   18698:	vadd.f64	d5, d7, d6
   1869c:	vsub.f64	d7, d7, d5
   186a0:	mov.w	r3, #4294967295
   186a4:	vadd.f64	d7, d7, d6
   186a8:	vstr	d5, [r0]
   186ac:	vstr	d7, [r0, #8]
   186b0:	b.n	1858e <__ieee754_rem_pio2+0xe6>
   186b2:	vldr	d6, [r4]
   186b6:	vldr	d7, [r4, #8]
   186ba:	vneg.f64	d6, d6
   186be:	vneg.f64	d7, d7
   186c2:	negs	r3, r0
   186c4:	vstr	d6, [r4]
   186c8:	vstr	d7, [r4, #8]
   186cc:	b.n	1858e <__ieee754_rem_pio2+0xe6>
   186ce:	movs	r3, #3
   186d0:	b.n	18566 <__ieee754_rem_pio2+0xbe>
   186d2:	vldr	d5, [pc, #44]	; 18700 <__ieee754_rem_pio2+0x258>
   186d6:	vldr	d6, [pc, #48]	; 18708 <__ieee754_rem_pio2+0x260>
   186da:	vadd.f64	d7, d7, d5
   186de:	b.n	18698 <__ieee754_rem_pio2+0x1f0>
   186e0:	vmov.f64	d0, d3
   186e4:	b.n	185fa <__ieee754_rem_pio2+0x152>
   186e6:	nop
   186e8:	.word	0x54400000
   186ec:	.word	0x3ff921fb
   186f0:	.word	0x1a626331
   186f4:	.word	0x3dd0b461
   186f8:	.word	0x00000000
   186fc:	.word	0x41700000
   18700:	.word	0x1a600000
   18704:	.word	0x3dd0b461
   18708:	.word	0x2e037073
   1870c:	.word	0x3ba3198a
   18710:	.word	0x6dc9c883
   18714:	.word	0x3fe45f30
   18718:	.word	0x2e000000
   1871c:	.word	0x3ba3198a
   18720:	.word	0x252049c1
   18724:	.word	0x397b839a
   18728:	.word	0x3fe921fb
   1872c:	.word	0x4002d97b
   18730:	.word	0x413921fb
   18734:	.word	0x7fefffff
   18738:	.word	0x2001ff10
   1873c:	.word	0x2001fe90
   18740:	.word	0x3ff921fb

00018744 <__ieee754_expf>:
   18744:	vmov	r3, s0
   18748:	bic.w	r2, r3, #2147483648	; 0x80000000
   1874c:	cmp.w	r2, #2139095040	; 0x7f800000
   18750:	bhi.n	18800 <__ieee754_expf+0xbc>
   18752:	mov.w	r1, r3, lsr #31
   18756:	beq.n	18806 <__ieee754_expf+0xc2>
   18758:	ldr	r0, [pc, #336]	; (188ac <__ieee754_expf+0x168>)
   1875a:	cmp	r3, r0
   1875c:	bgt.n	18846 <__ieee754_expf+0x102>
   1875e:	cmp	r3, #0
   18760:	blt.n	18836 <__ieee754_expf+0xf2>
   18762:	ldr	r3, [pc, #332]	; (188b0 <__ieee754_expf+0x16c>)
   18764:	cmp	r2, r3
   18766:	bls.n	18814 <__ieee754_expf+0xd0>
   18768:	ldr	r3, [pc, #328]	; (188b4 <__ieee754_expf+0x170>)
   1876a:	cmp	r2, r3
   1876c:	bhi.n	1886a <__ieee754_expf+0x126>
   1876e:	ldr	r0, [pc, #328]	; (188b8 <__ieee754_expf+0x174>)
   18770:	ldr	r2, [pc, #328]	; (188bc <__ieee754_expf+0x178>)
   18772:	lsls	r3, r1, #2
   18774:	add	r0, r3
   18776:	vldr	s14, [r0]
   1877a:	add	r2, r3
   1877c:	vsub.f32	s9, s0, s14
   18780:	rsb	r3, r1, #1
   18784:	vldr	s14, [r2]
   18788:	subs	r3, r3, r1
   1878a:	vsub.f32	s0, s9, s14
   1878e:	vmul.f32	s15, s0, s0
   18792:	vldr	s8, [pc, #300]	; 188c0 <__ieee754_expf+0x17c>
   18796:	vldr	s10, [pc, #300]	; 188c4 <__ieee754_expf+0x180>
   1879a:	vldr	s11, [pc, #300]	; 188c8 <__ieee754_expf+0x184>
   1879e:	vldr	s12, [pc, #300]	; 188cc <__ieee754_expf+0x188>
   187a2:	vldr	s13, [pc, #300]	; 188d0 <__ieee754_expf+0x18c>
   187a6:	vfma.f32	s10, s15, s8
   187aa:	vfma.f32	s11, s15, s10
   187ae:	vfma.f32	s12, s15, s11
   187b2:	vfma.f32	s13, s15, s12
   187b6:	vmov.f32	s12, s0
   187ba:	vfms.f32	s12, s15, s13
   187be:	vmov.f32	s13, #0	; 0x40000000  2.0
   187c2:	cmp	r3, #0
   187c4:	beq.n	18850 <__ieee754_expf+0x10c>
   187c6:	vmul.f32	s0, s0, s12
   187ca:	vsub.f32	s15, s13, s12
   187ce:	cmn.w	r3, #125	; 0x7d
   187d2:	vdiv.f32	s12, s0, s15
   187d6:	vmov.f32	s13, #112	; 0x3f800000  1.0
   187da:	vsub.f32	s14, s14, s12
   187de:	vsub.f32	s14, s14, s9
   187e2:	vsub.f32	s0, s13, s14
   187e6:	bge.n	1889e <__ieee754_expf+0x15a>
   187e8:	vmov	r2, s0
   187ec:	adds	r3, #100	; 0x64
   187ee:	add.w	r3, r2, r3, lsl #23
   187f2:	vldr	s15, [pc, #224]	; 188d4 <__ieee754_expf+0x190>
   187f6:	vmov	s0, r3
   187fa:	vmul.f32	s0, s0, s15
   187fe:	bx	lr
   18800:	vadd.f32	s0, s0, s0
   18804:	bx	lr
   18806:	vldr	s15, [pc, #208]	; 188d8 <__ieee754_expf+0x194>
   1880a:	cmp	r1, #0
   1880c:	it	ne
   1880e:	vmovne.f32	s0, s15
   18812:	bx	lr
   18814:	cmp.w	r2, #830472192	; 0x31800000
   18818:	bcs.n	18842 <__ieee754_expf+0xfe>
   1881a:	vldr	s15, [pc, #192]	; 188dc <__ieee754_expf+0x198>
   1881e:	vadd.f32	s15, s0, s15
   18822:	vmov.f32	s13, #112	; 0x3f800000  1.0
   18826:	vcmpe.f32	s15, s13
   1882a:	vmrs	APSR_nzcv, fpscr
   1882e:	ble.n	18842 <__ieee754_expf+0xfe>
   18830:	vadd.f32	s0, s0, s13
   18834:	bx	lr
   18836:	ldr	r3, [pc, #168]	; (188e0 <__ieee754_expf+0x19c>)
   18838:	cmp	r2, r3
   1883a:	bls.n	18762 <__ieee754_expf+0x1e>
   1883c:	vldr	s0, [pc, #152]	; 188d8 <__ieee754_expf+0x194>
   18840:	bx	lr
   18842:	movs	r3, #0
   18844:	b.n	1878e <__ieee754_expf+0x4a>
   18846:	vldr	s0, [pc, #148]	; 188dc <__ieee754_expf+0x198>
   1884a:	vmul.f32	s0, s0, s0
   1884e:	bx	lr
   18850:	vmul.f32	s15, s0, s12
   18854:	vsub.f32	s13, s12, s13
   18858:	vmov.f32	s12, #112	; 0x3f800000  1.0
   1885c:	vdiv.f32	s14, s15, s13
   18860:	vsub.f32	s0, s14, s0
   18864:	vsub.f32	s0, s12, s0
   18868:	bx	lr
   1886a:	ldr	r3, [pc, #120]	; (188e4 <__ieee754_expf+0x1a0>)
   1886c:	vldr	s12, [pc, #120]	; 188e8 <__ieee754_expf+0x1a4>
   18870:	vldr	s13, [pc, #120]	; 188ec <__ieee754_expf+0x1a8>
   18874:	vldr	s14, [pc, #120]	; 188f0 <__ieee754_expf+0x1ac>
   18878:	add.w	r3, r3, r1, lsl #2
   1887c:	vldr	s15, [r3]
   18880:	vfma.f32	s15, s0, s12
   18884:	vmov.f32	s9, s0
   18888:	vcvt.s32.f32	s15, s15
   1888c:	vmov	r3, s15
   18890:	vcvt.f32.s32	s15, s15
   18894:	vfms.f32	s9, s15, s13
   18898:	vmul.f32	s14, s15, s14
   1889c:	b.n	1878a <__ieee754_expf+0x46>
   1889e:	vmov	r2, s0
   188a2:	add.w	r3, r2, r3, lsl #23
   188a6:	vmov	s0, r3
   188aa:	bx	lr
   188ac:	.word	0x42b17217
   188b0:	.word	0x3eb17218
   188b4:	.word	0x3f851591
   188b8:	.word	0x20020028
   188bc:	.word	0x20020020
   188c0:	.word	0x3331bb4c
   188c4:	.word	0xb5ddea0e
   188c8:	.word	0x388ab355
   188cc:	.word	0xbb360b61
   188d0:	.word	0x3e2aaaab
   188d4:	.word	0x0d800000
   188d8:	.word	0x00000000
   188dc:	.word	0x7149f2ca
   188e0:	.word	0x42cff1b5
   188e4:	.word	0x20020018
   188e8:	.word	0x3fb8aa3b
   188ec:	.word	0x3f317180
   188f0:	.word	0x3717f7d1

000188f4 <__ieee754_powf>:
   188f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   188f8:	vpush	{d8}
   188fc:	sub	sp, #8
   188fe:	vstr	s1, [sp]
   18902:	ldr	r4, [sp, #0]
   18904:	vstr	s0, [sp, #4]
   18908:	bics.w	r6, r4, #2147483648	; 0x80000000
   1890c:	beq.n	18938 <__ieee754_powf+0x44>
   1890e:	ldr.w	r8, [sp, #4]
   18912:	bic.w	r7, r8, #2147483648	; 0x80000000
   18916:	cmp.w	r7, #2139095040	; 0x7f800000
   1891a:	ble.n	1892c <__ieee754_powf+0x38>
   1891c:	ldr	r0, [pc, #352]	; (18a80 <__ieee754_powf+0x18c>)
   1891e:	add	sp, #8
   18920:	vpop	{d8}
   18924:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18928:	b.w	1a914 <nanf>
   1892c:	cmp.w	r6, #2139095040	; 0x7f800000
   18930:	ble.n	18946 <__ieee754_powf+0x52>
   18932:	cmp.w	r7, #1065353216	; 0x3f800000
   18936:	bne.n	1891c <__ieee754_powf+0x28>
   18938:	vmov.f32	s0, #112	; 0x3f800000  1.0
   1893c:	add	sp, #8
   1893e:	vpop	{d8}
   18942:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18946:	cmp.w	r8, #0
   1894a:	blt.n	189e8 <__ieee754_powf+0xf4>
   1894c:	mov.w	sl, #0
   18950:	cmp.w	r6, #2139095040	; 0x7f800000
   18954:	beq.n	189d6 <__ieee754_powf+0xe2>
   18956:	cmp.w	r6, #1065353216	; 0x3f800000
   1895a:	beq.n	18a0e <__ieee754_powf+0x11a>
   1895c:	cmp.w	r4, #1073741824	; 0x40000000
   18960:	beq.n	18a40 <__ieee754_powf+0x14c>
   18962:	ldr	r5, [sp, #4]
   18964:	ldr.w	r9, [sp]
   18968:	cmp.w	r4, #1056964608	; 0x3f000000
   1896c:	vmov	s0, r5
   18970:	beq.n	189ac <__ieee754_powf+0xb8>
   18972:	bl	1a860 <fabsf>
   18976:	cmp.w	r7, #2139095040	; 0x7f800000
   1897a:	beq.n	18a18 <__ieee754_powf+0x124>
   1897c:	cmp	r7, #0
   1897e:	beq.n	18a18 <__ieee754_powf+0x124>
   18980:	cmp.w	r7, #1065353216	; 0x3f800000
   18984:	beq.n	18a18 <__ieee754_powf+0x124>
   18986:	mov.w	r3, r8, lsr #31
   1898a:	subs	r3, #1
   1898c:	orrs.w	r2, sl, r3
   18990:	beq.n	18a70 <__ieee754_powf+0x17c>
   18992:	cmp.w	r6, #1291845632	; 0x4d000000
   18996:	ble.n	18a90 <__ieee754_powf+0x19c>
   18998:	ldr	r2, [pc, #232]	; (18a84 <__ieee754_powf+0x190>)
   1899a:	cmp	r7, r2
   1899c:	bgt.w	18d42 <__ieee754_powf+0x44e>
   189a0:	cmp	r4, #0
   189a2:	blt.w	18d4e <__ieee754_powf+0x45a>
   189a6:	vldr	s0, [pc, #224]	; 18a88 <__ieee754_powf+0x194>
   189aa:	b.n	1893c <__ieee754_powf+0x48>
   189ac:	cmp.w	r8, #0
   189b0:	bge.n	18a4a <__ieee754_powf+0x156>
   189b2:	bl	1a860 <fabsf>
   189b6:	cmp.w	r7, #2139095040	; 0x7f800000
   189ba:	beq.n	189c0 <__ieee754_powf+0xcc>
   189bc:	cmp	r7, #0
   189be:	bne.n	18980 <__ieee754_powf+0x8c>
   189c0:	sub.w	r7, r7, #1065353216	; 0x3f800000
   189c4:	orrs.w	r3, r7, sl
   189c8:	beq.n	18a66 <__ieee754_powf+0x172>
   189ca:	cmp.w	sl, #1
   189ce:	bne.n	1893c <__ieee754_powf+0x48>
   189d0:	vneg.f32	s0, s0
   189d4:	b.n	1893c <__ieee754_powf+0x48>
   189d6:	cmp.w	r7, #1065353216	; 0x3f800000
   189da:	beq.n	18938 <__ieee754_powf+0x44>
   189dc:	ble.n	18a32 <__ieee754_powf+0x13e>
   189de:	cmp	r4, #0
   189e0:	blt.n	189a6 <__ieee754_powf+0xb2>
   189e2:	vldr	s0, [sp]
   189e6:	b.n	1893c <__ieee754_powf+0x48>
   189e8:	cmp.w	r6, #1266679808	; 0x4b800000
   189ec:	bge.n	18a2c <__ieee754_powf+0x138>
   189ee:	cmp.w	r6, #1065353216	; 0x3f800000
   189f2:	blt.n	18a08 <__ieee754_powf+0x114>
   189f4:	asrs	r3, r6, #23
   189f6:	rsb	r3, r3, #150	; 0x96
   189fa:	asr.w	r2, r6, r3
   189fe:	lsl.w	r3, r2, r3
   18a02:	cmp	r6, r3
   18a04:	beq.w	18d38 <__ieee754_powf+0x444>
   18a08:	mov.w	sl, #0
   18a0c:	b.n	18956 <__ieee754_powf+0x62>
   18a0e:	cmp	r4, #0
   18a10:	blt.n	18a58 <__ieee754_powf+0x164>
   18a12:	vldr	s0, [sp, #4]
   18a16:	b.n	1893c <__ieee754_powf+0x48>
   18a18:	cmp	r4, #0
   18a1a:	itt	lt
   18a1c:	vmovlt.f32	s15, #112	; 0x3f800000  1.0
   18a20:	vdivlt.f32	s0, s15, s0
   18a24:	cmp.w	r8, #0
   18a28:	bge.n	1893c <__ieee754_powf+0x48>
   18a2a:	b.n	189c0 <__ieee754_powf+0xcc>
   18a2c:	mov.w	sl, #2
   18a30:	b.n	18950 <__ieee754_powf+0x5c>
   18a32:	cmp	r4, #0
   18a34:	bge.n	189a6 <__ieee754_powf+0xb2>
   18a36:	vldr	s15, [sp]
   18a3a:	vneg.f32	s0, s15
   18a3e:	b.n	1893c <__ieee754_powf+0x48>
   18a40:	vldr	s15, [sp, #4]
   18a44:	vmul.f32	s0, s15, s15
   18a48:	b.n	1893c <__ieee754_powf+0x48>
   18a4a:	add	sp, #8
   18a4c:	vpop	{d8}
   18a50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18a54:	b.w	19188 <__ieee754_sqrtf>
   18a58:	vldr	s14, [sp, #4]
   18a5c:	vmov.f32	s15, #112	; 0x3f800000  1.0
   18a60:	vdiv.f32	s0, s15, s14
   18a64:	b.n	1893c <__ieee754_powf+0x48>
   18a66:	vsub.f32	s15, s0, s0
   18a6a:	vdiv.f32	s0, s15, s15
   18a6e:	b.n	1893c <__ieee754_powf+0x48>
   18a70:	vmov	s15, r5
   18a74:	vsub.f32	s15, s15, s15
   18a78:	vdiv.f32	s0, s15, s15
   18a7c:	b.n	1893c <__ieee754_powf+0x48>
   18a7e:	nop
   18a80:	.word	0x2001fe84
   18a84:	.word	0x3f7ffff7
   18a88:	.word	0x00000000
   18a8c:	.word	0x4b800000
   18a90:	cmp.w	r7, #8388608	; 0x800000
   18a94:	bge.w	18d68 <__ieee754_powf+0x474>
   18a98:	vldr	s15, [pc, #-16]	; 18a8c <__ieee754_powf+0x198>
   18a9c:	vmul.f32	s15, s0, s15
   18aa0:	mvn.w	r2, #23
   18aa4:	vmov	r7, s15
   18aa8:	ldr	r0, [pc, #968]	; (18e74 <__ieee754_powf+0x580>)
   18aaa:	asrs	r1, r7, #23
   18aac:	ubfx	r7, r7, #0, #23
   18ab0:	subs	r1, #127	; 0x7f
   18ab2:	cmp	r7, r0
   18ab4:	add	r2, r1
   18ab6:	orr.w	r1, r7, #1065353216	; 0x3f800000
   18aba:	ble.w	18d58 <__ieee754_powf+0x464>
   18abe:	ldr	r0, [pc, #952]	; (18e78 <__ieee754_powf+0x584>)
   18ac0:	cmp	r7, r0
   18ac2:	ble.w	18dfc <__ieee754_powf+0x508>
   18ac6:	vldr	s8, [pc, #948]	; 18e7c <__ieee754_powf+0x588>
   18aca:	adds	r2, #1
   18acc:	sub.w	r1, r1, #8388608	; 0x800000
   18ad0:	vmov.f32	s6, s8
   18ad4:	movs	r0, #0
   18ad6:	vmov.f32	s12, #112	; 0x3f800000  1.0
   18ada:	vmov	s14, r1
   18ade:	vadd.f32	s15, s14, s12
   18ae2:	vmov.f32	s13, #112	; 0x3f800000  1.0
   18ae6:	vdiv.f32	s11, s13, s15
   18aea:	asrs	r1, r1, #1
   18aec:	orr.w	r1, r1, #536870912	; 0x20000000
   18af0:	add.w	r1, r1, #262144	; 0x40000
   18af4:	add	r1, r0
   18af6:	vsub.f32	s13, s14, s12
   18afa:	vmov	s4, r1
   18afe:	vmul.f32	s7, s13, s11
   18b02:	vsub.f32	s9, s4, s12
   18b06:	vldr	s17, [pc, #888]	; 18e80 <__ieee754_powf+0x58c>
   18b0a:	vldr	s16, [pc, #888]	; 18e84 <__ieee754_powf+0x590>
   18b0e:	vldr	s3, [pc, #888]	; 18e88 <__ieee754_powf+0x594>
   18b12:	vldr	s0, [pc, #888]	; 18e8c <__ieee754_powf+0x598>
   18b16:	vldr	s1, [pc, #888]	; 18e90 <__ieee754_powf+0x59c>
   18b1a:	vldr	s2, [pc, #888]	; 18e94 <__ieee754_powf+0x5a0>
   18b1e:	vldr	s15, [pc, #888]	; 18e98 <__ieee754_powf+0x5a4>
   18b22:	vldr	s5, [pc, #888]	; 18e9c <__ieee754_powf+0x5a8>
   18b26:	vmul.f32	s12, s7, s7
   18b2a:	vmov	r1, s7
   18b2e:	vfma.f32	s16, s12, s17
   18b32:	bic.w	r1, r1, #4080	; 0xff0
   18b36:	bic.w	r1, r1, #15
   18b3a:	vsub.f32	s14, s14, s9
   18b3e:	vmov.f32	s9, s3
   18b42:	vmov	s10, r1
   18b46:	vfma.f32	s9, s12, s16
   18b4a:	vneg.f32	s3, s10
   18b4e:	vfma.f32	s13, s3, s4
   18b52:	vfma.f32	s0, s12, s9
   18b56:	vfma.f32	s13, s3, s14
   18b5a:	vfma.f32	s1, s12, s0
   18b5e:	vmul.f32	s11, s13, s11
   18b62:	vmov.f32	s13, s2
   18b66:	vfma.f32	s13, s12, s1
   18b6a:	vadd.f32	s14, s7, s10
   18b6e:	vmul.f32	s12, s12, s12
   18b72:	vmul.f32	s14, s14, s11
   18b76:	vmov.f32	s9, #8	; 0x40400000  3.0
   18b7a:	vfma.f32	s14, s12, s13
   18b7e:	vmov.f32	s13, s9
   18b82:	vfma.f32	s13, s10, s10
   18b86:	vldr	s4, [pc, #792]	; 18ea0 <__ieee754_powf+0x5ac>
   18b8a:	vadd.f32	s12, s13, s14
   18b8e:	vmov	s13, r2
   18b92:	vmov	r2, s12
   18b96:	bic.w	r2, r2, #4080	; 0xff0
   18b9a:	bic.w	r2, r2, #15
   18b9e:	vmov	s12, r2
   18ba2:	vsub.f32	s9, s12, s9
   18ba6:	vcvt.f32.s32	s13, s13
   18baa:	vfma.f32	s9, s3, s10
   18bae:	vsub.f32	s14, s14, s9
   18bb2:	vmul.f32	s14, s14, s7
   18bb6:	vfma.f32	s14, s11, s12
   18bba:	vmov.f32	s11, s14
   18bbe:	vfma.f32	s11, s10, s12
   18bc2:	vmov	r2, s11
   18bc6:	bic.w	r2, r2, #4080	; 0xff0
   18bca:	bic.w	r2, r2, #15
   18bce:	vmov	s10, r2
   18bd2:	vfma.f32	s10, s3, s12
   18bd6:	vmov	s11, r2
   18bda:	vsub.f32	s14, s14, s10
   18bde:	vmul.f32	s15, s14, s15
   18be2:	vfma.f32	s15, s11, s5
   18be6:	vadd.f32	s15, s15, s6
   18bea:	vmov.f32	s14, s15
   18bee:	vfma.f32	s14, s11, s4
   18bf2:	vadd.f32	s14, s14, s8
   18bf6:	vadd.f32	s14, s14, s13
   18bfa:	vmov	r2, s14
   18bfe:	bic.w	r2, r2, #4080	; 0xff0
   18c02:	bic.w	r2, r2, #15
   18c06:	vmov	s14, r2
   18c0a:	vsub.f32	s13, s14, s13
   18c0e:	vsub.f32	s14, s13, s8
   18c12:	vfms.f32	s14, s11, s4
   18c16:	vsub.f32	s14, s15, s14
   18c1a:	bic.w	r4, r4, #4080	; 0xff0
   18c1e:	bic.w	r4, r4, #15
   18c22:	vmov	s15, r9
   18c26:	vmov	s13, r4
   18c2a:	vmul.f32	s14, s14, s15
   18c2e:	vmov	s12, r4
   18c32:	vsub.f32	s15, s15, s13
   18c36:	vmov	s13, r2
   18c3a:	vmul.f32	s13, s13, s12
   18c3e:	vmov	s12, r2
   18c42:	vfma.f32	s14, s12, s15
   18c46:	add.w	sl, sl, #4294967295
   18c4a:	orrs.w	r3, sl, r3
   18c4e:	vmov.f32	s0, #240	; 0xbf800000 -1.0
   18c52:	vadd.f32	s12, s14, s13
   18c56:	vmov.f32	s15, #112	; 0x3f800000  1.0
   18c5a:	vmov	r2, s12
   18c5e:	ite	ne
   18c60:	vmovne.f32	s16, s15
   18c64:	vmoveq.f32	s16, s0
   18c68:	cmp	r2, #0
   18c6a:	bic.w	r3, r2, #2147483648	; 0x80000000
   18c6e:	ble.w	18dd6 <__ieee754_powf+0x4e2>
   18c72:	cmp.w	r3, #1124073472	; 0x43000000
   18c76:	bgt.w	18d82 <__ieee754_powf+0x48e>
   18c7a:	beq.n	18d6c <__ieee754_powf+0x478>
   18c7c:	cmp.w	r3, #1056964608	; 0x3f000000
   18c80:	bgt.w	18d90 <__ieee754_powf+0x49c>
   18c84:	movs	r3, #0
   18c86:	mov	r0, r3
   18c88:	bic.w	r2, r2, #4080	; 0xff0
   18c8c:	bic.w	r2, r2, #15
   18c90:	vmov	s11, r2
   18c94:	vldr	s12, [pc, #524]	; 18ea4 <__ieee754_powf+0x5b0>
   18c98:	vldr	s15, [pc, #524]	; 18ea8 <__ieee754_powf+0x5b4>
   18c9c:	vldr	s5, [pc, #524]	; 18eac <__ieee754_powf+0x5b8>
   18ca0:	vldr	s6, [pc, #524]	; 18eb0 <__ieee754_powf+0x5bc>
   18ca4:	vldr	s4, [pc, #524]	; 18eb4 <__ieee754_powf+0x5c0>
   18ca8:	vldr	s7, [pc, #524]	; 18eb8 <__ieee754_powf+0x5c4>
   18cac:	vldr	s8, [pc, #524]	; 18ebc <__ieee754_powf+0x5c8>
   18cb0:	vldr	s9, [pc, #524]	; 18ec0 <__ieee754_powf+0x5cc>
   18cb4:	vsub.f32	s13, s11, s13
   18cb8:	vmov.f32	s10, #112	; 0x3f800000  1.0
   18cbc:	vsub.f32	s14, s14, s13
   18cc0:	vmul.f32	s13, s11, s12
   18cc4:	vmov.f32	s12, #0	; 0x40000000  2.0
   18cc8:	vfma.f32	s13, s14, s15
   18ccc:	vmov.f32	s14, s13
   18cd0:	vfma.f32	s13, s11, s5
   18cd4:	vmul.f32	s15, s13, s13
   18cd8:	vmov.f32	s3, s13
   18cdc:	vfms.f32	s3, s11, s5
   18ce0:	vmov.f32	s11, s6
   18ce4:	vfma.f32	s11, s15, s4
   18ce8:	vsub.f32	s14, s14, s3
   18cec:	vfma.f32	s7, s15, s11
   18cf0:	vfma.f32	s14, s13, s14
   18cf4:	vfma.f32	s8, s15, s7
   18cf8:	vfma.f32	s9, s15, s8
   18cfc:	vmov.f32	s11, s9
   18d00:	vmov.f32	s9, s13
   18d04:	vfms.f32	s9, s15, s11
   18d08:	vmul.f32	s11, s13, s9
   18d0c:	vsub.f32	s12, s9, s12
   18d10:	vdiv.f32	s15, s11, s12
   18d14:	vsub.f32	s14, s15, s14
   18d18:	vsub.f32	s13, s14, s13
   18d1c:	vsub.f32	s0, s10, s13
   18d20:	vmov	r2, s0
   18d24:	add	r3, r2
   18d26:	cmp.w	r3, #8388608	; 0x800000
   18d2a:	blt.w	18e6c <__ieee754_powf+0x578>
   18d2e:	vmov	s0, r3
   18d32:	vmul.f32	s0, s0, s16
   18d36:	b.n	1893c <__ieee754_powf+0x48>
   18d38:	and.w	r2, r2, #1
   18d3c:	rsb	sl, r2, #2
   18d40:	b.n	18956 <__ieee754_powf+0x62>
   18d42:	ldr	r2, [pc, #384]	; (18ec4 <__ieee754_powf+0x5d0>)
   18d44:	cmp	r7, r2
   18d46:	ble.n	18e0e <__ieee754_powf+0x51a>
   18d48:	cmp	r4, #0
   18d4a:	ble.w	189a6 <__ieee754_powf+0xb2>
   18d4e:	vldr	s0, [pc, #376]	; 18ec8 <__ieee754_powf+0x5d4>
   18d52:	vmul.f32	s0, s0, s0
   18d56:	b.n	1893c <__ieee754_powf+0x48>
   18d58:	vldr	s8, [pc, #288]	; 18e7c <__ieee754_powf+0x588>
   18d5c:	movs	r0, #0
   18d5e:	vmov.f32	s6, s8
   18d62:	vmov.f32	s12, #112	; 0x3f800000  1.0
   18d66:	b.n	18ada <__ieee754_powf+0x1e6>
   18d68:	movs	r2, #0
   18d6a:	b.n	18aa8 <__ieee754_powf+0x1b4>
   18d6c:	vldr	s15, [pc, #348]	; 18ecc <__ieee754_powf+0x5d8>
   18d70:	vsub.f32	s12, s12, s13
   18d74:	vadd.f32	s15, s14, s15
   18d78:	vcmpe.f32	s15, s12
   18d7c:	vmrs	APSR_nzcv, fpscr
   18d80:	ble.n	18d90 <__ieee754_powf+0x49c>
   18d82:	vldr	s0, [pc, #324]	; 18ec8 <__ieee754_powf+0x5d4>
   18d86:	vmul.f32	s15, s16, s0
   18d8a:	vmul.f32	s0, s15, s0
   18d8e:	b.n	1893c <__ieee754_powf+0x48>
   18d90:	asrs	r3, r3, #23
   18d92:	mov.w	r1, #8388608	; 0x800000
   18d96:	subs	r3, #126	; 0x7e
   18d98:	asr.w	r3, r1, r3
   18d9c:	adds	r1, r3, r2
   18d9e:	ubfx	r0, r1, #23, #8
   18da2:	ldr	r4, [pc, #300]	; (18ed0 <__ieee754_powf+0x5dc>)
   18da4:	subs	r0, #127	; 0x7f
   18da6:	asrs	r4, r0
   18da8:	ubfx	r3, r1, #0, #23
   18dac:	bic.w	r1, r1, r4
   18db0:	vmov	s15, r1
   18db4:	vsub.f32	s13, s13, s15
   18db8:	orr.w	r3, r3, #8388608	; 0x800000
   18dbc:	rsb	r0, r0, #23
   18dc0:	asr.w	r0, r3, r0
   18dc4:	cmp	r2, #0
   18dc6:	vadd.f32	s15, s14, s13
   18dca:	it	lt
   18dcc:	neglt	r0, r0
   18dce:	lsls	r3, r0, #23
   18dd0:	vmov	r2, s15
   18dd4:	b.n	18c88 <__ieee754_powf+0x394>
   18dd6:	ldr	r1, [pc, #252]	; (18ed4 <__ieee754_powf+0x5e0>)
   18dd8:	cmp	r3, r1
   18dda:	bgt.n	18dee <__ieee754_powf+0x4fa>
   18ddc:	bne.w	18c7c <__ieee754_powf+0x388>
   18de0:	vsub.f32	s12, s12, s13
   18de4:	vcmpe.f32	s14, s12
   18de8:	vmrs	APSR_nzcv, fpscr
   18dec:	bhi.n	18d90 <__ieee754_powf+0x49c>
   18dee:	vldr	s0, [pc, #232]	; 18ed8 <__ieee754_powf+0x5e4>
   18df2:	vmul.f32	s15, s16, s0
   18df6:	vmul.f32	s0, s15, s0
   18dfa:	b.n	1893c <__ieee754_powf+0x48>
   18dfc:	vldr	s8, [pc, #220]	; 18edc <__ieee754_powf+0x5e8>
   18e00:	vldr	s6, [pc, #220]	; 18ee0 <__ieee754_powf+0x5ec>
   18e04:	mov.w	r0, #2097152	; 0x200000
   18e08:	vmov.f32	s12, #120	; 0x3fc00000  1.5
   18e0c:	b.n	18ada <__ieee754_powf+0x1e6>
   18e0e:	vmov.f32	s15, #112	; 0x3f800000  1.0
   18e12:	vsub.f32	s0, s0, s15
   18e16:	vldr	s12, [pc, #116]	; 18e8c <__ieee754_powf+0x598>
   18e1a:	vldr	s15, [pc, #200]	; 18ee4 <__ieee754_powf+0x5f0>
   18e1e:	vldr	s10, [pc, #200]	; 18ee8 <__ieee754_powf+0x5f4>
   18e22:	vldr	s11, [pc, #200]	; 18eec <__ieee754_powf+0x5f8>
   18e26:	vneg.f32	s13, s0
   18e2a:	vmov.f32	s14, #80	; 0x3e800000  0.250
   18e2e:	vfma.f32	s12, s13, s14
   18e32:	vmov.f32	s14, #96	; 0x3f000000  0.5
   18e36:	vfma.f32	s14, s13, s12
   18e3a:	vmul.f32	s12, s0, s0
   18e3e:	vmul.f32	s14, s14, s12
   18e42:	vnmul.f32	s15, s15, s14
   18e46:	vfma.f32	s15, s0, s10
   18e4a:	vmov.f32	s14, s15
   18e4e:	vfma.f32	s14, s0, s11
   18e52:	vmov	r2, s14
   18e56:	bic.w	r2, r2, #4080	; 0xff0
   18e5a:	bic.w	r2, r2, #15
   18e5e:	vmov	s14, r2
   18e62:	vfma.f32	s14, s13, s11
   18e66:	vsub.f32	s14, s15, s14
   18e6a:	b.n	18c1a <__ieee754_powf+0x326>
   18e6c:	bl	1a920 <scalbnf>
   18e70:	b.n	18d32 <__ieee754_powf+0x43e>
   18e72:	nop
   18e74:	.word	0x001cc471
   18e78:	.word	0x005db3d6
   18e7c:	.word	0x00000000
   18e80:	.word	0x3e53f142
   18e84:	.word	0x3e6c3255
   18e88:	.word	0x3e8ba305
   18e8c:	.word	0x3eaaaaab
   18e90:	.word	0x3edb6db7
   18e94:	.word	0x3f19999a
   18e98:	.word	0x3f76384f
   18e9c:	.word	0x369dc3a0
   18ea0:	.word	0x3f763800
   18ea4:	.word	0x35bfbe8c
   18ea8:	.word	0x3f317218
   18eac:	.word	0x3f317200
   18eb0:	.word	0xb5ddea0e
   18eb4:	.word	0x3331bb4c
   18eb8:	.word	0x388ab355
   18ebc:	.word	0xbb360b61
   18ec0:	.word	0x3e2aaaab
   18ec4:	.word	0x3f800007
   18ec8:	.word	0x7149f2ca
   18ecc:	.word	0x3338aa3c
   18ed0:	.word	0x007fffff
   18ed4:	.word	0x43160000
   18ed8:	.word	0x0da24260
   18edc:	.word	0x3f15c000
   18ee0:	.word	0x35d1cfdc
   18ee4:	.word	0x3fb8aa3b
   18ee8:	.word	0x36eca570
   18eec:	.word	0x3fb8aa00

00018ef0 <__ieee754_rem_pio2f>:
   18ef0:	push	{r4, r5, r6, lr}
   18ef2:	vmov	r3, s0
   18ef6:	ldr	r2, [pc, #600]	; (19150 <__ieee754_rem_pio2f+0x260>)
   18ef8:	bic.w	r4, r3, #2147483648	; 0x80000000
   18efc:	cmp	r4, r2
   18efe:	sub	sp, #24
   18f00:	ble.n	18fc2 <__ieee754_rem_pio2f+0xd2>
   18f02:	ldr	r2, [pc, #592]	; (19154 <__ieee754_rem_pio2f+0x264>)
   18f04:	cmp	r4, r2
   18f06:	vmov	r6, s0
   18f0a:	bgt.n	18f44 <__ieee754_rem_pio2f+0x54>
   18f0c:	cmp	r3, #0
   18f0e:	vldr	s15, [pc, #584]	; 19158 <__ieee754_rem_pio2f+0x268>
   18f12:	ldr	r2, [pc, #584]	; (1915c <__ieee754_rem_pio2f+0x26c>)
   18f14:	bic.w	r4, r4, #15
   18f18:	ble.w	190c6 <__ieee754_rem_pio2f+0x1d6>
   18f1c:	cmp	r4, r2
   18f1e:	vsub.f32	s15, s0, s15
   18f22:	beq.n	18fe2 <__ieee754_rem_pio2f+0xf2>
   18f24:	vldr	s14, [pc, #568]	; 19160 <__ieee754_rem_pio2f+0x270>
   18f28:	vsub.f32	s13, s15, s14
   18f2c:	movs	r3, #1
   18f2e:	vsub.f32	s15, s15, s13
   18f32:	vstr	s13, [r0]
   18f36:	vsub.f32	s15, s15, s14
   18f3a:	vstr	s15, [r0, #4]
   18f3e:	mov	r0, r3
   18f40:	add	sp, #24
   18f42:	pop	{r4, r5, r6, pc}
   18f44:	ldr	r2, [pc, #540]	; (19164 <__ieee754_rem_pio2f+0x274>)
   18f46:	cmp	r4, r2
   18f48:	mov	r5, r0
   18f4a:	ble.n	19006 <__ieee754_rem_pio2f+0x116>
   18f4c:	cmp.w	r4, #2139095040	; 0x7f800000
   18f50:	bge.n	18fd2 <__ieee754_rem_pio2f+0xe2>
   18f52:	asrs	r2, r4, #23
   18f54:	subs	r2, #134	; 0x86
   18f56:	sub.w	r3, r4, r2, lsl #23
   18f5a:	vmov	s14, r3
   18f5e:	vcvt.s32.f32	s13, s14
   18f62:	vldr	s15, [pc, #516]	; 19168 <__ieee754_rem_pio2f+0x278>
   18f66:	vcvt.f32.s32	s13, s13
   18f6a:	vsub.f32	s14, s14, s13
   18f6e:	vstr	s13, [sp, #12]
   18f72:	vmul.f32	s14, s14, s15
   18f76:	vcvt.s32.f32	s13, s14
   18f7a:	vcvt.f32.s32	s13, s13
   18f7e:	vsub.f32	s14, s14, s13
   18f82:	vstr	s13, [sp, #16]
   18f86:	vmul.f32	s15, s14, s15
   18f8a:	vcmp.f32	s15, #0.0
   18f8e:	vmrs	APSR_nzcv, fpscr
   18f92:	vstr	s15, [sp, #20]
   18f96:	bne.w	19108 <__ieee754_rem_pio2f+0x218>
   18f9a:	vcmp.f32	s13, #0.0
   18f9e:	vmrs	APSR_nzcv, fpscr
   18fa2:	ite	eq
   18fa4:	moveq	r3, #1
   18fa6:	movne	r3, #2
   18fa8:	ldr	r1, [pc, #448]	; (1916c <__ieee754_rem_pio2f+0x27c>)
   18faa:	str	r1, [sp, #4]
   18fac:	movs	r1, #2
   18fae:	str	r1, [sp, #0]
   18fb0:	add	r0, sp, #12
   18fb2:	mov	r1, r5
   18fb4:	bl	19a80 <__kernel_rem_pio2f>
   18fb8:	cmp	r6, #0
   18fba:	blt.w	190ec <__ieee754_rem_pio2f+0x1fc>
   18fbe:	mov	r3, r0
   18fc0:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   18fc2:	movs	r2, #0
   18fc4:	vstr	s0, [r0]
   18fc8:	str	r2, [r0, #4]
   18fca:	movs	r3, #0
   18fcc:	mov	r0, r3
   18fce:	add	sp, #24
   18fd0:	pop	{r4, r5, r6, pc}
   18fd2:	vsub.f32	s15, s0, s0
   18fd6:	movs	r3, #0
   18fd8:	vstr	s15, [r0, #4]
   18fdc:	vstr	s15, [r0]
   18fe0:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   18fe2:	vldr	s13, [pc, #396]	; 19170 <__ieee754_rem_pio2f+0x280>
   18fe6:	vldr	s14, [pc, #396]	; 19174 <__ieee754_rem_pio2f+0x284>
   18fea:	vsub.f32	s15, s15, s13
   18fee:	movs	r3, #1
   18ff0:	vsub.f32	s13, s15, s14
   18ff4:	vsub.f32	s15, s15, s13
   18ff8:	vstr	s13, [r0]
   18ffc:	vsub.f32	s15, s15, s14
   19000:	vstr	s15, [r0, #4]
   19004:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   19006:	bl	1a860 <fabsf>
   1900a:	vldr	s13, [pc, #364]	; 19178 <__ieee754_rem_pio2f+0x288>
   1900e:	vldr	s11, [pc, #328]	; 19158 <__ieee754_rem_pio2f+0x268>
   19012:	vldr	s14, [pc, #332]	; 19160 <__ieee754_rem_pio2f+0x270>
   19016:	vmov.f32	s15, #96	; 0x3f000000  0.5
   1901a:	vfma.f32	s15, s0, s13
   1901e:	vcvt.s32.f32	s15, s15
   19022:	vmov	r3, s15
   19026:	vcvt.f32.s32	s13, s15
   1902a:	cmp	r3, #31
   1902c:	vneg.f32	s12, s13
   19030:	vfma.f32	s0, s12, s11
   19034:	vmul.f32	s15, s13, s14
   19038:	bgt.n	19076 <__ieee754_rem_pio2f+0x186>
   1903a:	ldr	r1, [pc, #320]	; (1917c <__ieee754_rem_pio2f+0x28c>)
   1903c:	subs	r0, r3, #1
   1903e:	bic.w	r2, r4, #255	; 0xff
   19042:	ldr.w	r1, [r1, r0, lsl #2]
   19046:	cmp	r2, r1
   19048:	beq.n	19076 <__ieee754_rem_pio2f+0x186>
   1904a:	vsub.f32	s14, s0, s15
   1904e:	vstr	s14, [r5]
   19052:	vsub.f32	s0, s0, s14
   19056:	cmp	r6, #0
   19058:	vsub.f32	s0, s0, s15
   1905c:	vstr	s0, [r5, #4]
   19060:	bge.n	18fcc <__ieee754_rem_pio2f+0xdc>
   19062:	vneg.f32	s14, s14
   19066:	vneg.f32	s0, s0
   1906a:	vstr	s14, [r5]
   1906e:	vstr	s0, [r5, #4]
   19072:	negs	r3, r3
   19074:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   19076:	vsub.f32	s14, s0, s15
   1907a:	asrs	r4, r4, #23
   1907c:	vmov	r2, s14
   19080:	ubfx	r2, r2, #23, #8
   19084:	subs	r2, r4, r2
   19086:	cmp	r2, #8
   19088:	ble.n	1904e <__ieee754_rem_pio2f+0x15e>
   1908a:	vldr	s15, [pc, #228]	; 19170 <__ieee754_rem_pio2f+0x280>
   1908e:	vldr	s14, [pc, #228]	; 19174 <__ieee754_rem_pio2f+0x284>
   19092:	vmov.f32	s11, s0
   19096:	vfma.f32	s11, s12, s15
   1909a:	vsub.f32	s0, s0, s11
   1909e:	vfma.f32	s0, s12, s15
   190a2:	vmov.f32	s15, s0
   190a6:	vfnms.f32	s15, s13, s14
   190aa:	vsub.f32	s14, s11, s15
   190ae:	vmov	r2, s14
   190b2:	ubfx	r2, r2, #23, #8
   190b6:	subs	r4, r4, r2
   190b8:	cmp	r4, #25
   190ba:	bgt.n	19132 <__ieee754_rem_pio2f+0x242>
   190bc:	vstr	s14, [r5]
   190c0:	vmov.f32	s0, s11
   190c4:	b.n	19052 <__ieee754_rem_pio2f+0x162>
   190c6:	cmp	r4, r2
   190c8:	vadd.f32	s15, s0, s15
   190cc:	beq.n	1910c <__ieee754_rem_pio2f+0x21c>
   190ce:	vldr	s14, [pc, #144]	; 19160 <__ieee754_rem_pio2f+0x270>
   190d2:	vadd.f32	s13, s15, s14
   190d6:	mov.w	r3, #4294967295
   190da:	vsub.f32	s15, s15, s13
   190de:	vstr	s13, [r0]
   190e2:	vadd.f32	s15, s15, s14
   190e6:	vstr	s15, [r0, #4]
   190ea:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   190ec:	vldr	s14, [r5]
   190f0:	vldr	s15, [r5, #4]
   190f4:	vneg.f32	s14, s14
   190f8:	vneg.f32	s15, s15
   190fc:	negs	r3, r0
   190fe:	vstr	s14, [r5]
   19102:	vstr	s15, [r5, #4]
   19106:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   19108:	movs	r3, #3
   1910a:	b.n	18fa8 <__ieee754_rem_pio2f+0xb8>
   1910c:	vldr	s13, [pc, #96]	; 19170 <__ieee754_rem_pio2f+0x280>
   19110:	vldr	s14, [pc, #96]	; 19174 <__ieee754_rem_pio2f+0x284>
   19114:	vadd.f32	s15, s15, s13
   19118:	mov.w	r3, #4294967295
   1911c:	vadd.f32	s13, s15, s14
   19120:	vsub.f32	s15, s15, s13
   19124:	vstr	s13, [r0]
   19128:	vadd.f32	s15, s15, s14
   1912c:	vstr	s15, [r0, #4]
   19130:	b.n	18fcc <__ieee754_rem_pio2f+0xdc>
   19132:	vldr	s14, [pc, #76]	; 19180 <__ieee754_rem_pio2f+0x290>
   19136:	vldr	s10, [pc, #76]	; 19184 <__ieee754_rem_pio2f+0x294>
   1913a:	vmov.f32	s0, s11
   1913e:	vfma.f32	s0, s12, s14
   19142:	vsub.f32	s15, s11, s0
   19146:	vfma.f32	s15, s12, s14
   1914a:	vfnms.f32	s15, s13, s10
   1914e:	b.n	1904a <__ieee754_rem_pio2f+0x15a>
   19150:	.word	0x3f490fd8
   19154:	.word	0x4016cbe3
   19158:	.word	0x3fc90f80
   1915c:	.word	0x3fc90fd0
   19160:	.word	0x37354443
   19164:	.word	0x43490f80
   19168:	.word	0x43800000
   1916c:	.word	0x200200b0
   19170:	.word	0x37354400
   19174:	.word	0x2e85a308
   19178:	.word	0x3f22f984
   1917c:	.word	0x20020030
   19180:	.word	0x2e85a300
   19184:	.word	0x248d3132

00019188 <__ieee754_sqrtf>:
   19188:	vmov	r3, s0
   1918c:	bic.w	r2, r3, #2147483648	; 0x80000000
   19190:	cmp.w	r2, #2139095040	; 0x7f800000
   19194:	push	{r4, r5, r6}
   19196:	bcs.n	191fa <__ieee754_sqrtf+0x72>
   19198:	cbz	r2, 191f6 <__ieee754_sqrtf+0x6e>
   1919a:	cmp	r3, #0
   1919c:	blt.n	1921a <__ieee754_sqrtf+0x92>
   1919e:	cmp.w	r2, #8388608	; 0x800000
   191a2:	mov.w	r0, r3, asr #23
   191a6:	bcc.n	19202 <__ieee754_sqrtf+0x7a>
   191a8:	sub.w	r2, r0, #127	; 0x7f
   191ac:	ubfx	r3, r3, #0, #23
   191b0:	lsls	r1, r2, #31
   191b2:	orr.w	r3, r3, #8388608	; 0x800000
   191b6:	it	mi
   191b8:	lslmi	r3, r3, #1
   191ba:	movs	r4, #0
   191bc:	asrs	r6, r2, #1
   191be:	lsls	r3, r3, #1
   191c0:	mov	r5, r4
   191c2:	movs	r1, #25
   191c4:	mov.w	r2, #16777216	; 0x1000000
   191c8:	adds	r0, r5, r2
   191ca:	cmp	r0, r3
   191cc:	bgt.n	191d4 <__ieee754_sqrtf+0x4c>
   191ce:	subs	r3, r3, r0
   191d0:	adds	r5, r0, r2
   191d2:	add	r4, r2
   191d4:	subs	r1, #1
   191d6:	mov.w	r3, r3, lsl #1
   191da:	mov.w	r2, r2, lsr #1
   191de:	bne.n	191c8 <__ieee754_sqrtf+0x40>
   191e0:	cbz	r3, 191e8 <__ieee754_sqrtf+0x60>
   191e2:	and.w	r3, r4, #1
   191e6:	add	r4, r3
   191e8:	asrs	r4, r4, #1
   191ea:	add.w	r4, r4, #1056964608	; 0x3f000000
   191ee:	add.w	r3, r4, r6, lsl #23
   191f2:	vmov	s0, r3
   191f6:	pop	{r4, r5, r6}
   191f8:	bx	lr
   191fa:	vfma.f32	s0, s0, s0
   191fe:	pop	{r4, r5, r6}
   19200:	bx	lr
   19202:	ands.w	r2, r3, #8388608	; 0x800000
   19206:	beq.n	1920c <__ieee754_sqrtf+0x84>
   19208:	b.n	19224 <__ieee754_sqrtf+0x9c>
   1920a:	mov	r2, r1
   1920c:	lsls	r3, r3, #1
   1920e:	lsls	r4, r3, #8
   19210:	add.w	r1, r2, #1
   19214:	bpl.n	1920a <__ieee754_sqrtf+0x82>
   19216:	subs	r0, r0, r2
   19218:	b.n	191a8 <__ieee754_sqrtf+0x20>
   1921a:	vsub.f32	s15, s0, s0
   1921e:	vdiv.f32	s0, s15, s15
   19222:	b.n	191f6 <__ieee754_sqrtf+0x6e>
   19224:	mov.w	r2, #4294967295
   19228:	b.n	19216 <__ieee754_sqrtf+0x8e>
   1922a:	nop
   1922c:	movs	r0, r0
	...

00019230 <__kernel_cos>:
   19230:	vmov	r3, s1
   19234:	bic.w	r3, r3, #2147483648	; 0x80000000
   19238:	cmp.w	r3, #1044381696	; 0x3e400000
   1923c:	bge.n	19298 <__kernel_cos+0x68>
   1923e:	vcvt.s32.f64	s15, d0
   19242:	vmov	r3, s15
   19246:	cmp	r3, #0
   19248:	beq.n	1930e <__kernel_cos+0xde>
   1924a:	vmul.f64	d7, d0, d0
   1924e:	vldr	d4, [pc, #200]	; 19318 <__kernel_cos+0xe8>
   19252:	vldr	d5, [pc, #204]	; 19320 <__kernel_cos+0xf0>
   19256:	vldr	d6, [pc, #208]	; 19328 <__kernel_cos+0xf8>
   1925a:	vfma.f64	d5, d7, d4
   1925e:	vldr	d4, [pc, #208]	; 19330 <__kernel_cos+0x100>
   19262:	vfma.f64	d6, d7, d5
   19266:	vldr	d5, [pc, #208]	; 19338 <__kernel_cos+0x108>
   1926a:	vfma.f64	d4, d7, d6
   1926e:	vldr	d6, [pc, #208]	; 19340 <__kernel_cos+0x110>
   19272:	vfma.f64	d5, d7, d4
   19276:	vfma.f64	d6, d7, d5
   1927a:	vmul.f64	d6, d6, d7
   1927e:	vnmul.f64	d0, d1, d0
   19282:	vmov.f64	d5, #96	; 0x3f000000  0.5
   19286:	vfma.f64	d0, d7, d6
   1928a:	vmov.f64	d6, #112	; 0x3f800000  1.0
   1928e:	vfnms.f64	d0, d7, d5
   19292:	vsub.f64	d0, d6, d0
   19296:	bx	lr
   19298:	vldr	d4, [pc, #124]	; 19318 <__kernel_cos+0xe8>
   1929c:	vmul.f64	d7, d0, d0
   192a0:	vldr	d5, [pc, #124]	; 19320 <__kernel_cos+0xf0>
   192a4:	vldr	d6, [pc, #128]	; 19328 <__kernel_cos+0xf8>
   192a8:	vfma.f64	d5, d7, d4
   192ac:	vldr	d4, [pc, #128]	; 19330 <__kernel_cos+0x100>
   192b0:	vfma.f64	d6, d7, d5
   192b4:	ldr	r2, [pc, #144]	; (19348 <__kernel_cos+0x118>)
   192b6:	vfma.f64	d4, d7, d6
   192ba:	vldr	d5, [pc, #124]	; 19338 <__kernel_cos+0x108>
   192be:	vldr	d6, [pc, #128]	; 19340 <__kernel_cos+0x110>
   192c2:	vfma.f64	d5, d7, d4
   192c6:	cmp	r3, r2
   192c8:	vfma.f64	d6, d7, d5
   192cc:	vmul.f64	d6, d6, d7
   192d0:	ble.n	1927e <__kernel_cos+0x4e>
   192d2:	ldr	r2, [pc, #120]	; (1934c <__kernel_cos+0x11c>)
   192d4:	cmp	r3, r2
   192d6:	bgt.n	19304 <__kernel_cos+0xd4>
   192d8:	vmov.f64	d4, #112	; 0x3f800000  1.0
   192dc:	movs	r0, #0
   192de:	sub.w	r1, r3, #2097152	; 0x200000
   192e2:	vmov	d5, r0, r1
   192e6:	vsub.f64	d4, d4, d5
   192ea:	vnmul.f64	d1, d1, d0
   192ee:	vmov.f64	d3, #96	; 0x3f000000  0.5
   192f2:	vfma.f64	d1, d7, d6
   192f6:	vfnms.f64	d5, d7, d3
   192fa:	vsub.f64	d5, d5, d1
   192fe:	vsub.f64	d0, d4, d5
   19302:	bx	lr
   19304:	vmov.f64	d4, #103	; 0x3f380000  0.7187500
   19308:	vmov.f64	d5, #82	; 0x3e900000  0.2812500
   1930c:	b.n	192ea <__kernel_cos+0xba>
   1930e:	vmov.f64	d0, #112	; 0x3f800000  1.0
   19312:	bx	lr
   19314:	nop.w
   19318:	.word	0xbe8838d4
   1931c:	.word	0xbda8fae9
   19320:	.word	0xbdb4b1c4
   19324:	.word	0x3e21ee9e
   19328:	.word	0x809c52ad
   1932c:	.word	0xbe927e4f
   19330:	.word	0x19cb1590
   19334:	.word	0x3efa01a0
   19338:	.word	0x16c15177
   1933c:	.word	0xbf56c16c
   19340:	.word	0x5555554c
   19344:	.word	0x3fa55555
   19348:	.word	0x3fd33332
   1934c:	.word	0x3fe90000

00019350 <__kernel_rem_pio2>:
   19350:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19354:	vpush	{d8-d11}
   19358:	sub.w	sp, sp, #588	; 0x24c
   1935c:	ldr	r4, [pc, #704]	; (19620 <__kernel_rem_pio2+0x2d0>)
   1935e:	ldr	r6, [sp, #656]	; 0x290
   19360:	ldr	r5, [pc, #704]	; (19624 <__kernel_rem_pio2+0x2d4>)
   19362:	ldr.w	r6, [r4, r6, lsl #2]
   19366:	str	r3, [sp, #4]
   19368:	subs	r4, r2, #3
   1936a:	smull	r7, r5, r5, r4
   1936e:	asrs	r4, r4, #31
   19370:	rsb	r4, r4, r5, asr #2
   19374:	bic.w	r4, r4, r4, asr #31
   19378:	subs	r7, r3, #1
   1937a:	add.w	sl, r4, #1
   1937e:	sub.w	sl, sl, sl, lsl #2
   19382:	mov	fp, r1
   19384:	adds	r1, r6, r7
   19386:	str	r4, [sp, #8]
   19388:	mov	r9, r0
   1938a:	add.w	sl, r2, sl, lsl #3
   1938e:	sub.w	r3, r4, r7
   19392:	bmi.n	193c6 <__kernel_rem_pio2+0x76>
   19394:	add	r1, r3
   19396:	adds	r1, #1
   19398:	add	r2, sp, #104	; 0x68
   1939a:	ldr	r0, [sp, #660]	; 0x294
   1939c:	b.n	193b4 <__kernel_rem_pio2+0x64>
   1939e:	ldr.w	r4, [r0, r3, lsl #2]
   193a2:	vmov	s15, r4
   193a6:	adds	r3, #1
   193a8:	vcvt.f64.s32	d7, s15
   193ac:	cmp	r3, r1
   193ae:	vstmia	r2!, {d7}
   193b2:	beq.n	193c6 <__kernel_rem_pio2+0x76>
   193b4:	cmp	r3, #0
   193b6:	bge.n	1939e <__kernel_rem_pio2+0x4e>
   193b8:	vldr	d7, [pc, #588]	; 19608 <__kernel_rem_pio2+0x2b8>
   193bc:	adds	r3, #1
   193be:	cmp	r3, r1
   193c0:	vstmia	r2!, {d7}
   193c4:	bne.n	193b4 <__kernel_rem_pio2+0x64>
   193c6:	cmp	r6, #0
   193c8:	blt.w	19990 <__kernel_rem_pio2+0x640>
   193cc:	ldr	r3, [sp, #4]
   193ce:	add	r0, sp, #424	; 0x1a8
   193d0:	add.w	lr, r6, #1
   193d4:	lsls	r4, r3, #3
   193d6:	add.w	lr, r0, lr, lsl #3
   193da:	add.w	r1, r9, r4
   193de:	mov	r5, r7
   193e0:	cmp	r7, #0
   193e2:	blt.w	19776 <__kernel_rem_pio2+0x426>
   193e6:	add	r3, sp, #104	; 0x68
   193e8:	vldr	d7, [pc, #540]	; 19608 <__kernel_rem_pio2+0x2b8>
   193ec:	add.w	r2, r3, r5, lsl #3
   193f0:	adds	r2, #8
   193f2:	mov	r3, r9
   193f4:	vldmia	r3!, {d5}
   193f8:	vldmdb	r2!, {d6}
   193fc:	cmp	r3, r1
   193fe:	vfma.f64	d7, d5, d6
   19402:	bne.n	193f4 <__kernel_rem_pio2+0xa4>
   19404:	vstmia	r0!, {d7}
   19408:	cmp	r0, lr
   1940a:	add.w	r5, r5, #1
   1940e:	bne.n	193e0 <__kernel_rem_pio2+0x90>
   19410:	add.w	r3, r6, #1073741824	; 0x40000000
   19414:	subs	r3, #2
   19416:	lsls	r3, r3, #2
   19418:	add	r2, sp, #24
   1941a:	vldr	d9, [pc, #500]	; 19610 <__kernel_rem_pio2+0x2c0>
   1941e:	vldr	d8, [pc, #504]	; 19618 <__kernel_rem_pio2+0x2c8>
   19422:	add.w	r8, r3, #4
   19426:	add	r3, r2
   19428:	add	r4, r9
   1942a:	add	r8, r2
   1942c:	str	r3, [sp, #12]
   1942e:	mov	r5, r6
   19430:	str.w	fp, [sp, #16]
   19434:	add	r3, sp, #584	; 0x248
   19436:	add.w	r3, r3, r5, lsl #3
   1943a:	cmp	r5, #0
   1943c:	vldr	d0, [r3, #-160]	; 0xffffff60
   19440:	ble.n	19472 <__kernel_rem_pio2+0x122>
   19442:	add	r1, sp, #424	; 0x1a8
   19444:	add.w	r3, r1, r5, lsl #3
   19448:	add	r2, sp, #20
   1944a:	vmul.f64	d7, d0, d9
   1944e:	vcvt.s32.f64	s14, d7
   19452:	vldmdb	r3!, {d6}
   19456:	vcvt.f64.s32	d7, s14
   1945a:	vfms.f64	d0, d7, d8
   1945e:	vcvt.s32.f64	s11, d0
   19462:	cmp	r3, r1
   19464:	vmov	r0, s11
   19468:	vadd.f64	d0, d7, d6
   1946c:	str.w	r0, [r2, #4]!
   19470:	bne.n	1944a <__kernel_rem_pio2+0xfa>
   19472:	mov	r0, sl
   19474:	bl	1a4d0 <scalbn>
   19478:	vmov.f64	d10, d0
   1947c:	vmov.f64	d0, #64	; 0x3e000000  0.125
   19480:	vmul.f64	d0, d10, d0
   19484:	bl	1a298 <floor>
   19488:	vmov.f64	d7, #32	; 0x41000000  8.0
   1948c:	vfms.f64	d10, d0, d7
   19490:	vcvt.s32.f64	s15, d10
   19494:	cmp.w	sl, #0
   19498:	vmov	fp, s15
   1949c:	vcvt.f64.s32	d7, s15
   194a0:	vsub.f64	d10, d10, d7
   194a4:	ble.w	19740 <__kernel_rem_pio2+0x3f0>
   194a8:	add.w	lr, r5, #4294967295
   194ac:	add	r3, sp, #24
   194ae:	rsb	r2, sl, #24
   194b2:	ldr.w	r3, [r3, lr, lsl #2]
   194b6:	asr.w	r0, r3, r2
   194ba:	lsl.w	r2, r0, r2
   194be:	add	r1, sp, #24
   194c0:	subs	r3, r3, r2
   194c2:	rsb	r2, sl, #23
   194c6:	str.w	r3, [r1, lr, lsl #2]
   194ca:	add	fp, r0
   194cc:	asr.w	r1, r3, r2
   194d0:	cmp	r1, #0
   194d2:	ble.n	19548 <__kernel_rem_pio2+0x1f8>
   194d4:	cmp	r5, #0
   194d6:	add.w	fp, fp, #1
   194da:	ble.w	19926 <__kernel_rem_pio2+0x5d6>
   194de:	movs	r2, #0
   194e0:	mov	r0, r2
   194e2:	add.w	lr, sp, #20
   194e6:	mov	ip, r1
   194e8:	b.n	194fc <__kernel_rem_pio2+0x1ac>
   194ea:	rsb	r1, r3, #16777216	; 0x1000000
   194ee:	cbz	r3, 194f6 <__kernel_rem_pio2+0x1a6>
   194f0:	str.w	r1, [lr]
   194f4:	movs	r0, #1
   194f6:	adds	r2, #1
   194f8:	cmp	r5, r2
   194fa:	ble.n	1951a <__kernel_rem_pio2+0x1ca>
   194fc:	ldr.w	r3, [lr, #4]!
   19500:	cmp	r0, #0
   19502:	beq.n	194ea <__kernel_rem_pio2+0x19a>
   19504:	rsb	r3, r3, #16711935	; 0xff00ff
   19508:	adds	r2, #1
   1950a:	add.w	r3, r3, #65280	; 0xff00
   1950e:	cmp	r5, r2
   19510:	str.w	r3, [lr]
   19514:	mov.w	r0, #1
   19518:	bgt.n	194fc <__kernel_rem_pio2+0x1ac>
   1951a:	mov	r1, ip
   1951c:	cmp.w	sl, #0
   19520:	ble.n	19544 <__kernel_rem_pio2+0x1f4>
   19522:	cmp.w	sl, #1
   19526:	beq.w	1974e <__kernel_rem_pio2+0x3fe>
   1952a:	cmp.w	sl, #2
   1952e:	bne.n	19544 <__kernel_rem_pio2+0x1f4>
   19530:	subs	r2, r5, #1
   19532:	add	r3, sp, #24
   19534:	add.w	lr, sp, #24
   19538:	ldr.w	r3, [r3, r2, lsl #2]
   1953c:	ubfx	r3, r3, #0, #22
   19540:	str.w	r3, [lr, r2, lsl #2]
   19544:	cmp	r1, #2
   19546:	beq.n	19628 <__kernel_rem_pio2+0x2d8>
   19548:	vcmp.f64	d10, #0.0
   1954c:	vmrs	APSR_nzcv, fpscr
   19550:	bne.n	1964c <__kernel_rem_pio2+0x2fc>
   19552:	add.w	lr, r5, #4294967295
   19556:	cmp	r6, lr
   19558:	bgt.n	1957a <__kernel_rem_pio2+0x22a>
   1955a:	add.w	r2, r5, #1073741824	; 0x40000000
   1955e:	subs	r2, #1
   19560:	add	r3, sp, #24
   19562:	add.w	r2, r3, r2, lsl #2
   19566:	movs	r0, #0
   19568:	ldr.w	r3, [r2], #-4
   1956c:	cmp	r2, r8
   1956e:	orr.w	r0, r0, r3
   19572:	bne.n	19568 <__kernel_rem_pio2+0x218>
   19574:	cmp	r0, #0
   19576:	bne.w	197a4 <__kernel_rem_pio2+0x454>
   1957a:	subs	r3, r6, #1
   1957c:	add	r2, sp, #24
   1957e:	ldr.w	r3, [r2, r3, lsl #2]
   19582:	cmp	r3, #0
   19584:	bne.w	19920 <__kernel_rem_pio2+0x5d0>
   19588:	ldr	r3, [sp, #12]
   1958a:	mov.w	lr, #1
   1958e:	ldr.w	r2, [r3], #-4
   19592:	add.w	lr, lr, #1
   19596:	cmp	r2, #0
   19598:	beq.n	1958e <__kernel_rem_pio2+0x23e>
   1959a:	add	lr, r5
   1959c:	adds	r3, r5, #1
   1959e:	cmp	r3, lr
   195a0:	bgt.n	195fe <__kernel_rem_pio2+0x2ae>
   195a2:	ldr	r2, [sp, #8]
   195a4:	adds	r0, r3, r2
   195a6:	ldr	r2, [sp, #4]
   195a8:	add.w	r0, r0, #1073741824	; 0x40000000
   195ac:	adds	r1, r2, r5
   195ae:	add.w	ip, lr, r2
   195b2:	ldr	r2, [sp, #660]	; 0x294
   195b4:	subs	r0, #1
   195b6:	add.w	r0, r2, r0, lsl #2
   195ba:	add	r2, sp, #104	; 0x68
   195bc:	add.w	r1, r2, r1, lsl #3
   195c0:	add.w	ip, r2, ip, lsl #3
   195c4:	add	r2, sp, #424	; 0x1a8
   195c6:	add.w	r5, r2, r3, lsl #3
   195ca:	ldr.w	r3, [r0, #4]!
   195ce:	vmov	s14, r3
   195d2:	vcvt.f64.s32	d7, s14
   195d6:	cmp	r7, #0
   195d8:	vstmia	r1!, {d7}
   195dc:	vldr	d7, [pc, #40]	; 19608 <__kernel_rem_pio2+0x2b8>
   195e0:	blt.n	195f6 <__kernel_rem_pio2+0x2a6>
   195e2:	mov	r3, r9
   195e4:	mov	r2, r1
   195e6:	vldmia	r3!, {d5}
   195ea:	vldmdb	r2!, {d6}
   195ee:	cmp	r3, r4
   195f0:	vfma.f64	d7, d5, d6
   195f4:	bne.n	195e6 <__kernel_rem_pio2+0x296>
   195f6:	cmp	r1, ip
   195f8:	vstmia	r5!, {d7}
   195fc:	bne.n	195ca <__kernel_rem_pio2+0x27a>
   195fe:	mov	r5, lr
   19600:	b.n	19434 <__kernel_rem_pio2+0xe4>
   19602:	nop
   19604:	nop.w
	...
   19614:	.word	0x3e700000
   19618:	.word	0x00000000
   1961c:	.word	0x41700000
   19620:	.word	0x200203c8
   19624:	.word	0x2aaaaaab
   19628:	vmov.f64	d0, #112	; 0x3f800000  1.0
   1962c:	vsub.f64	d10, d0, d10
   19630:	cmp	r0, #0
   19632:	beq.n	19548 <__kernel_rem_pio2+0x1f8>
   19634:	mov	r0, sl
   19636:	str	r1, [sp, #20]
   19638:	bl	1a4d0 <scalbn>
   1963c:	vsub.f64	d10, d10, d0
   19640:	vcmp.f64	d10, #0.0
   19644:	vmrs	APSR_nzcv, fpscr
   19648:	ldr	r1, [sp, #20]
   1964a:	beq.n	19552 <__kernel_rem_pio2+0x202>
   1964c:	vmov.f64	d0, d10
   19650:	rsb	r0, sl, #0
   19654:	vmov	s22, fp
   19658:	mov	r9, r1
   1965a:	ldr.w	fp, [sp, #16]
   1965e:	bl	1a4d0 <scalbn>
   19662:	vldr	d6, [pc, #836]	; 199a8 <__kernel_rem_pio2+0x658>
   19666:	vcmpe.f64	d0, d6
   1966a:	vmrs	APSR_nzcv, fpscr
   1966e:	blt.w	19956 <__kernel_rem_pio2+0x606>
   19672:	vldr	d7, [pc, #828]	; 199b0 <__kernel_rem_pio2+0x660>
   19676:	vmul.f64	d7, d0, d7
   1967a:	vcvt.s32.f64	s14, d7
   1967e:	add	r1, sp, #24
   19680:	vcvt.f64.s32	d5, s14
   19684:	vfms.f64	d0, d5, d6
   19688:	vcvt.s32.f64	s0, d0
   1968c:	adds	r3, r5, #1
   1968e:	vmov	r2, s0
   19692:	str.w	r2, [r1, r5, lsl #2]
   19696:	vmov	r2, s14
   1969a:	str.w	r2, [r1, r3, lsl #2]
   1969e:	add.w	sl, sl, #24
   196a2:	vmov.f64	d0, #112	; 0x3f800000  1.0
   196a6:	mov	r0, sl
   196a8:	str	r3, [sp, #4]
   196aa:	bl	1a4d0 <scalbn>
   196ae:	ldr	r3, [sp, #4]
   196b0:	cmp	r3, #0
   196b2:	blt.w	19972 <__kernel_rem_pio2+0x622>
   196b6:	add	r4, sp, #424	; 0x1a8
   196b8:	lsls	r7, r3, #3
   196ba:	add	r2, sp, #24
   196bc:	vldr	d6, [pc, #752]	; 199b0 <__kernel_rem_pio2+0x660>
   196c0:	add.w	r2, r2, r3, lsl #2
   196c4:	add.w	ip, r4, r7
   196c8:	adds	r2, #4
   196ca:	add.w	r0, ip, #8
   196ce:	vldmdb	r2!, {s14}
   196d2:	vcvt.f64.s32	d7, s14
   196d6:	vmul.f64	d7, d7, d0
   196da:	vstmdb	r0!, {d7}
   196de:	vmul.f64	d0, d0, d6
   196e2:	cmp	r0, r4
   196e4:	bne.n	196ce <__kernel_rem_pio2+0x37e>
   196e6:	add.w	r8, sp, #416	; 0x1a0
   196ea:	movs	r5, #0
   196ec:	add.w	lr, sp, #264	; 0x108
   196f0:	cmp	r6, #0
   196f2:	blt.w	1991a <__kernel_rem_pio2+0x5ca>
   196f6:	ldr	r0, [pc, #720]	; (199c8 <__kernel_rem_pio2+0x678>)
   196f8:	mov	r1, ip
   196fa:	vldr	d6, [pc, #700]	; 199b8 <__kernel_rem_pio2+0x668>
   196fe:	vldr	d7, [pc, #704]	; 199c0 <__kernel_rem_pio2+0x670>
   19702:	movs	r2, #0
   19704:	b.n	1970e <__kernel_rem_pio2+0x3be>
   19706:	cmp	r5, r2
   19708:	blt.n	1971c <__kernel_rem_pio2+0x3cc>
   1970a:	vldmia	r0!, {d6}
   1970e:	vldmia	r1!, {d5}
   19712:	adds	r2, #1
   19714:	cmp	r6, r2
   19716:	vfma.f64	d7, d5, d6
   1971a:	bge.n	19706 <__kernel_rem_pio2+0x3b6>
   1971c:	sub.w	ip, ip, #8
   19720:	add.w	r2, lr, r5, lsl #3
   19724:	cmp	ip, r8
   19726:	vstr	d7, [r2]
   1972a:	add.w	r5, r5, #1
   1972e:	bne.n	196f0 <__kernel_rem_pio2+0x3a0>
   19730:	ldr	r2, [sp, #656]	; 0x290
   19732:	cmp	r2, #3
   19734:	bhi.w	19892 <__kernel_rem_pio2+0x542>
   19738:	tbb	[pc, r2]
   1973c:	.word	0x50b5b5dd
   19740:	bne.n	19764 <__kernel_rem_pio2+0x414>
   19742:	subs	r3, r5, #1
   19744:	add	r2, sp, #24
   19746:	ldr.w	r1, [r2, r3, lsl #2]
   1974a:	asrs	r1, r1, #23
   1974c:	b.n	194d0 <__kernel_rem_pio2+0x180>
   1974e:	subs	r2, r5, #1
   19750:	add	r3, sp, #24
   19752:	add.w	lr, sp, #24
   19756:	ldr.w	r3, [r3, r2, lsl #2]
   1975a:	ubfx	r3, r3, #0, #23
   1975e:	str.w	r3, [lr, r2, lsl #2]
   19762:	b.n	19544 <__kernel_rem_pio2+0x1f4>
   19764:	vmov.f64	d7, #96	; 0x3f000000  0.5
   19768:	vcmpe.f64	d10, d7
   1976c:	vmrs	APSR_nzcv, fpscr
   19770:	bge.n	1978a <__kernel_rem_pio2+0x43a>
   19772:	movs	r1, #0
   19774:	b.n	19548 <__kernel_rem_pio2+0x1f8>
   19776:	vldr	d7, [pc, #584]	; 199c0 <__kernel_rem_pio2+0x670>
   1977a:	vstmia	r0!, {d7}
   1977e:	cmp	r0, lr
   19780:	add.w	r5, r5, #1
   19784:	bne.w	193e0 <__kernel_rem_pio2+0x90>
   19788:	b.n	19410 <__kernel_rem_pio2+0xc0>
   1978a:	cmp	r5, #0
   1978c:	add.w	fp, fp, #1
   19790:	it	gt
   19792:	movgt	r1, #2
   19794:	bgt.w	194de <__kernel_rem_pio2+0x18e>
   19798:	vmov.f64	d7, #112	; 0x3f800000  1.0
   1979c:	movs	r1, #2
   1979e:	vsub.f64	d10, d7, d10
   197a2:	b.n	19548 <__kernel_rem_pio2+0x1f8>
   197a4:	add	r2, sp, #24
   197a6:	vmov	s22, fp
   197aa:	ldr.w	r2, [r2, lr, lsl #2]
   197ae:	ldr.w	fp, [sp, #16]
   197b2:	mov	r3, lr
   197b4:	mov	r9, r1
   197b6:	sub.w	sl, sl, #24
   197ba:	cmp	r2, #0
   197bc:	bne.w	196a2 <__kernel_rem_pio2+0x352>
   197c0:	add.w	r2, lr, #1073741824	; 0x40000000
   197c4:	subs	r2, #1
   197c6:	add	r1, sp, #24
   197c8:	add.w	r2, r1, r2, lsl #2
   197cc:	ldr.w	r1, [r2], #-4
   197d0:	subs	r3, #1
   197d2:	sub.w	sl, sl, #24
   197d6:	cmp	r1, #0
   197d8:	beq.n	197cc <__kernel_rem_pio2+0x47c>
   197da:	b.n	196a2 <__kernel_rem_pio2+0x352>
   197dc:	cmp	r3, #0
   197de:	ble.w	1996c <__kernel_rem_pio2+0x61c>
   197e2:	add.w	r2, r3, #536870912	; 0x20000000
   197e6:	subs	r2, #1
   197e8:	add.w	r4, lr, r7
   197ec:	lsls	r0, r2, #3
   197ee:	vldr	d7, [r4]
   197f2:	add.w	r4, r0, #8
   197f6:	adds	r0, #16
   197f8:	add	r4, lr
   197fa:	add	r0, lr
   197fc:	add	r5, sp, #272	; 0x110
   197fe:	vldmdb	r4!, {d6}
   19802:	vadd.f64	d5, d6, d7
   19806:	vsub.f64	d6, d6, d5
   1980a:	vadd.f64	d7, d6, d7
   1980e:	vstmdb	r0!, {d7}
   19812:	vmov.f64	d7, d5
   19816:	cmp	r0, r5
   19818:	vstr	d5, [r4]
   1981c:	bne.n	197fe <__kernel_rem_pio2+0x4ae>
   1981e:	cmp	r3, #1
   19820:	ble.w	1996c <__kernel_rem_pio2+0x61c>
   19824:	lsls	r2, r2, #3
   19826:	add	r7, lr
   19828:	add.w	r0, r2, #16
   1982c:	vldr	d7, [r7]
   19830:	adds	r2, #8
   19832:	add	r0, lr
   19834:	add.w	r3, lr, r2
   19838:	add	r4, sp, #280	; 0x118
   1983a:	mov	r2, r0
   1983c:	vldmdb	r3!, {d6}
   19840:	vadd.f64	d5, d7, d6
   19844:	vsub.f64	d6, d6, d5
   19848:	vadd.f64	d7, d6, d7
   1984c:	vstmdb	r2!, {d7}
   19850:	vmov.f64	d7, d5
   19854:	cmp	r4, r2
   19856:	vstr	d5, [r3]
   1985a:	bne.n	1983c <__kernel_rem_pio2+0x4ec>
   1985c:	vldr	d7, [pc, #352]	; 199c0 <__kernel_rem_pio2+0x670>
   19860:	vldmdb	r0!, {d6}
   19864:	cmp	r4, r0
   19866:	vadd.f64	d7, d7, d6
   1986a:	bne.n	19860 <__kernel_rem_pio2+0x510>
   1986c:	mov	r3, r9
   1986e:	cmp	r3, #0
   19870:	beq.n	19940 <__kernel_rem_pio2+0x5f0>
   19872:	vneg.f64	d7, d7
   19876:	vldr	d5, [lr]
   1987a:	vldr	d6, [lr, #8]
   1987e:	vneg.f64	d5, d5
   19882:	vstr	d5, [fp]
   19886:	vstr	d7, [fp, #16]
   1988a:	vneg.f64	d7, d6
   1988e:	vstr	d7, [fp, #8]
   19892:	vmov	r3, s22
   19896:	and.w	r0, r3, #7
   1989a:	add.w	sp, sp, #588	; 0x24c
   1989e:	vpop	{d8-d11}
   198a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   198a6:	vldr	d7, [pc, #280]	; 199c0 <__kernel_rem_pio2+0x670>
   198aa:	add.w	r2, r7, #8
   198ae:	add	r2, lr
   198b0:	vldmdb	r2!, {d6}
   198b4:	cmp	r2, lr
   198b6:	vadd.f64	d7, d7, d6
   198ba:	bne.n	198b0 <__kernel_rem_pio2+0x560>
   198bc:	mov	r2, r9
   198be:	cbz	r2, 1992a <__kernel_rem_pio2+0x5da>
   198c0:	vneg.f64	d5, d7
   198c4:	vldr	d6, [lr]
   198c8:	cmp	r3, #0
   198ca:	vstr	d5, [fp]
   198ce:	vsub.f64	d7, d6, d7
   198d2:	ble.n	198ec <__kernel_rem_pio2+0x59c>
   198d4:	add	r0, sp, #272	; 0x110
   198d6:	movs	r2, #1
   198d8:	vldmia	r0!, {d6}
   198dc:	adds	r2, #1
   198de:	cmp	r3, r2
   198e0:	vadd.f64	d7, d7, d6
   198e4:	bge.n	198d8 <__kernel_rem_pio2+0x588>
   198e6:	mov	r3, r9
   198e8:	cmp	r3, #0
   198ea:	beq.n	1988e <__kernel_rem_pio2+0x53e>
   198ec:	vneg.f64	d7, d7
   198f0:	vstr	d7, [fp, #8]
   198f4:	b.n	19892 <__kernel_rem_pio2+0x542>
   198f6:	vldr	d7, [pc, #200]	; 199c0 <__kernel_rem_pio2+0x670>
   198fa:	adds	r7, #8
   198fc:	add	lr, r7
   198fe:	vldmdb	lr!, {d6}
   19902:	subs	r3, #1
   19904:	adds	r2, r3, #1
   19906:	vadd.f64	d7, d7, d6
   1990a:	bne.n	198fe <__kernel_rem_pio2+0x5ae>
   1990c:	mov	r3, r9
   1990e:	cbz	r3, 19914 <__kernel_rem_pio2+0x5c4>
   19910:	vneg.f64	d7, d7
   19914:	vstr	d7, [fp]
   19918:	b.n	19892 <__kernel_rem_pio2+0x542>
   1991a:	vldr	d7, [pc, #164]	; 199c0 <__kernel_rem_pio2+0x670>
   1991e:	b.n	1971c <__kernel_rem_pio2+0x3cc>
   19920:	mov.w	lr, #1
   19924:	b.n	1959a <__kernel_rem_pio2+0x24a>
   19926:	movs	r0, #0
   19928:	b.n	1951c <__kernel_rem_pio2+0x1cc>
   1992a:	vldr	d6, [lr]
   1992e:	cmp	r3, #0
   19930:	vstr	d7, [fp]
   19934:	vsub.f64	d7, d6, d7
   19938:	bgt.n	198d4 <__kernel_rem_pio2+0x584>
   1993a:	vstr	d7, [fp, #8]
   1993e:	b.n	19892 <__kernel_rem_pio2+0x542>
   19940:	ldrd	r0, r1, [lr]
   19944:	ldrd	r2, r3, [lr, #8]
   19948:	vstr	d7, [fp, #16]
   1994c:	strd	r0, r1, [fp]
   19950:	strd	r2, r3, [fp, #8]
   19954:	b.n	19892 <__kernel_rem_pio2+0x542>
   19956:	vcvt.s32.f64	s0, d0
   1995a:	add	r1, sp, #24
   1995c:	vmov	r2, s0
   19960:	mov	r3, r5
   19962:	str.w	r2, [r1, r5, lsl #2]
   19966:	b.n	196a2 <__kernel_rem_pio2+0x352>
   19968:	add.w	lr, sp, #264	; 0x108
   1996c:	vldr	d7, [pc, #80]	; 199c0 <__kernel_rem_pio2+0x670>
   19970:	b.n	1986c <__kernel_rem_pio2+0x51c>
   19972:	ldr	r2, [sp, #656]	; 0x290
   19974:	cmp	r2, #3
   19976:	bhi.n	19892 <__kernel_rem_pio2+0x542>
   19978:	add	r1, pc, #4	; (adr r1, 19980 <__kernel_rem_pio2+0x630>)
   1997a:	ldr.w	pc, [r1, r2, lsl #2]
   1997e:	nop
   19980:	.word	0x000199a1
   19984:	.word	0x00019997
   19988:	.word	0x00019997
   1998c:	.word	0x00019969
   19990:	ldr	r3, [sp, #4]
   19992:	lsls	r4, r3, #3
   19994:	b.n	19410 <__kernel_rem_pio2+0xc0>
   19996:	vldr	d7, [pc, #40]	; 199c0 <__kernel_rem_pio2+0x670>
   1999a:	add.w	lr, sp, #264	; 0x108
   1999e:	b.n	198bc <__kernel_rem_pio2+0x56c>
   199a0:	vldr	d7, [pc, #28]	; 199c0 <__kernel_rem_pio2+0x670>
   199a4:	b.n	1990c <__kernel_rem_pio2+0x5bc>
   199a6:	nop
   199a8:	.word	0x00000000
   199ac:	.word	0x41700000
   199b0:	.word	0x00000000
   199b4:	.word	0x3e700000
   199b8:	.word	0x40000000
   199bc:	.word	0x3ff921fb
	...
   199c8:	.word	0x200203e0
   199cc:	.word	0x00000000

000199d0 <__kernel_sin>:
   199d0:	vmov	r3, s1
   199d4:	bic.w	r3, r3, #2147483648	; 0x80000000
   199d8:	cmp.w	r3, #1044381696	; 0x3e400000
   199dc:	bge.n	199e8 <__kernel_sin+0x18>
   199de:	vcvt.s32.f64	s15, d0
   199e2:	vmov	r3, s15
   199e6:	cbz	r3, 19a32 <__kernel_sin+0x62>
   199e8:	vmul.f64	d7, d0, d0
   199ec:	vmul.f64	d4, d0, d7
   199f0:	vldr	d5, [pc, #84]	; 19a48 <__kernel_sin+0x78>
   199f4:	vldr	d6, [pc, #88]	; 19a50 <__kernel_sin+0x80>
   199f8:	vldr	d3, [pc, #92]	; 19a58 <__kernel_sin+0x88>
   199fc:	vfma.f64	d6, d7, d5
   19a00:	vldr	d5, [pc, #92]	; 19a60 <__kernel_sin+0x90>
   19a04:	vfma.f64	d3, d7, d6
   19a08:	vldr	d6, [pc, #92]	; 19a68 <__kernel_sin+0x98>
   19a0c:	vfma.f64	d5, d7, d3
   19a10:	vfma.f64	d6, d7, d5
   19a14:	cbz	r0, 19a34 <__kernel_sin+0x64>
   19a16:	vnmul.f64	d6, d6, d4
   19a1a:	vmov.f64	d3, #96	; 0x3f000000  0.5
   19a1e:	vldr	d5, [pc, #80]	; 19a70 <__kernel_sin+0xa0>
   19a22:	vfma.f64	d6, d1, d3
   19a26:	vfnms.f64	d1, d7, d6
   19a2a:	vfma.f64	d1, d4, d5
   19a2e:	vsub.f64	d0, d0, d1
   19a32:	bx	lr
   19a34:	vldr	d5, [pc, #64]	; 19a78 <__kernel_sin+0xa8>
   19a38:	vfma.f64	d5, d7, d6
   19a3c:	vfma.f64	d0, d4, d5
   19a40:	bx	lr
   19a42:	nop
   19a44:	nop.w
   19a48:	.word	0x5acfd57c
   19a4c:	.word	0x3de5d93a
   19a50:	.word	0x8a2b9ceb
   19a54:	.word	0xbe5ae5e6
   19a58:	.word	0x57b1fe7d
   19a5c:	.word	0x3ec71de3
   19a60:	.word	0x19c161d5
   19a64:	.word	0xbf2a01a0
   19a68:	.word	0x1110f8a6
   19a6c:	.word	0x3f811111
   19a70:	.word	0x55555549
   19a74:	.word	0x3fc55555
   19a78:	.word	0x55555549
   19a7c:	.word	0xbfc55555

00019a80 <__kernel_rem_pio2f>:
   19a80:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19a84:	vpush	{d8-d9}
   19a88:	sub	sp, #348	; 0x15c
   19a8a:	subs	r7, r3, #1
   19a8c:	ldr	r4, [pc, #656]	; (19d20 <__kernel_rem_pio2f+0x2a0>)
   19a8e:	ldr	r5, [sp, #400]	; 0x190
   19a90:	str	r3, [sp, #4]
   19a92:	subs	r3, r2, #3
   19a94:	it	mi
   19a96:	addmi	r3, r2, #4
   19a98:	ldr.w	r6, [r4, r5, lsl #2]
   19a9c:	asrs	r3, r3, #3
   19a9e:	bic.w	r3, r3, r3, asr #31
   19aa2:	add.w	sl, r3, #1
   19aa6:	mov	fp, r1
   19aa8:	adds	r1, r6, r7
   19aaa:	str	r3, [sp, #8]
   19aac:	mov	r9, r0
   19aae:	sub.w	sl, r2, sl, lsl #3
   19ab2:	sub.w	r3, r3, r7
   19ab6:	bmi.n	19ae2 <__kernel_rem_pio2f+0x62>
   19ab8:	add	r1, r3
   19aba:	ldr	r0, [sp, #404]	; 0x194
   19abc:	adds	r1, #1
   19abe:	add	r2, sp, #104	; 0x68
   19ac0:	cmp	r3, #0
   19ac2:	itet	ge
   19ac4:	ldrge.w	r4, [r0, r3, lsl #2]
   19ac8:	vldrlt	s15, [pc, #600]	; 19d24 <__kernel_rem_pio2f+0x2a4>
   19acc:	vmovge	s15, r4
   19ad0:	add.w	r3, r3, #1
   19ad4:	it	ge
   19ad6:	vcvtge.f32.s32	s15, s15
   19ada:	cmp	r3, r1
   19adc:	vstmia	r2!, {s15}
   19ae0:	bne.n	19ac0 <__kernel_rem_pio2f+0x40>
   19ae2:	cmp	r6, #0
   19ae4:	blt.w	1a090 <__kernel_rem_pio2f+0x610>
   19ae8:	ldr	r3, [sp, #4]
   19aea:	add	r0, sp, #264	; 0x108
   19aec:	add.w	lr, r6, #1
   19af0:	lsls	r4, r3, #2
   19af2:	add.w	lr, r0, lr, lsl #2
   19af6:	add.w	r1, r9, r4
   19afa:	mov	r5, r7
   19afc:	cmp	r7, #0
   19afe:	blt.w	19e80 <__kernel_rem_pio2f+0x400>
   19b02:	add	r3, sp, #104	; 0x68
   19b04:	add.w	r2, r3, r5, lsl #2
   19b08:	vldr	s15, [pc, #536]	; 19d24 <__kernel_rem_pio2f+0x2a4>
   19b0c:	adds	r2, #4
   19b0e:	mov	r3, r9
   19b10:	vldmia	r3!, {s13}
   19b14:	vldmdb	r2!, {s14}
   19b18:	cmp	r3, r1
   19b1a:	vfma.f32	s15, s13, s14
   19b1e:	bne.n	19b10 <__kernel_rem_pio2f+0x90>
   19b20:	vstmia	r0!, {s15}
   19b24:	cmp	r0, lr
   19b26:	add.w	r5, r5, #1
   19b2a:	bne.n	19afc <__kernel_rem_pio2f+0x7c>
   19b2c:	add.w	r3, r6, #1073741824	; 0x40000000
   19b30:	subs	r3, #2
   19b32:	lsls	r3, r3, #2
   19b34:	add	r2, sp, #24
   19b36:	add.w	r8, r3, #4
   19b3a:	vldr	s17, [pc, #496]	; 19d2c <__kernel_rem_pio2f+0x2ac>
   19b3e:	vldr	s16, [pc, #488]	; 19d28 <__kernel_rem_pio2f+0x2a8>
   19b42:	str.w	fp, [sp, #16]
   19b46:	add	r3, r2
   19b48:	add	r4, r9
   19b4a:	add	r8, r2
   19b4c:	str	r3, [sp, #12]
   19b4e:	mov	r5, r6
   19b50:	add	r3, sp, #344	; 0x158
   19b52:	add.w	r3, r3, r5, lsl #2
   19b56:	cmp	r5, #0
   19b58:	vldr	s0, [r3, #-80]	; 0xffffffb0
   19b5c:	ble.n	19b92 <__kernel_rem_pio2f+0x112>
   19b5e:	add	r1, sp, #264	; 0x108
   19b60:	add.w	r3, r1, r5, lsl #2
   19b64:	add	r2, sp, #20
   19b66:	vmul.f32	s15, s0, s17
   19b6a:	vmov.f32	s14, s0
   19b6e:	vcvt.s32.f32	s15, s15
   19b72:	vldmdb	r3!, {s13}
   19b76:	vcvt.f32.s32	s15, s15
   19b7a:	cmp	r3, r1
   19b7c:	vfms.f32	s14, s15, s16
   19b80:	vadd.f32	s0, s15, s13
   19b84:	vcvt.s32.f32	s14, s14
   19b88:	vmov	r0, s14
   19b8c:	str.w	r0, [r2, #4]!
   19b90:	bne.n	19b66 <__kernel_rem_pio2f+0xe6>
   19b92:	mov	r0, sl
   19b94:	bl	1a920 <scalbnf>
   19b98:	vmov.f32	s18, s0
   19b9c:	vmov.f32	s0, #64	; 0x3e000000  0.125
   19ba0:	vmul.f32	s0, s18, s0
   19ba4:	bl	1a884 <floorf>
   19ba8:	vmov.f32	s15, #32	; 0x41000000  8.0
   19bac:	vfms.f32	s18, s0, s15
   19bb0:	cmp.w	sl, #0
   19bb4:	vcvt.s32.f32	s15, s18
   19bb8:	vmov	fp, s15
   19bbc:	vcvt.f32.s32	s15, s15
   19bc0:	vsub.f32	s18, s18, s15
   19bc4:	ble.w	19e4a <__kernel_rem_pio2f+0x3ca>
   19bc8:	add.w	lr, r5, #4294967295
   19bcc:	add	r3, sp, #24
   19bce:	rsb	r2, sl, #8
   19bd2:	ldr.w	r3, [r3, lr, lsl #2]
   19bd6:	asr.w	r0, r3, r2
   19bda:	lsl.w	r2, r0, r2
   19bde:	add	r1, sp, #24
   19be0:	subs	r3, r3, r2
   19be2:	rsb	r2, sl, #7
   19be6:	str.w	r3, [r1, lr, lsl #2]
   19bea:	add	fp, r0
   19bec:	asr.w	r1, r3, r2
   19bf0:	cmp	r1, #0
   19bf2:	ble.n	19c64 <__kernel_rem_pio2f+0x1e4>
   19bf4:	cmp	r5, #0
   19bf6:	add.w	fp, fp, #1
   19bfa:	ble.w	1a046 <__kernel_rem_pio2f+0x5c6>
   19bfe:	movs	r2, #0
   19c00:	mov	r0, r2
   19c02:	add.w	lr, sp, #20
   19c06:	mov	ip, r1
   19c08:	b.n	19c1c <__kernel_rem_pio2f+0x19c>
   19c0a:	rsb	r1, r3, #256	; 0x100
   19c0e:	cbz	r3, 19c16 <__kernel_rem_pio2f+0x196>
   19c10:	str.w	r1, [lr]
   19c14:	movs	r0, #1
   19c16:	adds	r2, #1
   19c18:	cmp	r5, r2
   19c1a:	ble.n	19c36 <__kernel_rem_pio2f+0x1b6>
   19c1c:	ldr.w	r3, [lr, #4]!
   19c20:	cmp	r0, #0
   19c22:	beq.n	19c0a <__kernel_rem_pio2f+0x18a>
   19c24:	adds	r2, #1
   19c26:	rsb	r3, r3, #255	; 0xff
   19c2a:	cmp	r5, r2
   19c2c:	str.w	r3, [lr]
   19c30:	mov.w	r0, #1
   19c34:	bgt.n	19c1c <__kernel_rem_pio2f+0x19c>
   19c36:	mov	r1, ip
   19c38:	cmp.w	sl, #0
   19c3c:	ble.n	19c60 <__kernel_rem_pio2f+0x1e0>
   19c3e:	cmp.w	sl, #1
   19c42:	beq.w	19e58 <__kernel_rem_pio2f+0x3d8>
   19c46:	cmp.w	sl, #2
   19c4a:	bne.n	19c60 <__kernel_rem_pio2f+0x1e0>
   19c4c:	subs	r2, r5, #1
   19c4e:	add	r3, sp, #24
   19c50:	add.w	lr, sp, #24
   19c54:	ldr.w	r3, [r3, r2, lsl #2]
   19c58:	and.w	r3, r3, #63	; 0x3f
   19c5c:	str.w	r3, [lr, r2, lsl #2]
   19c60:	cmp	r1, #2
   19c62:	beq.n	19d30 <__kernel_rem_pio2f+0x2b0>
   19c64:	vcmp.f32	s18, #0.0
   19c68:	vmrs	APSR_nzcv, fpscr
   19c6c:	bne.n	19d54 <__kernel_rem_pio2f+0x2d4>
   19c6e:	add.w	lr, r5, #4294967295
   19c72:	cmp	r6, lr
   19c74:	bgt.n	19c96 <__kernel_rem_pio2f+0x216>
   19c76:	add.w	r2, r5, #1073741824	; 0x40000000
   19c7a:	subs	r2, #1
   19c7c:	add	r3, sp, #24
   19c7e:	add.w	r2, r3, r2, lsl #2
   19c82:	movs	r0, #0
   19c84:	ldr.w	r3, [r2], #-4
   19c88:	cmp	r2, r8
   19c8a:	orr.w	r0, r0, r3
   19c8e:	bne.n	19c84 <__kernel_rem_pio2f+0x204>
   19c90:	cmp	r0, #0
   19c92:	bne.w	19eae <__kernel_rem_pio2f+0x42e>
   19c96:	subs	r3, r6, #1
   19c98:	add	r2, sp, #24
   19c9a:	ldr.w	r3, [r2, r3, lsl #2]
   19c9e:	cmp	r3, #0
   19ca0:	bne.w	1a040 <__kernel_rem_pio2f+0x5c0>
   19ca4:	ldr	r3, [sp, #12]
   19ca6:	mov.w	lr, #1
   19caa:	ldr.w	r2, [r3], #-4
   19cae:	add.w	lr, lr, #1
   19cb2:	cmp	r2, #0
   19cb4:	beq.n	19caa <__kernel_rem_pio2f+0x22a>
   19cb6:	add	lr, r5
   19cb8:	adds	r3, r5, #1
   19cba:	cmp	r3, lr
   19cbc:	bgt.n	19d1a <__kernel_rem_pio2f+0x29a>
   19cbe:	ldr	r2, [sp, #8]
   19cc0:	adds	r0, r3, r2
   19cc2:	ldr	r2, [sp, #4]
   19cc4:	add.w	r0, r0, #1073741824	; 0x40000000
   19cc8:	adds	r1, r2, r5
   19cca:	add.w	ip, lr, r2
   19cce:	ldr	r2, [sp, #404]	; 0x194
   19cd0:	subs	r0, #1
   19cd2:	add.w	r0, r2, r0, lsl #2
   19cd6:	add	r2, sp, #104	; 0x68
   19cd8:	add.w	r1, r2, r1, lsl #2
   19cdc:	add.w	ip, r2, ip, lsl #2
   19ce0:	add	r2, sp, #264	; 0x108
   19ce2:	add.w	r5, r2, r3, lsl #2
   19ce6:	ldr.w	r3, [r0, #4]!
   19cea:	vmov	s15, r3
   19cee:	vcvt.f32.s32	s15, s15
   19cf2:	cmp	r7, #0
   19cf4:	vstmia	r1!, {s15}
   19cf8:	vldr	s15, [pc, #40]	; 19d24 <__kernel_rem_pio2f+0x2a4>
   19cfc:	blt.n	19d12 <__kernel_rem_pio2f+0x292>
   19cfe:	mov	r3, r9
   19d00:	mov	r2, r1
   19d02:	vldmia	r3!, {s13}
   19d06:	vldmdb	r2!, {s14}
   19d0a:	cmp	r3, r4
   19d0c:	vfma.f32	s15, s13, s14
   19d10:	bne.n	19d02 <__kernel_rem_pio2f+0x282>
   19d12:	cmp	r1, ip
   19d14:	vstmia	r5!, {s15}
   19d18:	bne.n	19ce6 <__kernel_rem_pio2f+0x266>
   19d1a:	mov	r5, lr
   19d1c:	b.n	19b50 <__kernel_rem_pio2f+0xd0>
   19d1e:	nop
   19d20:	.word	0x20020418
   19d24:	.word	0x00000000
   19d28:	.word	0x43800000
   19d2c:	.word	0x3b800000
   19d30:	vmov.f32	s0, #112	; 0x3f800000  1.0
   19d34:	vsub.f32	s18, s0, s18
   19d38:	cmp	r0, #0
   19d3a:	beq.n	19c64 <__kernel_rem_pio2f+0x1e4>
   19d3c:	mov	r0, sl
   19d3e:	str	r1, [sp, #20]
   19d40:	bl	1a920 <scalbnf>
   19d44:	vsub.f32	s18, s18, s0
   19d48:	ldr	r1, [sp, #20]
   19d4a:	vcmp.f32	s18, #0.0
   19d4e:	vmrs	APSR_nzcv, fpscr
   19d52:	beq.n	19c6e <__kernel_rem_pio2f+0x1ee>
   19d54:	vmov.f32	s0, s18
   19d58:	rsb	r0, sl, #0
   19d5c:	vmov	s19, fp
   19d60:	mov	r8, r1
   19d62:	ldr.w	fp, [sp, #16]
   19d66:	bl	1a920 <scalbnf>
   19d6a:	vldr	s14, [pc, #-68]	; 19d28 <__kernel_rem_pio2f+0x2a8>
   19d6e:	vcmpe.f32	s0, s14
   19d72:	vmrs	APSR_nzcv, fpscr
   19d76:	blt.w	1a05c <__kernel_rem_pio2f+0x5dc>
   19d7a:	vldr	s15, [pc, #-80]	; 19d2c <__kernel_rem_pio2f+0x2ac>
   19d7e:	vmul.f32	s15, s0, s15
   19d82:	add	r1, sp, #24
   19d84:	vcvt.s32.f32	s15, s15
   19d88:	adds	r3, r5, #1
   19d8a:	vcvt.f32.s32	s15, s15
   19d8e:	add.w	sl, sl, #8
   19d92:	vfms.f32	s0, s15, s14
   19d96:	vcvt.s32.f32	s15, s15
   19d9a:	vcvt.s32.f32	s0, s0
   19d9e:	vmov	r2, s0
   19da2:	str.w	r2, [r1, r5, lsl #2]
   19da6:	vmov	r2, s15
   19daa:	str.w	r2, [r1, r3, lsl #2]
   19dae:	mov	r0, sl
   19db0:	vmov.f32	s0, #112	; 0x3f800000  1.0
   19db4:	str	r3, [sp, #4]
   19db6:	bl	1a920 <scalbnf>
   19dba:	ldr	r3, [sp, #4]
   19dbc:	cmp	r3, #0
   19dbe:	blt.w	1a074 <__kernel_rem_pio2f+0x5f4>
   19dc2:	lsls	r7, r3, #2
   19dc4:	add	r4, sp, #264	; 0x108
   19dc6:	add	r2, sp, #24
   19dc8:	adds	r0, r7, #4
   19dca:	add.w	lr, r4, r7
   19dce:	vldr	s14, [pc, #-164]	; 19d2c <__kernel_rem_pio2f+0x2ac>
   19dd2:	add	r0, r2
   19dd4:	add.w	r2, lr, #4
   19dd8:	vldmdb	r0!, {s15}
   19ddc:	vcvt.f32.s32	s15, s15
   19de0:	vmul.f32	s15, s15, s0
   19de4:	vmul.f32	s0, s0, s14
   19de8:	vstmdb	r2!, {s15}
   19dec:	cmp	r2, r4
   19dee:	bne.n	19dd8 <__kernel_rem_pio2f+0x358>
   19df0:	add.w	ip, sp, #260	; 0x104
   19df4:	movs	r5, #0
   19df6:	cmp	r6, #0
   19df8:	blt.w	1a024 <__kernel_rem_pio2f+0x5a4>
   19dfc:	ldr	r0, [pc, #676]	; (1a0a4 <__kernel_rem_pio2f+0x624>)
   19dfe:	vldr	s14, [pc, #680]	; 1a0a8 <__kernel_rem_pio2f+0x628>
   19e02:	vldr	s15, [pc, #680]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   19e06:	mov	r1, lr
   19e08:	movs	r2, #0
   19e0a:	b.n	19e16 <__kernel_rem_pio2f+0x396>
   19e0c:	cmp	r5, r2
   19e0e:	blt.n	19e24 <__kernel_rem_pio2f+0x3a4>
   19e10:	adds	r0, #4
   19e12:	vldr	s14, [r0]
   19e16:	vldmia	r1!, {s13}
   19e1a:	adds	r2, #1
   19e1c:	cmp	r6, r2
   19e1e:	vfma.f32	s15, s13, s14
   19e22:	bge.n	19e0c <__kernel_rem_pio2f+0x38c>
   19e24:	sub.w	lr, lr, #4
   19e28:	add	r2, sp, #344	; 0x158
   19e2a:	add.w	r2, r2, r5, lsl #2
   19e2e:	cmp	ip, lr
   19e30:	vstr	s15, [r2, #-160]	; 0xffffff60
   19e34:	add.w	r5, r5, #1
   19e38:	bne.n	19df6 <__kernel_rem_pio2f+0x376>
   19e3a:	ldr	r2, [sp, #400]	; 0x190
   19e3c:	cmp	r2, #3
   19e3e:	bhi.w	19f9e <__kernel_rem_pio2f+0x51e>
   19e42:	tbb	[pc, r2]
   19e46:	.short	0xb5dc
   19e48:	.short	0x50b5
   19e4a:	bne.n	19e6e <__kernel_rem_pio2f+0x3ee>
   19e4c:	subs	r3, r5, #1
   19e4e:	add	r2, sp, #24
   19e50:	ldr.w	r1, [r2, r3, lsl #2]
   19e54:	asrs	r1, r1, #8
   19e56:	b.n	19bf0 <__kernel_rem_pio2f+0x170>
   19e58:	subs	r2, r5, #1
   19e5a:	add	r3, sp, #24
   19e5c:	add.w	lr, sp, #24
   19e60:	ldr.w	r3, [r3, r2, lsl #2]
   19e64:	and.w	r3, r3, #127	; 0x7f
   19e68:	str.w	r3, [lr, r2, lsl #2]
   19e6c:	b.n	19c60 <__kernel_rem_pio2f+0x1e0>
   19e6e:	vmov.f32	s15, #96	; 0x3f000000  0.5
   19e72:	vcmpe.f32	s18, s15
   19e76:	vmrs	APSR_nzcv, fpscr
   19e7a:	bge.n	19e94 <__kernel_rem_pio2f+0x414>
   19e7c:	movs	r1, #0
   19e7e:	b.n	19c64 <__kernel_rem_pio2f+0x1e4>
   19e80:	vldr	s15, [pc, #552]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   19e84:	vstmia	r0!, {s15}
   19e88:	cmp	r0, lr
   19e8a:	add.w	r5, r5, #1
   19e8e:	bne.w	19afc <__kernel_rem_pio2f+0x7c>
   19e92:	b.n	19b2c <__kernel_rem_pio2f+0xac>
   19e94:	cmp	r5, #0
   19e96:	add.w	fp, fp, #1
   19e9a:	it	gt
   19e9c:	movgt	r1, #2
   19e9e:	bgt.w	19bfe <__kernel_rem_pio2f+0x17e>
   19ea2:	vmov.f32	s15, #112	; 0x3f800000  1.0
   19ea6:	vsub.f32	s18, s15, s18
   19eaa:	movs	r1, #2
   19eac:	b.n	19c64 <__kernel_rem_pio2f+0x1e4>
   19eae:	add	r2, sp, #24
   19eb0:	vmov	s19, fp
   19eb4:	ldr.w	r2, [r2, lr, lsl #2]
   19eb8:	ldr.w	fp, [sp, #16]
   19ebc:	mov	r3, lr
   19ebe:	mov	r8, r1
   19ec0:	sub.w	sl, sl, #8
   19ec4:	cmp	r2, #0
   19ec6:	bne.w	19dae <__kernel_rem_pio2f+0x32e>
   19eca:	add.w	r2, lr, #1073741824	; 0x40000000
   19ece:	subs	r2, #1
   19ed0:	add	r1, sp, #24
   19ed2:	add.w	r2, r1, r2, lsl #2
   19ed6:	ldr.w	r1, [r2], #-4
   19eda:	subs	r3, #1
   19edc:	sub.w	sl, sl, #8
   19ee0:	cmp	r1, #0
   19ee2:	beq.n	19ed6 <__kernel_rem_pio2f+0x456>
   19ee4:	b.n	19dae <__kernel_rem_pio2f+0x32e>
   19ee6:	cmp	r3, #0
   19ee8:	ble.w	1a06e <__kernel_rem_pio2f+0x5ee>
   19eec:	add.w	r2, r3, #1073741824	; 0x40000000
   19ef0:	subs	r2, #1
   19ef2:	lsls	r0, r2, #2
   19ef4:	add	r1, sp, #344	; 0x158
   19ef6:	adds	r5, r1, r7
   19ef8:	adds	r4, r0, #4
   19efa:	add	r1, sp, #184	; 0xb8
   19efc:	adds	r0, #8
   19efe:	vldr	s14, [r5, #-160]	; 0xffffff60
   19f02:	add	r4, r1
   19f04:	add	r0, r1
   19f06:	add	r5, sp, #188	; 0xbc
   19f08:	vldmdb	r4!, {s15}
   19f0c:	vadd.f32	s13, s15, s14
   19f10:	vsub.f32	s15, s15, s13
   19f14:	vadd.f32	s15, s15, s14
   19f18:	vmov.f32	s14, s13
   19f1c:	vstmdb	r0!, {s15}
   19f20:	cmp	r0, r5
   19f22:	vstr	s13, [r4]
   19f26:	bne.n	19f08 <__kernel_rem_pio2f+0x488>
   19f28:	cmp	r3, #1
   19f2a:	ble.w	1a06e <__kernel_rem_pio2f+0x5ee>
   19f2e:	lsls	r2, r2, #2
   19f30:	add	r3, sp, #344	; 0x158
   19f32:	add	r7, r3
   19f34:	add.w	r0, r2, #8
   19f38:	add	r3, sp, #184	; 0xb8
   19f3a:	add	r0, r3
   19f3c:	adds	r2, #4
   19f3e:	vldr	s14, [r7, #-160]	; 0xffffff60
   19f42:	add	r3, r2
   19f44:	add	r4, sp, #192	; 0xc0
   19f46:	mov	r2, r0
   19f48:	vldmdb	r3!, {s15}
   19f4c:	vadd.f32	s13, s14, s15
   19f50:	vsub.f32	s15, s15, s13
   19f54:	vadd.f32	s15, s15, s14
   19f58:	vmov.f32	s14, s13
   19f5c:	vstmdb	r2!, {s15}
   19f60:	cmp	r4, r2
   19f62:	vstr	s13, [r3]
   19f66:	bne.n	19f48 <__kernel_rem_pio2f+0x4c8>
   19f68:	vldr	s15, [pc, #320]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   19f6c:	vldmdb	r0!, {s14}
   19f70:	cmp	r4, r0
   19f72:	vadd.f32	s15, s15, s14
   19f76:	bne.n	19f6c <__kernel_rem_pio2f+0x4ec>
   19f78:	mov	r3, r8
   19f7a:	cmp	r3, #0
   19f7c:	beq.n	1a04a <__kernel_rem_pio2f+0x5ca>
   19f7e:	vldr	s13, [sp, #184]	; 0xb8
   19f82:	vldr	s14, [sp, #188]	; 0xbc
   19f86:	vneg.f32	s15, s15
   19f8a:	vneg.f32	s13, s13
   19f8e:	vneg.f32	s14, s14
   19f92:	vstr	s15, [fp, #8]
   19f96:	vstr	s13, [fp]
   19f9a:	vstr	s14, [fp, #4]
   19f9e:	vmov	r3, s19
   19fa2:	and.w	r0, r3, #7
   19fa6:	add	sp, #348	; 0x15c
   19fa8:	vpop	{d8-d9}
   19fac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19fb0:	adds	r2, r7, #4
   19fb2:	add	r0, sp, #184	; 0xb8
   19fb4:	vldr	s15, [pc, #244]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   19fb8:	add	r2, r0
   19fba:	vldmdb	r2!, {s14}
   19fbe:	cmp	r2, r0
   19fc0:	vadd.f32	s15, s15, s14
   19fc4:	bne.n	19fba <__kernel_rem_pio2f+0x53a>
   19fc6:	mov	r2, r8
   19fc8:	cbz	r2, 1a02a <__kernel_rem_pio2f+0x5aa>
   19fca:	vldr	s13, [sp, #184]	; 0xb8
   19fce:	vneg.f32	s14, s15
   19fd2:	cmp	r3, #0
   19fd4:	vsub.f32	s15, s13, s15
   19fd8:	vstr	s14, [fp]
   19fdc:	ble.n	19ff4 <__kernel_rem_pio2f+0x574>
   19fde:	add	r0, sp, #188	; 0xbc
   19fe0:	movs	r2, #1
   19fe2:	vldmia	r0!, {s14}
   19fe6:	adds	r2, #1
   19fe8:	cmp	r3, r2
   19fea:	vadd.f32	s15, s15, s14
   19fee:	bge.n	19fe2 <__kernel_rem_pio2f+0x562>
   19ff0:	mov	r3, r8
   19ff2:	cbz	r3, 19ff8 <__kernel_rem_pio2f+0x578>
   19ff4:	vneg.f32	s15, s15
   19ff8:	vstr	s15, [fp, #4]
   19ffc:	b.n	19f9e <__kernel_rem_pio2f+0x51e>
   19ffe:	add	r2, sp, #344	; 0x158
   1a000:	add	r2, r7
   1a002:	vldr	s15, [pc, #168]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   1a006:	subs	r2, #156	; 0x9c
   1a008:	vldmdb	r2!, {s14}
   1a00c:	subs	r3, #1
   1a00e:	adds	r1, r3, #1
   1a010:	vadd.f32	s15, s15, s14
   1a014:	bne.n	1a008 <__kernel_rem_pio2f+0x588>
   1a016:	mov	r3, r8
   1a018:	cbz	r3, 1a01e <__kernel_rem_pio2f+0x59e>
   1a01a:	vneg.f32	s15, s15
   1a01e:	vstr	s15, [fp]
   1a022:	b.n	19f9e <__kernel_rem_pio2f+0x51e>
   1a024:	vldr	s15, [pc, #132]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   1a028:	b.n	19e24 <__kernel_rem_pio2f+0x3a4>
   1a02a:	vldr	s14, [sp, #184]	; 0xb8
   1a02e:	vstr	s15, [fp]
   1a032:	cmp	r3, #0
   1a034:	vsub.f32	s15, s14, s15
   1a038:	bgt.n	19fde <__kernel_rem_pio2f+0x55e>
   1a03a:	vstr	s15, [fp, #4]
   1a03e:	b.n	19f9e <__kernel_rem_pio2f+0x51e>
   1a040:	mov.w	lr, #1
   1a044:	b.n	19cb6 <__kernel_rem_pio2f+0x236>
   1a046:	movs	r0, #0
   1a048:	b.n	19c38 <__kernel_rem_pio2f+0x1b8>
   1a04a:	ldr	r2, [sp, #184]	; 0xb8
   1a04c:	ldr	r3, [sp, #188]	; 0xbc
   1a04e:	vstr	s15, [fp, #8]
   1a052:	str.w	r2, [fp]
   1a056:	str.w	r3, [fp, #4]
   1a05a:	b.n	19f9e <__kernel_rem_pio2f+0x51e>
   1a05c:	vcvt.s32.f32	s0, s0
   1a060:	add	r1, sp, #24
   1a062:	vmov	r2, s0
   1a066:	mov	r3, r5
   1a068:	str.w	r2, [r1, r5, lsl #2]
   1a06c:	b.n	19dae <__kernel_rem_pio2f+0x32e>
   1a06e:	vldr	s15, [pc, #60]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   1a072:	b.n	19f78 <__kernel_rem_pio2f+0x4f8>
   1a074:	ldr	r2, [sp, #400]	; 0x190
   1a076:	cmp	r2, #3
   1a078:	bhi.n	19f9e <__kernel_rem_pio2f+0x51e>
   1a07a:	add	r1, pc, #4	; (adr r1, 1a080 <__kernel_rem_pio2f+0x600>)
   1a07c:	ldr.w	pc, [r1, r2, lsl #2]
   1a080:	.word	0x0001a09d
   1a084:	.word	0x0001a097
   1a088:	.word	0x0001a097
   1a08c:	.word	0x0001a06f
   1a090:	ldr	r3, [sp, #4]
   1a092:	lsls	r4, r3, #2
   1a094:	b.n	19b2c <__kernel_rem_pio2f+0xac>
   1a096:	vldr	s15, [pc, #20]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   1a09a:	b.n	19fc6 <__kernel_rem_pio2f+0x546>
   1a09c:	vldr	s15, [pc, #12]	; 1a0ac <__kernel_rem_pio2f+0x62c>
   1a0a0:	b.n	1a016 <__kernel_rem_pio2f+0x596>
   1a0a2:	nop
   1a0a4:	.word	0x20020424
   1a0a8:	.word	0x3fc90000
   1a0ac:	.word	0x00000000

0001a0b0 <__kernel_tanf>:
   1a0b0:	push	{r3, lr}
   1a0b2:	vmov	r3, s0
   1a0b6:	bic.w	r2, r3, #2147483648	; 0x80000000
   1a0ba:	cmp.w	r2, #830472192	; 0x31800000
   1a0be:	vpush	{d8}
   1a0c2:	vmov.f32	s14, s0
   1a0c6:	bge.n	1a0ee <__kernel_tanf+0x3e>
   1a0c8:	vcvt.s32.f32	s15, s0
   1a0cc:	vmov	r1, s15
   1a0d0:	cbnz	r1, 1a118 <__kernel_tanf+0x68>
   1a0d2:	adds	r3, r0, #1
   1a0d4:	orrs	r3, r2
   1a0d6:	beq.w	1a230 <__kernel_tanf+0x180>
   1a0da:	cmp	r0, #1
   1a0dc:	beq.w	1a1ea <__kernel_tanf+0x13a>
   1a0e0:	vpop	{d8}
   1a0e4:	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1a0e8:	vdiv.f32	s0, s15, s14
   1a0ec:	pop	{r3, pc}
   1a0ee:	ldr	r1, [pc, #336]	; (1a240 <__kernel_tanf+0x190>)
   1a0f0:	cmp	r2, r1
   1a0f2:	ble.n	1a118 <__kernel_tanf+0x68>
   1a0f4:	cmp	r3, #0
   1a0f6:	vldr	s15, [pc, #332]	; 1a244 <__kernel_tanf+0x194>
   1a0fa:	vldr	s13, [pc, #332]	; 1a248 <__kernel_tanf+0x198>
   1a0fe:	itt	lt
   1a100:	vneglt.f32	s1, s1
   1a104:	vneglt.f32	s14, s0
   1a108:	vsub.f32	s14, s15, s14
   1a10c:	vsub.f32	s15, s13, s1
   1a110:	vldr	s1, [pc, #312]	; 1a24c <__kernel_tanf+0x19c>
   1a114:	vadd.f32	s14, s15, s14
   1a118:	vmul.f32	s13, s14, s14
   1a11c:	vldr	s0, [pc, #304]	; 1a250 <__kernel_tanf+0x1a0>
   1a120:	vldr	s4, [pc, #304]	; 1a254 <__kernel_tanf+0x1a4>
   1a124:	vldr	s16, [pc, #304]	; 1a258 <__kernel_tanf+0x1a8>
   1a128:	vldr	s3, [pc, #304]	; 1a25c <__kernel_tanf+0x1ac>
   1a12c:	vldr	s6, [pc, #304]	; 1a260 <__kernel_tanf+0x1b0>
   1a130:	vldr	s5, [pc, #304]	; 1a264 <__kernel_tanf+0x1b4>
   1a134:	vldr	s8, [pc, #304]	; 1a268 <__kernel_tanf+0x1b8>
   1a138:	vldr	s7, [pc, #304]	; 1a26c <__kernel_tanf+0x1bc>
   1a13c:	vldr	s10, [pc, #304]	; 1a270 <__kernel_tanf+0x1c0>
   1a140:	vldr	s9, [pc, #304]	; 1a274 <__kernel_tanf+0x1c4>
   1a144:	vldr	s11, [pc, #304]	; 1a278 <__kernel_tanf+0x1c8>
   1a148:	vldr	s12, [pc, #304]	; 1a27c <__kernel_tanf+0x1cc>
   1a14c:	vldr	s2, [pc, #304]	; 1a280 <__kernel_tanf+0x1d0>
   1a150:	ldr	r1, [pc, #236]	; (1a240 <__kernel_tanf+0x190>)
   1a152:	vmul.f32	s15, s13, s13
   1a156:	cmp	r2, r1
   1a158:	vfma.f32	s4, s15, s0
   1a15c:	vfma.f32	s3, s15, s16
   1a160:	vfma.f32	s6, s15, s4
   1a164:	vfma.f32	s5, s15, s3
   1a168:	vfma.f32	s8, s15, s6
   1a16c:	vfma.f32	s7, s15, s5
   1a170:	vfma.f32	s10, s15, s8
   1a174:	vfma.f32	s9, s15, s7
   1a178:	vfma.f32	s11, s15, s10
   1a17c:	vfma.f32	s12, s15, s9
   1a180:	vmov.f32	s15, s11
   1a184:	vfma.f32	s12, s13, s15
   1a188:	vmul.f32	s11, s14, s13
   1a18c:	vmov.f32	s15, s12
   1a190:	vmov.f32	s12, s1
   1a194:	vfma.f32	s12, s11, s15
   1a198:	vfma.f32	s1, s13, s12
   1a19c:	vfma.f32	s1, s11, s2
   1a1a0:	vadd.f32	s0, s14, s1
   1a1a4:	bgt.n	1a1f0 <__kernel_tanf+0x140>
   1a1a6:	cmp	r0, #1
   1a1a8:	beq.n	1a1ea <__kernel_tanf+0x13a>
   1a1aa:	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1a1ae:	vdiv.f32	s13, s15, s0
   1a1b2:	vmov	r3, s0
   1a1b6:	vmov	r2, s13
   1a1ba:	bic.w	r3, r3, #4080	; 0xff0
   1a1be:	bic.w	r2, r2, #4080	; 0xff0
   1a1c2:	bic.w	r3, r3, #15
   1a1c6:	bic.w	r2, r2, #15
   1a1ca:	vmov	s0, r2
   1a1ce:	vmov	s12, r3
   1a1d2:	vmov.f32	s15, #112	; 0x3f800000  1.0
   1a1d6:	vfma.f32	s15, s12, s0
   1a1da:	vsub.f32	s14, s12, s14
   1a1de:	vsub.f32	s1, s1, s14
   1a1e2:	vfma.f32	s15, s1, s0
   1a1e6:	vfma.f32	s0, s13, s15
   1a1ea:	vpop	{d8}
   1a1ee:	pop	{r3, pc}
   1a1f0:	vmov	s15, r0
   1a1f4:	vcvt.f32.s32	s13, s15
   1a1f8:	vmul.f32	s11, s0, s0
   1a1fc:	vadd.f32	s15, s0, s13
   1a200:	asrs	r3, r3, #30
   1a202:	vdiv.f32	s12, s11, s15
   1a206:	and.w	r3, r3, #2
   1a20a:	rsb	r3, r3, #1
   1a20e:	vpop	{d8}
   1a212:	vmov.f32	s11, #0	; 0x40000000  2.0
   1a216:	vsub.f32	s1, s12, s1
   1a21a:	vmov	s0, r3
   1a21e:	vsub.f32	s14, s14, s1
   1a222:	vcvt.f32.s32	s15, s0
   1a226:	vfms.f32	s13, s14, s11
   1a22a:	vmul.f32	s0, s13, s15
   1a22e:	pop	{r3, pc}
   1a230:	bl	1a860 <fabsf>
   1a234:	vmov.f32	s15, #112	; 0x3f800000  1.0
   1a238:	vdiv.f32	s0, s15, s0
   1a23c:	b.n	1a1ea <__kernel_tanf+0x13a>
   1a23e:	nop
   1a240:	.word	0x3f2ca13f
   1a244:	.word	0x3f490fda
   1a248:	.word	0x33222168
   1a24c:	.word	0x00000000
   1a250:	.word	0x37d95384
   1a254:	.word	0x3895c07a
   1a258:	.word	0xb79bae5f
   1a25c:	.word	0x38a3f445
   1a260:	.word	0x398137b9
   1a264:	.word	0x3a1a26c8
   1a268:	.word	0x3abede48
   1a26c:	.word	0x3b6b6916
   1a270:	.word	0x3c11371f
   1a274:	.word	0x3cb327a4
   1a278:	.word	0x3d5d0dd1
   1a27c:	.word	0x3e088889
   1a280:	.word	0x3eaaaaab

0001a284 <fabs>:
   1a284:	vmov	r2, r3, d0
   1a288:	bic.w	r3, r3, #2147483648	; 0x80000000
   1a28c:	vmov	d0, r2, r3
   1a290:	bx	lr
   1a292:	nop
   1a294:	movs	r0, r0
	...

0001a298 <floor>:
   1a298:	push	{r4, r5, r6}
   1a29a:	sub	sp, #12
   1a29c:	vstr	d0, [sp]
   1a2a0:	ldr	r1, [sp, #4]
   1a2a2:	ldr	r4, [sp, #0]
   1a2a4:	ubfx	r2, r1, #20, #11
   1a2a8:	subw	r3, r2, #1023	; 0x3ff
   1a2ac:	cmp	r3, #19
   1a2ae:	mov	r5, r1
   1a2b0:	mov	r0, r4
   1a2b2:	bgt.n	1a2f2 <floor+0x5a>
   1a2b4:	cmp	r3, #0
   1a2b6:	blt.n	1a340 <floor+0xa8>
   1a2b8:	ldr	r2, [pc, #236]	; (1a3a8 <floor+0x110>)
   1a2ba:	asrs	r2, r3
   1a2bc:	and.w	r6, r1, r2
   1a2c0:	orrs	r4, r6
   1a2c2:	beq.n	1a2fc <floor+0x64>
   1a2c4:	vldr	d7, [pc, #216]	; 1a3a0 <floor+0x108>
   1a2c8:	vldr	d6, [sp]
   1a2cc:	vadd.f64	d7, d6, d7
   1a2d0:	vcmpe.f64	d7, #0.0
   1a2d4:	vmrs	APSR_nzcv, fpscr
   1a2d8:	ble.n	1a2e4 <floor+0x4c>
   1a2da:	cmp	r1, #0
   1a2dc:	blt.n	1a366 <floor+0xce>
   1a2de:	bic.w	r1, r5, r2
   1a2e2:	movs	r0, #0
   1a2e4:	mov	r3, r1
   1a2e6:	mov	r2, r0
   1a2e8:	vmov	d0, r2, r3
   1a2ec:	add	sp, #12
   1a2ee:	pop	{r4, r5, r6}
   1a2f0:	bx	lr
   1a2f2:	cmp	r3, #51	; 0x33
   1a2f4:	ble.n	1a306 <floor+0x6e>
   1a2f6:	cmp.w	r3, #1024	; 0x400
   1a2fa:	beq.n	1a35c <floor+0xc4>
   1a2fc:	vldr	d0, [sp]
   1a300:	add	sp, #12
   1a302:	pop	{r4, r5, r6}
   1a304:	bx	lr
   1a306:	subw	r2, r2, #1043	; 0x413
   1a30a:	mov.w	r4, #4294967295
   1a30e:	lsr.w	r2, r4, r2
   1a312:	tst	r0, r2
   1a314:	beq.n	1a2fc <floor+0x64>
   1a316:	vldr	d7, [pc, #136]	; 1a3a0 <floor+0x108>
   1a31a:	vldr	d6, [sp]
   1a31e:	vadd.f64	d7, d6, d7
   1a322:	vcmpe.f64	d7, #0.0
   1a326:	vmrs	APSR_nzcv, fpscr
   1a32a:	ble.n	1a2e4 <floor+0x4c>
   1a32c:	cmp	r1, #0
   1a32e:	blt.n	1a372 <floor+0xda>
   1a330:	mov	r1, r5
   1a332:	bic.w	r0, r0, r2
   1a336:	mov	r3, r1
   1a338:	mov	r2, r0
   1a33a:	vmov	d0, r2, r3
   1a33e:	b.n	1a2ec <floor+0x54>
   1a340:	vldr	d7, [pc, #92]	; 1a3a0 <floor+0x108>
   1a344:	vadd.f64	d7, d0, d7
   1a348:	vcmpe.f64	d7, #0.0
   1a34c:	vmrs	APSR_nzcv, fpscr
   1a350:	ble.n	1a2e4 <floor+0x4c>
   1a352:	cmp	r1, #0
   1a354:	blt.n	1a388 <floor+0xf0>
   1a356:	movs	r0, #0
   1a358:	mov	r1, r0
   1a35a:	b.n	1a2e4 <floor+0x4c>
   1a35c:	vldr	d7, [sp]
   1a360:	vadd.f64	d0, d7, d7
   1a364:	b.n	1a300 <floor+0x68>
   1a366:	mov.w	r1, #1048576	; 0x100000
   1a36a:	asr.w	r3, r1, r3
   1a36e:	add	r5, r3
   1a370:	b.n	1a2de <floor+0x46>
   1a372:	cmp	r3, #20
   1a374:	beq.n	1a398 <floor+0x100>
   1a376:	movs	r1, #1
   1a378:	rsb	r3, r3, #52	; 0x34
   1a37c:	lsl.w	r3, r1, r3
   1a380:	adds	r0, r3, r0
   1a382:	it	cs
   1a384:	addcs	r5, r5, r1
   1a386:	b.n	1a330 <floor+0x98>
   1a388:	bic.w	r2, r1, #2147483648	; 0x80000000
   1a38c:	ldr	r3, [pc, #28]	; (1a3ac <floor+0x114>)
   1a38e:	orrs	r2, r4
   1a390:	it	ne
   1a392:	movne	r1, r3
   1a394:	movs	r0, #0
   1a396:	b.n	1a2e4 <floor+0x4c>
   1a398:	adds	r5, #1
   1a39a:	b.n	1a330 <floor+0x98>
   1a39c:	nop.w
   1a3a0:	.word	0x8800759c
   1a3a4:	.word	0x7e37e43c
   1a3a8:	.word	0x000fffff
   1a3ac:	.word	0xbff00000

0001a3b0 <matherr>:
   1a3b0:	movs	r0, #0
   1a3b2:	bx	lr

0001a3b4 <rint>:
   1a3b4:	push	{r4, r5, r6, r7}
   1a3b6:	vmov	r2, r3, d0
   1a3ba:	ubfx	r5, r3, #20, #11
   1a3be:	subw	r0, r5, #1023	; 0x3ff
   1a3c2:	cmp	r0, #19
   1a3c4:	sub	sp, #16
   1a3c6:	mov	r1, r3
   1a3c8:	mov.w	r7, r3, lsr #31
   1a3cc:	vmov	r4, s0
   1a3d0:	bgt.n	1a42c <rint+0x78>
   1a3d2:	cmp	r0, #0
   1a3d4:	blt.n	1a466 <rint+0xb2>
   1a3d6:	ldr	r5, [pc, #240]	; (1a4c8 <rint+0x114>)
   1a3d8:	asrs	r5, r0
   1a3da:	and.w	r6, r3, r5
   1a3de:	orrs	r6, r2
   1a3e0:	beq.n	1a436 <rint+0x82>
   1a3e2:	lsrs	r5, r5, #1
   1a3e4:	ands	r3, r5
   1a3e6:	orrs	r4, r3
   1a3e8:	beq.n	1a404 <rint+0x50>
   1a3ea:	mov.w	r3, #262144	; 0x40000
   1a3ee:	cmp	r0, #19
   1a3f0:	bic.w	r5, r1, r5
   1a3f4:	asr.w	r1, r3, r0
   1a3f8:	orr.w	r1, r1, r5
   1a3fc:	ite	eq
   1a3fe:	moveq.w	r4, #2147483648	; 0x80000000
   1a402:	movne	r4, #0
   1a404:	ldr	r0, [pc, #196]	; (1a4cc <rint+0x118>)
   1a406:	add.w	r7, r0, r7, lsl #3
   1a40a:	vldr	d0, [r7]
   1a40e:	mov	r3, r1
   1a410:	mov	r2, r4
   1a412:	vmov	d7, r2, r3
   1a416:	vadd.f64	d7, d7, d0
   1a41a:	vstr	d7, [sp, #8]
   1a41e:	vldr	d7, [sp, #8]
   1a422:	vsub.f64	d0, d7, d0
   1a426:	add	sp, #16
   1a428:	pop	{r4, r5, r6, r7}
   1a42a:	bx	lr
   1a42c:	cmp	r0, #51	; 0x33
   1a42e:	ble.n	1a440 <rint+0x8c>
   1a430:	cmp.w	r0, #1024	; 0x400
   1a434:	beq.n	1a4c0 <rint+0x10c>
   1a436:	vmov	d0, r2, r3
   1a43a:	add	sp, #16
   1a43c:	pop	{r4, r5, r6, r7}
   1a43e:	bx	lr
   1a440:	subw	r5, r5, #1043	; 0x413
   1a444:	mov.w	r0, #4294967295
   1a448:	lsrs	r0, r5
   1a44a:	tst	r2, r0
   1a44c:	beq.n	1a436 <rint+0x82>
   1a44e:	lsrs	r0, r0, #1
   1a450:	tst	r2, r0
   1a452:	beq.n	1a404 <rint+0x50>
   1a454:	mov.w	r3, #1073741824	; 0x40000000
   1a458:	bic.w	r0, r4, r0
   1a45c:	asr.w	r5, r3, r5
   1a460:	orr.w	r4, r5, r0
   1a464:	b.n	1a404 <rint+0x50>
   1a466:	bic.w	r0, r3, #2147483648	; 0x80000000
   1a46a:	orrs	r0, r2
   1a46c:	vmov	r6, s0
   1a470:	beq.n	1a436 <rint+0x82>
   1a472:	ubfx	r0, r3, #0, #20
   1a476:	orrs	r6, r0
   1a478:	negs	r0, r6
   1a47a:	orrs	r6, r0
   1a47c:	ldr	r0, [pc, #76]	; (1a4cc <rint+0x118>)
   1a47e:	lsrs	r1, r3, #17
   1a480:	lsrs	r6, r6, #12
   1a482:	lsls	r1, r1, #17
   1a484:	and.w	r6, r6, #524288	; 0x80000
   1a488:	add.w	r0, r0, r7, lsl #3
   1a48c:	orr.w	r3, r6, r1
   1a490:	vldr	d6, [r0]
   1a494:	vmov	d7, r2, r3
   1a498:	vadd.f64	d7, d7, d6
   1a49c:	vstr	d7, [sp, #8]
   1a4a0:	vldr	d7, [sp, #8]
   1a4a4:	vsub.f64	d7, d7, d6
   1a4a8:	vstr	d7, [sp]
   1a4ac:	ldr	r1, [sp, #4]
   1a4ae:	ldrd	r2, r3, [sp]
   1a4b2:	bic.w	r1, r1, #2147483648	; 0x80000000
   1a4b6:	orr.w	r3, r1, r7, lsl #31
   1a4ba:	vmov	d0, r2, r3
   1a4be:	b.n	1a43a <rint+0x86>
   1a4c0:	vadd.f64	d0, d0, d0
   1a4c4:	b.n	1a43a <rint+0x86>
   1a4c6:	nop
   1a4c8:	.word	0x000fffff
   1a4cc:	.word	0x20020450

0001a4d0 <scalbn>:
   1a4d0:	push	{r4, lr}
   1a4d2:	vpush	{d8}
   1a4d6:	sub	sp, #8
   1a4d8:	vstr	d0, [sp]
   1a4dc:	ldr	r3, [sp, #4]
   1a4de:	ldr	r1, [sp, #0]
   1a4e0:	ubfx	r2, r3, #20, #11
   1a4e4:	cbnz	r2, 1a532 <scalbn+0x62>
   1a4e6:	bic.w	r3, r3, #2147483648	; 0x80000000
   1a4ea:	orrs	r3, r1
   1a4ec:	beq.n	1a54a <scalbn+0x7a>
   1a4ee:	vldr	d7, [pc, #216]	; 1a5c8 <scalbn+0xf8>
   1a4f2:	ldr	r2, [pc, #244]	; (1a5e8 <scalbn+0x118>)
   1a4f4:	vmul.f64	d7, d0, d7
   1a4f8:	cmp	r0, r2
   1a4fa:	vstr	d7, [sp]
   1a4fe:	ldr	r3, [sp, #4]
   1a500:	blt.n	1a556 <scalbn+0x86>
   1a502:	ubfx	r2, r3, #20, #11
   1a506:	subs	r2, #54	; 0x36
   1a508:	adds	r4, r0, r2
   1a50a:	movw	r2, #2046	; 0x7fe
   1a50e:	cmp	r4, r2
   1a510:	bgt.n	1a574 <scalbn+0xa4>
   1a512:	cmp	r4, #0
   1a514:	ble.n	1a566 <scalbn+0x96>
   1a516:	bic.w	r1, r3, #2139095040	; 0x7f800000
   1a51a:	ldrd	r2, r3, [sp]
   1a51e:	bic.w	r1, r1, #7340032	; 0x700000
   1a522:	orr.w	r3, r1, r4, lsl #20
   1a526:	vmov	d0, r2, r3
   1a52a:	add	sp, #8
   1a52c:	vpop	{d8}
   1a530:	pop	{r4, pc}
   1a532:	movw	r1, #2047	; 0x7ff
   1a536:	cmp	r2, r1
   1a538:	bne.n	1a508 <scalbn+0x38>
   1a53a:	vldr	d7, [sp]
   1a53e:	vadd.f64	d0, d7, d7
   1a542:	add	sp, #8
   1a544:	vpop	{d8}
   1a548:	pop	{r4, pc}
   1a54a:	vldr	d0, [sp]
   1a54e:	add	sp, #8
   1a550:	vpop	{d8}
   1a554:	pop	{r4, pc}
   1a556:	vldr	d0, [pc, #120]	; 1a5d0 <scalbn+0x100>
   1a55a:	vmul.f64	d0, d7, d0
   1a55e:	add	sp, #8
   1a560:	vpop	{d8}
   1a564:	pop	{r4, pc}
   1a566:	cmn.w	r4, #53	; 0x35
   1a56a:	bge.n	1a590 <scalbn+0xc0>
   1a56c:	movw	r3, #50000	; 0xc350
   1a570:	cmp	r0, r3
   1a572:	ble.n	1a5b0 <scalbn+0xe0>
   1a574:	vldr	d8, [pc, #96]	; 1a5d8 <scalbn+0x108>
   1a578:	vldr	d1, [sp]
   1a57c:	vmov.f64	d0, d8
   1a580:	bl	1a9f0 <copysign>
   1a584:	vmul.f64	d0, d0, d8
   1a588:	add	sp, #8
   1a58a:	vpop	{d8}
   1a58e:	pop	{r4, pc}
   1a590:	bic.w	r1, r3, #2139095040	; 0x7f800000
   1a594:	ldrd	r2, r3, [sp]
   1a598:	bic.w	r1, r1, #7340032	; 0x700000
   1a59c:	adds	r4, #54	; 0x36
   1a59e:	orr.w	r3, r1, r4, lsl #20
   1a5a2:	vldr	d0, [pc, #60]	; 1a5e0 <scalbn+0x110>
   1a5a6:	vmov	d7, r2, r3
   1a5aa:	vmul.f64	d0, d7, d0
   1a5ae:	b.n	1a52a <scalbn+0x5a>
   1a5b0:	vldr	d8, [pc, #28]	; 1a5d0 <scalbn+0x100>
   1a5b4:	vldr	d1, [sp]
   1a5b8:	vmov.f64	d0, d8
   1a5bc:	bl	1a9f0 <copysign>
   1a5c0:	vmul.f64	d0, d0, d8
   1a5c4:	b.n	1a52a <scalbn+0x5a>
   1a5c6:	nop
   1a5c8:	.word	0x00000000
   1a5cc:	.word	0x43500000
   1a5d0:	.word	0xc2f8f359
   1a5d4:	.word	0x01a56e1f
   1a5d8:	.word	0x8800759c
   1a5dc:	.word	0x7e37e43c
   1a5e0:	.word	0x00000000
   1a5e4:	.word	0x3c900000
   1a5e8:	.word	0xffff3cb0

0001a5ec <expm1f>:
   1a5ec:	vmov	r3, s0
   1a5f0:	ldr	r1, [pc, #560]	; (1a824 <expm1f+0x238>)
   1a5f2:	bic.w	r2, r3, #2147483648	; 0x80000000
   1a5f6:	cmp	r2, r1
   1a5f8:	and.w	r3, r3, #2147483648	; 0x80000000
   1a5fc:	bls.n	1a648 <expm1f+0x5c>
   1a5fe:	cmp.w	r2, #2139095040	; 0x7f800000
   1a602:	bhi.n	1a702 <expm1f+0x116>
   1a604:	beq.w	1a7a6 <expm1f+0x1ba>
   1a608:	cmp	r3, #0
   1a60a:	bne.w	1a72c <expm1f+0x140>
   1a60e:	ldr	r3, [pc, #536]	; (1a828 <expm1f+0x23c>)
   1a610:	cmp	r2, r3
   1a612:	bhi.w	1a812 <expm1f+0x226>
   1a616:	vldr	s14, [pc, #532]	; 1a82c <expm1f+0x240>
   1a61a:	vmul.f32	s14, s0, s14
   1a61e:	vmov.f32	s15, #96	; 0x3f000000  0.5
   1a622:	vadd.f32	s14, s15, s14
   1a626:	vldr	s15, [pc, #520]	; 1a830 <expm1f+0x244>
   1a62a:	vldr	s13, [pc, #520]	; 1a834 <expm1f+0x248>
   1a62e:	vcvt.s32.f32	s14, s14
   1a632:	vmov	r3, s14
   1a636:	vcvt.f32.s32	s14, s14
   1a63a:	vfms.f32	s0, s14, s15
   1a63e:	vmul.f32	s13, s14, s13
   1a642:	vmov.f32	s15, s0
   1a646:	b.n	1a71e <expm1f+0x132>
   1a648:	ldr	r1, [pc, #492]	; (1a838 <expm1f+0x24c>)
   1a64a:	cmp	r2, r1
   1a64c:	bhi.n	1a708 <expm1f+0x11c>
   1a64e:	cmp.w	r2, #855638016	; 0x33000000
   1a652:	bcc.w	1a77a <expm1f+0x18e>
   1a656:	movs	r3, #0
   1a658:	vmov.f32	s6, #96	; 0x3f000000  0.5
   1a65c:	vmul.f32	s8, s0, s6
   1a660:	vldr	s12, [pc, #472]	; 1a83c <expm1f+0x250>
   1a664:	vldr	s11, [pc, #472]	; 1a840 <expm1f+0x254>
   1a668:	vldr	s9, [pc, #472]	; 1a844 <expm1f+0x258>
   1a66c:	vldr	s10, [pc, #472]	; 1a848 <expm1f+0x25c>
   1a670:	vldr	s13, [pc, #472]	; 1a84c <expm1f+0x260>
   1a674:	vmul.f32	s14, s0, s8
   1a678:	vmov.f32	s7, #112	; 0x3f800000  1.0
   1a67c:	vfma.f32	s11, s14, s12
   1a680:	vmov.f32	s12, #8	; 0x40400000  3.0
   1a684:	vfma.f32	s9, s14, s11
   1a688:	vmov.f32	s11, #24	; 0x40c00000  6.0
   1a68c:	vfma.f32	s10, s14, s9
   1a690:	vfma.f32	s13, s14, s10
   1a694:	vmov.f32	s10, s7
   1a698:	vfma.f32	s10, s14, s13
   1a69c:	vfms.f32	s12, s8, s10
   1a6a0:	vfms.f32	s11, s0, s12
   1a6a4:	vsub.f32	s12, s10, s12
   1a6a8:	vdiv.f32	s13, s12, s11
   1a6ac:	vmul.f32	s13, s13, s14
   1a6b0:	cbz	r3, 1a6f8 <expm1f+0x10c>
   1a6b2:	vsub.f32	s13, s13, s15
   1a6b6:	adds	r2, r3, #1
   1a6b8:	vfnms.f32	s15, s0, s13
   1a6bc:	vsub.f32	s14, s15, s14
   1a6c0:	beq.w	1a7ce <expm1f+0x1e2>
   1a6c4:	cmp	r3, #1
   1a6c6:	beq.n	1a74c <expm1f+0x160>
   1a6c8:	adds	r2, r3, #1
   1a6ca:	cmp	r2, #57	; 0x39
   1a6cc:	bhi.n	1a7b4 <expm1f+0x1c8>
   1a6ce:	cmp	r3, #22
   1a6d0:	ble.w	1a7ee <expm1f+0x202>
   1a6d4:	rsb	r2, r3, #127	; 0x7f
   1a6d8:	lsls	r2, r2, #23
   1a6da:	vmov	s15, r2
   1a6de:	vadd.f32	s15, s14, s15
   1a6e2:	vsub.f32	s15, s0, s15
   1a6e6:	vadd.f32	s0, s15, s7
   1a6ea:	vmov	r2, s0
   1a6ee:	add.w	r3, r2, r3, lsl #23
   1a6f2:	vmov	s0, r3
   1a6f6:	bx	lr
   1a6f8:	vfnms.f32	s14, s0, s13
   1a6fc:	vsub.f32	s0, s0, s14
   1a700:	bx	lr
   1a702:	vadd.f32	s0, s0, s0
   1a706:	bx	lr
   1a708:	ldr	r1, [pc, #324]	; (1a850 <expm1f+0x264>)
   1a70a:	cmp	r2, r1
   1a70c:	bhi.n	1a78c <expm1f+0x1a0>
   1a70e:	vldr	s14, [pc, #288]	; 1a830 <expm1f+0x244>
   1a712:	cbnz	r3, 1a76c <expm1f+0x180>
   1a714:	vldr	s13, [pc, #284]	; 1a834 <expm1f+0x248>
   1a718:	vsub.f32	s15, s0, s14
   1a71c:	movs	r3, #1
   1a71e:	vsub.f32	s0, s15, s13
   1a722:	vsub.f32	s15, s15, s0
   1a726:	vsub.f32	s15, s15, s13
   1a72a:	b.n	1a658 <expm1f+0x6c>
   1a72c:	vldr	s15, [pc, #292]	; 1a854 <expm1f+0x268>
   1a730:	vadd.f32	s15, s0, s15
   1a734:	vcmpe.f32	s15, #0.0
   1a738:	vmrs	APSR_nzcv, fpscr
   1a73c:	bmi.n	1a81c <expm1f+0x230>
   1a73e:	vldr	s14, [pc, #236]	; 1a82c <expm1f+0x240>
   1a742:	vmov.f32	s15, #224	; 0xbf000000 -0.5
   1a746:	vmul.f32	s14, s0, s14
   1a74a:	b.n	1a622 <expm1f+0x36>
   1a74c:	vmov.f32	s15, #208	; 0xbe800000 -0.250
   1a750:	vcmpe.f32	s0, s15
   1a754:	vmrs	APSR_nzcv, fpscr
   1a758:	bpl.n	1a7dc <expm1f+0x1f0>
   1a75a:	vadd.f32	s0, s0, s6
   1a75e:	vmov.f32	s15, #128	; 0xc0000000 -2.0
   1a762:	vsub.f32	s0, s14, s0
   1a766:	vmul.f32	s0, s0, s15
   1a76a:	bx	lr
   1a76c:	vldr	s13, [pc, #232]	; 1a858 <expm1f+0x26c>
   1a770:	vadd.f32	s15, s0, s14
   1a774:	mov.w	r3, #4294967295
   1a778:	b.n	1a71e <expm1f+0x132>
   1a77a:	vldr	s15, [pc, #224]	; 1a85c <expm1f+0x270>
   1a77e:	vadd.f32	s15, s0, s15
   1a782:	vsub.f32	s15, s15, s15
   1a786:	vsub.f32	s0, s0, s15
   1a78a:	bx	lr
   1a78c:	vldr	s14, [pc, #156]	; 1a82c <expm1f+0x240>
   1a790:	cmp	r3, #0
   1a792:	vmov.f32	s15, #96	; 0x3f000000  0.5
   1a796:	vmov.f32	s13, #224	; 0xbf000000 -0.5
   1a79a:	vmul.f32	s14, s0, s14
   1a79e:	it	ne
   1a7a0:	vmovne.f32	s15, s13
   1a7a4:	b.n	1a622 <expm1f+0x36>
   1a7a6:	cmp	r3, #0
   1a7a8:	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1a7ac:	it	ne
   1a7ae:	vmovne.f32	s0, s15
   1a7b2:	bx	lr
   1a7b4:	vsub.f32	s15, s14, s0
   1a7b8:	vsub.f32	s0, s7, s15
   1a7bc:	vmov	r2, s0
   1a7c0:	add.w	r3, r2, r3, lsl #23
   1a7c4:	vmov	s0, r3
   1a7c8:	vsub.f32	s0, s0, s7
   1a7cc:	bx	lr
   1a7ce:	vsub.f32	s15, s0, s14
   1a7d2:	vmov.f32	s0, #224	; 0xbf000000 -0.5
   1a7d6:	vfma.f32	s0, s15, s6
   1a7da:	bx	lr
   1a7dc:	vsub.f32	s14, s0, s14
   1a7e0:	vmov.f32	s15, #0	; 0x40000000  2.0
   1a7e4:	vfma.f32	s7, s14, s15
   1a7e8:	vmov.f32	s0, s7
   1a7ec:	bx	lr
   1a7ee:	mov.w	r2, #16777216	; 0x1000000
   1a7f2:	asrs	r2, r3
   1a7f4:	rsb	r2, r2, #1065353216	; 0x3f800000
   1a7f8:	vsub.f32	s15, s14, s0
   1a7fc:	vmov	s0, r2
   1a800:	vsub.f32	s0, s0, s15
   1a804:	vmov	r2, s0
   1a808:	add.w	r3, r2, r3, lsl #23
   1a80c:	vmov	s0, r3
   1a810:	bx	lr
   1a812:	vldr	s0, [pc, #72]	; 1a85c <expm1f+0x270>
   1a816:	vmul.f32	s0, s0, s0
   1a81a:	bx	lr
   1a81c:	vmov.f32	s0, #240	; 0xbf800000 -1.0
   1a820:	bx	lr
   1a822:	nop
   1a824:	.word	0x4195b843
   1a828:	.word	0x42b17217
   1a82c:	.word	0x3fb8aa3b
   1a830:	.word	0x3f317180
   1a834:	.word	0x3717f7d1
   1a838:	.word	0x3eb17218
   1a83c:	.word	0xb457edbb
   1a840:	.word	0x36867e54
   1a844:	.word	0xb8a670cd
   1a848:	.word	0x3ad00d01
   1a84c:	.word	0xbd088889
   1a850:	.word	0x3f851591
   1a854:	.word	0x0da24260
   1a858:	.word	0xb717f7d1
   1a85c:	.word	0x7149f2ca

0001a860 <fabsf>:
   1a860:	vmov	r3, s0
   1a864:	bic.w	r3, r3, #2147483648	; 0x80000000
   1a868:	vmov	s0, r3
   1a86c:	bx	lr
   1a86e:	nop

0001a870 <finitef>:
   1a870:	vmov	r3, s0
   1a874:	bic.w	r0, r3, #2147483648	; 0x80000000
   1a878:	cmp.w	r0, #2139095040	; 0x7f800000
   1a87c:	ite	ge
   1a87e:	movge	r0, #0
   1a880:	movlt	r0, #1
   1a882:	bx	lr

0001a884 <floorf>:
   1a884:	vmov	r2, s0
   1a888:	bic.w	r1, r2, #2147483648	; 0x80000000
   1a88c:	lsrs	r3, r1, #23
   1a88e:	subs	r3, #127	; 0x7f
   1a890:	cmp	r3, #22
   1a892:	bgt.n	1a8c4 <floorf+0x40>
   1a894:	cmp	r3, #0
   1a896:	vmov	r0, s0
   1a89a:	blt.n	1a8d0 <floorf+0x4c>
   1a89c:	ldr	r1, [pc, #104]	; (1a908 <floorf+0x84>)
   1a89e:	asrs	r1, r3
   1a8a0:	tst	r2, r1
   1a8a2:	beq.n	1a8ea <floorf+0x66>
   1a8a4:	vldr	s15, [pc, #100]	; 1a90c <floorf+0x88>
   1a8a8:	vadd.f32	s15, s0, s15
   1a8ac:	vcmpe.f32	s15, #0.0
   1a8b0:	vmrs	APSR_nzcv, fpscr
   1a8b4:	ble.n	1a8ea <floorf+0x66>
   1a8b6:	cmp	r2, #0
   1a8b8:	blt.n	1a8ec <floorf+0x68>
   1a8ba:	bic.w	r3, r0, r1
   1a8be:	vmov	s0, r3
   1a8c2:	bx	lr
   1a8c4:	cmp.w	r1, #2139095040	; 0x7f800000
   1a8c8:	bcc.n	1a8ea <floorf+0x66>
   1a8ca:	vadd.f32	s0, s0, s0
   1a8ce:	bx	lr
   1a8d0:	vldr	s15, [pc, #56]	; 1a90c <floorf+0x88>
   1a8d4:	vadd.f32	s15, s0, s15
   1a8d8:	vcmpe.f32	s15, #0.0
   1a8dc:	vmrs	APSR_nzcv, fpscr
   1a8e0:	ble.n	1a8ea <floorf+0x66>
   1a8e2:	cmp	r2, #0
   1a8e4:	blt.n	1a8f8 <floorf+0x74>
   1a8e6:	vldr	s0, [pc, #40]	; 1a910 <floorf+0x8c>
   1a8ea:	bx	lr
   1a8ec:	mov.w	r2, #8388608	; 0x800000
   1a8f0:	asr.w	r3, r2, r3
   1a8f4:	add	r0, r3
   1a8f6:	b.n	1a8ba <floorf+0x36>
   1a8f8:	cmp	r1, #0
   1a8fa:	vmov.f32	s15, #240	; 0xbf800000 -1.0
   1a8fe:	it	ne
   1a900:	vmovne.f32	s0, s15
   1a904:	bx	lr
   1a906:	nop
   1a908:	.word	0x007fffff
   1a90c:	.word	0x7149f2ca
   1a910:	.word	0x00000000

0001a914 <nanf>:
   1a914:	vldr	s0, [pc, #4]	; 1a91c <nanf+0x8>
   1a918:	bx	lr
   1a91a:	nop
   1a91c:	.word	0x7fc00000

0001a920 <scalbnf>:
   1a920:	push	{r3, lr}
   1a922:	vmov	r3, s0
   1a926:	bics.w	r2, r3, #2147483648	; 0x80000000
   1a92a:	vpush	{d8}
   1a92e:	beq.n	1a954 <scalbnf+0x34>
   1a930:	cmp.w	r2, #2139095040	; 0x7f800000
   1a934:	bcs.n	1a95a <scalbnf+0x3a>
   1a936:	cmp.w	r2, #8388608	; 0x800000
   1a93a:	bcc.n	1a964 <scalbnf+0x44>
   1a93c:	lsrs	r2, r2, #23
   1a93e:	add	r2, r0
   1a940:	cmp	r2, #254	; 0xfe
   1a942:	bgt.n	1a9a2 <scalbnf+0x82>
   1a944:	cmp	r2, #0
   1a946:	ble.n	1a97e <scalbnf+0x5e>
   1a948:	bic.w	r3, r3, #2139095040	; 0x7f800000
   1a94c:	orr.w	r3, r3, r2, lsl #23
   1a950:	vmov	s0, r3
   1a954:	vpop	{d8}
   1a958:	pop	{r3, pc}
   1a95a:	vpop	{d8}
   1a95e:	vadd.f32	s0, s0, s0
   1a962:	pop	{r3, pc}
   1a964:	ldr	r3, [pc, #116]	; (1a9dc <scalbnf+0xbc>)
   1a966:	vldr	s15, [pc, #120]	; 1a9e0 <scalbnf+0xc0>
   1a96a:	cmp	r0, r3
   1a96c:	vmul.f32	s0, s0, s15
   1a970:	blt.n	1a9b8 <scalbnf+0x98>
   1a972:	vmov	r3, s0
   1a976:	ubfx	r2, r3, #23, #8
   1a97a:	subs	r2, #25
   1a97c:	b.n	1a93e <scalbnf+0x1e>
   1a97e:	cmn.w	r2, #22
   1a982:	bge.n	1a9c2 <scalbnf+0xa2>
   1a984:	movw	r3, #50000	; 0xc350
   1a988:	cmp	r0, r3
   1a98a:	bgt.n	1a9a2 <scalbnf+0x82>
   1a98c:	vldr	s16, [pc, #84]	; 1a9e4 <scalbnf+0xc4>
   1a990:	vmov.f32	s1, s0
   1a994:	vmov.f32	s0, s16
   1a998:	bl	1aa0c <copysignf>
   1a99c:	vmul.f32	s0, s0, s16
   1a9a0:	b.n	1a954 <scalbnf+0x34>
   1a9a2:	vldr	s16, [pc, #68]	; 1a9e8 <scalbnf+0xc8>
   1a9a6:	vmov.f32	s1, s0
   1a9aa:	vmov.f32	s0, s16
   1a9ae:	bl	1aa0c <copysignf>
   1a9b2:	vmul.f32	s0, s0, s16
   1a9b6:	b.n	1a954 <scalbnf+0x34>
   1a9b8:	vldr	s1, [pc, #40]	; 1a9e4 <scalbnf+0xc4>
   1a9bc:	vmul.f32	s0, s0, s1
   1a9c0:	b.n	1a954 <scalbnf+0x34>
   1a9c2:	adds	r2, #25
   1a9c4:	bic.w	r3, r3, #2139095040	; 0x7f800000
   1a9c8:	orr.w	r3, r3, r2, lsl #23
   1a9cc:	vldr	s15, [pc, #28]	; 1a9ec <scalbnf+0xcc>
   1a9d0:	vmov	s0, r3
   1a9d4:	vmul.f32	s0, s0, s15
   1a9d8:	b.n	1a954 <scalbnf+0x34>
   1a9da:	nop
   1a9dc:	.word	0xffff3cb0
   1a9e0:	.word	0x4c000000
   1a9e4:	.word	0x0da24260
   1a9e8:	.word	0x7149f2ca
   1a9ec:	.word	0x33000000

0001a9f0 <copysign>:
   1a9f0:	vmov	r2, r3, d0
   1a9f4:	vmov	r0, s3
   1a9f8:	bic.w	r1, r3, #2147483648	; 0x80000000
   1a9fc:	and.w	r0, r0, #2147483648	; 0x80000000
   1aa00:	orr.w	r3, r1, r0
   1aa04:	vmov	d0, r2, r3
   1aa08:	bx	lr
   1aa0a:	nop

0001aa0c <copysignf>:
   1aa0c:	vmov	r3, s0
   1aa10:	bic.w	r2, r3, #2147483648	; 0x80000000
   1aa14:	vmov	r3, s1
   1aa18:	and.w	r3, r3, #2147483648	; 0x80000000
   1aa1c:	orrs	r3, r2
   1aa1e:	vmov	s0, r3
   1aa22:	bx	lr

0001aa24 <__aeabi_atexit>:
   1aa24:	mov	r3, r1
   1aa26:	mov	r1, r0
   1aa28:	mov	r0, r3
   1aa2a:	b.w	1aa30 <__cxa_atexit>
   1aa2e:	nop

0001aa30 <__cxa_atexit>:
   1aa30:	mov	r3, r2
   1aa32:	mov	r2, r1
   1aa34:	mov	r1, r0
   1aa36:	movs	r0, #2
   1aa38:	b.w	1b0e0 <__register_exitproc>

0001aa3c <__errno>:
   1aa3c:	ldr	r3, [pc, #4]	; (1aa44 <__errno+0x8>)
   1aa3e:	ldr	r0, [r3, #0]
   1aa40:	bx	lr
   1aa42:	nop
   1aa44:	.word	0x20020ec8

0001aa48 <__libc_init_array>:
   1aa48:	push	{r4, r5, r6, lr}
   1aa4a:	ldr	r6, [pc, #60]	; (1aa88 <__libc_init_array+0x40>)
   1aa4c:	ldr	r5, [pc, #60]	; (1aa8c <__libc_init_array+0x44>)
   1aa4e:	subs	r6, r6, r5
   1aa50:	asrs	r6, r6, #2
   1aa52:	it	ne
   1aa54:	movne	r4, #0
   1aa56:	beq.n	1aa64 <__libc_init_array+0x1c>
   1aa58:	adds	r4, #1
   1aa5a:	ldr.w	r3, [r5], #4
   1aa5e:	blx	r3
   1aa60:	cmp	r6, r4
   1aa62:	bne.n	1aa58 <__libc_init_array+0x10>
   1aa64:	ldr	r6, [pc, #40]	; (1aa90 <__libc_init_array+0x48>)
   1aa66:	ldr	r5, [pc, #44]	; (1aa94 <__libc_init_array+0x4c>)
   1aa68:	subs	r6, r6, r5
   1aa6a:	bl	1b400 <___init_veneer>
   1aa6e:	asrs	r6, r6, #2
   1aa70:	it	ne
   1aa72:	movne	r4, #0
   1aa74:	beq.n	1aa84 <__libc_init_array+0x3c>
   1aa76:	adds	r4, #1
   1aa78:	ldr.w	r3, [r5], #4
   1aa7c:	blx	r3
   1aa7e:	cmp	r6, r4
   1aa80:	bne.n	1aa76 <__libc_init_array+0x2e>
   1aa82:	pop	{r4, r5, r6, pc}
   1aa84:	pop	{r4, r5, r6, pc}
   1aa86:	nop
   1aa88:	.word	0x600018a8
   1aa8c:	.word	0x600018a8
   1aa90:	.word	0x60001914
   1aa94:	.word	0x600018a8

0001aa98 <malloc>:
   1aa98:	ldr	r3, [pc, #8]	; (1aaa4 <malloc+0xc>)
   1aa9a:	mov	r1, r0
   1aa9c:	ldr	r0, [r3, #0]
   1aa9e:	b.w	1aaa8 <_malloc_r>
   1aaa2:	nop
   1aaa4:	.word	0x20020ec8

0001aaa8 <_malloc_r>:
   1aaa8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1aaac:	add.w	r5, r1, #11
   1aab0:	cmp	r5, #22
   1aab2:	sub	sp, #12
   1aab4:	mov	r6, r0
   1aab6:	bls.w	1abf8 <_malloc_r+0x150>
   1aaba:	bics.w	r5, r5, #7
   1aabe:	bmi.w	1ac40 <_malloc_r+0x198>
   1aac2:	cmp	r1, r5
   1aac4:	bhi.w	1ac40 <_malloc_r+0x198>
   1aac8:	bl	1b0b4 <__malloc_lock>
   1aacc:	cmp.w	r5, #504	; 0x1f8
   1aad0:	bcc.w	1b00c <_malloc_r+0x564>
   1aad4:	lsrs	r3, r5, #9
   1aad6:	beq.w	1ac4e <_malloc_r+0x1a6>
   1aada:	cmp	r3, #4
   1aadc:	bhi.w	1ade6 <_malloc_r+0x33e>
   1aae0:	lsrs	r0, r5, #6
   1aae2:	add.w	lr, r0, #57	; 0x39
   1aae6:	mov.w	r3, lr, lsl #1
   1aaea:	adds	r0, #56	; 0x38
   1aaec:	ldr	r7, [pc, #784]	; (1ae00 <_malloc_r+0x358>)
   1aaee:	add.w	r3, r7, r3, lsl #2
   1aaf2:	sub.w	r1, r3, #8
   1aaf6:	ldr	r4, [r3, #4]
   1aaf8:	cmp	r1, r4
   1aafa:	bne.n	1ab0c <_malloc_r+0x64>
   1aafc:	b.n	1ac58 <_malloc_r+0x1b0>
   1aafe:	cmp	r2, #0
   1ab00:	bge.w	1ac5c <_malloc_r+0x1b4>
   1ab04:	ldr	r4, [r4, #12]
   1ab06:	cmp	r1, r4
   1ab08:	beq.w	1ac58 <_malloc_r+0x1b0>
   1ab0c:	ldr	r3, [r4, #4]
   1ab0e:	bic.w	r3, r3, #3
   1ab12:	subs	r2, r3, r5
   1ab14:	cmp	r2, #15
   1ab16:	ble.n	1aafe <_malloc_r+0x56>
   1ab18:	ldr	r1, [pc, #740]	; (1ae00 <_malloc_r+0x358>)
   1ab1a:	ldr	r4, [r7, #16]
   1ab1c:	add.w	lr, r1, #8
   1ab20:	cmp	r4, lr
   1ab22:	beq.w	1ae8c <_malloc_r+0x3e4>
   1ab26:	ldr	r3, [r4, #4]
   1ab28:	bic.w	r3, r3, #3
   1ab2c:	subs	r2, r3, r5
   1ab2e:	cmp	r2, #15
   1ab30:	bgt.w	1ae66 <_malloc_r+0x3be>
   1ab34:	cmp	r2, #0
   1ab36:	str.w	lr, [r1, #20]
   1ab3a:	str.w	lr, [r1, #16]
   1ab3e:	bge.w	1ac7e <_malloc_r+0x1d6>
   1ab42:	cmp.w	r3, #512	; 0x200
   1ab46:	bcs.w	1ae18 <_malloc_r+0x370>
   1ab4a:	lsrs	r3, r3, #3
   1ab4c:	add.w	ip, r3, #1
   1ab50:	movs	r2, #1
   1ab52:	asrs	r3, r3, #2
   1ab54:	lsl.w	r3, r2, r3
   1ab58:	ldr	r2, [r1, #4]
   1ab5a:	ldr.w	r8, [r1, ip, lsl #3]
   1ab5e:	str.w	r8, [r4, #8]
   1ab62:	add.w	r9, r1, ip, lsl #3
   1ab66:	orrs	r2, r3
   1ab68:	sub.w	r3, r9, #8
   1ab6c:	str	r3, [r4, #12]
   1ab6e:	str	r2, [r1, #4]
   1ab70:	str.w	r4, [r1, ip, lsl #3]
   1ab74:	str.w	r4, [r8, #12]
   1ab78:	asrs	r3, r0, #2
   1ab7a:	movs	r4, #1
   1ab7c:	lsls	r4, r3
   1ab7e:	cmp	r4, r2
   1ab80:	bhi.w	1ac98 <_malloc_r+0x1f0>
   1ab84:	tst	r4, r2
   1ab86:	bne.n	1ab96 <_malloc_r+0xee>
   1ab88:	bic.w	r0, r0, #3
   1ab8c:	lsls	r4, r4, #1
   1ab8e:	tst	r4, r2
   1ab90:	add.w	r0, r0, #4
   1ab94:	beq.n	1ab8c <_malloc_r+0xe4>
   1ab96:	add.w	r9, r7, r0, lsl #3
   1ab9a:	mov	ip, r9
   1ab9c:	mov	r8, r0
   1ab9e:	ldr.w	r1, [ip, #12]
   1aba2:	cmp	ip, r1
   1aba4:	bne.n	1abb6 <_malloc_r+0x10e>
   1aba6:	b.n	1ae90 <_malloc_r+0x3e8>
   1aba8:	cmp	r2, #0
   1abaa:	bge.w	1aeb0 <_malloc_r+0x408>
   1abae:	ldr	r1, [r1, #12]
   1abb0:	cmp	ip, r1
   1abb2:	beq.w	1ae90 <_malloc_r+0x3e8>
   1abb6:	ldr	r3, [r1, #4]
   1abb8:	bic.w	r3, r3, #3
   1abbc:	subs	r2, r3, r5
   1abbe:	cmp	r2, #15
   1abc0:	ble.n	1aba8 <_malloc_r+0x100>
   1abc2:	mov	r4, r1
   1abc4:	ldr.w	ip, [r1, #12]
   1abc8:	ldr.w	r8, [r4, #8]!
   1abcc:	adds	r3, r1, r5
   1abce:	orr.w	r5, r5, #1
   1abd2:	str	r5, [r1, #4]
   1abd4:	orr.w	r1, r2, #1
   1abd8:	str.w	ip, [r8, #12]
   1abdc:	mov	r0, r6
   1abde:	str.w	r8, [ip, #8]
   1abe2:	str	r3, [r7, #20]
   1abe4:	str	r3, [r7, #16]
   1abe6:	str.w	lr, [r3, #12]
   1abea:	str.w	lr, [r3, #8]
   1abee:	str	r1, [r3, #4]
   1abf0:	str	r2, [r3, r2]
   1abf2:	bl	1b0b8 <__malloc_unlock>
   1abf6:	b.n	1ac38 <_malloc_r+0x190>
   1abf8:	cmp	r1, #16
   1abfa:	bhi.n	1ac40 <_malloc_r+0x198>
   1abfc:	bl	1b0b4 <__malloc_lock>
   1ac00:	movs	r5, #16
   1ac02:	movs	r3, #6
   1ac04:	movs	r0, #2
   1ac06:	ldr	r7, [pc, #504]	; (1ae00 <_malloc_r+0x358>)
   1ac08:	add.w	r3, r7, r3, lsl #2
   1ac0c:	sub.w	r2, r3, #8
   1ac10:	ldr	r4, [r3, #4]
   1ac12:	cmp	r4, r2
   1ac14:	beq.w	1aea2 <_malloc_r+0x3fa>
   1ac18:	ldr	r3, [r4, #4]
   1ac1a:	ldr	r1, [r4, #12]
   1ac1c:	ldr	r5, [r4, #8]
   1ac1e:	bic.w	r3, r3, #3
   1ac22:	add	r3, r4
   1ac24:	mov	r0, r6
   1ac26:	ldr	r2, [r3, #4]
   1ac28:	str	r1, [r5, #12]
   1ac2a:	orr.w	r2, r2, #1
   1ac2e:	str	r5, [r1, #8]
   1ac30:	str	r2, [r3, #4]
   1ac32:	bl	1b0b8 <__malloc_unlock>
   1ac36:	adds	r4, #8
   1ac38:	mov	r0, r4
   1ac3a:	add	sp, #12
   1ac3c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ac40:	movs	r4, #0
   1ac42:	movs	r3, #12
   1ac44:	mov	r0, r4
   1ac46:	str	r3, [r6, #0]
   1ac48:	add	sp, #12
   1ac4a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ac4e:	movs	r3, #128	; 0x80
   1ac50:	mov.w	lr, #64	; 0x40
   1ac54:	movs	r0, #63	; 0x3f
   1ac56:	b.n	1aaec <_malloc_r+0x44>
   1ac58:	mov	r0, lr
   1ac5a:	b.n	1ab18 <_malloc_r+0x70>
   1ac5c:	add	r3, r4
   1ac5e:	ldr	r1, [r4, #12]
   1ac60:	ldr	r2, [r3, #4]
   1ac62:	ldr	r5, [r4, #8]
   1ac64:	orr.w	r2, r2, #1
   1ac68:	str	r1, [r5, #12]
   1ac6a:	mov	r0, r6
   1ac6c:	str	r5, [r1, #8]
   1ac6e:	str	r2, [r3, #4]
   1ac70:	bl	1b0b8 <__malloc_unlock>
   1ac74:	adds	r4, #8
   1ac76:	mov	r0, r4
   1ac78:	add	sp, #12
   1ac7a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ac7e:	add	r3, r4
   1ac80:	mov	r0, r6
   1ac82:	ldr	r2, [r3, #4]
   1ac84:	orr.w	r2, r2, #1
   1ac88:	str	r2, [r3, #4]
   1ac8a:	bl	1b0b8 <__malloc_unlock>
   1ac8e:	adds	r4, #8
   1ac90:	mov	r0, r4
   1ac92:	add	sp, #12
   1ac94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ac98:	ldr	r4, [r7, #8]
   1ac9a:	ldr	r3, [r4, #4]
   1ac9c:	bic.w	r8, r3, #3
   1aca0:	cmp	r8, r5
   1aca2:	bcc.n	1acae <_malloc_r+0x206>
   1aca4:	rsb	r3, r5, r8
   1aca8:	cmp	r3, #15
   1acaa:	bgt.w	1adc6 <_malloc_r+0x31e>
   1acae:	ldr	r3, [pc, #340]	; (1ae04 <_malloc_r+0x35c>)
   1acb0:	ldr.w	r9, [pc, #352]	; 1ae14 <_malloc_r+0x36c>
   1acb4:	ldr	r2, [r3, #0]
   1acb6:	ldr.w	r3, [r9]
   1acba:	adds	r3, #1
   1acbc:	add	r2, r5
   1acbe:	add.w	sl, r4, r8
   1acc2:	beq.w	1af86 <_malloc_r+0x4de>
   1acc6:	add.w	r2, r2, #4096	; 0x1000
   1acca:	adds	r2, #15
   1accc:	bic.w	r2, r2, #4080	; 0xff0
   1acd0:	bic.w	r2, r2, #15
   1acd4:	mov	r1, r2
   1acd6:	mov	r0, r6
   1acd8:	str	r2, [sp, #4]
   1acda:	bl	1b0bc <_sbrk_r>
   1acde:	cmp.w	r0, #4294967295
   1ace2:	mov	fp, r0
   1ace4:	ldr	r2, [sp, #4]
   1ace6:	beq.w	1af9a <_malloc_r+0x4f2>
   1acea:	cmp	sl, r0
   1acec:	bhi.w	1aee8 <_malloc_r+0x440>
   1acf0:	ldr	r3, [pc, #276]	; (1ae08 <_malloc_r+0x360>)
   1acf2:	ldr	r1, [r3, #0]
   1acf4:	cmp	sl, fp
   1acf6:	add	r1, r2
   1acf8:	str	r1, [r3, #0]
   1acfa:	beq.w	1afa4 <_malloc_r+0x4fc>
   1acfe:	ldr.w	r0, [r9]
   1ad02:	ldr.w	lr, [pc, #272]	; 1ae14 <_malloc_r+0x36c>
   1ad06:	adds	r0, #1
   1ad08:	ittet	ne
   1ad0a:	rsbne	sl, sl, fp
   1ad0e:	addne	r1, sl
   1ad10:	streq.w	fp, [lr]
   1ad14:	strne	r1, [r3, #0]
   1ad16:	ands.w	r1, fp, #7
   1ad1a:	beq.w	1af4c <_malloc_r+0x4a4>
   1ad1e:	rsb	r0, r1, #8
   1ad22:	rsb	r1, r1, #4096	; 0x1000
   1ad26:	add	fp, r0
   1ad28:	adds	r1, #8
   1ad2a:	add	r2, fp
   1ad2c:	ubfx	r2, r2, #0, #12
   1ad30:	rsb	r9, r2, r1
   1ad34:	mov	r1, r9
   1ad36:	mov	r0, r6
   1ad38:	str	r3, [sp, #4]
   1ad3a:	bl	1b0bc <_sbrk_r>
   1ad3e:	adds	r3, r0, #1
   1ad40:	ldr	r3, [sp, #4]
   1ad42:	beq.w	1afc4 <_malloc_r+0x51c>
   1ad46:	rsb	r2, fp, r0
   1ad4a:	add	r2, r9
   1ad4c:	orr.w	r2, r2, #1
   1ad50:	ldr	r1, [r3, #0]
   1ad52:	str.w	fp, [r7, #8]
   1ad56:	add	r1, r9
   1ad58:	cmp	r4, r7
   1ad5a:	str.w	r2, [fp, #4]
   1ad5e:	str	r1, [r3, #0]
   1ad60:	ldr.w	r9, [pc, #164]	; 1ae08 <_malloc_r+0x360>
   1ad64:	beq.n	1ad94 <_malloc_r+0x2ec>
   1ad66:	cmp.w	r8, #15
   1ad6a:	bls.w	1af68 <_malloc_r+0x4c0>
   1ad6e:	ldr	r2, [r4, #4]
   1ad70:	sub.w	r3, r8, #12
   1ad74:	bic.w	r3, r3, #7
   1ad78:	adds	r0, r4, r3
   1ad7a:	and.w	r2, r2, #1
   1ad7e:	mov.w	lr, #5
   1ad82:	orrs	r2, r3
   1ad84:	cmp	r3, #15
   1ad86:	str	r2, [r4, #4]
   1ad88:	str.w	lr, [r0, #4]
   1ad8c:	str.w	lr, [r0, #8]
   1ad90:	bhi.w	1afcc <_malloc_r+0x524>
   1ad94:	ldr	r3, [pc, #116]	; (1ae0c <_malloc_r+0x364>)
   1ad96:	ldr	r4, [r7, #8]
   1ad98:	ldr	r2, [r3, #0]
   1ad9a:	cmp	r1, r2
   1ad9c:	it	hi
   1ad9e:	strhi	r1, [r3, #0]
   1ada0:	ldr	r3, [pc, #108]	; (1ae10 <_malloc_r+0x368>)
   1ada2:	ldr	r2, [r3, #0]
   1ada4:	cmp	r1, r2
   1ada6:	ldr	r2, [r4, #4]
   1ada8:	it	hi
   1adaa:	strhi	r1, [r3, #0]
   1adac:	bic.w	r2, r2, #3
   1adb0:	cmp	r5, r2
   1adb2:	sub.w	r3, r2, r5
   1adb6:	bhi.n	1adbc <_malloc_r+0x314>
   1adb8:	cmp	r3, #15
   1adba:	bgt.n	1adc6 <_malloc_r+0x31e>
   1adbc:	mov	r0, r6
   1adbe:	bl	1b0b8 <__malloc_unlock>
   1adc2:	movs	r4, #0
   1adc4:	b.n	1ac38 <_malloc_r+0x190>
   1adc6:	adds	r2, r4, r5
   1adc8:	orr.w	r3, r3, #1
   1adcc:	orr.w	r5, r5, #1
   1add0:	str	r5, [r4, #4]
   1add2:	mov	r0, r6
   1add4:	str	r2, [r7, #8]
   1add6:	str	r3, [r2, #4]
   1add8:	bl	1b0b8 <__malloc_unlock>
   1addc:	adds	r4, #8
   1adde:	mov	r0, r4
   1ade0:	add	sp, #12
   1ade2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ade6:	cmp	r3, #20
   1ade8:	bls.n	1aece <_malloc_r+0x426>
   1adea:	cmp	r3, #84	; 0x54
   1adec:	bhi.w	1af38 <_malloc_r+0x490>
   1adf0:	lsrs	r0, r5, #12
   1adf2:	add.w	lr, r0, #111	; 0x6f
   1adf6:	mov.w	r3, lr, lsl #1
   1adfa:	adds	r0, #110	; 0x6e
   1adfc:	b.n	1aaec <_malloc_r+0x44>
   1adfe:	nop
   1ae00:	.word	0x20020ecc
   1ae04:	.word	0x20058814
   1ae08:	.word	0x20058818
   1ae0c:	.word	0x20058810
   1ae10:	.word	0x2005880c
   1ae14:	.word	0x200212d8
   1ae18:	lsrs	r2, r3, #9
   1ae1a:	cmp	r2, #4
   1ae1c:	bls.n	1aedc <_malloc_r+0x434>
   1ae1e:	cmp	r2, #20
   1ae20:	bhi.w	1af8a <_malloc_r+0x4e2>
   1ae24:	add.w	r1, r2, #92	; 0x5c
   1ae28:	lsls	r1, r1, #1
   1ae2a:	adds	r2, #91	; 0x5b
   1ae2c:	add.w	ip, r7, r1, lsl #2
   1ae30:	ldr.w	r1, [r7, r1, lsl #2]
   1ae34:	ldr.w	r8, [pc, #476]	; 1b014 <_malloc_r+0x56c>
   1ae38:	sub.w	ip, ip, #8
   1ae3c:	cmp	ip, r1
   1ae3e:	beq.w	1af52 <_malloc_r+0x4aa>
   1ae42:	ldr	r2, [r1, #4]
   1ae44:	bic.w	r2, r2, #3
   1ae48:	cmp	r3, r2
   1ae4a:	bcs.n	1ae52 <_malloc_r+0x3aa>
   1ae4c:	ldr	r1, [r1, #8]
   1ae4e:	cmp	ip, r1
   1ae50:	bne.n	1ae42 <_malloc_r+0x39a>
   1ae52:	ldr.w	ip, [r1, #12]
   1ae56:	ldr	r2, [r7, #4]
   1ae58:	str.w	ip, [r4, #12]
   1ae5c:	str	r1, [r4, #8]
   1ae5e:	str.w	r4, [ip, #8]
   1ae62:	str	r4, [r1, #12]
   1ae64:	b.n	1ab78 <_malloc_r+0xd0>
   1ae66:	adds	r3, r4, r5
   1ae68:	orr.w	r7, r2, #1
   1ae6c:	orr.w	r5, r5, #1
   1ae70:	str	r5, [r4, #4]
   1ae72:	mov	r0, r6
   1ae74:	str	r3, [r1, #20]
   1ae76:	str	r3, [r1, #16]
   1ae78:	str.w	lr, [r3, #12]
   1ae7c:	str.w	lr, [r3, #8]
   1ae80:	str	r7, [r3, #4]
   1ae82:	str	r2, [r3, r2]
   1ae84:	adds	r4, #8
   1ae86:	bl	1b0b8 <__malloc_unlock>
   1ae8a:	b.n	1ac38 <_malloc_r+0x190>
   1ae8c:	ldr	r2, [r1, #4]
   1ae8e:	b.n	1ab78 <_malloc_r+0xd0>
   1ae90:	add.w	r8, r8, #1
   1ae94:	tst.w	r8, #3
   1ae98:	add.w	ip, ip, #8
   1ae9c:	bne.w	1ab9e <_malloc_r+0xf6>
   1aea0:	b.n	1af04 <_malloc_r+0x45c>
   1aea2:	ldr	r4, [r3, #12]
   1aea4:	cmp	r3, r4
   1aea6:	it	eq
   1aea8:	addeq	r0, #2
   1aeaa:	beq.w	1ab18 <_malloc_r+0x70>
   1aeae:	b.n	1ac18 <_malloc_r+0x170>
   1aeb0:	add	r3, r1
   1aeb2:	mov	r4, r1
   1aeb4:	ldr	r2, [r3, #4]
   1aeb6:	ldr	r1, [r1, #12]
   1aeb8:	ldr.w	r5, [r4, #8]!
   1aebc:	orr.w	r2, r2, #1
   1aec0:	str	r2, [r3, #4]
   1aec2:	mov	r0, r6
   1aec4:	str	r1, [r5, #12]
   1aec6:	str	r5, [r1, #8]
   1aec8:	bl	1b0b8 <__malloc_unlock>
   1aecc:	b.n	1ac38 <_malloc_r+0x190>
   1aece:	add.w	lr, r3, #92	; 0x5c
   1aed2:	add.w	r0, r3, #91	; 0x5b
   1aed6:	mov.w	r3, lr, lsl #1
   1aeda:	b.n	1aaec <_malloc_r+0x44>
   1aedc:	lsrs	r2, r3, #6
   1aede:	add.w	r1, r2, #57	; 0x39
   1aee2:	lsls	r1, r1, #1
   1aee4:	adds	r2, #56	; 0x38
   1aee6:	b.n	1ae2c <_malloc_r+0x384>
   1aee8:	cmp	r4, r7
   1aeea:	ldr	r3, [pc, #296]	; (1b014 <_malloc_r+0x56c>)
   1aeec:	beq.w	1acf0 <_malloc_r+0x248>
   1aef0:	ldr	r4, [r3, #8]
   1aef2:	ldr	r2, [r4, #4]
   1aef4:	bic.w	r2, r2, #3
   1aef8:	b.n	1adb0 <_malloc_r+0x308>
   1aefa:	ldr.w	r3, [r9], #-8
   1aefe:	cmp	r9, r3
   1af00:	bne.w	1b008 <_malloc_r+0x560>
   1af04:	tst.w	r0, #3
   1af08:	add.w	r0, r0, #4294967295
   1af0c:	bne.n	1aefa <_malloc_r+0x452>
   1af0e:	ldr	r3, [r7, #4]
   1af10:	bic.w	r3, r3, r4
   1af14:	str	r3, [r7, #4]
   1af16:	lsls	r4, r4, #1
   1af18:	cmp	r4, r3
   1af1a:	bhi.w	1ac98 <_malloc_r+0x1f0>
   1af1e:	cmp	r4, #0
   1af20:	beq.w	1ac98 <_malloc_r+0x1f0>
   1af24:	tst	r4, r3
   1af26:	mov	r0, r8
   1af28:	bne.w	1ab96 <_malloc_r+0xee>
   1af2c:	lsls	r4, r4, #1
   1af2e:	tst	r4, r3
   1af30:	add.w	r0, r0, #4
   1af34:	beq.n	1af2c <_malloc_r+0x484>
   1af36:	b.n	1ab96 <_malloc_r+0xee>
   1af38:	cmp.w	r3, #340	; 0x154
   1af3c:	bhi.n	1af70 <_malloc_r+0x4c8>
   1af3e:	lsrs	r0, r5, #15
   1af40:	add.w	lr, r0, #120	; 0x78
   1af44:	mov.w	r3, lr, lsl #1
   1af48:	adds	r0, #119	; 0x77
   1af4a:	b.n	1aaec <_malloc_r+0x44>
   1af4c:	mov.w	r1, #4096	; 0x1000
   1af50:	b.n	1ad2a <_malloc_r+0x282>
   1af52:	movs	r1, #1
   1af54:	ldr.w	r3, [r8, #4]
   1af58:	asrs	r2, r2, #2
   1af5a:	lsl.w	r2, r1, r2
   1af5e:	orrs	r2, r3
   1af60:	str.w	r2, [r8, #4]
   1af64:	mov	r1, ip
   1af66:	b.n	1ae58 <_malloc_r+0x3b0>
   1af68:	movs	r3, #1
   1af6a:	str.w	r3, [fp, #4]
   1af6e:	b.n	1adbc <_malloc_r+0x314>
   1af70:	movw	r2, #1364	; 0x554
   1af74:	cmp	r3, r2
   1af76:	bhi.n	1afba <_malloc_r+0x512>
   1af78:	lsrs	r0, r5, #18
   1af7a:	add.w	lr, r0, #125	; 0x7d
   1af7e:	mov.w	r3, lr, lsl #1
   1af82:	adds	r0, #124	; 0x7c
   1af84:	b.n	1aaec <_malloc_r+0x44>
   1af86:	adds	r2, #16
   1af88:	b.n	1acd4 <_malloc_r+0x22c>
   1af8a:	cmp	r2, #84	; 0x54
   1af8c:	bhi.n	1afdc <_malloc_r+0x534>
   1af8e:	lsrs	r2, r3, #12
   1af90:	add.w	r1, r2, #111	; 0x6f
   1af94:	lsls	r1, r1, #1
   1af96:	adds	r2, #110	; 0x6e
   1af98:	b.n	1ae2c <_malloc_r+0x384>
   1af9a:	ldr	r4, [r7, #8]
   1af9c:	ldr	r2, [r4, #4]
   1af9e:	bic.w	r2, r2, #3
   1afa2:	b.n	1adb0 <_malloc_r+0x308>
   1afa4:	ubfx	r0, sl, #0, #12
   1afa8:	cmp	r0, #0
   1afaa:	bne.w	1acfe <_malloc_r+0x256>
   1afae:	add	r2, r8
   1afb0:	ldr	r3, [r7, #8]
   1afb2:	orr.w	r2, r2, #1
   1afb6:	str	r2, [r3, #4]
   1afb8:	b.n	1ad94 <_malloc_r+0x2ec>
   1afba:	movs	r3, #254	; 0xfe
   1afbc:	mov.w	lr, #127	; 0x7f
   1afc0:	movs	r0, #126	; 0x7e
   1afc2:	b.n	1aaec <_malloc_r+0x44>
   1afc4:	movs	r2, #1
   1afc6:	mov.w	r9, #0
   1afca:	b.n	1ad50 <_malloc_r+0x2a8>
   1afcc:	add.w	r1, r4, #8
   1afd0:	mov	r0, r6
   1afd2:	bl	1b220 <_free_r>
   1afd6:	ldr.w	r1, [r9]
   1afda:	b.n	1ad94 <_malloc_r+0x2ec>
   1afdc:	cmp.w	r2, #340	; 0x154
   1afe0:	bhi.n	1afee <_malloc_r+0x546>
   1afe2:	lsrs	r2, r3, #15
   1afe4:	add.w	r1, r2, #120	; 0x78
   1afe8:	lsls	r1, r1, #1
   1afea:	adds	r2, #119	; 0x77
   1afec:	b.n	1ae2c <_malloc_r+0x384>
   1afee:	movw	r1, #1364	; 0x554
   1aff2:	cmp	r2, r1
   1aff4:	bhi.n	1b002 <_malloc_r+0x55a>
   1aff6:	lsrs	r2, r3, #18
   1aff8:	add.w	r1, r2, #125	; 0x7d
   1affc:	lsls	r1, r1, #1
   1affe:	adds	r2, #124	; 0x7c
   1b000:	b.n	1ae2c <_malloc_r+0x384>
   1b002:	movs	r1, #254	; 0xfe
   1b004:	movs	r2, #126	; 0x7e
   1b006:	b.n	1ae2c <_malloc_r+0x384>
   1b008:	ldr	r3, [r7, #4]
   1b00a:	b.n	1af16 <_malloc_r+0x46e>
   1b00c:	lsrs	r0, r5, #3
   1b00e:	adds	r3, r0, #1
   1b010:	lsls	r3, r3, #1
   1b012:	b.n	1ac06 <_malloc_r+0x15e>
   1b014:	.word	0x20020ecc

0001b018 <memset>:
   1b018:	push	{r4, r5, r6}
   1b01a:	lsls	r4, r0, #30
   1b01c:	beq.n	1b0ac <memset+0x94>
   1b01e:	subs	r4, r2, #1
   1b020:	cmp	r2, #0
   1b022:	beq.n	1b0a8 <memset+0x90>
   1b024:	uxtb	r5, r1
   1b026:	mov	r3, r0
   1b028:	b.n	1b030 <memset+0x18>
   1b02a:	subs	r2, r4, #1
   1b02c:	cbz	r4, 1b0a8 <memset+0x90>
   1b02e:	mov	r4, r2
   1b030:	strb.w	r5, [r3], #1
   1b034:	lsls	r2, r3, #30
   1b036:	bne.n	1b02a <memset+0x12>
   1b038:	cmp	r4, #3
   1b03a:	bls.n	1b09a <memset+0x82>
   1b03c:	uxtb	r5, r1
   1b03e:	orr.w	r5, r5, r5, lsl #8
   1b042:	cmp	r4, #15
   1b044:	orr.w	r5, r5, r5, lsl #16
   1b048:	bls.n	1b07e <memset+0x66>
   1b04a:	add.w	r2, r3, #16
   1b04e:	mov	r6, r4
   1b050:	subs	r6, #16
   1b052:	cmp	r6, #15
   1b054:	str.w	r5, [r2, #-16]
   1b058:	str.w	r5, [r2, #-12]
   1b05c:	str.w	r5, [r2, #-8]
   1b060:	str.w	r5, [r2, #-4]
   1b064:	add.w	r2, r2, #16
   1b068:	bhi.n	1b050 <memset+0x38>
   1b06a:	sub.w	r2, r4, #16
   1b06e:	bic.w	r2, r2, #15
   1b072:	and.w	r4, r4, #15
   1b076:	adds	r2, #16
   1b078:	cmp	r4, #3
   1b07a:	add	r3, r2
   1b07c:	bls.n	1b09a <memset+0x82>
   1b07e:	mov	r6, r3
   1b080:	mov	r2, r4
   1b082:	subs	r2, #4
   1b084:	cmp	r2, #3
   1b086:	str.w	r5, [r6], #4
   1b08a:	bhi.n	1b082 <memset+0x6a>
   1b08c:	subs	r2, r4, #4
   1b08e:	bic.w	r2, r2, #3
   1b092:	adds	r2, #4
   1b094:	add	r3, r2
   1b096:	and.w	r4, r4, #3
   1b09a:	cbz	r4, 1b0a8 <memset+0x90>
   1b09c:	uxtb	r1, r1
   1b09e:	add	r4, r3
   1b0a0:	strb.w	r1, [r3], #1
   1b0a4:	cmp	r3, r4
   1b0a6:	bne.n	1b0a0 <memset+0x88>
   1b0a8:	pop	{r4, r5, r6}
   1b0aa:	bx	lr
   1b0ac:	mov	r4, r2
   1b0ae:	mov	r3, r0
   1b0b0:	b.n	1b038 <memset+0x20>
   1b0b2:	nop

0001b0b4 <__malloc_lock>:
   1b0b4:	bx	lr
   1b0b6:	nop

0001b0b8 <__malloc_unlock>:
   1b0b8:	bx	lr
   1b0ba:	nop

0001b0bc <_sbrk_r>:
   1b0bc:	push	{r3, r4, r5, lr}
   1b0be:	ldr	r4, [pc, #28]	; (1b0dc <_sbrk_r+0x20>)
   1b0c0:	movs	r3, #0
   1b0c2:	mov	r5, r0
   1b0c4:	mov	r0, r1
   1b0c6:	str	r3, [r4, #0]
   1b0c8:	bl	16a6c <_sbrk>
   1b0cc:	adds	r3, r0, #1
   1b0ce:	beq.n	1b0d2 <_sbrk_r+0x16>
   1b0d0:	pop	{r3, r4, r5, pc}
   1b0d2:	ldr	r3, [r4, #0]
   1b0d4:	cmp	r3, #0
   1b0d6:	beq.n	1b0d0 <_sbrk_r+0x14>
   1b0d8:	str	r3, [r5, #0]
   1b0da:	pop	{r3, r4, r5, pc}
   1b0dc:	.word	0x2005a7ec

0001b0e0 <__register_exitproc>:
   1b0e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1b0e4:	ldr	r4, [pc, #148]	; (1b17c <__register_exitproc+0x9c>)
   1b0e6:	ldr	r5, [r4, #0]
   1b0e8:	ldr.w	r4, [r5, #328]	; 0x148
   1b0ec:	mov	r6, r0
   1b0ee:	mov	r8, r1
   1b0f0:	mov	sl, r2
   1b0f2:	mov	r9, r3
   1b0f4:	cbz	r4, 1b168 <__register_exitproc+0x88>
   1b0f6:	ldr	r0, [r4, #4]
   1b0f8:	cmp	r0, #31
   1b0fa:	bgt.n	1b12c <__register_exitproc+0x4c>
   1b0fc:	adds	r3, r0, #1
   1b0fe:	cbz	r6, 1b11e <__register_exitproc+0x3e>
   1b100:	add.w	r5, r4, r0, lsl #2
   1b104:	movs	r2, #1
   1b106:	str.w	sl, [r5, #136]	; 0x88
   1b10a:	ldr.w	r1, [r4, #392]	; 0x188
   1b10e:	lsls	r2, r0
   1b110:	orrs	r1, r2
   1b112:	cmp	r6, #2
   1b114:	str.w	r1, [r4, #392]	; 0x188
   1b118:	str.w	r9, [r5, #264]	; 0x108
   1b11c:	beq.n	1b15c <__register_exitproc+0x7c>
   1b11e:	adds	r0, #2
   1b120:	str	r3, [r4, #4]
   1b122:	str.w	r8, [r4, r0, lsl #2]
   1b126:	movs	r0, #0
   1b128:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1b12c:	ldr	r3, [pc, #80]	; (1b180 <__register_exitproc+0xa0>)
   1b12e:	cbz	r3, 1b172 <__register_exitproc+0x92>
   1b130:	mov.w	r0, #400	; 0x190
   1b134:	bl	1aa98 <malloc>
   1b138:	mov	r4, r0
   1b13a:	cbz	r0, 1b172 <__register_exitproc+0x92>
   1b13c:	ldr.w	r3, [r5, #328]	; 0x148
   1b140:	movs	r7, #0
   1b142:	stmia.w	r0, {r3, r7}
   1b146:	str.w	r4, [r5, #328]	; 0x148
   1b14a:	mov	r0, r7
   1b14c:	movs	r3, #1
   1b14e:	str.w	r7, [r4, #392]	; 0x188
   1b152:	str.w	r7, [r4, #396]	; 0x18c
   1b156:	cmp	r6, #0
   1b158:	beq.n	1b11e <__register_exitproc+0x3e>
   1b15a:	b.n	1b100 <__register_exitproc+0x20>
   1b15c:	ldr.w	r1, [r4, #396]	; 0x18c
   1b160:	orrs	r2, r1
   1b162:	str.w	r2, [r4, #396]	; 0x18c
   1b166:	b.n	1b11e <__register_exitproc+0x3e>
   1b168:	add.w	r4, r5, #332	; 0x14c
   1b16c:	str.w	r4, [r5, #328]	; 0x148
   1b170:	b.n	1b0f6 <__register_exitproc+0x16>
   1b172:	mov.w	r0, #4294967295
   1b176:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1b17a:	nop
   1b17c:	.word	0x20020460
   1b180:	.word	0x0001aa99

0001b184 <_malloc_trim_r>:
   1b184:	push	{r3, r4, r5, r6, r7, lr}
   1b186:	ldr	r7, [pc, #140]	; (1b214 <_malloc_trim_r+0x90>)
   1b188:	mov	r4, r1
   1b18a:	mov	r6, r0
   1b18c:	bl	1b0b4 <__malloc_lock>
   1b190:	ldr	r3, [r7, #8]
   1b192:	ldr	r5, [r3, #4]
   1b194:	bic.w	r5, r5, #3
   1b198:	subs	r1, r5, r4
   1b19a:	addw	r1, r1, #4079	; 0xfef
   1b19e:	bic.w	r1, r1, #4080	; 0xff0
   1b1a2:	bic.w	r1, r1, #15
   1b1a6:	sub.w	r4, r1, #4096	; 0x1000
   1b1aa:	cmp.w	r4, #4096	; 0x1000
   1b1ae:	blt.n	1b1c0 <_malloc_trim_r+0x3c>
   1b1b0:	movs	r1, #0
   1b1b2:	mov	r0, r6
   1b1b4:	bl	1b0bc <_sbrk_r>
   1b1b8:	ldr	r3, [r7, #8]
   1b1ba:	add	r3, r5
   1b1bc:	cmp	r0, r3
   1b1be:	beq.n	1b1ca <_malloc_trim_r+0x46>
   1b1c0:	mov	r0, r6
   1b1c2:	bl	1b0b8 <__malloc_unlock>
   1b1c6:	movs	r0, #0
   1b1c8:	pop	{r3, r4, r5, r6, r7, pc}
   1b1ca:	negs	r1, r4
   1b1cc:	mov	r0, r6
   1b1ce:	bl	1b0bc <_sbrk_r>
   1b1d2:	adds	r0, #1
   1b1d4:	beq.n	1b1f2 <_malloc_trim_r+0x6e>
   1b1d6:	ldr	r3, [pc, #64]	; (1b218 <_malloc_trim_r+0x94>)
   1b1d8:	ldr	r2, [r7, #8]
   1b1da:	ldr	r1, [r3, #0]
   1b1dc:	subs	r5, r5, r4
   1b1de:	orr.w	r5, r5, #1
   1b1e2:	mov	r0, r6
   1b1e4:	subs	r1, r1, r4
   1b1e6:	str	r5, [r2, #4]
   1b1e8:	str	r1, [r3, #0]
   1b1ea:	bl	1b0b8 <__malloc_unlock>
   1b1ee:	movs	r0, #1
   1b1f0:	pop	{r3, r4, r5, r6, r7, pc}
   1b1f2:	movs	r1, #0
   1b1f4:	mov	r0, r6
   1b1f6:	bl	1b0bc <_sbrk_r>
   1b1fa:	ldr	r2, [r7, #8]
   1b1fc:	subs	r3, r0, r2
   1b1fe:	cmp	r3, #15
   1b200:	ble.n	1b1c0 <_malloc_trim_r+0x3c>
   1b202:	ldr	r4, [pc, #24]	; (1b21c <_malloc_trim_r+0x98>)
   1b204:	ldr	r1, [pc, #16]	; (1b218 <_malloc_trim_r+0x94>)
   1b206:	ldr	r4, [r4, #0]
   1b208:	orr.w	r3, r3, #1
   1b20c:	subs	r0, r0, r4
   1b20e:	str	r3, [r2, #4]
   1b210:	str	r0, [r1, #0]
   1b212:	b.n	1b1c0 <_malloc_trim_r+0x3c>
   1b214:	.word	0x20020ecc
   1b218:	.word	0x20058818
   1b21c:	.word	0x200212d8

0001b220 <_free_r>:
   1b220:	cmp	r1, #0
   1b222:	beq.n	1b2b0 <_free_r+0x90>
   1b224:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b228:	mov	r5, r1
   1b22a:	mov	r8, r0
   1b22c:	bl	1b0b4 <__malloc_lock>
   1b230:	ldr.w	r7, [r5, #-4]
   1b234:	ldr	r1, [pc, #424]	; (1b3e0 <_free_r+0x1c0>)
   1b236:	bic.w	r3, r7, #1
   1b23a:	sub.w	r4, r5, #8
   1b23e:	adds	r2, r4, r3
   1b240:	ldr	r6, [r1, #8]
   1b242:	ldr	r0, [r2, #4]
   1b244:	cmp	r2, r6
   1b246:	bic.w	r0, r0, #3
   1b24a:	beq.n	1b312 <_free_r+0xf2>
   1b24c:	lsls	r6, r7, #31
   1b24e:	str	r0, [r2, #4]
   1b250:	bmi.n	1b26a <_free_r+0x4a>
   1b252:	ldr.w	r7, [r5, #-8]
   1b256:	subs	r4, r4, r7
   1b258:	add.w	lr, r1, #8
   1b25c:	ldr	r5, [r4, #8]
   1b25e:	cmp	r5, lr
   1b260:	add	r3, r7
   1b262:	beq.n	1b344 <_free_r+0x124>
   1b264:	ldr	r7, [r4, #12]
   1b266:	str	r7, [r5, #12]
   1b268:	str	r5, [r7, #8]
   1b26a:	adds	r5, r2, r0
   1b26c:	ldr	r5, [r5, #4]
   1b26e:	lsls	r5, r5, #31
   1b270:	bpl.n	1b2f8 <_free_r+0xd8>
   1b272:	orr.w	r2, r3, #1
   1b276:	str	r2, [r4, #4]
   1b278:	str	r3, [r4, r3]
   1b27a:	cmp.w	r3, #512	; 0x200
   1b27e:	bcs.n	1b2b2 <_free_r+0x92>
   1b280:	lsrs	r3, r3, #3
   1b282:	adds	r2, r3, #1
   1b284:	ldr	r5, [r1, #4]
   1b286:	ldr.w	r7, [r1, r2, lsl #3]
   1b28a:	str	r7, [r4, #8]
   1b28c:	movs	r0, #1
   1b28e:	asrs	r3, r3, #2
   1b290:	lsl.w	r3, r0, r3
   1b294:	add.w	r0, r1, r2, lsl #3
   1b298:	orrs	r5, r3
   1b29a:	subs	r0, #8
   1b29c:	str	r0, [r4, #12]
   1b29e:	str	r5, [r1, #4]
   1b2a0:	str.w	r4, [r1, r2, lsl #3]
   1b2a4:	str	r4, [r7, #12]
   1b2a6:	mov	r0, r8
   1b2a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1b2ac:	b.w	1b0b8 <__malloc_unlock>
   1b2b0:	bx	lr
   1b2b2:	lsrs	r2, r3, #9
   1b2b4:	cmp	r2, #4
   1b2b6:	bhi.n	1b360 <_free_r+0x140>
   1b2b8:	lsrs	r2, r3, #6
   1b2ba:	add.w	r7, r2, #57	; 0x39
   1b2be:	lsls	r7, r7, #1
   1b2c0:	add.w	r5, r2, #56	; 0x38
   1b2c4:	add.w	r0, r1, r7, lsl #2
   1b2c8:	ldr.w	r2, [r1, r7, lsl #2]
   1b2cc:	ldr	r1, [pc, #272]	; (1b3e0 <_free_r+0x1c0>)
   1b2ce:	subs	r0, #8
   1b2d0:	cmp	r0, r2
   1b2d2:	beq.n	1b370 <_free_r+0x150>
   1b2d4:	ldr	r1, [r2, #4]
   1b2d6:	bic.w	r1, r1, #3
   1b2da:	cmp	r3, r1
   1b2dc:	bcs.n	1b2e4 <_free_r+0xc4>
   1b2de:	ldr	r2, [r2, #8]
   1b2e0:	cmp	r0, r2
   1b2e2:	bne.n	1b2d4 <_free_r+0xb4>
   1b2e4:	ldr	r0, [r2, #12]
   1b2e6:	str	r0, [r4, #12]
   1b2e8:	str	r2, [r4, #8]
   1b2ea:	str	r4, [r0, #8]
   1b2ec:	str	r4, [r2, #12]
   1b2ee:	mov	r0, r8
   1b2f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1b2f4:	b.w	1b0b8 <__malloc_unlock>
   1b2f8:	ldr	r5, [r2, #8]
   1b2fa:	ldr	r7, [pc, #232]	; (1b3e4 <_free_r+0x1c4>)
   1b2fc:	cmp	r5, r7
   1b2fe:	add	r3, r0
   1b300:	beq.n	1b382 <_free_r+0x162>
   1b302:	ldr	r0, [r2, #12]
   1b304:	str	r0, [r5, #12]
   1b306:	orr.w	r2, r3, #1
   1b30a:	str	r5, [r0, #8]
   1b30c:	str	r2, [r4, #4]
   1b30e:	str	r3, [r4, r3]
   1b310:	b.n	1b27a <_free_r+0x5a>
   1b312:	lsls	r7, r7, #31
   1b314:	add	r3, r0
   1b316:	bmi.n	1b328 <_free_r+0x108>
   1b318:	ldr.w	r2, [r5, #-8]
   1b31c:	subs	r4, r4, r2
   1b31e:	add	r3, r2
   1b320:	ldr	r0, [r4, #8]
   1b322:	ldr	r2, [r4, #12]
   1b324:	str	r2, [r0, #12]
   1b326:	str	r0, [r2, #8]
   1b328:	ldr	r2, [pc, #188]	; (1b3e8 <_free_r+0x1c8>)
   1b32a:	ldr	r2, [r2, #0]
   1b32c:	orr.w	r0, r3, #1
   1b330:	cmp	r3, r2
   1b332:	str	r0, [r4, #4]
   1b334:	str	r4, [r1, #8]
   1b336:	bcc.n	1b2a6 <_free_r+0x86>
   1b338:	ldr	r3, [pc, #176]	; (1b3ec <_free_r+0x1cc>)
   1b33a:	mov	r0, r8
   1b33c:	ldr	r1, [r3, #0]
   1b33e:	bl	1b184 <_malloc_trim_r>
   1b342:	b.n	1b2a6 <_free_r+0x86>
   1b344:	adds	r1, r2, r0
   1b346:	ldr	r1, [r1, #4]
   1b348:	lsls	r1, r1, #31
   1b34a:	bmi.n	1b3d6 <_free_r+0x1b6>
   1b34c:	ldr	r1, [r2, #8]
   1b34e:	ldr	r2, [r2, #12]
   1b350:	str	r2, [r1, #12]
   1b352:	add	r3, r0
   1b354:	orr.w	r0, r3, #1
   1b358:	str	r1, [r2, #8]
   1b35a:	str	r0, [r4, #4]
   1b35c:	str	r3, [r4, r3]
   1b35e:	b.n	1b2a6 <_free_r+0x86>
   1b360:	cmp	r2, #20
   1b362:	bhi.n	1b394 <_free_r+0x174>
   1b364:	add.w	r7, r2, #92	; 0x5c
   1b368:	lsls	r7, r7, #1
   1b36a:	add.w	r5, r2, #91	; 0x5b
   1b36e:	b.n	1b2c4 <_free_r+0xa4>
   1b370:	asrs	r2, r5, #2
   1b372:	ldr	r3, [r1, #4]
   1b374:	movs	r5, #1
   1b376:	lsl.w	r2, r5, r2
   1b37a:	orrs	r3, r2
   1b37c:	str	r3, [r1, #4]
   1b37e:	mov	r2, r0
   1b380:	b.n	1b2e6 <_free_r+0xc6>
   1b382:	orr.w	r2, r3, #1
   1b386:	str	r4, [r1, #20]
   1b388:	str	r4, [r1, #16]
   1b38a:	str	r5, [r4, #12]
   1b38c:	str	r5, [r4, #8]
   1b38e:	str	r2, [r4, #4]
   1b390:	str	r3, [r4, r3]
   1b392:	b.n	1b2a6 <_free_r+0x86>
   1b394:	cmp	r2, #84	; 0x54
   1b396:	bhi.n	1b3a6 <_free_r+0x186>
   1b398:	lsrs	r2, r3, #12
   1b39a:	add.w	r7, r2, #111	; 0x6f
   1b39e:	lsls	r7, r7, #1
   1b3a0:	add.w	r5, r2, #110	; 0x6e
   1b3a4:	b.n	1b2c4 <_free_r+0xa4>
   1b3a6:	cmp.w	r2, #340	; 0x154
   1b3aa:	bhi.n	1b3ba <_free_r+0x19a>
   1b3ac:	lsrs	r2, r3, #15
   1b3ae:	add.w	r7, r2, #120	; 0x78
   1b3b2:	lsls	r7, r7, #1
   1b3b4:	add.w	r5, r2, #119	; 0x77
   1b3b8:	b.n	1b2c4 <_free_r+0xa4>
   1b3ba:	movw	r0, #1364	; 0x554
   1b3be:	cmp	r2, r0
   1b3c0:	bhi.n	1b3d0 <_free_r+0x1b0>
   1b3c2:	lsrs	r2, r3, #18
   1b3c4:	add.w	r7, r2, #125	; 0x7d
   1b3c8:	lsls	r7, r7, #1
   1b3ca:	add.w	r5, r2, #124	; 0x7c
   1b3ce:	b.n	1b2c4 <_free_r+0xa4>
   1b3d0:	movs	r7, #254	; 0xfe
   1b3d2:	movs	r5, #126	; 0x7e
   1b3d4:	b.n	1b2c4 <_free_r+0xa4>
   1b3d6:	orr.w	r2, r3, #1
   1b3da:	str	r2, [r4, #4]
   1b3dc:	str	r3, [r4, r3]
   1b3de:	b.n	1b2a6 <_free_r+0x86>
   1b3e0:	.word	0x20020ecc
   1b3e4:	.word	0x20020ed4
   1b3e8:	.word	0x200212d4
   1b3ec:	.word	0x20058814

0001b3f0 <___ZN11AudioStream17initialize_memoryEP18audio_block_structj_veneer>:
   1b3f0:	ldr.w	pc, [pc]	; 1b3f4 <___ZN11AudioStream17initialize_memoryEP18audio_block_structj_veneer+0x4>
   1b3f4:	.word	0x600016bd

0001b3f8 <___Z14set_audioClockilmb_veneer>:
   1b3f8:	ldr.w	pc, [pc]	; 1b3fc <___Z14set_audioClockilmb_veneer+0x4>
   1b3fc:	.word	0x600012a5

0001b400 <___init_veneer>:
   1b400:	ldr.w	pc, [pc]	; 1b404 <___init_veneer+0x4>
   1b404:	.word	0x60001855
	...

Disassembly of section .fini:

0001b410 <_fini>:
   1b410:	push	{r3, r4, r5, r6, r7, lr}
   1b412:	nop
